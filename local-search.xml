<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>I卡配IU之我购买了一张Intel显卡--DG1</title>
    <link href="/I%E5%8D%A1%E9%85%8DIU%E4%B9%8B%E6%88%91%E8%B4%AD%E4%B9%B0%E4%BA%86%E4%B8%80%E5%BC%A0Intel%E6%98%BE%E5%8D%A1-DG1/"/>
    <url>/I%E5%8D%A1%E9%85%8DIU%E4%B9%8B%E6%88%91%E8%B4%AD%E4%B9%B0%E4%BA%86%E4%B8%80%E5%BC%A0Intel%E6%98%BE%E5%8D%A1-DG1/</url>
    
    <content type="html"><![CDATA[<h1 id="一-简介"><a href="#一-简介" class="headerlink" title="一.简介"></a>一.简介</h1><p>在去年很长的一段时间里，我的主力机配置都是r5 5600+ Msi b450m mortar max+ Radeon RX 6700xt 12g组成的3A平台</p><p>因为一些原因到今年还是换成了比较普遍的I U+N卡，最近逛咸鱼时发现二手平台上的所谓Intel第一张显卡DG1<del>实际上有更早的i740 GPU（Real3D i740 Starfighter），鱼上也有卖的，不过是AGP协议的（可见于上学期的嵌入式系统课）</del>掉到了200元以内，看了下参数感觉还是比较符合亮机卡的水平的，于是买了一张来作为收藏……顺便搭建一下3I平台来增添一点信仰值。这和我不多添100r买带核显的12400而买12400F绝没有半毛钱的关系&#x2F;(ㄒoㄒ)&#x2F;。</p><p>头图和内容无关，不是Arc独显买不起，而是Xe亮机卡更有性价比。</p><p><img src="https://n.sinaimg.cn/spider2020115/244/w600h444/20201105/6cff-kcpxnwv6744180.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="I740 agp"></p><p><img src="https://tpucdn.com/gpu-specs/images/b/8654-front.jpg" srcset="/img/mahmoud-habibi.gif" lazyload alt="我买的就是这款阿苏斯被动散热款 | TechPowerUp GPU Database"></p><p>报一报参数，DG1共有两个版本，一种是80eu的普通版，<del>我的就是</del>，另一种是96eu的max版本，在咸鱼价钱稍微贵一些，但其实性能相差也不大，这两样都和移动端非HX的Xe核显一样（12XXXHX 32eu;12450H 48eu；12500H&#x2F;12600H 80eu;12700H&#x2F;12900H 96eu），比桌面端的Xe强不少(UHD710,16EU,如G7400;UHD730,24EU如12100&#x2F;12400&#x2F;13100&#x2F;13400;UHD750&#x2F;UHD770,32EU，12500+&#x2F;13500+&#x2F;14600k+)</p><p>下面就看看实物图吧，看着薄薄一片，实则被动散热铁皮分量够，其实还挺重的</p><p><img src="/I%E5%8D%A1%E9%85%8DIU%E4%B9%8B%E6%88%91%E8%B4%AD%E4%B9%B0%E4%BA%86%E4%B8%80%E5%BC%A0Intel%E6%98%BE%E5%8D%A1-DG1/image-20231111201406048.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="空荡荡的机箱，散热器变双塔了"></p><p><img src="/I%E5%8D%A1%E9%85%8DIU%E4%B9%8B%E6%88%91%E8%B4%AD%E4%B9%B0%E4%BA%86%E4%B8%80%E5%BC%A0Intel%E6%98%BE%E5%8D%A1-DG1/image-20231111201445577.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="睾贵的阿苏斯显卡"></p><p><img src="/I%E5%8D%A1%E9%85%8DIU%E4%B9%8B%E6%88%91%E8%B4%AD%E4%B9%B0%E4%BA%86%E4%B8%80%E5%BC%A0Intel%E6%98%BE%E5%8D%A1-DG1/image-20231111201511874.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="接口齐全"></p><p><img src="/I%E5%8D%A1%E9%85%8DIU%E4%B9%8B%E6%88%91%E8%B4%AD%E4%B9%B0%E4%BA%86%E4%B8%80%E5%BC%A0Intel%E6%98%BE%E5%8D%A1-DG1/image-20231111201532294.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="亮机卡哪来的背板"></p><h1 id="二-点亮"><a href="#二-点亮" class="headerlink" title="二.点亮"></a>二.点亮</h1><p>关于I卡，一般都得在10代以上平台使用，还要关csm，开above 4G和Resizable bar这三样设置才行。然而DG1根本不支持开rebar，可有可无。</p><p>好在我使用的12代平台直接插上就能亮机，无需过多设置。</p><p><img src="/I%E5%8D%A1%E9%85%8DIU%E4%B9%8B%E6%88%91%E8%B4%AD%E4%B9%B0%E4%BA%86%E4%B8%80%E5%BC%A0Intel%E6%98%BE%E5%8D%A1-DG1/image-20231111185454037.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="不打驱动也能进系统"></p><p><img src="/I%E5%8D%A1%E9%85%8DIU%E4%B9%8B%E6%88%91%E8%B4%AD%E4%B9%B0%E4%BA%86%E4%B8%80%E5%BC%A0Intel%E6%98%BE%E5%8D%A1-DG1/image-20231111190133103.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="windows自动打的驱动"></p><p>图吧工具箱识别显存大小不对，GPUZ的频率也不对。。。</p><p>然后手动去官网打驱动</p><p><img src="/I%E5%8D%A1%E9%85%8DIU%E4%B9%8B%E6%88%91%E8%B4%AD%E4%B9%B0%E4%BA%86%E4%B8%80%E5%BC%A0Intel%E6%98%BE%E5%8D%A1-DG1/image-20231111190348274.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="Xe显卡"></p><p>打上后还是有识别错误，感觉Intel全力发展Arc显卡完全不再管这款80eu的大号核显了</p><p><img src="/I%E5%8D%A1%E9%85%8DIU%E4%B9%8B%E6%88%91%E8%B4%AD%E4%B9%B0%E4%BA%86%E4%B8%80%E5%BC%A0Intel%E6%98%BE%E5%8D%A1-DG1/image-20231111190427803.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="突破天际的频率"></p><h1 id="三-跑分"><a href="#三-跑分" class="headerlink" title="三.跑分"></a>三.跑分</h1><p>接着就是常规的跑分测试环节了，看看这张亮机卡&#x2F;大号核显性能如何。–<a href="http://www.3dmark.com/spy/42945698">链接</a></p><p><img src="/I%E5%8D%A1%E9%85%8DIU%E4%B9%8B%E6%88%91%E8%B4%AD%E4%B9%B0%E4%BA%86%E4%B8%80%E5%BC%A0Intel%E6%98%BE%E5%8D%A1-DG1/image-20231111191237344.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="1492分，接近1500了"></p><p>比我笔记本的Vega7核显1181分还是要强的–<a href="http://www.3dmark.com/spy/35558299">链接</a></p><p><img src="/I%E5%8D%A1%E9%85%8DIU%E4%B9%8B%E6%88%91%E8%B4%AD%E4%B9%B0%E4%BA%86%E4%B8%80%E5%BC%A0Intel%E6%98%BE%E5%8D%A1-DG1/image-20231111191055761.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="小新笔记本"></p><p>比比十年前的高端N卡是否有优势呢（忘了用12400F跑了，就拿之前5600的记录来看吧），还是差不不少呢–<a href="http://www.3dmark.com/spy/37450411">链接</a></p><p><img src="/I%E5%8D%A1%E9%85%8DIU%E4%B9%8B%E6%88%91%E8%B4%AD%E4%B9%B0%E4%BA%86%E4%B8%80%E5%BC%A0Intel%E6%98%BE%E5%8D%A1-DG1/image-20231111191600184.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="公版泰坦皮GTX770"></p><p>最后是主力3070–<a href="http://www.3dmark.com/spy/42841778">链接</a></p><p><img src="/I%E5%8D%A1%E9%85%8DIU%E4%B9%8B%E6%88%91%E8%B4%AD%E4%B9%B0%E4%BA%86%E4%B8%80%E5%BC%A0Intel%E6%98%BE%E5%8D%A1-DG1/image-20231111192329325.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="强大十倍"></p><p>再用更大众的鲁大师跑分来看看对比吧</p><p><img src="/I%E5%8D%A1%E9%85%8DIU%E4%B9%8B%E6%88%91%E8%B4%AD%E4%B9%B0%E4%BA%86%E4%B8%80%E5%BC%A0Intel%E6%98%BE%E5%8D%A1-DG1/image-20231111191749948.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="1号选手DG1跑出8.5w"></p><p><img src="/I%E5%8D%A1%E9%85%8DIU%E4%B9%8B%E6%88%91%E8%B4%AD%E4%B9%B0%E4%BA%86%E4%B8%80%E5%BC%A0Intel%E6%98%BE%E5%8D%A1-DG1/image-20231111191825109.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="二号选手gtx770，9.6w"></p><p><img src="/I%E5%8D%A1%E9%85%8DIU%E4%B9%8B%E6%88%91%E8%B4%AD%E4%B9%B0%E4%BA%86%E4%B8%80%E5%BC%A0Intel%E6%98%BE%E5%8D%A1-DG1/image-20231111191945906.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="三号选手3070 62w，内存分低是因为没超频3500"></p><p>最后再对比一下游戏差距叭，就拿最近玩的MC为例了</p><p>不打光影能有150帧，还算不错</p><p><img src="/I%E5%8D%A1%E9%85%8DIU%E4%B9%8B%E6%88%91%E8%B4%AD%E4%B9%B0%E4%BA%86%E4%B8%80%E5%BC%A0Intel%E6%98%BE%E5%8D%A1-DG1/image-20231111192656865.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="1"></p><p>试试第一个光影，直接不能渲染</p><p><img src="/I%E5%8D%A1%E9%85%8DIU%E4%B9%8B%E6%88%91%E8%B4%AD%E4%B9%B0%E4%BA%86%E4%B8%80%E5%BC%A0Intel%E6%98%BE%E5%8D%A1-DG1/image-20231111192736906.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="呃呃"></p><p>试试换一个光影，15帧电竞，和gtx770帧数差不多</p><p><img src="/I%E5%8D%A1%E9%85%8DIU%E4%B9%8B%E6%88%91%E8%B4%AD%E4%B9%B0%E4%BA%86%E4%B8%80%E5%BC%A0Intel%E6%98%BE%E5%8D%A1-DG1/image-20231111192821144.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="渲染正常了"></p><p>我的3070开光影大概能有70-100帧左右吧，差距也挺大了。看来DG1还是作为亮机卡比较合适。。。。。。</p><h1 id="四-整个花活"><a href="#四-整个花活" class="headerlink" title="四.整个花活"></a>四.整个花活</h1><p>继续玩我在b450平台上玩过的多卡。。。不过华擎这张板子的pcie划分很难受，只有一根全长的pcie 4.0x16插槽和一根pcie3.0*1的插槽，而且距离过近，也不适合插多卡（完全不如之前坏掉的b450迫击炮max）。</p><p><img src="/I%E5%8D%A1%E9%85%8DIU%E4%B9%8B%E6%88%91%E8%B4%AD%E4%B9%B0%E4%BA%86%E4%B8%80%E5%BC%A0Intel%E6%98%BE%E5%8D%A1-DG1/image-20231111193514764.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="b660m pg riptide"></p><p><img src="/I%E5%8D%A1%E9%85%8DIU%E4%B9%8B%E6%88%91%E8%B4%AD%E4%B9%B0%E4%BA%86%E4%B8%80%E5%BC%A0Intel%E6%98%BE%E5%8D%A1-DG1/image-20231111193537926.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="b450m mortar max"></p><p>A&#x2F;I亮机卡之战</p><p><img src="/I%E5%8D%A1%E9%85%8DIU%E4%B9%8B%E6%88%91%E8%B4%AD%E4%B9%B0%E4%BA%86%E4%B8%80%E5%BC%A0Intel%E6%98%BE%E5%8D%A1-DG1/image-20231111193130771.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="加上我的经典亮机卡"></p><p><img src="/I%E5%8D%A1%E9%85%8DIU%E4%B9%8B%E6%88%91%E8%B4%AD%E4%B9%B0%E4%BA%86%E4%B8%80%E5%BC%A0Intel%E6%98%BE%E5%8D%A1-DG1/image-20231111193622464.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="驱动并不冲突"></p><p>P106也行？我的评价是不如核显带P106的玩法</p><p><img src="/I%E5%8D%A1%E9%85%8DIU%E4%B9%8B%E6%88%91%E8%B4%AD%E4%B9%B0%E4%BA%86%E4%B8%80%E5%BC%A0Intel%E6%98%BE%E5%8D%A1-DG1/image-20231111193657156.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="x1槽的带宽会不会太低了些"></p><h1 id="五-后事处理"><a href="#五-后事处理" class="headerlink" title="五.后事处理"></a>五.后事处理</h1><p>本来这件事就属于冲动消费，也不打算自己长期使用，这张卡的归宿可能就是收藏起来长期吃灰（这张板子matx版型插不下更多卡了😡，不然我一定给插上），然后被我卖掉或者拿回老家当亮机卡发光发热（给父母办公看视频还不错嘛），不过DIY嘛，开心就行，以后我出去炫耀也可以说本人也是玩过Intel独显的男人，哈哈。折腾本身就是一种乐趣，拿到喜欢的电子产品高兴才是最重要的一件事……</p><p>下期预告：12代Non-K OC看到华擎妖板懂得都懂<del>才不是本人太懒了，素材存了好久都懒得写博客。。。</del></p>]]></content>
    
    
    
    <tags>
      
      <tag>DIY</tag>
      
      <tag>显卡</tag>
      
      <tag>Intel</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>旧时代电子产品REborn-三星数码相册SPF-87H副屏数据监测</title>
    <link href="/%E6%97%A7%E6%97%B6%E4%BB%A3%E7%94%B5%E5%AD%90%E4%BA%A7%E5%93%81REborn-%E4%B8%89%E6%98%9F%E6%95%B0%E7%A0%81%E7%9B%B8%E5%86%8CSPF-87H%E5%89%AF%E5%B1%8F%E6%95%B0%E6%8D%AE%E7%9B%91%E6%B5%8B/"/>
    <url>/%E6%97%A7%E6%97%B6%E4%BB%A3%E7%94%B5%E5%AD%90%E4%BA%A7%E5%93%81REborn-%E4%B8%89%E6%98%9F%E6%95%B0%E7%A0%81%E7%9B%B8%E5%86%8CSPF-87H%E5%89%AF%E5%B1%8F%E6%95%B0%E6%8D%AE%E7%9B%91%E6%B5%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="一-起因"><a href="#一-起因" class="headerlink" title="一.起因"></a>一.起因</h1><p>前不久发现便携屏挺火的，有点动心，价格在大多百元以上，如果我自己是ITX装机或者又别的便携需求买一个倒是无所谓，可是宿舍已经又有一个2k高刷大屏幕了，但是仔细想想自己也没那啥需求，买一个也就纯纯玩具（浪费钱），所以话都说到这份上了还不如直接捡一个便宜的玩具来玩呢。我的需求也不是拿廉价的副屏幕来看文档，只是纯粹当个性能桌面摆件。恰巧搜到了一个三星数码相册改造成监控副屏的方案<a href="https://post.smzdm.com/p/and2q780/">这边是张大妈的文章</a>（可支持大多数三星的数码相册型号），而且是垃圾佬常用的<a href="https://forums.aida64.com/topic/2424-new-lcd-device-support-samsung-spf-digital-photo-frames/">AIDA64软件官方支持方案</a>，这下也不太需要自己去弄，买来装好驱动，即插即用就即可😊。</p><p><img src="/%E6%97%A7%E6%97%B6%E4%BB%A3%E7%94%B5%E5%AD%90%E4%BA%A7%E5%93%81REborn-%E4%B8%89%E6%98%9F%E6%95%B0%E7%A0%81%E7%9B%B8%E5%86%8CSPF-87H%E5%89%AF%E5%B1%8F%E6%95%B0%E6%8D%AE%E7%9B%91%E6%B5%8B/image-20231030213208761.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="兼容型号"></p><h1 id="二-简评"><a href="#二-简评" class="headerlink" title="二.简评"></a>二.简评</h1><p>电子相册现在肯定很多人是没有听说过了，毕竟这玩意儿十几年前就得卖几百上千（三星），现在基本也是销声匿迹，当时买得起的肯定也是副歌们了，就拿我买的SPF-87H为例</p><p><img src="/%E6%97%A7%E6%97%B6%E4%BB%A3%E7%94%B5%E5%AD%90%E4%BA%A7%E5%93%81REborn-%E4%B8%89%E6%98%9F%E6%95%B0%E7%A0%81%E7%9B%B8%E5%86%8CSPF-87H%E5%89%AF%E5%B1%8F%E6%95%B0%E6%8D%AE%E7%9B%91%E6%B5%8B/image-20231030211404660.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="12年报价"></p><p>这是2009年的评测文章<a href="https://lcd.zol.com.cn/134/1345497.html">https://lcd.zol.com.cn/134/1345497.html</a></p><p><img src="/%E6%97%A7%E6%97%B6%E4%BB%A3%E7%94%B5%E5%AD%90%E4%BA%A7%E5%93%81REborn-%E4%B8%89%E6%98%9F%E6%95%B0%E7%A0%81%E7%9B%B8%E5%86%8CSPF-87H%E5%89%AF%E5%B1%8F%E6%95%B0%E6%8D%AE%E7%9B%91%E6%B5%8B/image-20231030211757342.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="距今已经14年了"></p><p><img src="/%E6%97%A7%E6%97%B6%E4%BB%A3%E7%94%B5%E5%AD%90%E4%BA%A7%E5%93%81REborn-%E4%B8%89%E6%98%9F%E6%95%B0%E7%A0%81%E7%9B%B8%E5%86%8CSPF-87H%E5%89%AF%E5%B1%8F%E6%95%B0%E6%8D%AE%E7%9B%91%E6%B5%8B/image-20231030211457796.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="09年要卖上1500rmb"></p><blockquote><p> 在三星SPF-87H的外包装上我们就能清晰的看到这款产品的部分卖点，8英寸的屏幕尺寸，内置1GB的内存容量，迷你显示器功能和超薄机身设计。</p></blockquote><p><img src="https://img2.zol.com.cn/product/31_500x2000/584/cedJ1OIiWpUZ.jpg" srcset="/img/mahmoud-habibi.gif" lazyload alt="抢先体验！三星超时尚相框新品(视频) "></p><p><img src="https://img2.zol.com.cn/product/31_500x2000/673/ceARz444653cI.jpg" srcset="/img/mahmoud-habibi.gif" lazyload alt="抢先体验！三星超时尚相框新品(视频) "></p><p><img src="https://img2.zol.com.cn/product/31_500x2000/679/cec1Z4ENmh9z6.jpg" srcset="/img/mahmoud-habibi.gif" lazyload alt="抢先体验！三星超时尚相框新品(视频) "></p><p>当然现在这款电子相册在海鲜市场只需要几十块就能入手了，成色好的可能要60多，像我淘的这个成色略差（两角漏光），且缺少数据线，只花了35大洋就包邮到学校了。</p><p><img src="/%E6%97%A7%E6%97%B6%E4%BB%A3%E7%94%B5%E5%AD%90%E4%BA%A7%E5%93%81REborn-%E4%B8%89%E6%98%9F%E6%95%B0%E7%A0%81%E7%9B%B8%E5%86%8CSPF-87H%E5%89%AF%E5%B1%8F%E6%95%B0%E6%8D%AE%E7%9B%91%E6%B5%8B/image-20231030212518748.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="万能海鲜市场"></p><p><img src="/%E6%97%A7%E6%97%B6%E4%BB%A3%E7%94%B5%E5%AD%90%E4%BA%A7%E5%93%81REborn-%E4%B8%89%E6%98%9F%E6%95%B0%E7%A0%81%E7%9B%B8%E5%86%8CSPF-87H%E5%89%AF%E5%B1%8F%E6%95%B0%E6%8D%AE%E7%9B%91%E6%B5%8B/image-20231030215302138.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="盒子"></p><p>到手第一件事就是检查有无问题，还好并无大碍，插上数据线后的第一个难题就是电脑无反应，设备管理器里也没有任何新东西，驱动装上后也没反应。。。。。。折腾半天发现是我买的mini B线材问题，检查后发现里面只有两根供电线，没有数据线。无奈只好重新下单购买，这次我选择了一个这样带辅助供电的线材，这样子可以不用外接12V小砖块电源了，全靠主板供电就行。</p><p><img src="/%E6%97%A7%E6%97%B6%E4%BB%A3%E7%94%B5%E5%AD%90%E4%BA%A7%E5%93%81REborn-%E4%B8%89%E6%98%9F%E6%95%B0%E7%A0%81%E7%9B%B8%E5%86%8CSPF-87H%E5%89%AF%E5%B1%8F%E6%95%B0%E6%8D%AE%E7%9B%91%E6%B5%8B/image-20231030213615055.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="一边是Type A另一边是mini usb和辅助供电的type A"></p><h1 id="三-操作流程"><a href="#三-操作流程" class="headerlink" title="三.操作流程"></a>三.操作流程</h1><p>1.打开DIY爱好者和垃圾佬必备的图吧工具箱(<a href="https://www.tbtool.cn/?gozelm=a3oj1">没有的自己下一个</a>)，找到AIDA64，并打开AIDA64</p><p>2.主界面点击 文件-&gt;设置-&gt;LCD，选择Samsung，点击启用SPF LCD支持的选项，如果出现和我一样的绿色SPF Init OK字样，并且屏幕上显示AIDA64字样，则表示接管成功</p><p><img src="/%E6%97%A7%E6%97%B6%E4%BB%A3%E7%94%B5%E5%AD%90%E4%BA%A7%E5%93%81REborn-%E4%B8%89%E6%98%9F%E6%95%B0%E7%A0%81%E7%9B%B8%E5%86%8CSPF-87H%E5%89%AF%E5%B1%8F%E6%95%B0%E6%8D%AE%E7%9B%91%E6%B5%8B/image-20231030214338831.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="这样的"></p><p>接下来就只需要在LCD项目里导入模板修改就行了</p><p><img src="/%E6%97%A7%E6%97%B6%E4%BB%A3%E7%94%B5%E5%AD%90%E4%BA%A7%E5%93%81REborn-%E4%B8%89%E6%98%9F%E6%95%B0%E7%A0%81%E7%9B%B8%E5%86%8CSPF-87H%E5%89%AF%E5%B1%8F%E6%95%B0%E6%8D%AE%E7%9B%91%E6%B5%8B/image-20231030214639874.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="我copy了论坛上的一个主题"></p><p>如果绿字处显示错误，那么就点击出现的网址下载驱动安装，安装结束再进行尝试。</p><p>注意我这个东西，需要在USB插入后的5s内点击“启用SPF LCD支持”内才能顺利接管，具体就听USB设备音效判断即可（5s真男人）。</p><p><img src="/%E6%97%A7%E6%97%B6%E4%BB%A3%E7%94%B5%E5%AD%90%E4%BA%A7%E5%93%81REborn-%E4%B8%89%E6%98%9F%E6%95%B0%E7%A0%81%E7%9B%B8%E5%86%8CSPF-87H%E5%89%AF%E5%B1%8F%E6%95%B0%E6%8D%AE%E7%9B%91%E6%B5%8B/image-20231030215015787.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="设备管理器里的样子"></p><p>想要开机自启也很简单，设置开机自启即可</p><p><img src="/%E6%97%A7%E6%97%B6%E4%BB%A3%E7%94%B5%E5%AD%90%E4%BA%A7%E5%93%81REborn-%E4%B8%89%E6%98%9F%E6%95%B0%E7%A0%81%E7%9B%B8%E5%86%8CSPF-87H%E5%89%AF%E5%B1%8F%E6%95%B0%E6%8D%AE%E7%9B%91%E6%B5%8B/image-20231030215618969.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="设置"></p><p>发现我现在用的ASRock主板关机后USB是可以设置供电的，这样也不需要再对相册进行设定了，不需要关闭相册，正常开关机相册会自动被AIDA64接管</p><h1 id="四-具体效果展示"><a href="#四-具体效果展示" class="headerlink" title="四.具体效果展示"></a>四.具体效果展示</h1><p><img src="/%E6%97%A7%E6%97%B6%E4%BB%A3%E7%94%B5%E5%AD%90%E4%BA%A7%E5%93%81REborn-%E4%B8%89%E6%98%9F%E6%95%B0%E7%A0%81%E7%9B%B8%E5%86%8CSPF-87H%E5%89%AF%E5%B1%8F%E6%95%B0%E6%8D%AE%E7%9B%91%E6%B5%8B/image-20231030215126371.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="效果"></p><p><img src="/%E6%97%A7%E6%97%B6%E4%BB%A3%E7%94%B5%E5%AD%90%E4%BA%A7%E5%93%81REborn-%E4%B8%89%E6%98%9F%E6%95%B0%E7%A0%81%E7%9B%B8%E5%86%8CSPF-87H%E5%89%AF%E5%B1%8F%E6%95%B0%E6%8D%AE%E7%9B%91%E6%B5%8B/image-20231030215150341.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="桌面摆件"></p><p><img src="/%E6%97%A7%E6%97%B6%E4%BB%A3%E7%94%B5%E5%AD%90%E4%BA%A7%E5%93%81REborn-%E4%B8%89%E6%98%9F%E6%95%B0%E7%A0%81%E7%9B%B8%E5%86%8CSPF-87H%E5%89%AF%E5%B1%8F%E6%95%B0%E6%8D%AE%E7%9B%91%E6%B5%8B/image-20231030215317705.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="接口，单线就行"></p><p>居然不是萌萌二次元，果然数据展示还是要有点战斗感啊:)</p>]]></content>
    
    
    
    <tags>
      
      <tag>DIY</tag>
      
      <tag>魔改</tag>
      
      <tag>SUMSUNG</tag>
      
      <tag>副屏幕</tag>
      
      <tag>AIDA64</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>IoT__第3章__无线传感器网络__3.2_MAC协议</title>
    <link href="/IoT-%E7%AC%AC3%E7%AB%A0-%E6%97%A0%E7%BA%BF%E4%BC%A0%E6%84%9F%E5%99%A8%E7%BD%91%E7%BB%9C-3-2-MAC%E5%8D%8F%E8%AE%AE/"/>
    <url>/IoT-%E7%AC%AC3%E7%AB%A0-%E6%97%A0%E7%BA%BF%E4%BC%A0%E6%84%9F%E5%99%A8%E7%BD%91%E7%BB%9C-3-2-MAC%E5%8D%8F%E8%AE%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="第三章-无线传感器网络"><a href="#第三章-无线传感器网络" class="headerlink" title="第三章 无线传感器网络"></a>第三章 无线传感器网络</h1><h2 id="3-2-MAC协议"><a href="#3-2-MAC协议" class="headerlink" title="3.2 MAC协议"></a>3.2 <strong>MAC协议</strong></h2><p><strong>竞争型MAC协议—局部同步local synchronization</strong></p><ul><li><strong>IEEE 802.11 MAC层</strong></li><li><strong>S-MAC协议</strong></li><li><strong>T-MAC协议</strong></li></ul><p><strong>竞争型MAC协议—异步no synchronization</strong></p><ul><li><strong>B-MAC协议</strong></li><li><strong>RI-MAC协议</strong></li></ul><p><strong>调度型（分配型）MAC协议—全局同步global synchronization</strong></p><ul><li><strong>TRAMA协议</strong></li><li><strong>DMAC协议</strong></li></ul><p><strong>混合型MAC协议</strong></p><ul><li><strong>Z-MAC</strong></li><li><strong>Funneling-MAC</strong></li></ul><h2 id="3-2-1-1-IEEE-802-11-MAC层"><a href="#3-2-1-1-IEEE-802-11-MAC层" class="headerlink" title="3.2.1.1    IEEE 802.11 MAC层"></a>3.2.1.1    <strong>IEEE 802.11 MAC层</strong></h2><h3 id="ALOHA协议"><a href="#ALOHA协议" class="headerlink" title="ALOHA协议"></a><strong>ALOHA协议</strong></h3><p><strong>Pure ALOHA协议</strong>  </p><p><img src="/IoT-%E7%AC%AC3%E7%AB%A0-%E6%97%A0%E7%BA%BF%E4%BC%A0%E6%84%9F%E5%99%A8%E7%BD%91%E7%BB%9C-3-2-MAC%E5%8D%8F%E8%AE%AE/image-20231220190414294.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="pure"></p><p>Ø<strong>当站点有数据需要发送时，直接向信道发送数据帧。</strong></p><p>Ø<strong>如果发生数据冲突，发送站点等待随机时间，再进行重发，直到发送成功，或最后放弃。</strong></p><p><strong>Slotted ALOHA协议</strong>  </p><p><img src="/IoT-%E7%AC%AC3%E7%AB%A0-%E6%97%A0%E7%BA%BF%E4%BC%A0%E6%84%9F%E5%99%A8%E7%BD%91%E7%BB%9C-3-2-MAC%E5%8D%8F%E8%AE%AE/image-20231220190430564.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="slotted"></p><p>Ø<strong>信道上的时间被划分成离散的时隙，其大小相当于帧的传输时间。所有站点的时钟保持同步。站点只有在时隙开始时才能传输数据。</strong></p><p>Ø<strong>只有那些都在同一个时槽进行传输的帧才有可能冲突，冲突危险区比Pure ALOHA降低了一半 。</strong></p><h3 id="CSMA（载波侦听多路访问协议）"><a href="#CSMA（载波侦听多路访问协议）" class="headerlink" title="CSMA（载波侦听多路访问协议）"></a><strong>CSMA（载波侦听多路访问协议）</strong></h3><p><strong>Pure ALOHA和SlottedALOHA都没有利用到以太网和无线分组网的一个主要特性，那就是与帧的传输时间相比，传播时间是很短的：当一个站点发送帧后，具有载波侦听的其它站点很快就会知道。</strong></p><p><strong>CSMA</strong></p><p>Ø<strong>非坚持CSMA协议（NonpersistentCSMA）</strong></p><p>Ø<strong>1-坚持CSMA协议 （1-persistent CSMA）</strong></p><p>Ø<strong>P-坚持CSMA协议（P-persistent CSMA）</strong></p><h4 id="几种CSMA-协议"><a href="#几种CSMA-协议" class="headerlink" title="几种CSMA 协议"></a><strong>几种CSMA 协议</strong></h4><p><strong>与ALOHA的区别：提供载波侦听功能</strong></p><p><strong>节点在发送数据之前，对信道进行侦听，根据信道的忙闲程度再决定是否发送。（更“礼貌”，性能更好）</strong></p><ul><li><p><strong>非坚持CSMA协议</strong></p><ul><li><strong>侦听信道，</strong><ul><li><strong>1) 若信道空闲：发送数据帧。</strong></li><li><strong>2) 若信道忙：等待一段随机时间，重新再侦听。</strong></li></ul></li></ul></li><li><p><strong>1-坚持CSMA</strong>  <strong>协议</strong> </p><ul><li><strong>侦听信道，</strong><ul><li><strong>1) 若信道空闲：发送数据帧。</strong></li><li><strong>2) 若信道忙：仍坚持侦听，一直侦听到信道空闲。</strong></li></ul></li></ul></li><li><p><strong>p -坚持CSMA 协议</strong> (<strong>IEEE 802.11无线局域网使用p-坚持CSMA协议的改进版</strong>)</p><ul><li><strong>侦听信道，</strong><ul><li><strong>1) 若信道空闲：以概率</strong>  <strong>p发送数据帧；以概率</strong>  <strong>1-p</strong>  <strong>延迟一段时间τ，重新侦听。</strong></li><li><strong>2) 若信道忙：仍坚持侦听，一直侦听到信道空闲。</strong></li></ul></li></ul></li></ul><p><img src="/IoT-%E7%AC%AC3%E7%AB%A0-%E6%97%A0%E7%BA%BF%E4%BC%A0%E6%84%9F%E5%99%A8%E7%BD%91%E7%BB%9C-3-2-MAC%E5%8D%8F%E8%AE%AE/image-20231220190740601.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="各种协议的性能对比"></p><h3 id="CSMA-x2F-CD-带冲突检测的载波侦听多路访问"><a href="#CSMA-x2F-CD-带冲突检测的载波侦听多路访问" class="headerlink" title="CSMA&#x2F;CD 带冲突检测的载波侦听多路访问"></a><strong>CSMA&#x2F;CD 带冲突检测的载波侦听多路访问</strong></h3><p><img src="/IoT-%E7%AC%AC3%E7%AB%A0-%E6%97%A0%E7%BA%BF%E4%BC%A0%E6%84%9F%E5%99%A8%E7%BD%91%E7%BB%9C-3-2-MAC%E5%8D%8F%E8%AE%AE/image-20231220190856217.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="cd"></p><p><strong>虽然 CSMA 协议能够通过载波侦听减少数据冲突发生的机会，但由于传播时延的存在，仍然不可避免会发生数据冲突。</strong></p><p><strong>CSMA&#x2F;CD：在 CSMA 的基础上，增加冲突检测的功能，即站点在传输时能够侦听到是否发生冲突。</strong></p><p><strong>CSMA&#x2F;CD 协议思路</strong></p><ul><li><strong>当站点侦听到信道空闲时就发送数据，同时继续侦听下去。</strong></li><li><strong>冲突检测：站点在传输的同时侦听信道，一旦检测到本站传输帧与别的站点传输帧发生冲突时，立即放弃当前帧的发送（而不是继续完成传输），这样可以使信道很快地空闲下来。</strong></li><li><strong>是经典以太网的基础</strong></li></ul><h3 id="无线局域网协议"><a href="#无线局域网协议" class="headerlink" title="无线局域网协议"></a><strong>无线局域网协议</strong></h3><p><strong>隐藏终端问题（hidden station problem）</strong></p><p><strong>暴露终端问题（exposedstation problem）</strong></p><p><strong>冲突避免多路访问（MACA, Multiple Access with CollisionAviodance）</strong></p><ul><li><strong>RTS（Request To Send）帧</strong></li><li><strong>CTS（Clear To Send）帧</strong></li></ul><p><img src="/IoT-%E7%AC%AC3%E7%AB%A0-%E6%97%A0%E7%BA%BF%E4%BC%A0%E6%84%9F%E5%99%A8%E7%BD%91%E7%BB%9C-3-2-MAC%E5%8D%8F%E8%AE%AE/image-20231220190943960.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="ex"></p><p><img src="/IoT-%E7%AC%AC3%E7%AB%A0-%E6%97%A0%E7%BA%BF%E4%BC%A0%E6%84%9F%E5%99%A8%E7%BD%91%E7%BB%9C-3-2-MAC%E5%8D%8F%E8%AE%AE/image-20231220191007273.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="冲突避免多路访问协议MACA：RTS / CTS"></p><h4 id="802-11-MAC子层协议"><a href="#802-11-MAC子层协议" class="headerlink" title="802.11 MAC子层协议"></a><strong>802.11 MAC子层协议</strong></h4><ul><li><strong>操作模式：分布式协调功能DCF、点协调功能PCF（较少用到）</strong></li><li><strong>使用CSMA&#x2F;CA的虚拟信道侦听，借助于</strong></li><li><strong>网络分配向量NAV：记录信道的忙碌时段</strong></li><li><strong>图例：</strong><ul><li><strong>A发送给B，C在A范围内，D在B范围内、但不在A范围内</strong></li></ul></li></ul><p><img src="/IoT-%E7%AC%AC3%E7%AB%A0-%E6%97%A0%E7%BA%BF%E4%BC%A0%E6%84%9F%E5%99%A8%E7%BD%91%E7%BB%9C-3-2-MAC%E5%8D%8F%E8%AE%AE/image-20231220191137670.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="ex"></p><h4 id="CSMA-x2F-CA的基本过程"><a href="#CSMA-x2F-CA的基本过程" class="headerlink" title="CSMA&#x2F;CA的基本过程"></a><strong>CSMA&#x2F;CA的基本过程</strong></h4><ul><li><strong>CSMA&#x2F;CA（带冲突避免的CSMA）协议</strong><ul><li><strong>当一个节点要传输一个无线帧时，它首先侦听信道状态。</strong></li><li><strong>如果信道空闲，而且经过一个帧间间隔时间DIFS，信道仍为空闲，则站点立即开始发送信息。</strong></li><li><strong>如果信道忙，则站点一直侦听信道，直到信道的空闲时间超过DIFS。当信道空闲下来时，节点使用二进制退避算法来避免发生碰撞。</strong></li></ul></li></ul><p><img src="/IoT-%E7%AC%AC3%E7%AB%A0-%E6%97%A0%E7%BA%BF%E4%BC%A0%E6%84%9F%E5%99%A8%E7%BD%91%E7%BB%9C-3-2-MAC%E5%8D%8F%E8%AE%AE/image-20231220191216747.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="ca"></p><p><img src="/IoT-%E7%AC%AC3%E7%AB%A0-%E6%97%A0%E7%BA%BF%E4%BC%A0%E6%84%9F%E5%99%A8%E7%BD%91%E7%BB%9C-3-2-MAC%E5%8D%8F%E8%AE%AE/image-20231220191228424.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="CSMA/CA协议下的收发（例）"></p><p><strong>802.11提供了几种基本帧间间隔，对应于访问无线信道的优先级。</strong></p><p><img src="/IoT-%E7%AC%AC3%E7%AB%A0-%E6%97%A0%E7%BA%BF%E4%BC%A0%E6%84%9F%E5%99%A8%E7%BD%91%E7%BB%9C-3-2-MAC%E5%8D%8F%E8%AE%AE/image-20231220191253819.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="CSMA/CA的帧间间隔"></p><h4 id="无线传感器网络MAC协议概述"><a href="#无线传感器网络MAC协议概述" class="headerlink" title="无线传感器网络MAC协议概述"></a><strong>无线传感器网络MAC协议概述</strong></h4><p><strong>在设计无线传感器网络的MAC协议时，需要着重考虑以下几个方面：</strong></p><p><strong>（1）节省能量</strong></p><p>•<strong>满足应用要求下，尽量节省使用节点能量。</strong></p><p><strong>（2）可扩展性</strong></p><p>•<strong>适应动态变化的网络拓扑。</strong></p><p><strong>（3）网络效率</strong></p><p>•<strong>包括网络的公平性、实时性、网络吞吐容量以及带宽利用率。</strong></p><h4 id="WSN-MAC技术需求"><a href="#WSN-MAC技术需求" class="headerlink" title="WSN MAC技术需求"></a><strong>WSN MAC技术需求</strong></h4><p>What is a good MAC protocol for WSNs?</p><ul><li>energy efficiency</li><li>scalability (to the change in network size,nide density and topology)</li><li>fairness</li><li>latency</li><li>throughput</li><li>bandwidth utilization</li></ul><p>Major sources of energy waste</p><ul><li><strong>collision</strong>: increasing latency as well</li><li><strong>idle listening</strong>: listening to receive possible traffic that is not sent</li><li><strong>overhearing</strong>: a node picks up packets that are destined to other nodes</li><li><strong>overhead</strong>：control packet overhead</li></ul><h4 id="WSN-MAC协议的研究关注点"><a href="#WSN-MAC协议的研究关注点" class="headerlink" title="WSN MAC协议的研究关注点"></a><strong>WSN MAC协议的研究关注点</strong></h4><ul><li><strong>能量效率</strong><ul><li><strong>冲突重传</strong>  <strong>collision and retransmission</strong></li><li><strong>空闲侦听</strong>  <strong>idle listening</strong></li><li><strong>串听</strong>      <strong>overhearing</strong></li><li><strong>控制开销</strong>  <strong>control overhead</strong></li></ul></li><li><strong>可扩展性</strong> </li><li><strong>网络效率</strong> <ul><li><strong>延迟、吞吐量、公平性…</strong></li></ul></li><li><strong>算法复杂度</strong> </li><li><strong>与其它层协议的协同</strong></li></ul><p><strong>重要性依次递减！</strong></p><h4 id="WSN-MAC协议概述"><a href="#WSN-MAC协议概述" class="headerlink" title="WSN MAC协议概述"></a><strong>WSN MAC协议概述</strong></h4><p><strong>传感器节点无线通信模块的状态包括发送状态、接收状态、侦听状态、休眠状态等。</strong></p><ul><li><strong>无线通信模块在发送状态的消耗能量最多，</strong></li><li><strong>在休眠状态的消耗能量最少，</strong></li><li><strong>接收状态和侦听状态下的能量消耗略小于发送状态。</strong></li></ul><p><strong>基于上述原因，传感器网络MAC协议为了减少能量的消耗，通常采用“侦听&#x2F;休眠”交替的无线信道使用策略。</strong></p><p><strong>为使节点休眠时不错过发给它的数据，或减少节点的过度侦听，邻居节点间需要协调侦听和休眠的周期。</strong></p><h2 id="3-2-1-2-S-MAC协议"><a href="#3-2-1-2-S-MAC协议" class="headerlink" title="3.2.1.2   S-MAC协议"></a>3.2.1.2   <strong>S-MAC协议</strong></h2><p><strong>S-MAC协议：</strong></p><p><strong>在802.11 MAC协议基础上，针对传感器网络的节省能量需求而提出的传感器网络MAC协议。</strong></p><p><strong>S-MAC协议假设：通常情况下</strong></p><ul><li><strong>传感器网络的数据传输量少,速率较低，</strong></li><li><strong>节点协作完成共同的任务，</strong></li><li><strong>网络内部能够进行数据的处理和融合以减少数据通信量，</strong></li><li><strong>数据传输经常具有方向性，</strong></li><li><strong>网络能够容忍一定程度的通信延迟。</strong></li></ul><p><strong>主要设计目标：提供良好的扩展性，减少节点能量的消耗。</strong></p><p><strong>针对碰撞重传、串音、空闲侦听和控制消息等可能造成传感器网络消耗更多能量的主要因素，S-MAC协议采用以下机制：</strong></p><p>​–<strong>周期性侦听&#x2F;休眠的低占空比工作方式，控制节点尽可能处于睡眠状态来降低节点能量的消耗；</strong></p><p>​–<strong>邻居节点之间通过协商同步的一致性睡眠调度机制形成虚拟簇，减少节点的空闲侦听时间；</strong></p><p>​–<strong>通过流量自适应侦听机制，减少消息在网络中的传输延迟；</strong></p><p>​–<strong>通过“消息传递”（消息分割和突发传递）机制，减少节点的串听和控制消息的开销。</strong></p><p>​–<strong>尽管每一跳(per-hop)的公平性、延时性能有所降低，但全局(end-to-end)性能不受影响</strong></p><h3 id="S-MAC协议──（1）周期性侦听-x2F-休眠"><a href="#S-MAC协议──（1）周期性侦听-x2F-休眠" class="headerlink" title="S-MAC协议──（1）周期性侦听&#x2F;休眠"></a><strong>S-MAC协议──（1）周期性侦听&#x2F;休眠</strong></h3><h4 id="节点按照周期性的侦听-x2F-休眠时序工作"><a href="#节点按照周期性的侦听-x2F-休眠时序工作" class="headerlink" title="节点按照周期性的侦听&#x2F;休眠时序工作"></a><strong>节点按照周期性的侦听&#x2F;休眠时序工作</strong></h4><ul><li><strong>节点独立调度（schedule）其工作状态，周期性转入休眠，醒来后侦听信道状态，判断是否需要发送或接收数据。</strong></li><li><strong>调度周期：节点的“侦听-休眠”的时序。</strong></li><li><strong>占空比：侦听时段&#x2F; (侦听+休眠)时段</strong></li><li><strong>为了减少能量消耗，节点尽量处于低功耗的休眠状态–&gt;低占空比</strong></li></ul><p><img src="/IoT-%E7%AC%AC3%E7%AB%A0-%E6%97%A0%E7%BA%BF%E4%BC%A0%E6%84%9F%E5%99%A8%E7%BD%91%E7%BB%9C-3-2-MAC%E5%8D%8F%E8%AE%AE/image-20231220191900110.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="周期"></p><h4 id="节点周期的同步"><a href="#节点周期的同步" class="headerlink" title="节点周期的同步"></a><strong>节点周期的同步</strong></h4><ul><li><strong>调度周期的同步：在相同时间侦听，在相同时间休眠。</strong></li><li><strong>希望在相邻节点之间建立同步，以保证可能的收发节点之间具有共同的调度周期。</strong></li><li><strong>所以，节点间需要交换各自的调度信息（广播给邻居节点）。</strong></li><li><strong>通常只能保持局部的同步，很难做到全网同步。</strong></li></ul><p><img src="/IoT-%E7%AC%AC3%E7%AB%A0-%E6%97%A0%E7%BA%BF%E4%BC%A0%E6%84%9F%E5%99%A8%E7%BD%91%E7%BB%9C-3-2-MAC%E5%8D%8F%E8%AE%AE/image-20231220191948525.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="同步"></p><h4 id="相邻节点之间的通信"><a href="#相邻节点之间的通信" class="headerlink" title="相邻节点之间的通信"></a><strong>相邻节点之间的通信</strong></h4><ul><li><strong>假设A、C的周期为schedule1，B、D的周期为schedule2</strong></li><li><strong>周期相同：A、C按照schedule1交互，B、D按照schedule2交互</strong></li><li><strong>周期不同：如果A要和B交互时，则A需要等候B的侦听时间</strong></li><li><strong>如果多个A1… Ak要和B交互，则它们需要竞争信道（RTS&#x2F;CTS）</strong></li><li><strong>当节点开始传输数据时，就不用遵守休眠周期了，待传输结束再休眠</strong></li></ul><h4 id="节点的调度信息的创建和维护"><a href="#节点的调度信息的创建和维护" class="headerlink" title="节点的调度信息的创建和维护"></a><strong>节点的调度信息的创建和维护</strong></h4><p><strong>节点维护一张调度表，用以保存它所有邻居的调度信息</strong></p><p>​1.<strong>节点监听一段时间，如果没有收到其它节点的调度信息，则随机选择一个将来的休眠时间，并立即使用SYNC报文来广播此调度信息（t 秒后本人将休眠等）。称这类节点为synchronizer。</strong></p><p>​2.<strong>如果节点在监听时段内收到了其它节点的调度信息，则将自己的调度周期设为此调度信息，然后等待一个随机时间 td之后广播自己的调度信息。称这类节点为follower。</strong></p><p>​3.<strong>如果节点在已经选择并广播了自己的调度信息后，收到了其它节点的调度信息，则采用所有的调度信息（在所有侦听时间醒来）。</strong></p><p><strong>有可能两（多）个节点各自独立地创建了调度周期，则位于它们之间的边界节点将会同时采用这两（多）个调度周期</strong></p><h4 id="同步保持"><a href="#同步保持" class="headerlink" title="同步保持"></a><strong>同步保持</strong></h4><ul><li><strong>由于时钟漂移的存在，需要在节点之间周期性地重发调度信息，以达到精确同步。</strong></li><li><strong>相邻节点之间通过SYNC消息保持同步</strong></li><li><strong>SYNC 消息是一个很短的控制分组，它包含有发送节点的地址、及其下一次休眠时间（相对于开始发送SYNC消息的时间）等</strong></li><li><strong>当节点接收到SYNC 消息后，将会更新它调度表内的相应条目。</strong></li><li><strong>每个节点通过SYNC 消息来定期广播自己的调度信息，可以使新加入的节点与已有节点保持同步。</strong></li><li><strong>侦听时间分成两部分，用于 SYNC 分组、DATA 分组的收发</strong></li></ul><p><img src="/IoT-%E7%AC%AC3%E7%AB%A0-%E6%97%A0%E7%BA%BF%E4%BC%A0%E6%84%9F%E5%99%A8%E7%BD%91%E7%BB%9C-3-2-MAC%E5%8D%8F%E8%AE%AE/image-20231220192111001.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="同步保持"></p><h4 id="虚拟簇"><a href="#虚拟簇" class="headerlink" title="虚拟簇"></a><strong>虚拟簇</strong></h4><p>​–<strong>在一个分布式多跳网络中，实现所有相邻节点休眠时间的同步通常是比较困难的。因此，S-MAC允许一个节点采用多个休眠调度，以使采用不同调度周期的节点可以通过这类节点进行数据转发。</strong></p><p>​–<strong>通过相邻节点之间的同步，使得周期具有相同调度周期的节点形成一个虚拟簇，簇内节点间可以正常通信。</strong></p><p>​–<strong>对于具有多个调度周期的节点，成为虚拟簇的边界节点，可以同时与多个虚拟簇的节点通信。</strong></p><p>​–<strong>S-MAC协议可以形成众多不同的虚拟簇，对大规模部署的传感器网络具有良好的扩展性。</strong></p><p><img src="/IoT-%E7%AC%AC3%E7%AB%A0-%E6%97%A0%E7%BA%BF%E4%BC%A0%E6%84%9F%E5%99%A8%E7%BD%91%E7%BB%9C-3-2-MAC%E5%8D%8F%E8%AE%AE/image-20231220192158212.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="簇"></p><h3 id="S-MAC协议──（2）消息冲突和串音避免"><a href="#S-MAC协议──（2）消息冲突和串音避免" class="headerlink" title="S-MAC协议──（2）消息冲突和串音避免"></a><strong>S-MAC协议──（2）消息冲突和串音避免</strong></h3><p><img src="/IoT-%E7%AC%AC3%E7%AB%A0-%E6%97%A0%E7%BA%BF%E4%BC%A0%E6%84%9F%E5%99%A8%E7%BD%91%E7%BB%9C-3-2-MAC%E5%8D%8F%E8%AE%AE/image-20231220192235893.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="1"></p><p><strong>冲突避免</strong></p><ul><li><strong>采用 802.11 CSMA&#x2F;CA，即 RTS&#x2F;CTS&#x2F;DATA&#x2F;ACK 过程</strong></li><li><strong>802.11MAC 层的 NAV 虚拟载波侦听 + 物理层的物理载波侦听</strong></li></ul><p><strong>串音避免</strong></p><ul><li><strong>802.11 MAC 由于虚拟载波侦听的需要，要求长期保持对所有邻居流量的侦听，因此串听了大量并非发给它的消息，造成能量浪费，尤其在节点密度大、流量负载重的场合。</strong></li><li><strong>S-MAC的串音避免： 当节点收到RTS&#x2F;CTS ，如果目标不是自己，则进入休眠。</strong></li><li><strong>节点的NAV数据可以作为它休眠时间长度的依据之一。</strong></li><li><strong>例：A传输数据给B，哪些节点应该休眠以避免串听？</strong></li></ul><p><img src="/IoT-%E7%AC%AC3%E7%AB%A0-%E6%97%A0%E7%BA%BF%E4%BC%A0%E6%84%9F%E5%99%A8%E7%BD%91%E7%BB%9C-3-2-MAC%E5%8D%8F%E8%AE%AE/image-20231220192319593.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="ex"></p><h3 id="S-MAC协议──（3）自适应侦听"><a href="#S-MAC协议──（3）自适应侦听" class="headerlink" title="S-MAC协议──（3）自适应侦听"></a><strong>S-MAC协议──（3）自适应侦听</strong></h3><p><strong>流量自适应侦听</strong> </p><p>​<strong>–传感器网络采用多跳通信,节点的周期性休眠导致通信延迟增加，延迟会随着跳数的增多而累加。利用WSN数据传送的方向性特点，采用流量自适应侦听可以减少通信延迟的累加效应。</strong></p><p>​<strong>–基本原理： 在一次侦听周期中，当节点邻居节点传输结束后：</strong></p><p><strong>如果节点（例如C）在这段侦听时间内收到CTS分组，并发现自己正好是通信的下一跳，它就休眠一段时间（此时邻居在接收数据）、并及时醒来，在本调度周期内接收数据，而无需等到下一次调度周期，从而减少了数据的传输延迟。</strong></p><p><strong>如果节点在这段侦听时间内没有收到给自己的CTS分组，则按时返回休眠状态，直至下一次侦听周期。</strong></p><p><img src="/IoT-%E7%AC%AC3%E7%AB%A0-%E6%97%A0%E7%BA%BF%E4%BC%A0%E6%84%9F%E5%99%A8%E7%BD%91%E7%BB%9C-3-2-MAC%E5%8D%8F%E8%AE%AE/image-20231220192513886.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="tu"></p><h3 id="S-MAC协议──（4）消息传递"><a href="#S-MAC协议──（4）消息传递" class="headerlink" title="S-MAC协议──（4）消息传递"></a><strong>S-MAC协议──（4）消息传递</strong></h3><p><strong>消息传递机制</strong></p><p>​<strong>802.11 MAC 支持将长消息分割成几个短消息进行传送，每次传送都使用 RTS&#x2F;CTS 以预约一个短消息时间；</strong></p><p>​<strong>S-MAC 对于长消息采用了专门的消息传递机制：将长消息分割成几个短消息，让它们在预约时间内突发传送，只使用一次RTS&#x2F;CTS 来预约整个长消息时间。</strong></p><p>​<strong>接收节点对每个短消息都要发一个 ACK 应答，未收到ACK的发送节点将会重传该短消息。这里的多次ACK具有防止隐藏终端的作用（例：节点醒来或新节点加入、并且它是接收节点的邻居而非发送节点的邻居）。</strong></p><p><strong>S-MAC 消息传递 vs. 802.11 MAC</strong></p><ul><li><strong>802.11 MAC协议的RTS&#x2F;CTS只预约下一个短消息的时间（公平性），邻居节点必须多次侦听每个短消息的时间。</strong></li><li><strong>S-MAC协议的RTS&#x2F;CTS控制消息和数据消息携带的时间是整个长消息传输的剩余时间（全部预约、分段传输，达到传递长消息时的能量高效），邻居节点仅需一次侦听整个长消息的时间。</strong></li><li><strong>因此，S-MAC通过消息传递机制，减少了邻居的串听。</strong></li></ul><p><img src="/IoT-%E7%AC%AC3%E7%AB%A0-%E6%97%A0%E7%BA%BF%E4%BC%A0%E6%84%9F%E5%99%A8%E7%BD%91%E7%BB%9C-3-2-MAC%E5%8D%8F%E8%AE%AE/image-20231220192616013.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="vs"></p><p><img src="/IoT-%E7%AC%AC3%E7%AB%A0-%E6%97%A0%E7%BA%BF%E4%BC%A0%E6%84%9F%E5%99%A8%E7%BD%91%E7%BB%9C-3-2-MAC%E5%8D%8F%E8%AE%AE/image-20231220192658751.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="ex"></p><p><img src="/IoT-%E7%AC%AC3%E7%AB%A0-%E6%97%A0%E7%BA%BF%E4%BC%A0%E6%84%9F%E5%99%A8%E7%BD%91%E7%BB%9C-3-2-MAC%E5%8D%8F%E8%AE%AE/image-20231220192713811.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="ex2"></p><h3 id="S-MAC协议──小结"><a href="#S-MAC协议──小结" class="headerlink" title="S-MAC协议──小结"></a><strong>S-MAC协议──小结</strong></h3><p><strong>优缺点</strong></p><ul><li><strong>S-MAC协议比IEEE 802.11协议具有更高的能量效率（节省超过90%）、更强的可扩展性，能够更好地适应网络拓扑结构的变化。</strong></li><li><strong>但由于采用固定的休眠占空比，信道的带宽利用率受到一定影响；虚拟簇节点使用大量SYNC广播分组，当网络业务负载较大时，控制开销带来的能耗代价将成为负担。</strong></li><li><strong>S-MAC协议最主要的缺点是较大的传输迟延，因为它是以牺牲迟延换取能量节省的。</strong></li></ul><h2 id="3-2-1-3-T-MAC协议"><a href="#3-2-1-3-T-MAC协议" class="headerlink" title="3.2.1.3  T-MAC协议"></a>3.2.1.3  <strong>T-MAC协议</strong></h2><p>•<strong>T-MAC协议：在S-MAC协议的基础上提出。</strong></p><p>•<strong>传感器网络MAC协议最重要的设计目标是减少能量消耗，而空闲侦听的能量消耗占绝对大的比例，特别是在消息传输频率较低的情况下。</strong></p><p>•<strong>S-MAC协议通过采用周期性侦听&#x2F;睡眠工作方式来减少空闲侦听，周期长度固定不变，节点的侦听活动时间也是固定。</strong></p><p>•<strong>T-MAC协议中，发送数据时仍为RTS&#x2F;CTS&#x2F;DATA&#x2F;ACK的通信过程，节点周期性唤醒进行侦听，如果在一个给定时间TA(time active)内没有发生下面任何一个激活事件，则活动结束。</strong></p><p>​-<strong>周期时间定时器溢出</strong></p><p>​-<strong>在无线信道上收到数据</strong></p><p>​-<strong>通过接收信号强度指示RSSI感知存在无线通信</strong></p><p>​-<strong>节点数据包或确认消息发送完毕</strong></p><p>​-<strong>通过侦听RTS&#x2F;CTS分组，确认邻居的数据交换已经结束。</strong></p><h3 id="S-MAC与T-MAC协议的对比"><a href="#S-MAC与T-MAC协议的对比" class="headerlink" title="S-MAC与T-MAC协议的对比"></a><strong>S-MAC与T-MAC协议的对比</strong></h3><p><img src="/IoT-%E7%AC%AC3%E7%AB%A0-%E6%97%A0%E7%BA%BF%E4%BC%A0%E6%84%9F%E5%99%A8%E7%BD%91%E7%BB%9C-3-2-MAC%E5%8D%8F%E8%AE%AE/image-20231220192913972.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="vs"></p><h3 id="T-MAC协议的基本数据交换"><a href="#T-MAC协议的基本数据交换" class="headerlink" title="T-MAC协议的基本数据交换"></a><strong>T-MAC协议的基本数据交换</strong></h3><p>•<strong>TA取值</strong></p><p>  <strong>在每个活动期间开始，T-MAC协议按照突发方式发送所有数据。TA决定每个周期最小的空闲侦听时间，它的取值对于T-MAC协议性能至关重要,</strong></p><pre><code class="hljs">                                                                   **TA&gt; C+ R + T**</code></pre><p>  <strong>其中，C为竞争信道时间，R、T为发送RTS、CTS分组的时间。</strong></p><p><img src="/IoT-%E7%AC%AC3%E7%AB%A0-%E6%97%A0%E7%BA%BF%E4%BC%A0%E6%84%9F%E5%99%A8%E7%BD%91%E7%BB%9C-3-2-MAC%E5%8D%8F%E8%AE%AE/image-20231220192939088.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="交换"></p><h3 id="T-MAC协议：早睡问题"><a href="#T-MAC协议：早睡问题" class="headerlink" title="T-MAC协议：早睡问题"></a><strong>T-MAC协议：早睡问题</strong></h3><p><strong>假设传输方向A→B →C →D。</strong></p><p><strong>如果节点A通过竞争首先获得发送，A向B发送RTS消息，B应答CTS。</strong></p><p><strong>C收到B发出的CTS消息而转入睡眠状态，当B接收完数据，节点C醒来以便接收节点B发送给它的数据。</strong></p><p><strong>D可能不知道A与B的通信存在，在A→B时的通信状态结束后就已经处于睡眠状态，这样，节点C只能等到下一个周期才能传输数据到D。</strong></p><p><strong>这种通信延迟称为早睡问题（加剧于T-MAC的提前结束活动）。</strong></p><p><img src="/IoT-%E7%AC%AC3%E7%AB%A0-%E6%97%A0%E7%BA%BF%E4%BC%A0%E6%84%9F%E5%99%A8%E7%BD%91%E7%BB%9C-3-2-MAC%E5%8D%8F%E8%AE%AE/image-20231220193013975.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="early sleep"></p><h4 id="1）未来请求发送-future-request-to-send-FRTS"><a href="#1）未来请求发送-future-request-to-send-FRTS" class="headerlink" title="1）未来请求发送(future request-to-send, FRTS)"></a><strong>1）未来请求发送(future request-to-send, FRTS)</strong></h4><p><strong>当节点C收到B发送给A的CTS分组后，立刻向下一跳D发出FRTS分组。</strong></p><p><strong>FRTS分组包含节点D接收数据前需要等待的时间长度，节点D要在休眠相应长度时间后醒来接收数据。</strong></p><p><strong>由于节点C发送的FRTS分组可能干扰节点A发送的数据，所以节点A需要推迟发送数据的时间。节点A通过在接收到CTS分组后发送一个与FRTS分组长度相同的DS (data-send)分组实现对信道的占用。DS分组不包含有用信息。</strong></p><p><strong>节点A在DS分组之后开始发送正常的数据信息。FRTS方法可以提高吞吐率，但DS分组和FRTS分组带来了额外的通信开销。</strong></p><p><img src="/IoT-%E7%AC%AC3%E7%AB%A0-%E6%97%A0%E7%BA%BF%E4%BC%A0%E6%84%9F%E5%99%A8%E7%BD%91%E7%BB%9C-3-2-MAC%E5%8D%8F%E8%AE%AE/image-20231220193043844.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="FRTS"></p><p><img src="/IoT-%E7%AC%AC3%E7%AB%A0-%E6%97%A0%E7%BA%BF%E4%BC%A0%E6%84%9F%E5%99%A8%E7%BD%91%E7%BB%9C-3-2-MAC%E5%8D%8F%E8%AE%AE/image-20231220193054291.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="FRTS"></p><h4 id="2）满缓冲区优先-full-buffer-priority"><a href="#2）满缓冲区优先-full-buffer-priority" class="headerlink" title="2）满缓冲区优先(full buffer priority)"></a><strong>2）满缓冲区优先(full buffer priority)</strong></h4><p><strong>当节点的缓冲区接近占满时，对收到的RTS不作应答，而是立即向目标接收者发送RTS消息，并传输数据给目标节点。</strong></p><p>​–<strong>节点B向节点C发送RTS分组，节点C因缓冲区快满不发送CTS，而是向节点D发送RTS，将它的（缓冲区内）数据发送给节点D。</strong></p><p>​–<strong>该方法的优点是减少了早睡问题发生的可能，并起到了一定的网络流量的控制作用，带来的问题是增加了冲突的可能性。</strong></p><p><img src="/IoT-%E7%AC%AC3%E7%AB%A0-%E6%97%A0%E7%BA%BF%E4%BC%A0%E6%84%9F%E5%99%A8%E7%BD%91%E7%BB%9C-3-2-MAC%E5%8D%8F%E8%AE%AE/image-20231220193729431.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="fbp"></p><h4 id="T-MAC协议：小结"><a href="#T-MAC协议：小结" class="headerlink" title="T-MAC协议：小结"></a><strong>T-MAC协议：小结</strong></h4><p>•<strong>T-MAC协议根据当前的网络通信情况，通过提前结束活动周期来减少空闲侦听，但带来了早睡问题，需要FRTS等方案。</strong></p><p>•<strong>性能对比</strong></p><p>​–<strong>在负载恒定不变的情况下，T-MAC协议与采用固定占空比的S-MAC协议相比，节能效率相仿；</strong></p><p>​–<strong>在负载恒定不变的情况下，T-MAC协议与未采用占空比模式的CSMA协议相比，能够节省多达98%的能量；</strong></p><p>​–<strong>在负载动态可变的情况下，T-MAC协议与S-MAC协议相比，更加节省能量。</strong></p><p><img src="/IoT-%E7%AC%AC3%E7%AB%A0-%E6%97%A0%E7%BA%BF%E4%BC%A0%E6%84%9F%E5%99%A8%E7%BD%91%E7%BB%9C-3-2-MAC%E5%8D%8F%E8%AE%AE/image-20231220193800904.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="ex"></p><h2 id="3-2-2-竞争型MAC协议—异步no-synchronization"><a href="#3-2-2-竞争型MAC协议—异步no-synchronization" class="headerlink" title="3.2.2 竞争型MAC协议—异步no synchronization"></a>3.2.2 <strong>竞争型MAC协议—异步no synchronization</strong></h2><p><strong>上述基于竞争的MAC协议具有良好的扩展性，并且不要求严格的时钟同步，但它们往往只是从发送数据的节点考虑问题，对接收节点的考虑相对较少。</strong></p><p><strong>在基于竞争的MAC协议中，节点发送数据时竞争使用无线信道，并通知接收节点及时处于接收状态。节点处于休眠状态可能造成通信暂时中断，增大消息的传播延迟，所以在节省节点能量和增大消息延迟之间需要权衡。</strong></p><h3 id="竞争型MAC协议：局部同步-gt-异步"><a href="#竞争型MAC协议：局部同步-gt-异步" class="headerlink" title="竞争型MAC协议：局部同步-&gt;异步"></a><strong>竞争型MAC协议：局部同步-&gt;异步</strong></h3><p><strong>基于周期性侦听&#x2F;休眠的方式：减少因空闲侦听造成的能量消耗</strong></p><p><strong>固定占空比方式（局部同步，S-MAC为例）的缺点</strong></p><ul><li><strong>需要依靠大量的控制开销来建立和维护节点间的周期性同步</strong></li><li><strong>节点在没有数据收发时，仍然需要在整个侦听周期内保持侦听状态，对网络业务负载变化的适应性较差。</strong></li></ul><p><strong>异步占空比方式</strong></p><ul><li><strong>基于异步周期性侦听&#x2F;休眠调度机制的协议（B-MAC、RI-MAC 等）</strong></li><li><strong>由各个节点独自决定自己的休眠和唤醒时间，不需要在所有节点之间建立和保持同步，只在发送者&#x2F;接受者有数据需要传送时直接和目标节点建立同步</strong></li><li><strong>分类：发送方发起（B-MAC）、接收方发起（RI-MAC）</strong></li></ul><h3 id="B-MAC协议"><a href="#B-MAC协议" class="headerlink" title="B-MAC协议"></a><strong>B-MAC协议</strong></h3><p><strong>采用前导采样（preamble sampling）来实现收&#x2F;发节点之间的同步，也称为低功耗侦听（LPL）</strong></p><p><img src="/IoT-%E7%AC%AC3%E7%AB%A0-%E6%97%A0%E7%BA%BF%E4%BC%A0%E6%84%9F%E5%99%A8%E7%BD%91%E7%BB%9C-3-2-MAC%E5%8D%8F%E8%AE%AE/image-20231220194239824.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="b-mac"></p><p><strong>侦听周期Tp是一个重要参数，它直接影响节点的能耗</strong></p><ul><li><strong>如果Tp很小，接收节点会因频繁的唤醒侦听而浪费能量</strong></li><li><strong>如果Tp很大，发送节点会因传输很长的前导分组而增加能量消耗</strong></li></ul><p><strong>Preamble长度</strong></p><ul><li><strong>为避免分组空传，前导序列长度需要大于接收方的休眠时间</strong></li></ul><h4 id="B-MAC：低功耗侦听LPL的工作原理"><a href="#B-MAC：低功耗侦听LPL的工作原理" class="headerlink" title="B-MAC：低功耗侦听LPL的工作原理"></a><strong>B-MAC：低功耗侦听LPL的工作原理</strong></h4><p><strong>LPL机制的成功执行依赖于节点对信道状态的准确感知</strong></p><p><strong>采用空闲信道评估机制（clear channel assessment, CCA）</strong></p><p><strong>CCA主要考虑无线信道的两个特征：</strong></p><ul><li><strong>噪声信号易受环境影响而动态变化</strong></li><li><strong>数据包在信道上传输时表现在相对稳定的信道能量</strong></li></ul><p><strong>因此，不能仅仅依靠单独采样，而是需要一定时间内的多次采样。</strong></p><p><strong>CCA机制的工作流程</strong></p><ul><li><strong>噪声基准估计阶段：发送节点首先进行空闲信道采样，计算和更新噪声基准值。</strong></li><li><strong>传输信号检测阶段：发送数据之前，节点需要再次对当前信道信息采样，检测多个连续采样值中是否存在孤立点（低值点）</strong><ul><li><strong>如果存在，则认为信道空闲，节点开始发送数据；</strong></li><li><strong>如果不存在，则认为信道忙，节点退避一段时间后再重复上述。</strong></li></ul></li></ul><h3 id="RI-MAC协议"><a href="#RI-MAC协议" class="headerlink" title="RI-MAC协议"></a><strong>RI-MAC协议</strong></h3><p><strong>任何数据帧的传输都由接收节点发起，即由接收节点发送一个信标分组（beacon）来主动通知发送节点开始数据分组传输。</strong></p><p><img src="/IoT-%E7%AC%AC3%E7%AB%A0-%E6%97%A0%E7%BA%BF%E4%BC%A0%E6%84%9F%E5%99%A8%E7%BD%91%E7%BB%9C-3-2-MAC%E5%8D%8F%E8%AE%AE/image-20231220194418968.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="rimac"></p><h2 id="3-2-3-调度型（分配型）MAC协议—全局同步global-synchronization"><a href="#3-2-3-调度型（分配型）MAC协议—全局同步global-synchronization" class="headerlink" title="3.2.3  调度型（分配型）MAC协议—全局同步global synchronization"></a>3.2.3  <strong>调度型（分配型）MAC协议—全局同步global synchronization</strong></h2><h3 id="竞争型-gt-分配型"><a href="#竞争型-gt-分配型" class="headerlink" title="竞争型-&gt; 分配型"></a><strong>竞争型-&gt; 分配型</strong></h3><p><strong>随着网络流量的增大，竞争型的MAC协议中节点发生冲突的概率增大，这样不仅降低了网络带宽利用率，而且浪费大量能量。</strong></p><p><strong>分配型的MAC协议通常采用TDMA、CDMA、FDMA或者SDMA等技术，将一条物理信道划分为许多子信道，然后将这些子信道根据节点的需求动态或固定（静态）地分配给节点，避免不必要的冲突发生。</strong></p><p><strong>经常采用TDMA，具有较高的时间同步要求。</strong></p><p><strong>分配型MAC需要理想的介质和环境，不存在其他竞争网络或行为异常的节点。</strong></p><h3 id="TRAMA协议"><a href="#TRAMA协议" class="headerlink" title="TRAMA协议"></a><strong>TRAMA协议</strong></h3><p><strong>流量自适应介质访问(Traffic adaptive medium access, TRAMA)协议</strong></p><ul><li><strong>将信道按时间划分为连续的时隙</strong></li><li><strong>每个节点掌握其两跳范围内的邻居节点信息</strong></li><li><strong>采用分布式选举机制确定每个时隙的无冲突发送者：</strong></li><li><strong>根据节点的ID号及当前时隙号，各节点利用哈希函数分布式地计算出所有节点在每个时隙上的优先级，并将当前时隙分配给优先级最高的节点。</strong></li><li><strong>同时，通过避免将时隙分配给没有业务流量的节点，让没有通信任务的节点转入休眠状态。</strong></li></ul><h4 id="TRAMA协议的三部分"><a href="#TRAMA协议的三部分" class="headerlink" title="TRAMA协议的三部分"></a><strong>TRAMA协议的三部分</strong></h4><p><strong>（1）邻居协议NP（neighbor protocol)</strong> </p><p><strong>NP协议在随机访问周期内执行，节点间通过NP协议需要获得一致的两跳邻居拓扑结构及各节点的业务流量信息。</strong></p><p><strong>协议要求节点周期性通告自己的编号ID，是否有数据需要发送以及能够直接通信的邻居节点的相关信息，并实现节点间的时间同步。</strong></p><p><strong>（2）调度交换协议SEP（schedule exchange protocol)</strong> </p><p><strong>SEP协议用来建立和维护发送者和接收者的调度信息。在调度访问周期内，节点周期性地通过调度分组向邻居广播它的调度信息。</strong></p><p><strong>（3）自适应选举算法AEA（adaptive election algorithm)</strong> </p><p><strong>AEA用来通过计算两跳范围内所有节点的优先级，分布式地决定各个节点在当前时隙内的活动策略（发送、接收、休眠）。</strong></p><p><strong>节点s在时隙t的优先级通过伪随机的哈希函数计算：</strong></p><p> <strong>priority(s, t) &#x3D; hash(s∙t)</strong></p><p><strong>各节点最终确定的在每个时隙上优先级最高的优胜节点是一致的。</strong></p><h4 id="TRAMA协议的时隙组织"><a href="#TRAMA协议的时隙组织" class="headerlink" title="TRAMA协议的时隙组织"></a><strong>TRAMA协议的时隙组织</strong></h4><p><strong>连续时隙组成的信道被划分为周期性交替的随机访问阶段（包含通告时隙）、调度访问阶段（包含传输时隙）</strong></p><p><strong>随机访问阶段主要用于网络维护，如节点失效、新节点加入引起的网络拓扑结构变化</strong></p><p><strong>调度访问阶段用于确定每个时隙的发送者和接收者，实现无冲突的数据传输</strong></p><p><img src="/IoT-%E7%AC%AC3%E7%AB%A0-%E6%97%A0%E7%BA%BF%E4%BC%A0%E6%84%9F%E5%99%A8%E7%BD%91%E7%BB%9C-3-2-MAC%E5%8D%8F%E8%AE%AE/image-20231220194655014.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="TRAMA"></p><h3 id="DMAC协议"><a href="#DMAC协议" class="headerlink" title="DMAC协议"></a><strong>DMAC协议</strong></h3><p><strong>DMAC协议的基本思想</strong></p><pre><code class="hljs"> **传感器网络中一种重要的通信模式是多个传感器节点向一个汇聚节点发送数据。所有传感器节点转发收到的数据，形成一个以汇聚节点为根节点的树型网络结构，称为采集树(data gathering tree)。**  **在基于竞争方式的MAC协议中,节点采用周期性的活动/休眠策略来减少能量消耗，但会出现数据在转发过程中“走走–停停”的通信停顿问题。在数据采集树结构中，这种传输延迟会随着路径上的跳数比例增加。**  **DMAC协议就是针对这种数据采集树结构提出的，目标是减少数据的传输延迟和网络的能量消耗。**</code></pre><p><img src="/IoT-%E7%AC%AC3%E7%AB%A0-%E6%97%A0%E7%BA%BF%E4%BC%A0%E6%84%9F%E5%99%A8%E7%BD%91%E7%BB%9C-3-2-MAC%E5%8D%8F%E8%AE%AE/image-20231220194837972.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="针对数据采集树的DMAC协议"></p><h4 id="DMAC协议的工作原理"><a href="#DMAC协议的工作原理" class="headerlink" title="DMAC协议的工作原理"></a><strong>DMAC协议的工作原理</strong></h4><p><strong>DMAC的核心思想是采用交错调度机制。</strong></p><p><strong>将节点划分为接收时间，发送时间和睡眠时间。其中接收时间和发送时间相等，均为发送一个数据的分组时间。</strong></p><p><strong>每个节点的调度具有不同的偏移，下层节点的发送时间对应上层节点的接收时间。这样，数据能够连续地从数据源节点传送到汇聚节点，减少在网络中的传输延迟。</strong></p><p><img src="/IoT-%E7%AC%AC3%E7%AB%A0-%E6%97%A0%E7%BA%BF%E4%BC%A0%E6%84%9F%E5%99%A8%E7%BD%91%E7%BB%9C-3-2-MAC%E5%8D%8F%E8%AE%AE/image-20231220194908799.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="原理"></p><h2 id="3-2-4-混合型MAC协议"><a href="#3-2-4-混合型MAC协议" class="headerlink" title="3.2.4  混合型MAC协议"></a>3.2.4  <strong>混合型MAC协议</strong></h2><p><strong>同时包含了竞争型协议和分配型协议设计要素</strong></p><ul><li><strong>通过周期性分配型的MAC协议的优点减少空闲侦听、碰撞重传；</strong></li><li><strong>发挥竞争型协议的灵活性和低复杂性。</strong></li></ul><p><strong>但是，设计难度大，实现困难。</strong></p><p><strong>典型的协议主要有 Z-MAC、Funneling-MAC，二者均为 CSMA 与 TDMA 的混合型 MAC 协议</strong></p><h3 id="Z-MAC协议"><a href="#Z-MAC协议" class="headerlink" title="Z-MAC协议"></a><strong>Z-MAC协议</strong></h3><p><strong>协议运行包含两个阶段</strong></p><ul><li><strong>启动阶段：发现邻居，获得两跳网络拓扑，时隙分配</strong></li><li><strong>运行阶段：对节点进行传输控制</strong></li></ul><p><strong>在低流量条件下使用CSMA信道访问方式，可提高信道利用率并降低延时；</strong></p><p><strong>在高流量条件下使用TDMA信道方式，可减少冲突和串听。</strong></p><p><strong>特点：</strong></p><ul><li><strong>适合于中、高网络流量的传感器网络应用，具有比传统TDMA协议更好的可靠性和容错能力</strong></li><li><strong>在最坏情况下，性能接近于CSMA。</strong></li><li><strong>缺点：启动阶段的初始化操作复杂，局部范围通信量大，并且需要全局时间同步，节点有时存在隐藏终端问题。</strong></li></ul><h3 id="Funneling-MAC协议"><a href="#Funneling-MAC协议" class="headerlink" title="Funneling-MAC协议"></a><strong>Funneling-MAC协议</strong></h3><p><strong>传感器网络常见的单跳传输、多跳聚合的通信方式，造成sink附近的数据传输量大，容易发生冲突、拥塞和丢包，这种现象被称为漏斗效应（funneling effect）。</strong></p><p><img src="/IoT-%E7%AC%AC3%E7%AB%A0-%E6%97%A0%E7%BA%BF%E4%BC%A0%E6%84%9F%E5%99%A8%E7%BD%91%E7%BB%9C-3-2-MAC%E5%8D%8F%E8%AE%AE/image-20231220195038590.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="漏斗"></p><h4 id="Funneling-MAC协议的工作原理"><a href="#Funneling-MAC协议的工作原理" class="headerlink" title="Funneling-MAC协议的工作原理"></a><strong>Funneling-MAC协议的工作原理</strong></h4><p><strong>协议基本思想：全网采用CSMA，漏斗区域采用TDMA</strong></p><p><strong>工作过程</strong></p><ul><li><strong>节点默认采用CSMA，局部TDMA由sink节点发起。</strong></li><li><strong>当网络中的流量达到一定程度时，sink广播信标分组（beacon）触发TDMA。</strong></li><li><strong>收到信标分组的节点称为F-节点，采用CSMA和TDMA结合通信。</strong></li><li><strong>F-节点所在的区域称为强度区域，其范围由sink节点根据网络的实时流量情况，通过控制信标分组的发送功率动态调节。</strong></li><li><strong>为实现同步，所有的F-节点在收到信标分组时统一初始化时钟。</strong></li><li><strong>Sink节点负责F-节点的时隙调度。</strong></li><li><strong>协议采用超帧结构。</strong></li></ul><h4 id="Funneling-MAC协议的超帧结构"><a href="#Funneling-MAC协议的超帧结构" class="headerlink" title="Funneling-MAC协议的超帧结构"></a><strong>Funneling-MAC协议的超帧结构</strong></h4><p><strong>一个超帧由一个CSMA帧和一个TDMA帧构成，两个信标分组之间包含多个超帧。</strong></p><p><strong>F-节点依靠sink节点广播的信标分组将自己的时钟与超帧同步，使用CSMA帧和TDMA帧交替访问信道。</strong></p><ul><li><strong>CSMA帧</strong><ul><li><strong>通信过程中临时产生的新数据，还没有被分配通信时隙</strong></li><li><strong>网络中突发性的事件信息、实时性要求高的控制信息</strong></li></ul></li><li><strong>TDMA帧</strong><ul><li><strong>各个F-节点在分配的时隙内转发数据</strong></li></ul></li><li><strong>Sink节点的时隙分配表紧随信标分组发送</strong></li></ul><p><img src="/IoT-%E7%AC%AC3%E7%AB%A0-%E6%97%A0%E7%BA%BF%E4%BC%A0%E6%84%9F%E5%99%A8%E7%BD%91%E7%BB%9C-3-2-MAC%E5%8D%8F%E8%AE%AE/image-20231220195207150.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="ex"></p>]]></content>
    
    
    <categories>
      
      <category>学习资料</category>
      
    </categories>
    
    
    <tags>
      
      <tag>课件笔记</tag>
      
      <tag>物联网技术与应用</tag>
      
      <tag>IoT</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>IoT__第3章__无线传感器网络__3.1_简述</title>
    <link href="/IoT-%E7%AC%AC3%E7%AB%A0-%E6%97%A0%E7%BA%BF%E4%BC%A0%E6%84%9F%E5%99%A8%E7%BD%91%E7%BB%9C-3-1-%E7%AE%80%E8%BF%B0/"/>
    <url>/IoT-%E7%AC%AC3%E7%AB%A0-%E6%97%A0%E7%BA%BF%E4%BC%A0%E6%84%9F%E5%99%A8%E7%BD%91%E7%BB%9C-3-1-%E7%AE%80%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="第三章-无线传感器网络"><a href="#第三章-无线传感器网络" class="headerlink" title="**第三章 **无线传感器网络"></a>**第三章 **无线传感器网络</h1><h2 id="3-1-简述"><a href="#3-1-简述" class="headerlink" title="3.1 简述"></a>3.1 <strong>简述</strong></h2><h2 id="传感器网络-Sensor-Networks"><a href="#传感器网络-Sensor-Networks" class="headerlink" title="传感器网络 Sensor Networks"></a><strong>传感器网络</strong> <strong>Sensor Networks</strong></h2><p>传感器网络是一种由传感器节点组成的网络，其中每个传感器节点具有传感器、微处理器和通信接口电路，节点之间通过通信链路组成网络，共同协作来监测各种物理量和事件。简称传感网。</p><p>有线传感器网络</p><ul><li>较多用于自动化领域，可以构成网络控制系统，把单个分散的测量控制设备当成为网络节点，通过底层控制网络把它们连接起来，共同完成信息汇集、自动控制的任务。</li><li>现场总线系统可以在一对导线上挂接多个传感器、执行器、开关、按钮和控制设备等。</li><li>Profibus、LonWorks、HART、CAN (车内总线)、M-bus** (仪表总线) …</li></ul><p>无线传感器网络</p><ul><li>低功耗、短距离、无线移动网络</li><li>简称：无线传感网</li></ul><h3 id="无线传感网-（WSN-Wireless-Sensor-Network）"><a href="#无线传感网-（WSN-Wireless-Sensor-Network）" class="headerlink" title="无线传感网 （WSN: Wireless Sensor Network）"></a><strong>无线传感网 （WSN: Wireless Sensor Network）</strong></h3><p><img src="/IoT-%E7%AC%AC3%E7%AB%A0-%E6%97%A0%E7%BA%BF%E4%BC%A0%E6%84%9F%E5%99%A8%E7%BD%91%E7%BB%9C-3-1-%E7%AE%80%E8%BF%B0/image-20231030220308197.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="WSN"></p><p><img src="/IoT-%E7%AC%AC3%E7%AB%A0-%E6%97%A0%E7%BA%BF%E4%BC%A0%E6%84%9F%E5%99%A8%E7%BD%91%E7%BB%9C-3-1-%E7%AE%80%E8%BF%B0/image-20231030220319583.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="1"></p><p><img src="/IoT-%E7%AC%AC3%E7%AB%A0-%E6%97%A0%E7%BA%BF%E4%BC%A0%E6%84%9F%E5%99%A8%E7%BD%91%E7%BB%9C-3-1-%E7%AE%80%E8%BF%B0/image-20231030220325971.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="应用"></p><h4 id="WSN-的早期需求来源：态势感知"><a href="#WSN-的早期需求来源：态势感知" class="headerlink" title="WSN 的早期需求来源：态势感知"></a><strong>WSN</strong> <strong>的早期需求来源：态势感知</strong></h4><p><img src="/IoT-%E7%AC%AC3%E7%AB%A0-%E6%97%A0%E7%BA%BF%E4%BC%A0%E6%84%9F%E5%99%A8%E7%BD%91%E7%BB%9C-3-1-%E7%AE%80%E8%BF%B0/image-20231030220354462.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="1"></p><h4 id="无线传感器网络的早期发展"><a href="#无线传感器网络的早期发展" class="headerlink" title="无线传感器网络的早期发展"></a><strong>无线传感器网络的早期发展</strong></h4><p><img src="/IoT-%E7%AC%AC3%E7%AB%A0-%E6%97%A0%E7%BA%BF%E4%BC%A0%E6%84%9F%E5%99%A8%E7%BD%91%E7%BB%9C-3-1-%E7%AE%80%E8%BF%B0/image-20231030220412458.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="1"></p><p><img src="/IoT-%E7%AC%AC3%E7%AB%A0-%E6%97%A0%E7%BA%BF%E4%BC%A0%E6%84%9F%E5%99%A8%E7%BD%91%E7%BB%9C-3-1-%E7%AE%80%E8%BF%B0/image-20231030220427850.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="2"></p><p><img src="/IoT-%E7%AC%AC3%E7%AB%A0-%E6%97%A0%E7%BA%BF%E4%BC%A0%E6%84%9F%E5%99%A8%E7%BD%91%E7%BB%9C-3-1-%E7%AE%80%E8%BF%B0/image-20231030220441709.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="3"></p><h4 id="无线传感器网络的应用优势"><a href="#无线传感器网络的应用优势" class="headerlink" title="无线传感器网络的应用优势"></a><strong>无线传感器网络的应用优势</strong></h4><p><strong>分布节点中多角度和多方位信息的综合有效地提高了信噪比</strong></p><p><strong>低成本、高冗余的设计提供了较强的容错能力</strong></p><p><strong>节点与探测目标的近距离接触消除了环境噪声对系统性能的影响</strong></p><p><strong>节点中多种传感器的混合应用提高了探测的性能指标</strong></p><p><strong>多节点联合，形成覆盖面积较大的实时探测区域</strong></p><p><strong>个别移动节点对拓扑结构的调整有效消除了探测阴影和盲点</strong></p><p><img src="/IoT-%E7%AC%AC3%E7%AB%A0-%E6%97%A0%E7%BA%BF%E4%BC%A0%E6%84%9F%E5%99%A8%E7%BD%91%E7%BB%9C-3-1-%E7%AE%80%E8%BF%B0/image-20231030220736956.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="1"></p><p><img src="/IoT-%E7%AC%AC3%E7%AB%A0-%E6%97%A0%E7%BA%BF%E4%BC%A0%E6%84%9F%E5%99%A8%E7%BD%91%E7%BB%9C-3-1-%E7%AE%80%E8%BF%B0/image-20231030220743864.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="2"></p><p><img src="/IoT-%E7%AC%AC3%E7%AB%A0-%E6%97%A0%E7%BA%BF%E4%BC%A0%E6%84%9F%E5%99%A8%E7%BD%91%E7%BB%9C-3-1-%E7%AE%80%E8%BF%B0/image-20231030220749756.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="3"></p><h4 id="无线传感器网络的技术定位"><a href="#无线传感器网络的技术定位" class="headerlink" title="无线传感器网络的技术定位"></a><strong>无线传感器网络的技术定位</strong></h4><p><img src="/IoT-%E7%AC%AC3%E7%AB%A0-%E6%97%A0%E7%BA%BF%E4%BC%A0%E6%84%9F%E5%99%A8%E7%BD%91%E7%BB%9C-3-1-%E7%AE%80%E8%BF%B0/image-20231030220811581.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="定位"></p><h4 id="无线传感器网络的技术特点"><a href="#无线传感器网络的技术特点" class="headerlink" title="无线传感器网络的技术特点"></a><strong>无线传感器网络的技术特点</strong></h4><p><img src="/IoT-%E7%AC%AC3%E7%AB%A0-%E6%97%A0%E7%BA%BF%E4%BC%A0%E6%84%9F%E5%99%A8%E7%BD%91%E7%BB%9C-3-1-%E7%AE%80%E8%BF%B0/image-20231030220903857.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="1"></p><p><strong>节点</strong></p><p>–<strong>微型化：嵌入物理世界</strong></p><p>–<strong>智能化：增强的数据处理</strong></p><p>–<strong>自治化：容错性</strong></p><p>–<strong>多样化：尽可能感知周围感兴趣的物质现象</strong></p><p><strong>网络</strong></p><p>–<strong>密集性：抵抗敌意和恶意破坏</strong></p><p>–<strong>灵活性：快速构建信息基础设施</strong></p><p>–<strong>自组织：鲁棒性</strong></p><p>–<strong>多跳性：低能耗</strong></p><h4 id="无线传感器网络的体系结构"><a href="#无线传感器网络的体系结构" class="headerlink" title="无线传感器网络的体系结构"></a><strong>无线传感器网络的体系结构</strong></h4><p><strong>传感器网络结构</strong></p><p><img src="/IoT-%E7%AC%AC3%E7%AB%A0-%E6%97%A0%E7%BA%BF%E4%BC%A0%E6%84%9F%E5%99%A8%E7%BD%91%E7%BB%9C-3-1-%E7%AE%80%E8%BF%B0/image-20231030221000179.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="1"></p><p><strong>传感器网络系统通常包括传感器节点、汇聚节点和管理节点。</strong></p><p>大量<strong>传感器节点</strong>（sensor nodes）都随机部署在<strong>监测区域</strong>（sensor field）内部或附近，能够通过自组织方式构成网络。传感器节点监测的<strong>数据</strong>沿着其他传感器节点逐跳地进行传输，在传输过程中监测数据可能被多个节点处理，经过多跳后路由到<strong>汇聚节点</strong>，最后通过互联网或卫星到达管理节点。用户通过<strong>管理节点</strong>对传感器网络进行配置和管理，发布监测任务以及收集监测数据。</p><p><strong>传感器节点</strong>是一个微型的嵌入式系统，处理能力、存储能力和通信能力相对较弱。每个传感器节点兼顾传统网络节点的终端和路由功能，除了进行信息收集和数据处理外，还要对其它传感器节点发出来的数据进行存储、管理和融合等处理，同时与其它节点协作完成一些特定的任务。</p><p><strong>汇聚节点</strong>（sink node）的处理能力、存储能力和通信能力相对较强，它连接无线传感器网络与Internet等外部网络，实现两种协议之间的通讯协议转换，同时发布管理节点的监测任务，并把收集到的信息数据转发到外部网络上。</p><h5 id="传感器节点结构"><a href="#传感器节点结构" class="headerlink" title="传感器节点结构"></a><strong>传感器节点结构</strong></h5><p><strong>传感器节点一般由传感模块、处理模块、无线通信模块和能量供应模块组成。</strong></p><ul><li>传感器模块负责监测区域内信息的采集和数据转换；</li><li>处理模块负责控制整个传感器节点的操作，存储和处理本身采集的数据以及其他节点发来的数据；</li><li>无线通信模块负责与其他传感器节点进行无线通信，交换控制消息和收发采集数据；</li><li>能量供应模块为传感器节点提供运行所需的能量。</li></ul><p><img src="/IoT-%E7%AC%AC3%E7%AB%A0-%E6%97%A0%E7%BA%BF%E4%BC%A0%E6%84%9F%E5%99%A8%E7%BD%91%E7%BB%9C-3-1-%E7%AE%80%E8%BF%B0/image-20231030221419077.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="2"></p><h5 id="传感器节点硬件架构（例）"><a href="#传感器节点硬件架构（例）" class="headerlink" title="传感器节点硬件架构（例）"></a><strong>传感器节点硬件架构（例）</strong></h5><p><img src="/IoT-%E7%AC%AC3%E7%AB%A0-%E6%97%A0%E7%BA%BF%E4%BC%A0%E6%84%9F%E5%99%A8%E7%BD%91%E7%BB%9C-3-1-%E7%AE%80%E8%BF%B0/image-20231030221447224.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="1"></p><h5 id="传感器节点（例）-Motes"><a href="#传感器节点（例）-Motes" class="headerlink" title="传感器节点（例） Motes"></a><strong>传感器节点（例）</strong> Motes</h5><p><strong>Devices that incorporate communications, processing, sensors, and batteries into a small package</strong> </p><p><strong>Atmel microcontroller with sensors and a communication unit</strong></p><ul><li><strong>RF transceiver, laser module, or a corner cube reflector</strong> </li><li><strong>temperature, light, humidity, pressure, 3 axis magnetometers, 3 axis accelerometers</strong></li></ul><p><strong>TinyOS</strong></p><p><img src="/IoT-%E7%AC%AC3%E7%AB%A0-%E6%97%A0%E7%BA%BF%E4%BC%A0%E6%84%9F%E5%99%A8%E7%BD%91%E7%BB%9C-3-1-%E7%AE%80%E8%BF%B0/image-20231030221541629.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="1"></p><h5 id="传感器节点"><a href="#传感器节点" class="headerlink" title="传感器节点"></a><strong>传感器节点</strong></h5><p>传感器节点是一个微型化的嵌入式系统，它构成了传感网的基础层支持平台。</p><p>典型的传感器节点由数据采集的感知模块、数据处理和存储模块、无线通信模块、能源供给模块4个部分组成，</p><ul><li>感知模块由传感器、A&#x2F;D转换器组成，负责感知监控对象的信息；</li><li>能源供给单元负责供给节点工作所消耗的能量，一般为小体积的电池；</li><li>无线通信模块完成节点间的交互通信工作，一般为无线电收发装置；</li><li>数据处理模块包括存储器和微处理器等部分，负责控制整个传感器节点的操作，存储和处理本身采集的数据以及其它节点发来的数据。</li><li>同时，有些节点上还装配有能源再生装置、移动或执行机构、定位系统及复杂信号处理（包括声音、图像、数据处理及数据融合）等扩展设备以获得更完善的功能。</li></ul><p><img src="/IoT-%E7%AC%AC3%E7%AB%A0-%E6%97%A0%E7%BA%BF%E4%BC%A0%E6%84%9F%E5%99%A8%E7%BD%91%E7%BB%9C-3-1-%E7%AE%80%E8%BF%B0/image-20231030221654283.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="1"></p><h5 id="传感器网络协议栈"><a href="#传感器网络协议栈" class="headerlink" title="传感器网络协议栈"></a><strong>传感器网络协议栈</strong></h5><p><img src="/IoT-%E7%AC%AC3%E7%AB%A0-%E6%97%A0%E7%BA%BF%E4%BC%A0%E6%84%9F%E5%99%A8%E7%BD%91%E7%BB%9C-3-1-%E7%AE%80%E8%BF%B0/image-20231030221735340.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="A"></p><p><img src="/IoT-%E7%AC%AC3%E7%AB%A0-%E6%97%A0%E7%BA%BF%E4%BC%A0%E6%84%9F%E5%99%A8%E7%BD%91%E7%BB%9C-3-1-%E7%AE%80%E8%BF%B0/image-20231030221740807.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="B"></p><ul><li>物理层提供简单但健壮的信号调制和无线收发技术，主要解决编码调制、通信速率，通信频段的选取等问题 。</li><li>数据链路层负责数据成帧、多路复用、帧检测、媒体访问和差错控制，保证了传感器网络内点到点和点到多点的连接 。</li><li>网络层负责路由生成与路由选择。</li><li>传输层负责数据流的传输控制，是保证通信服务质量的重要部分。</li><li>应用层包括一系列基于监测任务的应用软件。</li><li>能量管理平台管理传感器节点如何使用能源，在各个协议层都需要考虑节省能量。</li><li>移动管理平台检测并注册传感器应用的移动，维护到汇聚节点的路由，使得传感器节点能够动态跟踪其邻居的位置。</li><li>任务管理平台在一个给定的区域内平衡和调度监测任务</li></ul><blockquote><p><strong>协议栈</strong> <strong>B</strong> <strong>细化并改进了协议栈</strong> <strong>A</strong></p><p>•<strong>定位和时间同步子层，既要依赖于数据通道进行协作定位和时间同步协商，同时又要为网络协议各层提供信息支持，如基于时分复用的MAC协议，基于地理位置的路由协议等都需要定位和同步信息。</strong></p><p>•<strong>右边的诸多机制一部份融合到各层协议中，用以优化和管理协议流程；另一部分独立在协议外层，通过各种收集和配置接口对相应机制进行配置和监控。</strong></p><p>•<strong>QoS管理在各协议层设计队列管理、优先级机制或带宽预留等机制，并对特定应用的数据给于特别处理。</strong></p><p>•<strong>拓扑控制利用物理层、链路层或路由层完成拓扑生成，反过来又为它们提供基础信息支持，优化MCA层协议和路由协议的协议过程，减少网络能量消耗。</strong></p><p>•<strong>网络管理则要求协议各层嵌入各种信息接口，并定时收集协议运行状态和流量信息，协调控制网络中各个协议组件的运行。</strong></p></blockquote><h5 id="传感器网络的特点"><a href="#传感器网络的特点" class="headerlink" title="传感器网络的特点"></a><strong>传感器网络的特点</strong></h5><ul><li>节点数量大，密度高</li><li>拓扑动态变化</li><li>节点异构，或只有少量特殊节点；</li><li>分布式：没有预先指定的中心，所有节点通过分布式算法相互协调；</li><li>自组织：传感器网络的部署和初始化等不需要外界干预；</li><li>节点资源受限，特别是能量非常有限；</li><li>以数据为中心的网络，节点具有数据处理的能力；</li><li>与应用紧密耦合的网络</li><li>大规模网络</li><li>自组织网络</li><li>动态性网络</li><li>可靠性网络</li><li>应用性相关的网络</li><li>以数据为中心的网络</li></ul><h5 id="传感器节点的能耗分布"><a href="#传感器节点的能耗分布" class="headerlink" title="传感器节点的能耗分布"></a><strong>传感器节点的能耗分布</strong></h5><p>E(trans.) ≈ E(rece.) ≈ E(idle) &gt;&gt; E(sleep) ≈ E(sens.) ≈ E(cpu)</p><p><img src="/IoT-%E7%AC%AC3%E7%AB%A0-%E6%97%A0%E7%BA%BF%E4%BC%A0%E6%84%9F%E5%99%A8%E7%BD%91%E7%BB%9C-3-1-%E7%AE%80%E8%BF%B0/image-20231030222316048.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="1"></p><blockquote><p><strong>降低功耗的举措</strong></p><p><strong>减少通信流量</strong></p><p><strong>采用多跳通信方式</strong></p><p><strong>增加休眠时间</strong></p><p><strong>……</strong> </p></blockquote><h2 id="无线传感器网络与物联网"><a href="#无线传感器网络与物联网" class="headerlink" title="无线传感器网络与物联网"></a><strong>无线传感器网络与物联网</strong></h2><p>•<strong>无线传感器网络为物联网奠定了传感和监控的技术基础</strong></p><p>•<strong>无线传感器网络位于物联网联接物理空间的感知层面</strong></p><p>•<strong>物联网是广义联网的无线传感器网络</strong></p><p>•<strong>物联网不仅仅感知，还要做到控制</strong></p><p>•<strong>物联网面临更多的技术挑战</strong></p>]]></content>
    
    
    <categories>
      
      <category>学习资料</category>
      
    </categories>
    
    
    <tags>
      
      <tag>课件笔记</tag>
      
      <tag>物联网技术与应用</tag>
      
      <tag>IoT</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>IoT-第2章-感知识别-2-3-传感器</title>
    <link href="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-3-%E4%BC%A0%E6%84%9F%E5%99%A8/"/>
    <url>/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-3-%E4%BC%A0%E6%84%9F%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="第二章-物联网感知识别"><a href="#第二章-物联网感知识别" class="headerlink" title="第二章 物联网感知识别"></a><strong>第二章 物联网感知识别</strong></h1><h2 id="2-3-传感器技术"><a href="#2-3-传感器技术" class="headerlink" title="2.3 传感器技术"></a><strong>2.3</strong> <strong>传感器技术</strong></h2><p><strong>自动门、自动水龙头、安检门</strong></p><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-3-%E4%BC%A0%E6%84%9F%E5%99%A8/image-20231029212914051.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="当有金属物体穿越安检门时报警"></p><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-3-%E4%BC%A0%E6%84%9F%E5%99%A8/image-20231029212932145.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="水龙头"></p><h3 id="传感器的作用"><a href="#传感器的作用" class="headerlink" title="传感器的作用"></a><strong>传感器的作用</strong></h3><ul><li><strong>一般的仪器、仪表要求输入的信号必须为电信号</strong> <strong>，计算机及各种电子设备只能处理电信号 ，</strong></li><li><strong>而表征物质特性或其运动形式的参数 中有很多都是非电量，如大家在自然界经常接触到的温度、压力、距离、流量、重量、速度、加速度、浓度、酸碱度、湿度、光 、磁场等 。</strong></li><li><strong>上述的非电量需要转换成与非电量有一定关系的电量，再运用电子设备和仪器测量，实现这种转换技术的器件就是传感器。</strong></li></ul><h3 id="传感器的定义与组成"><a href="#传感器的定义与组成" class="headerlink" title="传感器的定义与组成"></a><strong>传感器的定义与组成</strong></h3><p>根据国家标准（GB&#x2F;T 7665-2005）传感器通用术语的规定，传感器是能感受规定的被测量并按照一定的规律转换成可用输出信号的器件或装置。</p><p>传感器通常由对被测量敏感的元件和转换元件组成，</p><p>•<strong>敏感元件</strong>是指传感器中能直接感受或响应被测量的部分，如应变式压力传感器中的弹性膜片，就是敏感元件。</p><p>•<strong>转换元件</strong>是指传感器中能将敏感元件感受或响应到的被测量转换成适于传输或测量的电信号（电压、电流）部分，如电阻应变片就是转换元件。</p><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-3-%E4%BC%A0%E6%84%9F%E5%99%A8/image-20231029213047059.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="组成图"></p><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-3-%E4%BC%A0%E6%84%9F%E5%99%A8/image-20231029213955894.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="各类传感器"></p><h3 id="传感器的分类"><a href="#传感器的分类" class="headerlink" title="传感器的分类"></a><strong>传感器的分类</strong></h3><h4 id="1．按被测物理量划分"><a href="#1．按被测物理量划分" class="headerlink" title="1．按被测物理量划分"></a><strong>1．按被测物理量划分</strong></h4><p><strong>这一种方法是根据被测量的性质进行分类，如被测量分别为温度、湿度、压力、位移、流量、加速度、光，则对应的传感器分别为温度传感器、湿度传感器，压力传感器、位移传感器、流量传感器、加速度传感器、光电传感器。</strong></p><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-3-%E4%BC%A0%E6%84%9F%E5%99%A8/image-20231029214022444.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="物理量"></p><h4 id="2．按传感器工作原理划分"><a href="#2．按传感器工作原理划分" class="headerlink" title="2．按传感器工作原理划分"></a><strong>2．按传感器工作原理划分</strong></h4><p>​    这一种分类方法是以工作原理来划分，将物理、化学、生物等学科的原理、规律和效应作为分类的依据，据此可将传感器分为电阻式、电感式、电容式、阻抗式、磁电式、热电式、压电式、光电式、超声式、微波式等类别。这种分类方法有利于传感器的专业工作者从原理与设计上作归纳性的分析研究。</p><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-3-%E4%BC%A0%E6%84%9F%E5%99%A8/image-20231029214053494.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="工作原理"></p><h3 id="传感技术的特点"><a href="#传感技术的特点" class="headerlink" title="传感技术的特点"></a><strong>传感技术的特点</strong></h3><p><strong>1、用传感技术进行检测时，响应速度快，精确度高，灵敏度高；</strong></p><p><strong>2、能在特殊环境下连续进行检测，便于自动记录。</strong></p><p>能在人类无法存在的高温、高压、恶劣环境中，和对人类五官不能感觉到的信息（如超声波、红外线等），进行连续检测，记录变化的数据。</p><p><strong>3、可与计算机相连，进行数据的自动运算、分析和处理</strong></p><p>   传感器将非电物理量转换成电信号后，通过接口电路变成计算机能够处理的信号，进行自动运算、分析和处理。</p><p><strong>4、品种繁多，应用广泛</strong></p><p>​    现代信息系统中待测的信息量很多，一种待测信息可由几种传感器来测量，一种传感器也可测量多种信息，因此传感器种类繁多，应用广泛，从航空、航天、兵器、交通、机械、电子、冶炼、轻工、化工、煤炭、石油、环保、医疗、生物工程等领域，到农、林、牧、副、渔业，以及人们的衣、食、住、行等生活的方方面面，几乎无处不使用传感器，无处不需要传感器。</p><h3 id="传感器的发展趋势"><a href="#传感器的发展趋势" class="headerlink" title="传感器的发展趋势"></a>传感器的发展趋势</h3><p><strong>1．新材料的开发、应用</strong></p><p>如：半导体材料 、功能陶瓷材料 、功能金属、功能有机聚合物、非晶态材料、固体材料及薄膜材料等，都可进一步提高传感器的产品质量，降低生产成本。</p><p><strong>2．新工艺、新技术的应用</strong></p><p>将半导体的精密细微加工技术应用在传感器的制造中，可极大提高传感器的性能指标，并为传感器的集成化、超小型化提供技术支撑。借助半导体的蒸镀技术、扩散技术、光刻技术、静电封闭技术、全固态封接技术，也可取得类似的功效。</p><p><strong>3．向小型化、集成化方向发展</strong></p><p>由于航空技术的发展，以及医疗器件和一些特殊场合的需要，传感器必须向小型化、微型化方向发展，以便减小体积和质量。</p><p> <strong>4.</strong> <strong>向多功能化方向发展</strong></p><p>传感器多功能化也是传感器今后发展的一个重要方向，在一块集成传感器上综合多个传感器的功能，可以同时测量多个被测量，它可以借助于敏感元件中的不同物理结构或化学物质及其不同的表征方式，用单独一个传感器系统来同时实现多种传感器的功能。</p><p><strong>5．传感器的智能化</strong></p><p>将传统的传感器和微处器及相关电路组成一体化的结构就是智能传感器。因为它本身带有微型计算机，具有自动校准、自动补偿、自动诊断、数据处理、远距离双向通信、信息存储记忆和数字信号输出等功能。</p><p><strong>6．传感器的网络化</strong></p><p>将传感器和计算机与网络技术有机结合，使传感器成 为网 络中的智能节点。这种努力使多个传感器组成网络直接通信，实现数据的实施发布、共享，以及网络控制器对节点的控制操作。另外，通过Internet网，传感器与用户之间可异地交换信息，厂商能直接与异地用户交流，能及时完成传感器故障诊断，指导用户维修或交换新仪器改进的数据，软件升级等工作。另外，在微机电技术、自组织网络技术、低功耗射频通信技术及低功耗微型计算机技术的共同促进下，传感器朝微型化和网络化的方向迅速发展，产生了无线传感器网络。</p><h3 id="传感器的基本特性"><a href="#传感器的基本特性" class="headerlink" title="传感器的基本特性"></a><strong>传感器的基本特性</strong></h3><p>传感器的基本特性一般是指传感器的输出与输入之间的关系，有静态和动态之分。通常是以建立数学模型来体现的，为了简化传感器的静、动态特性，可以分开来研究。</p><h3 id="1．传感器的静态特性"><a href="#1．传感器的静态特性" class="headerlink" title="1．传感器的静态特性"></a><strong>1．传感器的静态特性</strong></h3><p><strong>静态特性是指在静态信号作用下，传感器输出与输入量间的一种函数关系，其静态特性可表示为</strong></p><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-3-%E4%BC%A0%E6%84%9F%E5%99%A8/image-20231029214459270.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="公"></p><p>  <strong>常用的静态性能指标包括灵敏度、精确度、测量范围、量程、线性度及误差等。</strong></p><h4 id="（1）灵敏度"><a href="#（1）灵敏度" class="headerlink" title="（1）灵敏度"></a><strong>（1）灵敏度</strong></h4><p><strong>传感器的灵敏度是指达到稳定状态时，输出增量与输入增量的比值</strong></p><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-3-%E4%BC%A0%E6%84%9F%E5%99%A8/image-20231029214523850.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="灵敏度"></p><p><strong>线性传感器的灵敏度就是其静态特性的斜率</strong></p><p><strong>非线性传感器的灵敏度则是其静态特性曲线某点处切线的斜率</strong></p><h4 id="（2）线性度"><a href="#（2）线性度" class="headerlink" title="（2）线性度"></a><strong>（2）线性度</strong></h4><p><strong>线性度是传感器输出量与输入量之间的实际关系曲线偏离直线的程度，又称非线性误差。</strong></p><p><strong>如图所示，即为在垂直方向上最大偏差</strong> <strong>|Δymax|</strong> <strong>与最大输出</strong> <strong>ymax</strong> <strong>的百分比。图中</strong> <strong>a0</strong> <strong>称为零位输出，即被测量为零时传感器的指示值。</strong></p><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-3-%E4%BC%A0%E6%84%9F%E5%99%A8/image-20231029214840938.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="线性度"></p><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-3-%E4%BC%A0%E6%84%9F%E5%99%A8/image-20231029214848575.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="传感器的线性度误差"></p><h4 id="（3）重复性"><a href="#（3）重复性" class="headerlink" title="（3）重复性"></a><strong>（3）重复性</strong></h4><p>   <strong>重复性表示传感器在输入量按同一方向作全量程连续多次变动时所得到的特性曲线的不一致程度，如图所示，用公式表示为</strong></p><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-3-%E4%BC%A0%E6%84%9F%E5%99%A8/image-20231029214912352.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="重复性"></p><p><strong>式中，⊿mmax取⊿</strong> <strong>m1、</strong> <strong>⊿</strong> <strong>m2中最大的计算，ymax为满量程输出值。</strong></p><p><strong>传感器输出特性的不重复性主要是由传感器的机械部分的磨损、间隙、松动、部件内摩擦、积尘、电路元件老化、工作点漂移等原因产生的。</strong></p><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-3-%E4%BC%A0%E6%84%9F%E5%99%A8/image-20231029214932446.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="线性度"></p><h4 id="（4）迟滞现象"><a href="#（4）迟滞现象" class="headerlink" title="（4）迟滞现象"></a><strong>（4）迟滞现象</strong></h4><p>   <strong>迟滞现象是传感器在正向行程（输入量增大）和反向行程（输入量减小）期间输出—输入曲线不重合的程度，如图所示。</strong></p><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-3-%E4%BC%A0%E6%84%9F%E5%99%A8/image-20231029215003318.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="1"></p><p>或</p><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-3-%E4%BC%A0%E6%84%9F%E5%99%A8/image-20231029215010336.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="2"></p><p><strong>迟滞现象反映了传感器机械结构和制造工艺上的缺陷，如轴承摩擦、间隙、螺钉松动、元件腐蚀等。</strong> </p><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-3-%E4%BC%A0%E6%84%9F%E5%99%A8/image-20231029215022563.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="迟滞"></p><h4 id="（5）精确度"><a href="#（5）精确度" class="headerlink" title="（5）精确度"></a><strong>（5）精确度</strong></h4><p>   <strong>传感器的精确度是指传感器的输出指示值与被测量约定真值的一致程度，反映了传感器测量结果的可靠程度。在工程应用中，为了简单表示测量结果的可靠性程度，引入精确度这个等级概念，用</strong> <strong>A</strong> <strong>表示，它表示允许的最大绝对误差与满度量程的比值的百分数，即</strong></p><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-3-%E4%BC%A0%E6%84%9F%E5%99%A8/image-20231029215045582.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="精确度"></p><p>式中 <em>A</em>——传感器精确度；</p><p>​     ⊿ <em>A</em>——测量范围内允许的最大绝对误差；</p><p>​     <em>y</em>max ——满度量程输出值。</p><p>常用的档次为 0.1、0.2、0.5、1.0、1.5、2.5、4.0、5.0。例如，0.5级的仪表表示其允许的最大使用误差为 0.5%。</p><h4 id="（6）分辨力"><a href="#（6）分辨力" class="headerlink" title="（6）分辨力"></a><strong>（6）分辨力</strong></h4><p>  <strong>传感器的分辨力是在规定测量范围内所能检测的输入量的最小变化量的能力。通常是以最小量程单位值表示。当被测量的变化值小于分辨力时，传感器对输入量的变化无任何反应。</strong></p><h4 id="（7）稳定性"><a href="#（7）稳定性" class="headerlink" title="（7）稳定性"></a><strong>（7）稳定性</strong></h4><p>  <strong>传感器的稳定性是指在室温条件下经过一定的时间间隔，传感器的输出与起始标定时的输出之间的差异。通常有长期稳定性（如年、月、日）和短期稳定性（如时、分、秒）之分，传感器的稳定性常用长期稳定性表示。</strong></p><h4 id="（8）漂移"><a href="#（8）漂移" class="headerlink" title="（8）漂移"></a><strong>（8）漂移</strong></h4><p>  <strong>传感器的漂移是指在外界的干扰下，输出量发生与输入量无关的不需要的变化。漂移包括零点漂移和灵敏度漂移等。零点漂移和灵敏度漂移又可分为时间漂移和温度漂移。</strong></p><ul><li><strong>时间漂移是指在规定的条件下，零点或灵敏度随时间的缓慢变化；</strong></li><li><strong>温度漂移为环境温度变化而引起的零点或灵敏度的变化。</strong></li></ul><h3 id="2．传感器的动态特性"><a href="#2．传感器的动态特性" class="headerlink" title="2．传感器的动态特性"></a><strong>2．传感器的动态特性</strong></h3><p>传感器的动态特性是指传感器在测量快速变化的输入信号情况下，输出对输入的响应特性。传感器测量静态信号时，由于被测量不随时间变化，测量和记录的过程不受时间限制。但是在工程实践中，检测的是大量随时间变化的动态信号，这就要求传感器不仅能精确地测量信号的幅值大小，而且还能显示被测量随时间变化的规律，即正确的再现被测量波形。传感器测量动态信号的能力用动态特性来表示。</p><p>在动态测量中，当被测量作周期性变化时，传感器的输出值随着周期性变化，其频率与前者相同，但输出幅值和相位随频率的变化而变化，这种关系称为频率特性。输出信号的幅值随频率变化而改变的特性称为幅频特性；输出信号的相位随频率的变化而改变的特性称为相频特性，幅值下降到稳定幅值的0.707倍时所对应的频率称为截止频率。</p><ul><li><strong>传感器静态特性是输入信号不随时间变化时的输出与输入之间的关系。</strong></li><li><strong>静态特性指标：灵敏度、线性度、重复性、迟滞现象、精确度、分辨力、稳定性和漂移。</strong></li><li><strong>传感器的动态特性是输入信号随时间周期性作变化时的输出与输入之间的关系。</strong></li></ul><h4 id="力敏传感器及其应用"><a href="#力敏传感器及其应用" class="headerlink" title="力敏传感器及其应用"></a><strong>力敏传感器及其应用</strong></h4><p>力敏传感器，顾名思义就是能对各种力或能转化为力的物理量产生反应，并能将其转变为电参数的装置或元件。很显然，要成为真正实用意义上的力敏传感器，这个由力转化为电参数的过程最好能成线性关系。</p><p>根据由力至电参数转变的方式不同，力敏传感器一般有电阻应变式传感器、电位计式传感器、电感式传感器、压电式传感器、电容式传感器等，它们可用来测量力值。</p><h3 id="电阻应变式传感器"><a href="#电阻应变式传感器" class="headerlink" title="电阻应变式传感器"></a>电阻应变式传感器</h3><p>  电阻应变式传感器是目前工程测力传感器中应用最普遍的一种传感器，它测量精度高，范围广，频率响应特性较好，结构简单，尺寸小，易实现小型化，并能在高温、强磁场等恶劣环境下使用，并且工艺性好，价格低廉。它主要应用在力作用下，将材料应变转变为电阻值的变化，从而实现力值的测量。组成电阻应变片的材料一般为金属或半导体材料。</p><h4 id="电阻应变式传感器工作原理"><a href="#电阻应变式传感器工作原理" class="headerlink" title="电阻应变式传感器工作原理"></a><strong>电阻应变式传感器工作原理</strong></h4><p><strong>（1）应变效应</strong></p><p>由物理学可知，电阻丝的电阻 <em>R</em> 与电阻丝的电阻率、导体长度及截面积存在如下关系</p><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-3-%E4%BC%A0%E6%84%9F%E5%99%A8/image-20231029221136388.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="f"></p><p>当电阻丝受到拉力作用时，长度伸长 <em>Δ**l</em>，横截面收缩 <em>Δ**S</em>，电阻率也将变化 <em>Δρ</em>，此时电阻值产生 ΔR 变化。</p><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-3-%E4%BC%A0%E6%84%9F%E5%99%A8/image-20231029221151327.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="**电阻丝应变效应**"></p><p><strong>电阻应变式传感器的结构及特性</strong> :</p><p><strong>金属电阻应变片分为金属丝式和金属箔式两种。</strong></p><p><strong>① 金属丝式电阻应变片。金属丝式电阻应变片的基本结构图如图所示。由敏感栅1、基底2和盖层3、引线4和黏结剂几个基本部分组成。</strong></p><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-3-%E4%BC%A0%E6%84%9F%E5%99%A8/image-20231029221241302.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="**金属丝式电阻应变片的基本结构图** "></p><p>  <strong>②</strong> <strong>金属箔式应变片。如图所示，它与金属丝式电阻应变片相比，有如下优点：用光刻技术能制成各种复杂形状的敏感栅；横向效应小；散热性好，允许通过较大电流，可提高相匹配的电桥电压，从而提高输出灵敏度；疲劳寿命长，蠕变小；生产效率高。</strong></p><p>  <strong>但是，制造箔式应变片的电阻值的分散性要比丝式应变片的大，有的能相差几十欧姆，需要调整阻值。金属箔式应变片因其一系列优点而将逐渐取代丝式应变片，并占主要地位。</strong></p><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-3-%E4%BC%A0%E6%84%9F%E5%99%A8/image-20231029221257100.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="金属箔"></p><blockquote><p><strong>各种箔式应变片</strong></p><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-3-%E4%BC%A0%E6%84%9F%E5%99%A8/image-20231029221321136.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="第二个有点像学校的校徽"></p></blockquote><p><strong>电阻应变片传感器基本应用电路</strong></p><p> <strong>将电阻应变片粘贴于待测构件上，应变片电阻随着构件应变而改变，将应变片电阻接入相应的电路中，使其转化为电流或电压输出，即可测出力值。</strong></p><p><strong>通常将应变片接入电桥来实现电阻至电压或电流的转换。根据电桥电源不同，又分直流电桥和交流电桥。这里主要介绍直流电桥。</strong></p><p><strong>如图所示为一直流电桥，计算可知：</strong></p><p><strong>∆U&#x3D;(R_1 R_3-R_2</strong> *<em>R_4)&#x2F;(R_1+R_2 )(R_3+R_4 ) <em>E</em></em></p><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-3-%E4%BC%A0%E6%84%9F%E5%99%A8/image-20231029221439447.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="电桥"></p><p><strong>若使此电桥平衡，即</strong> <strong>ΔU &#x3D; 0，只要</strong> <strong>R1</strong> <strong>R3</strong> <strong>–</strong> <strong>R2</strong> <strong>R4</strong> <strong>&#x3D;</strong> <strong>0</strong> <strong>。一般我们取</strong> <strong>R1</strong> <strong>&#x3D;</strong> <strong>R2</strong> <strong>&#x3D;</strong> <strong>R3</strong> <strong>&#x3D;</strong> <strong>R4</strong> <strong>&#x3D;</strong> <strong>R</strong> <strong>即可实现。</strong></p><p><strong>按上述，取</strong> <strong>R1</strong> <strong>&#x3D;</strong> <strong>R2</strong> <strong>&#x3D;</strong> <strong>R3</strong> <strong>&#x3D;</strong> <strong>R4</strong> <strong>&#x3D;</strong> <strong>R</strong> <strong>即可实现电桥平衡。</strong></p><p><strong>现将</strong> <strong>R1</strong> <strong>换成电阻应变片，即组成半桥单臂电桥，随构件产生应变造成传感器电阻变化时，上式变成</strong></p><p><strong>∆U&#x3D;∆R&#x2F;(4R+2∆R) E</strong></p><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-3-%E4%BC%A0%E6%84%9F%E5%99%A8/image-20231029221548915.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="image-20231029221548915"></p><p><strong>一般</strong> <strong>ΔU</strong> <strong>&lt;&lt;</strong> <strong>R</strong> <strong>，可忽略，由此可得</strong></p><p><strong>∆U≈1&#x2F;4  ∆R&#x2F;R E</strong></p><p> <strong>可见，输出电压与电阻变化率成线性关系，即和应变力成线性关系，由此即可测出力值。由上式可得半桥单臂工作输出的电压灵敏度</strong>  <strong>k_u&#x3D;∆U&#x2F;(∆R∕R)&#x3D; E&#x2F;4</strong> </p><p>  <strong>为了提高输出电压灵敏度，可以采用半桥双臂或全桥双肩电路。</strong></p><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-3-%E4%BC%A0%E6%84%9F%E5%99%A8/image-20231029221635236.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="图"></p><p><strong>即半桥双臂可使电压灵敏度比半桥单臂提高一倍，而全桥电路电压灵敏度又比半桥双臂电压灵敏度提高一倍。可见，利用全桥，并提高供电电压</strong> <strong>E，可提高灵敏度系数。</strong></p><h5 id="温度误差及其补偿"><a href="#温度误差及其补偿" class="headerlink" title="温度误差及其补偿"></a>温度误差及其补偿</h5><p><strong>（1） 温度误差</strong></p><p><strong>用作测量应变的金属应变片，希望其阻值仅随应变力变化，而不受其它因素的影响。但是，环境温度的变化，会造成阻值的额外变化。</strong></p><p>Ø<strong>阻温效应： 当环境温度改变时，由于热输出会引起电阻率的变化，而且与构件应变所造成的电阻变化有相同的数量级，从而产生很大的测量误差。</strong></p><p>Ø<strong>附加应变： 当环境温度改变时，构件和应变片产生变形，使应变片产生附加应变，从而使应变片在被测应力作用下产生</strong> <strong>Δ</strong> <strong>R</strong> <strong>的基础上附加了</strong> <strong>ΔRi</strong> <strong>，使测力结果发生误差。</strong></p><p><strong>（2） 温度补偿</strong></p><p><strong>一般采用桥路补偿法、应变片补偿法或热敏电阻补偿法。</strong></p><p><strong>桥路补偿法： 如图所示，当</strong> <strong>ab</strong> <strong>间接入应变片传感器，bc</strong> <strong>间也接入同样的应变片，但</strong> <strong>bc</strong> <strong>间接入的应变片不受构件应变力的作用，将它用同样的方法粘贴在与</strong> <strong>ab</strong> <strong>间应变片所贴构件材料相同的材料上，并与</strong> <strong>ab</strong> <strong>间应变片处于同一温度场，这样</strong> <strong>ab、bc</strong> <strong>间应变片的阻温效应相同，电阻的变化量</strong> <strong>ΔRi</strong> <strong>也相同，由电桥理论可知，它们起了互相抵消作用，对输出电压没有影响。</strong></p><p><strong>（阻温 ）</strong></p><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-3-%E4%BC%A0%E6%84%9F%E5%99%A8/image-20231029221729720.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="温度补偿"></p><blockquote><p><strong>应变片补偿法分自补偿和互补偿两种。</strong></p><p>•<strong>自补偿法：其原理是合理选择应变片阻温系数及线膨胀系数，使之与被测构件线膨胀系数匹配，使应变片温度变化</strong> <strong>Δt</strong> <strong>时，由热造成的输出值为</strong> <strong>0。（阻温</strong> <strong>+</strong> <strong>附加）</strong></p><p>•<strong>应变片互补偿法：其原理是检测用的应变片敏感栅由两种材料组成，在温度变化</strong> <strong>Δt</strong> <strong>时，它们的阻值变化量</strong> <strong>ΔR</strong> <strong>相同，但符号相反，这样就可抵消由于温度变化而造成传感器误输出。使用中要注意选配敏感栅电阻丝材料。</strong> <strong>（阻温</strong> <strong>）</strong></p><p><strong>热敏电阻补偿法</strong></p><p>•<strong>如图所示，图中</strong> <strong>R5</strong> <strong>为分流电阻，Rt</strong> <strong>为</strong> <strong>NTC热敏电阻，使</strong> <strong>Rt</strong> <strong>与应变式传感器处在同一温度场中，适当调整</strong> <strong>R5</strong> <strong>值，可使</strong> <strong>ΔR</strong> <strong>附加的热输出为零。（阻温）</strong></p><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-3-%E4%BC%A0%E6%84%9F%E5%99%A8/image-20231029221756683.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="热敏电阻补偿"></p></blockquote><p><strong>电阻应变式传感器应用于测力（如称重）</strong></p><p>•<strong>电阻应变式传感器广泛应用在测力及可以转化为力值的量（如加速度等）。</strong> </p><p>•<strong>图中</strong> <strong>1、2、3、4</strong> <strong>为四个相同的应变片，沿同一高度圆周均布，接入全桥测量电路。在外力</strong> <strong>F</strong> <strong>的作用下应变片</strong> <strong>1、3</strong> <strong>的电阻变大，应变片</strong> <strong>2、4</strong> <strong>的电阻变小。</strong></p><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-3-%E4%BC%A0%E6%84%9F%E5%99%A8/image-20231029221827761.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="图"></p><p>•<strong>测量电路输出电压为</strong>  <strong>∆U&#x3D;U</strong> <strong>∆R&#x2F;R</strong> <strong>&#x3D;k</strong> <strong>F</strong> <strong>，（k</strong> <strong>值与圆筒截面积、圆筒材料泊松比、弹性元件的弹性模量、馈电电源等相关）</strong></p><p>•<strong>∆U</strong> <strong>与所称重量成线性关系，将</strong> <strong>∆U经过放大等一系列处理电路，可送显示仪表直接读出称重量。</strong></p><h5 id="加速度传感器"><a href="#加速度传感器" class="headerlink" title="加速度传感器"></a><strong>加速度传感器</strong></h5><p><strong>将被测加速度</strong> <strong>a</strong> <strong>通过一个悬臂梁将力</strong> <strong>F</strong> <strong>&#x3D; ma</strong> <strong>转化成应变片的应力，从而达到测量加速度</strong> <strong>a</strong> <strong>的目的。</strong></p><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-3-%E4%BC%A0%E6%84%9F%E5%99%A8/image-20231029221856717.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="原理，悬梁臂是敏感元件，应变片是转换元件"></p><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-3-%E4%BC%A0%E6%84%9F%E5%99%A8/image-20231029222002107.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="例子"></p><p><strong>力敏传感器应用实例：电子秤</strong> </p><p><strong>如图所示是采用微处理器的电子秤原理图</strong>：</p><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-3-%E4%BC%A0%E6%84%9F%E5%99%A8/image-20231029222028557.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="电子秤"></p><h3 id="电感式传感器"><a href="#电感式传感器" class="headerlink" title="电感式传感器"></a>电感式传感器</h3><h4 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a><strong>工作原理</strong></h4><p><strong>电感式传感器是利用线圈自感或互感的变化来实现测量的一种装置，可以用来测量位移、振动、压力、流量、重量、力矩和应变等多种物理量。</strong></p><p><strong>电感式传感器的核心部分是可变自感或可变互感，在被测量转换成线圈自感或互感的变化时，一般要利用磁场作为媒介或利用铁磁体的某些现象。这类传感器的主要特征是具有绕组。</strong></p><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-3-%E4%BC%A0%E6%84%9F%E5%99%A8/image-20231029225957628.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="1"></p><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-3-%E4%BC%A0%E6%84%9F%E5%99%A8/image-20231029230002834.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="2"></p><h4 id="优点和缺点"><a href="#优点和缺点" class="headerlink" title="优点和缺点"></a><strong>优点和缺点</strong></h4><p><strong>（1）优点：结构简单可靠，输出功率大，抗干扰能力强，对工作环境要求不高，分辨力较高（如在测量长度时一般可达0.1mm），示值误差一般为示值范围的0.1%~0.5%，稳定性好。</strong></p><p><strong>（2）缺点：频率响应低，不宜用于快速动态测量。一般来说，电感式传感器的分辨力和示值误差与示值范围有关。示值范围大时，分辨力和示值精度将相应降低。</strong></p><h4 id="种类"><a href="#种类" class="headerlink" title="种类"></a><strong>种类</strong></h4><p><strong>有利用自感原理的自感式传感器，有利用互感原理的差动变压器式传感器。此外，还有利用涡流原理的涡流式传感器，利用压磁原理的压磁式传感器和利用互感原理的感应同步器等。</strong></p><h3 id="变压器式传感器"><a href="#变压器式传感器" class="headerlink" title="变压器式传感器"></a><strong>变压器式传感器</strong></h3><h4 id="工作原理-1"><a href="#工作原理-1" class="headerlink" title="工作原理"></a><strong>工作原理</strong></h4><p><strong>变压器式传感器是将非电量转换为线圈间互感的一种磁电动机构，很像变压器的工作原理，因此常称其为变压器式传感器。这种传感器多采用差动形式。</strong></p><p>Ø<strong>气隙型差动变压器式</strong></p><p>Ø<strong>截面积型差动变压器式</strong></p><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-3-%E4%BC%A0%E6%84%9F%E5%99%A8/image-20231029230100908.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="1"></p><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-3-%E4%BC%A0%E6%84%9F%E5%99%A8/image-20231029230103577.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="2"></p><h4 id="气隙型差动变压器式传感器"><a href="#气隙型差动变压器式传感器" class="headerlink" title="气隙型差动变压器式传感器"></a><strong>气隙型差动变压器式传感器</strong></h4><p><strong>当没有非电量输入时，衔铁</strong> <strong>C</strong> <strong>与铁芯</strong> <strong>A、B</strong> <strong>的间隔相同，则绕组</strong> <strong>W1a</strong> <strong>和</strong> <strong>W2a</strong> <strong>间的互感</strong> <strong>ma</strong> <strong>与绕组</strong> <strong>W1b</strong> <strong>和</strong> <strong>W2b</strong> <strong>间的互感</strong> <strong>mb</strong> <strong>相等。</strong></p><p><strong>当衔铁位置改变时，ma</strong> <strong>和</strong> <strong>mb</strong> <strong>的差值即反映被测量值的大小。</strong></p><p><strong>为反映差值互感，将两个一次绕组的同名端顺向串联，并施加交流电压</strong> <strong>u，二次绕组的同名端反向串联，同时测量串联后的合成电动势</strong> <strong>e2</strong> <strong>为：e2</strong> <strong>&#x3D;</strong> <strong>e2a</strong> <strong>-</strong> <strong>e2b</strong></p><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-3-%E4%BC%A0%E6%84%9F%E5%99%A8/image-20231029230133461.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="气隙"></p><h4 id="截面积型差动变压器式传感器"><a href="#截面积型差动变压器式传感器" class="headerlink" title="截面积型差动变压器式传感器"></a><strong>截面积型差动变压器式传感器</strong></h4><p>n<strong>改变气隙有效截面积，输入非电量为角位移Δα。它是一个山字形铁芯</strong> <strong>A上 绕有三个绕组。</strong> <strong>W1</strong> <strong>为一次绕组，W2a</strong> <strong>及</strong> <strong>W2b</strong> <strong>为两个二次绕组。</strong></p><p>n<strong>衔铁</strong> <strong>B</strong> <strong>以</strong> <strong>O</strong> <strong>点为轴转动时，由于改变了铁芯与衔铁间磁路上的垂直有效截面积</strong> <strong>s，也就改变了绕组间的互感，使其中一个互感增大，另一个互感减小，因此两个二次绕组中的感应电动势也随之改变。</strong></p><p>n<strong>将绕组</strong> <strong>w2a</strong> <strong>和</strong> <strong>w2b</strong> <strong>反相串联并测量合成电动势</strong> <strong>e2，就可以判断出非电量的大小及方向。</strong></p><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-3-%E4%BC%A0%E6%84%9F%E5%99%A8/image-20231029230159818.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="截面积"></p><h4 id="差动变压器应用实例"><a href="#差动变压器应用实例" class="headerlink" title="差动变压器应用实例"></a><strong>差动变压器应用实例</strong></h4><p><strong>一般来说，较小位移量的测量采用差动变压器，</strong></p><ul><li><strong>电子秤：用差动变压器把弹簧的位移变为电信号，换算为重量</strong></li><li><strong>偏心测量仪：以起始点作为基准，最后换算为转体的偏心程度</strong></li></ul><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-3-%E4%BC%A0%E6%84%9F%E5%99%A8/image-20231029230232645.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="左秤，右偏心测量仪"></p><h4 id="电感式传感器应用实例：测量列车运行"><a href="#电感式传感器应用实例：测量列车运行" class="headerlink" title="电感式传感器应用实例：测量列车运行"></a><strong>电感式传感器应用实例：测量列车运行</strong></h4><p><strong>测量列车运行的速度和加速度，组成包括：</strong></p><ul><li><strong>安装在列车头底部的一块强磁体</strong></li><li><strong>埋设在轨道地面的一组线圈</strong></li><li><strong>电流测量仪</strong></li></ul><p><strong>当列车经过线圈上方时，线圈中产生的电流被记录下来，即能求出列车在各位置的速度和加速度。</strong></p><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-3-%E4%BC%A0%E6%84%9F%E5%99%A8/image-20231030000647953.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="车"></p><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-3-%E4%BC%A0%E6%84%9F%E5%99%A8/image-20231030084134887.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="原理"></p><p><strong>力敏传感器是将动态或静态力的大小转换成便于测量的电量的装置。</strong></p><ul><li><p><strong>电阻应变式传感器：其将外力转化成电阻值的变化，再利用电桥电路检测出电阻值的变化值，从而得出对应的力变化量。</strong></p></li><li><p><strong>电感式传感器：其将外力引起的微小位移量转化成电感参数的变化，从而得出相应力的变化量。如位移量很小，可采用差动变压器来放大信号的方式，以提高传感器的灵敏度。</strong></p></li><li><p><strong>电容式传感器</strong></p></li><li><p><strong>…</strong></p></li></ul><h3 id="电容式传感器"><a href="#电容式传感器" class="headerlink" title="电容式传感器"></a>电容式传感器</h3><h4 id="电容式传感器的工作原理和结构"><a href="#电容式传感器的工作原理和结构" class="headerlink" title="电容式传感器的工作原理和结构"></a><strong>电容式传感器的工作原理和结构</strong></h4><p><strong>由绝缘介质分开的两个平行金属板组成的平板电容器，如果不考虑边缘效应，其电容量为：</strong> <strong>C&#x3D;ϵA&#x2F;d</strong></p><p><strong>式中：ε——电容极板间介质的介电常数，ε&#x3D;ε0εr，<br> 　　　　其中ε0为真空介电常数，εr为极板间介质的相对介电常数；</strong></p><pre><code class="hljs">         　**A——两平行板所覆盖的面积；**      **d——两平行板之间的距离。**</code></pre><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-3-%E4%BC%A0%E6%84%9F%E5%99%A8/image-20231030084432070.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="示意图"></p><p><strong>当被测参数变化使得公式中的</strong> <strong>A、d</strong> <strong>或</strong> <strong>ε</strong> <strong>发生变化时，电容量</strong> <strong>C</strong> <strong>也随之变化。</strong></p><p><strong>如果保持其中两个参数不变，而仅改变其中一个参数，就可把该参数的变化转换为电容量</strong> <strong>C</strong> <strong>的变化，通过测量电路就可转换为电量输出。</strong></p><p><strong>电容式传感器可分为变极距型、变面积型和变介电常数型三种。</strong></p><h5 id="变极距型电容传感器"><a href="#变极距型电容传感器" class="headerlink" title="变极距型电容传感器"></a><strong>变极距型电容传感器</strong></h5><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-3-%E4%BC%A0%E6%84%9F%E5%99%A8/image-20231030090108053.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="图"></p><p><strong>当</strong> <strong>εr</strong> <strong>和</strong> <strong>A</strong> <strong>为常数，初始极距为</strong> <strong>d0</strong> 时，初始电容量为 </p><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-3-%E4%BC%A0%E6%84%9F%E5%99%A8/image-20231030090035023.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="1"></p><hr><p> <strong>若电容器极板间距离由初始值</strong> <strong>d0</strong> <strong>缩小了</strong> <strong>Δd，电容量增大了</strong> **ΔC，则有 </p><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-3-%E4%BC%A0%E6%84%9F%E5%99%A8/image-20231030090046783.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="C"></p><hr><p><strong>如图，传感器的输出特性不是线性关系。</strong></p><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-3-%E4%BC%A0%E6%84%9F%E5%99%A8/image-20231030090056541.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="特性"></p><h5 id="采用云母片的变极距型电容传感器"><a href="#采用云母片的变极距型电容传感器" class="headerlink" title="采用云母片的变极距型电容传感器"></a><strong>采用云母片的变极距型电容传感器</strong></h5><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-3-%E4%BC%A0%E6%84%9F%E5%99%A8/image-20231030090423651.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="云母片"></p><ul><li><strong>在</strong> <strong>d0</strong> <strong>较小时，对于同样的</strong> <strong>Δd</strong> <strong>变化所引起的</strong> <strong>ΔC</strong> <strong>更大，从而使传感器灵敏度提高。</strong></li><li><strong>但</strong> <strong>d0</strong> <strong>过小，容易引起电容器击穿或短路。</strong></li><li><strong>为此，极板间可采用高介电常数的材料（云母、塑料膜等）作介质。此时电容</strong> <strong>C</strong> **变为<br>**</li></ul><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-3-%E4%BC%A0%E6%84%9F%E5%99%A8/image-20231030090442649.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="C"></p><p> 式中：εg——云母的相对介电常数，εg&#x3D;7；<br>　　**ε0——空气的介电常数，ε0&#x3D;1；<br>** 　　**d0——空气隙厚度；<br>** 　　<strong>dg——云母片的厚度。</strong></p><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-3-%E4%BC%A0%E6%84%9F%E5%99%A8/image-20231030090520233.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="云母片"></p><p><strong>云母片的相对介电常数是空气的</strong> <strong>7</strong> <strong>倍，其击穿电压不小于1000kV&#x2F;mm，而空气仅为3kV&#x2F;mm。因此有了云母片，极板间起始距离可大大减小。</strong></p><p><strong>一般起始电容在20～100pF，极板间距离在25～200μm。最大位移应小于间距的1&#x2F;10，故在微位移测量中应用最广。</strong></p><h5 id="变面积型电容式传感器"><a href="#变面积型电容式传感器" class="headerlink" title="变面积型电容式传感器"></a><strong>变面积型电容式传感器</strong></h5><p>被测量通过动极板移动引起两极板有效覆盖面积 A 改变，从而得到电容量的变化。</p><p>当动极板相对于定极板沿长度方向平移Δx时，电容变化量为<br> <img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-3-%E4%BC%A0%E6%84%9F%E5%99%A8/image-20231030090625375.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="电容"></p><p> 式中 <strong>C0</strong> <strong>&#x3D;</strong> <strong>ε0εrba&#x2F;d</strong> <strong>为初始电容。</strong></p><p>电容相对变化量为：</p><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-3-%E4%BC%A0%E6%84%9F%E5%99%A8/image-20231030090645315.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="相对变化"></p><p>很明显，这种形式的传感器其电容量 <strong>C</strong> 与水平位移Δx呈线性关系。</p><h5 id="电容式角位移传感器"><a href="#电容式角位移传感器" class="headerlink" title="电容式角位移传感器"></a><strong>电容式角位移传感器</strong></h5><p><strong>当动极板有一个角位移</strong> <strong>θ</strong> <strong>时，与定极板间的有效覆盖面积就发生改变，从而改变了两极板间的电容量。</strong></p><p><strong>当</strong> <strong>θ</strong> <strong>&#x3D; 0</strong> 时，有 </p><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-3-%E4%BC%A0%E6%84%9F%E5%99%A8/image-20231030091024036.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="电容"></p><p> 式中：εr——介质相对介电常数；<br> 　　d0——两极板间距离；</p><p>​A0——两极板间初始覆盖面积。</p><p>当θ ≠ 0时，有</p><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-3-%E4%BC%A0%E6%84%9F%E5%99%A8/image-20231030091047699.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="1"></p><p><strong>可见，传感器的电容量</strong> <strong>C</strong> <strong>与角位移</strong>θ呈线性关系。</p><h5 id="变介质型电容式传感器"><a href="#变介质型电容式传感器" class="headerlink" title="变介质型电容式传感器"></a><strong>变介质型电容式传感器</strong></h5><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-3-%E4%BC%A0%E6%84%9F%E5%99%A8/image-20231030091616241.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="1"></p><p><strong>变介质型电容传感器有较多的结构形式，可以用来测量纸张、绝缘薄膜等的厚度，也可用来测量粮食、纺织品、木材或煤等非导电固体介质的湿度。</strong></p><p><strong>图中，两平行电极固定不动，极距为</strong> <strong>d0，相对介电常数为</strong> <strong>εr2</strong> <strong>的电介质以不同深度嵌入电容器中，从而改变两种介质的极板覆盖面积。</strong></p><p><strong>传感器总电容量</strong> <strong>C</strong> 为 </p><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-3-%E4%BC%A0%E6%84%9F%E5%99%A8/image-20231030091640362.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="C"></p><p> **式中：L0、b0——极板的长度、宽度；<br>**L——第二种介质进入极板间的长度。</p><p><strong>若电介质</strong> <strong>εr1</strong> <strong>&#x3D;</strong> <strong>1，则当</strong> <strong>L</strong> <strong>&#x3D;</strong> <strong>0</strong> <strong>时，传感器初始电容</strong> <strong>C0</strong> <strong>&#x3D;</strong> <strong>ε0εr1L0b0&#x2F;d0。</strong></p><p><strong>当被测介质</strong> <strong>εr2</strong> <strong>进入极板间</strong> <strong>L深度后，引起电容相对变化量为</strong></p><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-3-%E4%BC%A0%E6%84%9F%E5%99%A8/image-20231030091713179.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="C"></p><p><strong>可见，电容量的变化与电介质</strong> <strong>εr2</strong> 的移动量 L成线性关系。</p><h4 id="电介质材料的相对介电常数"><a href="#电介质材料的相对介电常数" class="headerlink" title="电介质材料的相对介电常数"></a><strong>电介质材料的相对介电常数</strong></h4><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-3-%E4%BC%A0%E6%84%9F%E5%99%A8/image-20231030091743840.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="介电"></p><h5 id="应用：电容式液位变换器结构原理"><a href="#应用：电容式液位变换器结构原理" class="headerlink" title="应用：电容式液位变换器结构原理"></a><strong>应用：电容式液位变换器结构原理</strong></h5><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-3-%E4%BC%A0%E6%84%9F%E5%99%A8/image-20231030092020143.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="一案例"></p><p><strong>如图是一种利用改变极板间介质的方式测量液位高低的电容式传感器结构原理图。</strong></p><p><strong>设被测介质的介电常数为 ε1，液面高度为 h，变换器总高度为 H，内筒外径为 d，外筒内径为 D，则此时变换器电容值为</strong></p><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-3-%E4%BC%A0%E6%84%9F%E5%99%A8/image-20231030092011822.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="电容"></p><p>　　**式中：ε——空气介电常数；<br>　　    **C0——由变换器的基本尺寸决定的初始电容值，即</p><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-3-%E4%BC%A0%E6%84%9F%E5%99%A8/image-20231030092045801.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="初始"></p><p><strong>可见，此变换器的电容增量正比于被测液位高度</strong>h。</p><h4 id="变极距型差动平板式电容传感器"><a href="#变极距型差动平板式电容传感器" class="headerlink" title="变极距型差动平板式电容传感器"></a><strong>变极距型差动平板式电容传感器</strong></h4><p><strong>在实际应用中，为了提高灵敏度，减小非线性误差，大多采用差动式结构。</strong></p><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-3-%E4%BC%A0%E6%84%9F%E5%99%A8/image-20231030092154754.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="变极距"></p><p><strong>电容传感器做成差动式之后，灵敏度增加了一倍，而且非线性误差则大大降低了。</strong></p><h5 id="应用：-（差动）电容式加速度传感器"><a href="#应用：-（差动）电容式加速度传感器" class="headerlink" title="应用： （差动）电容式加速度传感器"></a><strong>应用：</strong> <strong>（差动）电容式加速度传感器</strong></h5><p><strong>有两个固定极板（与壳体绝缘），中间有一用弹簧片支撑的质量块，此质量块的两个端面经过磨平抛光后作为可动极板（与壳体电连接）。</strong></p><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-3-%E4%BC%A0%E6%84%9F%E5%99%A8/image-20231030092447889.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="1"></p><p>　　<strong>当传感器壳体随被测对象沿垂直方向作直线加速运动时，质量块在惯性空间中相对静止，两个固定电极将相对于质量块在垂直方向产生大小正比于被测加速度的位移。此位移使两电容的间隙发生变化，一个增加，一个减小，从而使C1、C2产生大小相等、符号相反的增量，此增量正比于被测加速度。<br> 　电容式加速度传感器的主要特点是频率响应快和量程范围大。</strong></p><h5 id="应用：（差动）电容式测厚传感器"><a href="#应用：（差动）电容式测厚传感器" class="headerlink" title="应用：（差动）电容式测厚传感器"></a><strong>应用：（差动）电容式测厚传感器</strong></h5><p>　　<strong>电容测厚传感器是用来对金属带材在轧制过程中厚度的检测。</strong></p><p><strong>其工作原理是在被测带材的上下两侧各置放一块面积相等，与带材距离相等的极板，这样极板与带材就构成了两个电容器C1、C2。</strong></p><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-3-%E4%BC%A0%E6%84%9F%E5%99%A8/image-20231030092527456.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="测厚"></p><p><strong>把两块极板用导线连接起来成为一个极，而带材就是电容的另一个极，其总电容为</strong> <strong>C1</strong> <strong>+</strong> <strong>C2。</strong></p><p><strong>如果带材的厚度发生变化，将引起电容量的变化。</strong></p><p><strong>用交流电桥将电容的变化测出来，经过放大即可由电表指示测量结果。</strong></p><h3 id="热电式传感器"><a href="#热电式传感器" class="headerlink" title="热电式传感器"></a><strong>热电式传感器</strong></h3><h4 id="热电式传感器的分类"><a href="#热电式传感器的分类" class="headerlink" title="热电式传感器的分类"></a><strong>热电式传感器的分类</strong></h4><p><strong>热电式传感器是一种将温度变化转换为电量变化的转换装置。它利用敏感元件的电参数随温度变化的特性，对温度和温度相关的参数进行测量，</strong></p><p><strong>其中将温度转换为电势的热电式传感器叫热电偶</strong></p><p><strong>将温度变化转换为电阻值的热电式传感器叫热电阻</strong></p><ul><li><strong>用金属作为感温元件的热电阻，称为金属热电阻</strong></li><li><strong>用半导体材料作为感温元件的热电阻，称为热敏电阻</strong></li></ul><h4 id="热电偶的测温原理"><a href="#热电偶的测温原理" class="headerlink" title="热电偶的测温原理"></a><strong>热电偶的测温原理</strong></h4><p><strong>热电偶是利用热电效应制成的温度传感器。</strong></p><p><strong>热电效应： 当不同材料的导体或半导体组成一个闭合回路时，若两个接点的温度不同，那么在回路中将会产生电动势的现象。</strong></p><p><strong>这种闭合回路组合被称为热电偶，不同的导体或半导体称为热电极，温度高的接点称为热端（或工作端、测量端），温度低的接点称为冷端（或自由端、补偿端）。</strong></p><p><strong>两点间的温差越大，产生的电动势就越大。引入适当的测量电路测量电动势的大小，就可测得温度的大小。</strong></p><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-3-%E4%BC%A0%E6%84%9F%E5%99%A8/image-20231030092644770.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="1"></p><p><strong>热电动势的组成</strong></p><ul><li><strong>接触电动势：是由两种不同导体的自由电子，其密度不同而在接触处形成的热电势。它的大小取决于两导体的性质及接触点的温度，而与导体的形状和尺寸无关。</strong></li><li><strong>温差电动势：是在同一根导体中，由于两端温度不同而产生的一种电势。</strong></li></ul><h4 id="热电偶的特点"><a href="#热电偶的特点" class="headerlink" title="热电偶的特点"></a><strong>热电偶的特点</strong></h4><p>热电偶作为热电式传感器，凭借其简单的结构，便捷的操作，稳定的性能，广阔的测温范围，较小的热惯性和热容量，便于检测和控制的输出信号，在温度测量中占有重要地位。所以常被用作测量炉子、管道内的气体或液体的温度及固体的表面温度。</p><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-3-%E4%BC%A0%E6%84%9F%E5%99%A8/image-20231030092729412.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="1"></p><h4 id="金属热电阻"><a href="#金属热电阻" class="headerlink" title="金属热电阻"></a><strong>金属热电阻</strong></h4><p><strong>金属热电阻传感器是利用导体的电阻值随温度变化的原理，将温度的变化量转换成与之有一定函数关系的电阻值的变化量，通过对电阻值的测量实现对温度的测量。</strong></p><p><strong>大多数金属导体的电阻随温度变化而变化，当温度升高时，金属内部自由电子的动能增加，在电场作用下，这些杂乱无章的电子作定向移动会遇到更大的阻力，导致金属电阻值随温度的升高而增加。</strong></p><p><strong>材料：温度系数大、线性度好、热容量小、电阻率大、易提纯等</strong></p><table><thead><tr><th><strong>材料</strong></th><th><strong>使用温度范围&#x2F;℃</strong></th><th><strong>（0～100）℃间电阻温度系数α（平均值）（1&#x2F;C）</strong></th><th><strong>化学稳定性</strong></th><th><strong>特性</strong></th><th><strong>应用</strong></th></tr></thead><tbody><tr><td><strong>铂</strong></td><td><strong>-200～850</strong></td><td><strong>0.00385</strong></td><td><strong>在氧化性介质中较稳定，不能在还原性介质中使用，尤其在高温情况下</strong></td><td><strong>特性近于线性、性能稳定、精度高</strong></td><td><strong>适于较高温度的测量，可作标准测温装置</strong></td></tr><tr><td><strong>铜</strong></td><td><strong>-50～150</strong></td><td><strong>0.00428</strong></td><td><strong>超过100℃易氧化</strong></td><td><strong>线性较好、价格低廉、体积大</strong></td><td><strong>适于测量低温、无水分、无腐蚀性介质的温度</strong></td></tr></tbody></table><h4 id="热敏电阻"><a href="#热敏电阻" class="headerlink" title="热敏电阻"></a><strong>热敏电阻</strong></h4><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-3-%E4%BC%A0%E6%84%9F%E5%99%A8/image-20231030092947212.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="1"></p><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-3-%E4%BC%A0%E6%84%9F%E5%99%A8/image-20231030092953595.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="2"></p><ul><li><strong>热敏电阻属于半导体器件，对温度敏感，不同的温度下表现出不同的电阻值。正温度系数热敏电阻在温度越高时电阻值越大，负温度系数热敏电阻在温度越高时电阻值越低。</strong></li><li><strong>热敏电阻具有结构简单、温度系数大、灵敏度高、电阻率高、热惯性小等特点，比较适合动态测量。</strong></li><li><strong>热敏电阻线性度较差，只在某一较窄温度范围内有较好的线性度，且由于是半导体材料其互换性差。</strong></li><li><strong>热敏电阻两大用途</strong></li></ul><p><strong>作为检测元件</strong></p><p><strong>作为电路元件</strong></p><h3 id="光电式传感器"><a href="#光电式传感器" class="headerlink" title="光电式传感器"></a><strong>光电式传感器</strong></h3><ul><li><strong>光电式传感器也称为光电器件，是将光信号转换为电信号的一种装置。</strong></li><li><strong>光电式传感器工作时，先将被测量的变化转换为光量的变化，然后通过光电器件再把光量的变化转换为相应的电量变化，从而实现非电量的测量。</strong></li><li><strong>其原理为光电效应，是指物体吸收了光能后，光能转化为该物体中某些电子的能量，从而产生电效应。</strong></li><li><strong>光电效应分类</strong><ul><li><strong>外光电效应：</strong> <strong>在光线作用下，电子逸出物体表面而产生光电子发射的现象。</strong></li><li><strong>内光电效应：</strong> <strong>在光线作用下，物体的电阻率改变的现象。</strong></li><li><strong>光生伏特效应：</strong> <strong>在光线作用下，物体内部产生一定方向电动势。</strong></li><li><strong>热释电现象：</strong> <strong>热电材料受红外线等照射时，若其表面温度发生变化，则该表面产生电荷的现象。</strong></li></ul></li></ul><h4 id="光电式传感器的工作原理"><a href="#光电式传感器的工作原理" class="headerlink" title="光电式传感器的工作原理"></a><strong>光电式传感器的工作原理</strong></h4><ul><li><strong>光电式传感器也称为光电器件，是将光信号转换为电信号的一种装置。</strong></li><li>光敏电阻作为被广泛使用的光电器件，工作原理基于内光电效应，其核心器件为光电导体，由半导体制成。<ul><li>在室温条件下，没有光照射时，阻值变大，电流变弱，流过回路的电流称为暗电流；有光照射时，阻值变小，电流变强。</li><li>能产生光电效应的器件称为光电效应器件，常用的制作材料为硫化镉，另外还有硒、硫化铝、硫化铅和硫化铋等材料。</li></ul></li><li><strong>光电池，即太阳能电池，也是光电器件的一种，其物理基础是光生伏特效应，将光量转换为电动势，它能够接收不同强度的光照射，产生不同大小的电流。</strong></li><li><strong>光电检测方法具有精度高、响应快、非接触、结构简单、形式多样等优点，因此在自动控制系统中得到了广泛应用。</strong></li></ul><h3 id="MEMS-传感器"><a href="#MEMS-传感器" class="headerlink" title="MEMS 传感器"></a><strong>MEMS</strong> 传感器</h3><p> <strong>（MEMS：微机电系统）</strong></p><p>•<strong>MEMS</strong> <strong>全称为</strong> <strong>Microelectro Mechanical Systems，中文名称为微机电系统，是利用微纳加工技术将机械零件、电子电路、传感与执行机构高度集成的高附加值半导体器件。</strong></p><p>•<strong>利用</strong> <strong>MEMS</strong> <strong>技术构建的器件具有体积小、重量轻、功耗低、集成度高、易于使用等特点，适于大批量生产，广泛应用于汽车、消费电子、工业、医疗、国防、航空航天等领域。</strong></p><p>•<strong>常见的产品包括</strong> <strong>MEMS</strong> <strong>加速度计、MEMS</strong> <strong>麦克风、微马达、微泵、微振子、MEMS</strong> <strong>光学传感器、MEMS</strong> <strong>压力传感器、MEMS陀螺仪、MEMS</strong> <strong>气体传感器等等，以及它们的集成产品。</strong></p><p>•<strong>MEMS技术的目标是通过系统的微型化、集成化、智能化来探索具有新原理、新功能的元件和系统。</strong></p><h4 id="MEMS-概况"><a href="#MEMS-概况" class="headerlink" title="MEMS 概况"></a><strong>MEMS</strong> <strong>概况</strong></h4><p><strong>微机电系统（MEMS, Micro-Electro-Mechanical System），也叫做微电子机械系统、微系统、微机械等，指尺寸在几毫米乃至更小的高科技装置。</strong></p><p><strong>微机电系统其内部结构一般在微米甚至纳米量级，是一个独立的智能系统。</strong> </p><p><strong>微机电系统是在微电子技术（半导体制造技术）基础上发展起来的，融合了光刻、腐蚀、薄膜、LIGA、硅微加工、非硅微加工和精密机械加工等技术制作的高科技电子机械器件。</strong></p><p><strong>微机电系统是集微传感器、微执行器、微机械结构、微电源微能源、信号处理和控制电路、高性能电子集成器件、接口、通信等于一体的微型器件或系统。MEMS是一项革命性的新技术，广泛应用于高新技术产业，是一项关系到国家的科技发展、经济繁荣和国防安全的关键技术。</strong> </p><p><strong>MEMS侧重于超精密机械加工，涉及微电子、材料、力学、化学、机械学诸多学科领域。它的学科面涵盖微尺度下的力、电、光、磁、声、表面等物理、化学、机械学的各分支。</strong> </p><h4 id="MEMS-主要研究方面"><a href="#MEMS-主要研究方面" class="headerlink" title="MEMS 主要研究方面"></a><strong>MEMS</strong> <strong>主要研究方面</strong></h4><p><strong>MEMS技术是一种典型的多学科交叉的前沿性研究领域，几乎涉及到自然及工程科学的所有领域，如电子技术、机械技术、物理学、化学、生物医学、材料科学、能源科学等。其研究内容一般可以归纳为以下三个基本方面：</strong><br> <strong>1．理论基础： 在当前MEMS所能达到的尺度下，宏观世界基本的物理规律仍然起作用，但由于尺寸缩小带来的影响（Scaling Effects），许多物理现象与宏观世界有很大区别，因此许多原来的理论基础都会发生变化，如力的尺寸效应、微结构的表面效应、微观摩擦机理等，因此有必要对微动力学、微流体力学、微热力学、微摩擦学、微光学和微结构学进行深入的研究。这一方面的研究虽然受到重视，但难度较大，往往需要多学科的学者进行基础研究。</strong></p><p><strong>2．技术基础研究：主要包括微机械设计、微机械材料、微细加工、微装配与封装、集成技术、微测量等技术基础研究。</strong></p><p><strong>3．微机械在各学科领域的应用研究。</strong></p><h4 id="MEMS主要应用分类"><a href="#MEMS主要应用分类" class="headerlink" title="MEMS主要应用分类"></a>MEMS主要应用分类</h4><p><strong>传感</strong>： 传感 MEMS 技术是指用微电子微机械加工出来的、用敏感元件如电容、压电、压阻、热电耦、谐振、隧道电流等来感受转换电信号的器件和系统。它包括速度、压力、湿度、加速度、气体、磁、光、声、生物、化学等各种传感器，按种类分主要有：面阵触觉传感器、谐振力敏感传感器、微型加速度传感器、真空微电子传感器等。传感器的发展方向是阵列化、集成化、智能化。由于传感器是人类探索自然界的触角，是各种自动化装置的神经元，且应用领域广泛，未来将备受世界各国的重视。</p><p><strong>生物</strong>： 生物 MEMS 技术是用 MEMS 技术制造的化学&#x2F;生物微型分析和检测芯片或仪器，有一种在衬底上制造出的微型驱动泵、微控制阀、通道网络、样品处理器、混合池、计量、增扩器、反应器、分离器以及检测器等元器件并集成为多功能芯片。可以实现样品的进样、稀释、加试剂、混合、增扩、反应、分离、检测和后处理等分析全过程。它把传统的分析实验室功能微缩在一个芯片上。生物 MEMS 系统具有微型化、集成化、智能化、成本低的特点。功能上有获取信息量大、分析效率高、系统与外部连接少、实时通信、连续检测的特点。国际上生物 MEMS 的研究已成为热点，不久将为生物、化学分析系统带来一场重大的革新。</p><p><strong>光学</strong>：随着信息技术、光通信技术的迅猛发展，MEMS 发展的又一领域是与光学相结合，即综合微电子、微机械、光电子技术等基础技术，开发新型光器件，称为微光机电系统 (MOEMS)。它能把各种 MEMS 结构件与微光学器件、光波导器件、半导体激光器件、光电检测器件等完整地集成在一起。形成一种全新的功能系统。MOEMS 具有体积小、成本低、可批量生产、可精确驱动和控制等特点。较成功的应用研究：</p><p> 一是基于 MOEMS 的新型显示、投影设备，主要研究如何通过反射面的物理运动来进行光的空间调制，典型代表为数字微镜阵列芯片和光栅光阀。</p><p>二是通信系统，主要研究通过微镜的物理运动来控制光路发生预期的改变，较成功的有光开关调制器、光滤波器及复用器等光通信器件。</p><p><strong>射频</strong>：射频 MEMS 技术传统上分为固定的和可动的两类。固定的 MEMS 器件包括本体微机械加工传输线、滤波器和耦合器，可动的 MEMS 器件包括开关、调谐器和可变电容。按技术层面又分为由微机械开关、可变电容器和电感谐振器组成的基本器件层面；由移相器、滤波器和 VCO 等组成的组件层面；由单片接收机、变波束雷达、相控阵雷达天线组成的应用系统层面。</p><h4 id="MEMS-加速度计"><a href="#MEMS-加速度计" class="headerlink" title="MEMS 加速度计"></a><strong>MEMS</strong> <strong>加速度计</strong></h4><p>ADXL203是完整的高精度、低功耗、单轴&#x2F;双轴加速度计，提供经过信号调理的电压输出，所有功能（MEMS &amp; IC）均集成于一个单芯片中。这些器件的满量程加速度测量范围为±1.7 g，既可以测量动态加速度（例如振动），也可以测量静态加速度（例如重力）。</p><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-3-%E4%BC%A0%E6%84%9F%E5%99%A8/image-20231030203302148.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="图： ADXL203（单片集成了MEMS与IC）"></p><p>  <strong>加速度传感器是最早广泛应用的</strong> <strong>MEMS</strong> <strong>之一。MEMS</strong> <strong>作为一个机械结构为主的技术，可以通过设计使一个部件（图中橙色部件）相对底座</strong> <strong>substrate</strong> <strong>产生位移（这也是绝大部分</strong> <strong>MEMS</strong> <strong>的工作原理），这个部件称为质量块（proof mass）。质量块通过锚</strong> <strong>anchor，铰链</strong> <strong>hinge，或弹簧</strong> <strong>spring与底座连接。绿色部分固定在底座。当感应到加速度时，质量块相对底座产生位移。通过一些换能技术可以将位移转换为电能，如果采用电容式传感结构（电容的大小受到两极板重叠面积或间距影响），电容大小的变化可以产生电流信号供其信号处理单元采样。通过梳齿结构可以极大地扩大传感面积，提高测量精度，降低信号处理难度。加速度计还可以通过压阻式、力平衡式和谐振式等方式实现。</strong></p><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-3-%E4%BC%A0%E6%84%9F%E5%99%A8/image-20231030203335697.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="ex"></p><h4 id="NEMS（Nanoelectromechanical-systems，纳机电系统）"><a href="#NEMS（Nanoelectromechanical-systems，纳机电系统）" class="headerlink" title="NEMS（Nanoelectromechanical systems，纳机电系统）"></a><strong>NEMS（Nanoelectromechanical systems，纳机电系统）</strong></h4><p>   首个 NEMS 器件由 IBM 在2000年展示。器件为一个 32×32的二维悬臂梁（2D cantilever array）。该器件采用表面微加工技术加工而成。该器件设计用来进行超高密度，快速数据存储，基于热机械读写技术（thermomechanical writing and readout），高聚物薄膜作为存储介质。该数据存储技术来源于AFM (原子力显微镜) 技术，相比磁存储技术，基于AFM的存储技术具有更大潜力。</p><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-3-%E4%BC%A0%E6%84%9F%E5%99%A8/image-20231030203836796.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="1"></p><h4 id="S-PPA-仿生水凝胶压力传感器"><a href="#S-PPA-仿生水凝胶压力传感器" class="headerlink" title="S-PPA 仿生水凝胶压力传感器"></a><strong>S-PPA</strong> <strong>仿生水凝胶压力传感器</strong></h4><p><strong>2023年，东北大学田野课题组受芦荟的启发，成功地制备一种特殊结构的水凝胶（名为皮肤-聚乙烯醇-聚苯胺-AgNWs，S-PPA）。相关研究成果发表在</strong> <strong>Advanced Functional Materials</strong> <strong>期刊。</strong></p><p><strong>S-PPA水凝胶具有很强的抗损伤能力（拉伸强度为5 MPa，是无皮肤水凝胶的11倍），具有双重电导率（内皮肤为0.8 S&#x2F;m，外皮肤为0.33 S&#x2F;m），具有保水能力、抗菌性能（对金黄色葡萄球菌的抑制率为89.4%）和对金属电极的最小腐蚀。</strong></p><p><strong>S-PPA水凝胶不仅具有优异的抗损伤性，而且还表现出高压缩性能。并且可以在多个加载循环中保持稳定的性能，而不会出现明显的变形或损坏。</strong></p><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-3-%E4%BC%A0%E6%84%9F%E5%99%A8/image-20231030203859300.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="1"></p><p><strong>S-PPA 水凝胶表现出高压缩性和可变形性，内部微观结构在施加压力时发生变化，导致电荷传输路径和阻抗发生变化，这些变化可以通过电气测量来测量和量化，从而实现压力信号的传感和测量。</strong></p><p><strong>具有良好的压敏稳定性，能够抵抗多次压缩的疲劳影响，表现出更高的压力灵敏度。</strong></p><p><strong>可用于评估肌肉力量、控制力和耐力。</strong></p><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-3-%E4%BC%A0%E6%84%9F%E5%99%A8/image-20231030203918572.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="2"></p><h4 id="基于-PMUT-的液体密度测量传感器"><a href="#基于-PMUT-的液体密度测量传感器" class="headerlink" title="基于 PMUT 的液体密度测量传感器"></a><strong>基于</strong> <strong>PMUT</strong> <strong>的液体密度测量传感器</strong></h4><ul><li><strong>2023年，中国科学院苏州纳米技术与纳米仿生研究所轻量化实验室、长春理工大学合作，开发了一种基于压电式微机械超声换能器（PMUT）的液体密度测量传感器。</strong></li><li><strong>解决当前传统密度测量装置体积大、功耗高、不易在线测量的问题，</strong></li><li><strong>由两个</strong> <strong>PMUT（半径</strong> <strong>500 μm，空气中的谐振频率</strong> <strong>136 kHz）组成，作为发射、接收端。</strong></li><li><strong>基于虚拟质量增加效应，即当一个机械结构在不同密度的介质中振动时，其固有频率会发生不同程度的变化。介质密度越大，机械结构的谐振频率变化越大。</strong></li><li><strong>通过对该传感器在不同密度介质中所产生的时域信号与频域信号的分析，得出液体密度与PMUT谐振频率的关系，可应用于微型化可在线测量液体密度传感器。</strong></li></ul><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-3-%E4%BC%A0%E6%84%9F%E5%99%A8/image-20231030203944904.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="1"></p><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-3-%E4%BC%A0%E6%84%9F%E5%99%A8/image-20231030203950595.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="2"></p><h4 id="微流控技术"><a href="#微流控技术" class="headerlink" title="微流控技术"></a><strong>微流控技术</strong></h4><p><strong>微流控（Microfluidics）指的是使用微管道（尺寸为数十到数百微米）处理或操纵微小流体（纳升到阿升）的系统所涉及的科学和技术，是一门涉及化学、流体物理、微电子、新材料、生物学和生物医学工程的新兴交叉学科。</strong></p><p><strong>微流控的重要特征之一是微尺度环境下具有独特的流体性质，如层流和液滴等。借助这些独特的流体现象，微流控可以实现一系列常规方法所难以完成的微加工和微操作。</strong></p><p><strong>过去十年，通过将最多达数千个阀门和泵集成到单个芯片平台上，实现高度多路复用的自动化复杂性液滴控制系统的研究爆炸式增长。</strong></p><p><strong>传统的方法大多使用串行控制来处理单个液滴，不能高效和稳定地控制微流体的存储路径或运动方位。其次，作为流体逻辑元件的微阀，通常需要通过施加包括外部压力、加热、电场或磁场来实现功能。在此背景下，缩小阀门及其驱动系统非常困难，对制造工艺提出了巨大的挑战。</strong></p><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-3-%E4%BC%A0%E6%84%9F%E5%99%A8/image-20231030204216577.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="总让我想起水冷头一类的东西"></p><p><strong>离心微流控系统：多进程控制的实现</strong></p><p><strong>依靠偏转角和偏转速度实现多进程</strong></p><p><strong>可变位姿微流控芯片在工作过程中能不断进行顺时针和逆时针的偏转，类似于提供时钟信号；离心力与电源十分相似同样为系统提供动力。</strong></p><p><strong>研究团队从逻辑电路角度去构思芯片设计，称之为逻辑水路。通过对偏转脉冲的控制，研究团队实现了逻辑液滴的加法器。证明在离心微流控平台实现液滴逻辑控制的可行性。</strong></p><p><strong>构建了一种由逻辑开关单元组成的液体混合器，ABCD端口代表四种携带生物信息的液体输入，其能排列组合合成所有混合产物，共计16种组合方式。能快速实现对生物信息的匹配，可应用于核酸大规模自动筛查。</strong></p><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-3-%E4%BC%A0%E6%84%9F%E5%99%A8/image-20231030204258688.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="1"></p><h4 id="中国首款商用可重构5G射频芯片“破风”"><a href="#中国首款商用可重构5G射频芯片“破风”" class="headerlink" title="中国首款商用可重构5G射频芯片“破风”"></a><strong>中国首款商用可重构5G射频芯片“破风”</strong></h4><p><strong>2023年8月30日，中国移动核心自主创新成果“破风8676” 可重构5G射频收发芯片首次亮相。</strong></p><p><strong>射频收发芯片是无线电波和数字信号之间的转换器，是</strong> <strong>5G</strong> <strong>网络设备中的关键器件，被称为</strong> <strong>5G</strong> <strong>基站上的“明珠”。</strong></p><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-3-%E4%BC%A0%E6%84%9F%E5%99%A8/image-20231030204322058.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="明珠+1"></p><p><strong>国内首款基于可重构架构设计，可广泛商业应用于</strong> <strong>5G</strong> <strong>云基站、皮基站、家庭基站等</strong> <strong>5G</strong> <strong>网络核心设备中的关键芯片，实现从零到一的关键性突破，填补了该领域的国内空白，有效提升了我国</strong> <strong>5G</strong> <strong>网络核心设备的自主可控度。</strong></p><h4 id="移动式高效率超导单光子探测系统"><a href="#移动式高效率超导单光子探测系统" class="headerlink" title="移动式高效率超导单光子探测系统"></a><strong>移动式高效率超导单光子探测系统</strong></h4><p><strong>2023年，中国科学院上海微系统所李浩、尤立星团队和赋同量子科技（浙江）有限公司合作，成功研制了基于小型液氦杜瓦（工作温度4.2K）、在1550nm波段系统探测效率超过70%的移动式超导单光子探测系统。</strong></p><p><strong>为未来开展基于移动平台（机载、车载等）的高性能单光子探应用铺平了道路。获得</strong> <strong>2023年上海工业博览会金奖。</strong></p><p><strong>超导条带光子探测器（SSPD：Superconducting strip photon detector）作为高性能的单光子探测器，广泛地应用于量子信息和弱光探测等领域。</strong></p><p><strong>迄今为止，高效率的</strong> <strong>SSPD</strong> <strong>系统通常需要使用</strong> <strong>GM</strong> <strong>制冷机</strong> <strong>(T≤2.5 K)、吸附式制冷机</strong> <strong>(T≤0.85 K)甚至更低温度的制冷机，这些系统的质量、体积、功耗等成为了限制</strong> <strong>SSPD</strong> <strong>在机载等移动平台应用的关键原因。</strong></p><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-3-%E4%BC%A0%E6%84%9F%E5%99%A8/image-20231030204410466.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="IF"></p>]]></content>
    
    
    <categories>
      
      <category>学习资料</category>
      
    </categories>
    
    
    <tags>
      
      <tag>课件笔记</tag>
      
      <tag>物联网技术与应用</tag>
      
      <tag>IoT</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>正则化直接构造DFA思路</title>
    <link href="/%E6%AD%A3%E5%88%99%E5%8C%96%E7%9B%B4%E6%8E%A5%E6%9E%84%E9%80%A0DFA%E6%80%9D%E8%B7%AF/"/>
    <url>/%E6%AD%A3%E5%88%99%E5%8C%96%E7%9B%B4%E6%8E%A5%E6%9E%84%E9%80%A0DFA%E6%80%9D%E8%B7%AF/</url>
    
    <content type="html"><![CDATA[<p>关于正则化直接构造法DFA的记录：</p><p>①构造firstpos，lastpos，nullable，followpos</p><p>②节点类型：|（或），*（闭包），·（连接）</p><p>③语法树：添加’#‘号作为接收状态标志</p><p>④最小化DFA</p><p><img src="/%E6%AD%A3%E5%88%99%E5%8C%96%E7%9B%B4%E6%8E%A5%E6%9E%84%E9%80%A0DFA%E6%80%9D%E8%B7%AF/image-20231018232957777.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="图"></p><p>最简单的nullable，如果空字符串是由以n为根的子表达式生成的字符串的成员，则为true。看节点是否可能为空：比如ɛ，*节点以及对应的组合</p><p>firstpos，定义了以结点n为根的子树中的位置集合。这些位置对应于以结点n为根推导出的某个句子的第一个符号：大多数情况都i是叶子前结点的并。在连接的情况下，如果前结点不为空就只有前结点，否则也是并</p><p>lastpos，和firstpos的前后节点情况对调</p><p>followpos：</p><ul><li><p>当n是一个连接结点，且其左右子树分别为c1、c2，那么对于lastpos(c1)中的所有位置i，firstpos(c2)中的所有位置都在followpos(i)中。  </p><p>​followpos（lastpos（c1））&#x3D;firstpos（c2）</p></li><li><p>当n是一个星结点，且i是lastpos(n)中的一个位置，那么firstpos(n)中的所有位置都在followpos(i)中。</p></li><li><p>followpos(lastpos（i）)&#x3D;firstpos（i）</p></li></ul><p>盯准两种结点，从下往上扫一遍并记录</p><p>最小化DFA：</p><p>第一步，写出firstpos(root)&#x3D;{1,2,3}&#x3D;A意思就是根节点的firstpos用来构建第一个状态（怎么找？别被迷惑，就是语法树顶的左边的几个数字）</p><p>第二步，A闭包，接a，b等东西(例如接a，那么就并上A中为a标号的followpos)。。。。和</p><p>具体可看：<a href="https://blog.nowcoder.net/n/a9bd25e694e547189bc691824ebc0d50">https://blog.nowcoder.net/n/a9bd25e694e547189bc691824ebc0d50</a></p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
      <tag>编译原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第1.1章-机器学习基础</title>
    <link href="/%E7%AC%AC1-1%E7%AB%A0-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/"/>
    <url>/%E7%AC%AC1-1%E7%AB%A0-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="机器学习基础（见PDF栏）"><a href="#机器学习基础（见PDF栏）" class="headerlink" title="机器学习基础（见PDF栏）"></a>机器学习基础（见PDF栏）</h1><p>突然发现老师给的ppt全是图片。。。实际上就是用pdf转的</p><p>于是参考了这篇博客<a href="https://blog.csdn.net/m0_59464010/article/details/123361053?spm=1001.2101.3001.6661.1&utm_medium=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~Rate-1-123361053-blog-104574959.235%5Ev38%5Epc_relevant_sort_base2&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~Rate-1-123361053-blog-104574959.235%5Ev38%5Epc_relevant_sort_base2&utm_relevant_index=1">如何在hexo博客中在线阅读pdf</a></p><p>点击PDF就可以阅读了</p>]]></content>
    
    
    <categories>
      
      <category>学习资料</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机器学习</tag>
      
      <tag>PDF</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>IoT__第2章__感知识别__2.2_RFID</title>
    <link href="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-2-RFID/"/>
    <url>/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-2-RFID/</url>
    
    <content type="html"><![CDATA[<h1 id="第二章-物联网感知识别"><a href="#第二章-物联网感知识别" class="headerlink" title="第二章 物联网感知识别"></a><strong>第二章 物联网感知识别</strong></h1><h2 id="2-2-RFID"><a href="#2-2-RFID" class="headerlink" title="2.2 RFID"></a><strong>2.2</strong> <strong>RFID</strong></h2><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-2-RFID/image-20230924195032140.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="RFID"></p><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-2-RFID/image-20230924195042841.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="process"></p><p>RFID是射频识别技术（Radio Frequency Identification）的英文缩写，利用射频信号通过空间耦合（交变磁场或电磁场）实现无接触信息传递并通过所传递的信息达到识别目的。</p><p>它是上世纪90年代兴起的自动识别技术，首先在欧洲市场上得以使用，随后在世界范围内普及。</p><p>RFID较其它技术明显的优点是电子标签和阅读器无需接触便可完成识别。射频识别技术改变了条形码依靠“有形”的一维或二维几何图案来提供信息的方式，通过芯片来提供存储在其中的数量巨大的“无形”信息。</p><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-2-RFID/image-20230924195124630.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="some logos"></p><h3 id="RFID-系统组成"><a href="#RFID-系统组成" class="headerlink" title="RFID 系统组成"></a><strong>RFID</strong> <strong>系统组成</strong></h3><p>RFID系统主要由电子标签、阅读器、中间件和位于后台的中央信息系统组成 </p><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-2-RFID/image-20230924195203568.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="RFID系统组成框图"></p><h3 id="RFID系统工作原理"><a href="#RFID系统工作原理" class="headerlink" title="RFID系统工作原理"></a><strong>RFID系统工作原理</strong></h3><p>RFID系统工作原理</p><p>标签进入磁场后，只要接收到阅读器发出的射频信号，就能产生感应电流获得能量，然后发送出存储在芯片中的信息，或者是主动发送信号（限于有源标签），阅读器读取标签信息，进行解码后送至后台的中央信息系统进行数据处理。</p><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-2-RFID/image-20230924195236669.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="扫描"></p><p>RFID 的两种耦合方式：电感耦合、电磁反向散射耦合</p><p>电子标签与阅读器之间通过耦合元件实现射频信号的非接触的空间耦合，从而根据时序关系，实现能量、数据的交换</p><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-2-RFID/image-20230924195307181.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="2-ways"></p><h3 id="RFID-设备基本组件"><a href="#RFID-设备基本组件" class="headerlink" title="RFID 设备基本组件"></a><strong>RFID</strong> <strong>设备基本组件</strong></h3><p>RFID 设备的基本组件构成</p><ul><li>阅读器 (Reader)</li><li>天线 (Antenna)</li><li>标签 (Tag)</li></ul><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-2-RFID/image-20230924195432353.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="basic parts"></p><h4 id="RFID-组件：阅读器"><a href="#RFID-组件：阅读器" class="headerlink" title="RFID 组件：阅读器"></a><strong>RFID</strong> <strong>组件：阅读器</strong></h4><p>阅读器：读取或读写电子标签信息的设备。主要任务是控制射频模块向标签发射信号，并接收标签的应答，对标签的对象识别信息及其它信息进行解码，传输到后台主机以供处理。</p><p>因其工作模式一般是主动向标签询问标识信息，所以又被称为询问器（Interrogator）。</p><p>固定式阅读器通过有线接口、手持式阅读器通过无线接口，同后台主机相连。</p><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-2-RFID/image-20230924195527917.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="reader"></p><h4 id="RFID-组件：天线"><a href="#RFID-组件：天线" class="headerlink" title="RFID 组件：天线"></a><strong>RFID</strong> <strong>组件：天线</strong></h4><p>天线：在标签和阅读器之间传递射频信号。阅读器可以连接一个或多个天线。</p><p>RFID系统的工作频率从低频到微波，这使得天线与标签芯片之间的匹配问题变得很复杂。</p><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-2-RFID/image-20230924195558007.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="天线"></p><h4 id="RFID-组件：标签"><a href="#RFID-组件：标签" class="headerlink" title="RFID 组件：标签"></a><strong>RFID</strong> <strong>组件：标签</strong></h4><p>标签（Tag）：由微型天线、耦合元件、芯片组成。芯片内保存有一定格式的电子数据，每个标签内部存有唯一的电子编码，作为标识性信息的数据载体，可附着在物体上用于标识目标对象。</p><p>标签进入 RFID 阅读器扫描场以后，接收到阅读器发出的射频信号，凭借感应电流获得的能量发送出存储在芯片中的电子编码（被动式标签），或者主动发送某一频率的信号（主动式标签）。</p><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-2-RFID/image-20230924195644611.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="tags"></p><h5 id="标签分类："><a href="#标签分类：" class="headerlink" title="标签分类："></a><strong>标签分类</strong>：</h5><ul><li>被动式标签（Passive Tag）：因内部没有电源设备又被称为无源标签。被动式标签内部的集成电路通过接收由阅读器发出的电磁波进行驱动，向阅读器发送数据。</li><li>主动标签（Active Tag）：因标签内部携带电源又被称为有源标签。主动式标签要比被动式标签体积大、价格昂贵。但主动标签通信距离更远，可达数十米。</li><li>半主动标签（Semi-active Tag）：兼有被动标签和主动标签的所有优点，内部携带电池，能够为标签内部计算提供电源。<ul><li>这种标签可以携带传感器，可用于检测环境参数，如温度、湿度、是否移动等。</li><li>然而与主动式标签不同的是它们的通信并不需要电池提供能量，而是像被动式标签一样通过阅读器发射的电磁波获取通信能量</li></ul></li></ul><h3 id="RFID技术分析：频率"><a href="#RFID技术分析：频率" class="headerlink" title="RFID技术分析：频率"></a><strong>RFID技术分析：频率</strong></h3><p>频率是RFID系统的一个很重要的参数，它决定了系统工作原理、通信距离、成本、天线形状和应用领域等因素。</p><p>RFID典型的工作频率有125KHz、133KHz、13.56MHz、27.12MHz、433MHz、860-960MHz、2.45GHz、5.8GHz等。按照工作频率的不同，RFID系统集中在低频、高频和超高频三个区域。</p><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-2-RFID/image-20230924195904377.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="f"></p><h4 id="标签分类：按-RFID-频率"><a href="#标签分类：按-RFID-频率" class="headerlink" title="标签分类：按 RFID 频率"></a><strong>标签分类：按</strong> <strong>RFID</strong> <strong>频率</strong></h4><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-2-RFID/image-20230924195927999.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="分类"></p><h4 id="阅读器及标签分类"><a href="#阅读器及标签分类" class="headerlink" title="阅读器及标签分类"></a><strong>阅读器及标签分类</strong></h4><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-2-RFID/image-20230924200008558.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="分类"></p><h3 id="阅读器操作规范"><a href="#阅读器操作规范" class="headerlink" title="阅读器操作规范"></a>阅读器操作规范</h3><p><strong>为保证阅读器的性能满足应用需求，在阅读器的使用过程中通常要遵循相应的操作规范。</strong></p><p><strong>在操作规范中，下面几点是选择使用阅读器时需要重点考虑的方面：</strong></p><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-2-RFID/image-20230924200047669.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="思维图"></p><h4 id="阅读器组成"><a href="#阅读器组成" class="headerlink" title="阅读器组成"></a>阅读器组成</h4><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-2-RFID/image-20230924200134811.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="reader"></p><h3 id="标签操作规范"><a href="#标签操作规范" class="headerlink" title="标签操作规范"></a>标签操作规范</h3><p><strong>与阅读器类似，在实际系统中，标签的操作规范也要考虑很多因素，下面几个是需要重点考虑的：</strong></p><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-2-RFID/image-20230924200216741.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="10"></p><h4 id="标签组成"><a href="#标签组成" class="headerlink" title="标签组成"></a>标签组成</h4><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-2-RFID/image-20230924200254153.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="标签"></p><h3 id="标签天线"><a href="#标签天线" class="headerlink" title="标签天线"></a>标签天线</h3><p><strong>天线是一种专门设计用来耦合、辐射电磁能量的导体结构。</strong></p><p><strong>通常标签天线尺寸越小，天线辐射阻抗越小，标签工作距离越短，工作效率越低。</strong></p><p><strong>天线性能包括方向特性、天线效率、天线增益等。</strong></p><p><strong>根据工作原理不同，可以将标签天线分为三类：</strong></p><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-2-RFID/image-20230924200325340.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="三类"></p><h3 id="标签芯片"><a href="#标签芯片" class="headerlink" title="标签芯片"></a>标签芯片</h3><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-2-RFID/image-20230924200410164.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="三"></p><p><strong>可分为：模拟前端、控制部件和存储部件</strong></p><p><strong>模拟前端：整流天线输入信号提供稳定电压、将天线输入检波得到数字信号、调制控制部件发送信号给天线发送、为控制模块提供时钟。</strong></p><p><strong>控制部件：数据解码、数据校验、数据编码、加密解密、防碰撞、读写控制。</strong></p><p><strong>存储部件：标签数据载体。</strong></p><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-2-RFID/image-20230924200401821.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="结构"></p><h3 id="标签制造"><a href="#标签制造" class="headerlink" title="标签制造"></a>标签制造</h3><p><strong>标签的制作工艺主要有：</strong></p><p><strong>线圈绕制法、化学蚀刻法和印刷法</strong></p><p><strong>制造过程分为：</strong></p><p><strong>天线制造和芯片组装</strong></p><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-2-RFID/image-20230924200448443.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="流程"></p><h4 id="声表面波电子标签结构"><a href="#声表面波电子标签结构" class="headerlink" title="声表面波电子标签结构"></a><strong>声表面波电子标签结构</strong></h4><p><strong>声表面波</strong></p><p>–<strong>Surface Acoustic Wave</strong></p><p>–<strong>SAW</strong></p><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-2-RFID/image-20230924200509030.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="结构"></p><h4 id="RFID-中间件"><a href="#RFID-中间件" class="headerlink" title="RFID 中间件"></a><strong>RFID</strong> <strong>中间件</strong></h4><p>RFID 中间件的主要功能</p><ul><li>对读写器或数据采集设备的管理、协同、控制</li><li>数据过滤与数据处理</li><li>事件数据报告生成与发送</li><li>访问安全控制</li><li>发布&#x2F;订阅模型</li><li>提供符合标准的接口、集中统一的管理界面</li><li>进程管理与负载均衡</li><li>数据路由与集成</li></ul><h4 id="RFID-标签的存储结构"><a href="#RFID-标签的存储结构" class="headerlink" title="RFID 标签的存储结构"></a><strong>RFID</strong> <strong>标签的存储结构</strong></h4><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-2-RFID/image-20230924200552864.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="EPC Class1 Generation 标签存储区示意图"></p><h4 id="RFID系统组件原理小结"><a href="#RFID系统组件原理小结" class="headerlink" title="RFID系统组件原理小结"></a><strong>RFID系统组件原理小结</strong></h4><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-2-RFID/image-20230924200610188.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="总结"></p><h3 id="EPCglobal-的-RFID-体系架构"><a href="#EPCglobal-的-RFID-体系架构" class="headerlink" title="EPCglobal 的 RFID 体系架构"></a>EPCglobal 的 RFID 体系架构</h3><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-2-RFID/image-20230924200647960.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="图"></p><h3 id="RFID标签与条形码相比的优点"><a href="#RFID标签与条形码相比的优点" class="headerlink" title="RFID标签与条形码相比的优点"></a><strong>RFID标签与条形码相比的优点</strong></h3><p><strong>体积小且形状多样：RFID标签在读取上并不受尺寸大小与形状限制，不需要为了读取精度而配合纸张的固定尺寸和印刷品质。</strong></p><p><strong>环境适应性：纸张容易被污染而影响识别。但RFID对水、油等物质却有极强的抗污性。另外，即使在黑暗的环境中，RFID标签也能够被读取。</strong></p><p><strong>可重复使用：标签具有读写功能，电子数据可被反复覆盖，因此可以被回收而重复使用。</strong></p><p><strong>穿透性强：标签在被纸张、木材和塑料等非金属或非透明的材质包裹的情况下也可以进行穿透性通讯。</strong></p><p><strong>数据安全性：标签内的数据通过循环冗余校验的方法来保证标签发送的数据准确性。</strong></p><h3 id="RFID和物联网"><a href="#RFID和物联网" class="headerlink" title="RFID和物联网"></a><strong>RFID和物联网</strong></h3><p>基于RFID标签对物体的唯一标识特性，引发了物联网初期的应用场景和热潮。</p><p>通过给物品贴上RFID标签，在现有互联网基础之上构建所有参与流通的物品信息网络。</p><p>通过RFID接入物联网，世界上任何物品都可以随时随地按需被标识、追踪和监控。</p><p>RFID和物联网的建立将对生产制造、销售、运输、使用、回收等物品流通的各个环节以及政府、企业和个人行为带来深刻影响。</p><h3 id="RFID的标签识别协议"><a href="#RFID的标签识别协议" class="headerlink" title="RFID的标签识别协议"></a><strong>RFID的标签识别协议</strong></h3><p><strong>RFID系统支持多目标识别，在多个阅读器和多个电子标签同时工作的情况下，会造成阅读器和电子标签之间的相互干扰，无法读取信息，这种现象称为冲突（或碰撞、干扰）。</strong></p><p><strong>RFID系统中，主要存在以下两种类型的信号干扰：</strong>标签冲突、阅读器冲突</p><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-2-RFID/image-20230924200758115.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="冲突"></p><p><strong>因此，需要降低阅读器之间以及标签之间的冲突来提高对标签的识别效率。</strong></p><h4 id="RFID系统的防冲突（防碰撞）技术"><a href="#RFID系统的防冲突（防碰撞）技术" class="headerlink" title="RFID系统的防冲突（防碰撞）技术"></a><strong>RFID系统的防冲突（防碰撞）技术</strong></h4><ul><li><strong>空分多址法</strong><ul><li><strong>按空间区域进行划分</strong><ul><li><strong>读写器和天线的作用距离</strong></li></ul></li><li><strong>相控阵天线</strong><ul><li><strong>天线的方向</strong></li></ul></li></ul></li><li><strong>频分多址法</strong><ul><li><strong>不同载波频率</strong><ul><li><strong>副载波</strong></li></ul></li></ul></li><li><strong>时分多址法</strong><ul><li><strong>ALOHA算法</strong></li><li><strong>基于二进制算法（确定性算法）</strong></li></ul></li></ul><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-2-RFID/image-20230924200937055.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="1"></p><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-2-RFID/image-20230924200941942.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="2"></p><p><strong>针对阅读器之间的冲突问题，存在一些典型的防冲突协议：</strong></p><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-2-RFID/image-20230924201001726.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="协议"></p><p><strong>与阅读器相比，标签受硬件资源限制，存储能力和计算能力很有限。这使得标签没有冲突检测功能，标签之间不能相互的通信，所有的冲突检测都需要借助于阅读器完成。从系统的复杂度以及成本方面考虑，TDMA</strong> <strong>可用于检测</strong> <strong>RFID</strong> <strong>标签之间的冲突。</strong></p><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-2-RFID/image-20230924201014569.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="算法"></p><h4 id="基于纯-ALOHA-的防冲突算法"><a href="#基于纯-ALOHA-的防冲突算法" class="headerlink" title="基于纯 ALOHA 的防冲突算法"></a><strong>基于纯</strong> <strong>ALOHA</strong> <strong>的防冲突算法</strong></h4><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-2-RFID/image-20230924201045878.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="aloha"></p><p><strong>算法简单，易于实现，但信道利用率仅为</strong> <strong>18.4%，性能差。</strong></p><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-2-RFID/image-20230924201104839.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="性能"></p><h4 id="基于时隙-ALOHA-的防冲突算法"><a href="#基于时隙-ALOHA-的防冲突算法" class="headerlink" title="基于时隙 ALOHA 的防冲突算法"></a><strong>基于时隙</strong> <strong>ALOHA</strong> <strong>的防冲突算法</strong></h4><p><strong>S-ALOHA</strong> <strong>算法将纯</strong> <strong>ALOHA</strong> <strong>的时间分为若干时隙，每个时隙大于或等于标签标识符发送的时间长度，并且每个标签只能在时隙开始时刻发送标识符。由于系统进行了时间同步，S‐ALOHA</strong> <strong>协议的信道利用率达到36.8%，是纯</strong> <strong>ALOHA</strong> <strong>的两倍。</strong></p><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-2-RFID/image-20230924201137601.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="性能"></p><h4 id="基于帧的时隙-ALOHA-FSA-防冲突算法"><a href="#基于帧的时隙-ALOHA-FSA-防冲突算法" class="headerlink" title="基于帧的时隙 ALOHA (FSA) 防冲突算法"></a><strong>基于帧的时隙</strong> <strong>ALOHA</strong> <strong>(FSA)</strong> <strong>防冲突算法</strong></h4><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-2-RFID/image-20230924201206242.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="帧"></p><p><strong>1、每一帧开始时，阅读器广播帧长度</strong> <strong>f（时隙个数），并激活所有标签。</strong></p><p><strong>各个标签在接收 f 以后随机在0 ~ ( f – 1 ) 中选择一个整数，作为其发送标识符的时隙序号 SN，并存于其寄存器内。</strong></p><p><strong>2、阅读器通过时隙开始命令启动一个新时隙。对每个标签而言：</strong></p><p><strong>如果 SN &#x3D; 0 则立即发送标识符；否则就不发送并且设 SN &#x3D; SN – 1 。</strong></p><p><strong>若标签发送成功即无冲突发生，则立即休眠即不再活动；否则，该标签进入等待，在下一帧中再选择一个时隙重新发送标识符。</strong></p><p><strong>3、重复此过程，直到阅读器在某一帧中没有收到标签信号，即标签均被识别</strong></p><p><strong>例：帧长</strong> <strong>f &#x3D; 3，每个标签产生</strong> <strong>0 ~ 2</strong> <strong>的随机数</strong></p><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-2-RFID/image-20230924201241930.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="例"></p><p><strong>冲突时隙：不止一个标签响应</strong>  <strong>（响应标签#</strong> <strong>&gt; 1）</strong></p><p><strong>单 时 隙：只有一个标签响应</strong>    <strong>（响应标签#</strong>  <strong>&#x3D; 1）</strong></p><p><strong>空 时 隙：没有标签响应</strong>           <strong>（响应标签#</strong>  <strong>&#x3D; 0）</strong></p><blockquote><p><strong>FSA</strong> <strong>算法的优点在于逻辑简单，电路设计简单，所需内存少，且在帧内只随机发送一次，这样能够更进一步降低了冲突的概率。</strong></p><p><strong>FSA</strong> <strong>成为</strong> <strong>RFID</strong> <strong>系统中最常用的一种基于</strong> <strong>ALOHA</strong> <strong>的防冲突算法</strong></p></blockquote><p><strong>FSA</strong> <strong>算法局限性：</strong></p><p>   <strong>帧的长度</strong> <strong>L</strong> <strong>固定（标签数</strong> <strong>n</strong> <strong>动态变化）</strong></p><ul><li><strong>当标签数远小于帧长度：时隙会巨大浪费，识别时间也会增加</strong></li><li><strong>当标签数远大于帧长度：标签冲突概率增大，识别标签的时间会极大地增加</strong></li><li><strong>当帧长度等于标签的数目（L &#x3D; n）时，FSA</strong> <strong>才能获得最佳的识别性能。</strong></li></ul><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-2-RFID/image-20230924201404261.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="性能计算"></p><h4 id="FSA-帧长调整-gt-Q-算法"><a href="#FSA-帧长调整-gt-Q-算法" class="headerlink" title="FSA + 帧长调整    -&gt;Q 算法"></a><strong>FSA +</strong> <strong>帧长调整</strong>    -&gt;<strong>Q</strong> <strong>算法</strong></h4><p><strong>实际中标签的数量是未知的，并且动态变化。</strong></p><p><strong>动态自适应设置帧长度的算法可以解决</strong> <strong>FSA</strong> <strong>的局限性。</strong></p><p><strong>常见的帧长调整方法：</strong></p><p><strong>方法一：根据前一帧通信获取的空时隙数目，发生碰撞的时隙数目、成功识别标签的时隙数目，来估计当前的标签数并设置下一帧的最优长度；</strong> <strong>（ISO&#x2F;IEC 18000-6</strong> <strong>中</strong> <strong>Type A</strong> <strong>标准）</strong></p><p><strong>方法二：根据前一时隙的反馈，动态调整帧长为</strong> <strong>2</strong> <strong>的整数倍，最具代表性的是</strong> <strong>EPCglobalGen2</strong> <strong>标准中的</strong> <strong>Q</strong> <strong>算法</strong> <strong>（ISO&#x2F;IEC 18000-6</strong> <strong>中</strong> <strong>Type C</strong> <strong>标准）</strong></p><ul><li><strong>当一个帧出现过多的冲突时隙时，阅读器会提前结束该帧，并重新启动一个更长的帧；</strong></li><li><strong>当一个帧出现过多的空闲时隙时，阅读器也会提前结束帧，并重新启动一个更短的帧</strong></li></ul><blockquote><p><strong>Q</strong> <strong>算法过程</strong>：</p><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-2-RFID/image-20230924202810104.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="图"></p><ul><li><strong>用</strong> <strong>Q</strong> <strong>值标记</strong> <strong>FSA</strong> <strong>中帧长</strong> <strong>2Q</strong> <strong>，Q</strong> <strong>值取值范围</strong> <strong>0 ~ 15，作为</strong> <strong>Query</strong> <strong>命令参数。</strong></li><li><strong>Qfp</strong> <strong>作为</strong> <strong>Q</strong> <strong>的浮点表示形式，初始值为</strong> <strong>4.0。</strong></li><li><strong>常量</strong> <strong>c</strong> <strong>是</strong> <strong>Q</strong> <strong>的浮动因子，取值为</strong> <strong>0.1 ~ 0.5。</strong></li><li><strong>reader</strong> <strong>广播帧长：</strong> <strong>帧开始命令Query</strong> <strong>中包含了</strong> <strong>Q值</strong> <strong>(帧长</strong> <strong>2Q</strong> <strong>)。</strong></li><li><strong>tag</strong> <strong>选时隙：非休眠的标签收到</strong> <strong>Query</strong> <strong>时，随机产生</strong> <strong>0 ~ 2Q-1</strong> <strong>并存入寄存器SN</strong> <strong>，每过一时隙减一。</strong></li><li><strong>当</strong> <strong>SN</strong> <strong>减至</strong> <strong>0</strong> <strong>则向阅读器回复。</strong></li><li><strong>reader</strong> <strong>根据前一个时隙的回复情况来更改</strong> <strong>Qfp</strong> <ul><li><strong>如没有标签回复：Qfp</strong> <strong>减去</strong> <strong>c</strong>  </li><li><strong>如多个标签回复：Qfp</strong> <strong>加上</strong> <strong>c</strong> </li><li><strong>如一个标签回复：Qfp</strong> <strong>不变</strong></li></ul></li><li><strong>根据</strong> <strong>Q &#x3D; round(Qfp)</strong> <strong>是否变化，决定是继续该帧还是重新开启新帧。</strong></li></ul><p><strong>Q</strong> <strong>算法自适应地调整帧长为</strong> <strong>2Q</strong> <strong>，识别效率高，该算法以及改进算法在超高频射频识别系统中得到广泛的应用。</strong></p></blockquote><h4 id="基于-ALOHA-算法的不足"><a href="#基于-ALOHA-算法的不足" class="headerlink" title="基于 ALOHA 算法的不足"></a><strong>基于</strong> <strong>ALOHA</strong> <strong>算法的不足</strong></h4><ul><li><h5 id="基于-ALOHA-的防冲突算法简单，并且兼顾了公平性。"><a href="#基于-ALOHA-的防冲突算法简单，并且兼顾了公平性。" class="headerlink" title="基于 ALOHA 的防冲突算法简单，并且兼顾了公平性。"></a><strong>基于</strong> <strong>ALOHA</strong> <strong>的防冲突算法简单，并且兼顾了公平性。</strong></h5></li><li><p><strong>但是，标签存在饿死的问题。当一个标签选择的时隙总是冲突时隙，则该标签可能永远无法被识别。</strong></p></li></ul><p><strong>确定性算法可解决上述问题。</strong></p><p><strong>基于确定性二进制的防冲突算法</strong></p><ul><li><strong>BSA</strong> <strong>二进制搜索算法、FBSA</strong> <strong>动态二进制搜索算法、基于查询二进制树</strong></li><li><strong>特点：</strong><ul><li><strong>无状态协议，标签只需要根据阅读器广播的标示符作比较，可用于无可写存储区的标签</strong></li><li><strong>不存在标签饿死</strong></li><li><strong>识别时延受标签ID分布及长度影响</strong></li></ul></li></ul><p><strong>基于随机二进制树的防冲突算法</strong></p><ul><li><strong>自适应</strong> <strong>B</strong> <strong>树算法</strong><ul><li><strong>状态协议，标签需要可写存储区</strong></li><li><strong>仍有可能存在标签饿死</strong></li><li><strong>识别时延受标签ID分布及长度影响</strong></li></ul></li></ul><h4 id="二进制搜索算法-BSA"><a href="#二进制搜索算法-BSA" class="headerlink" title="二进制搜索算法  BSA"></a><strong>二进制搜索算法</strong>  <strong>BSA</strong></h4><p><strong>算法原理</strong></p><ul><li><strong>标签</strong> <strong>SN：每个标签具有自身唯一的序号SN（假设序号长度一致）。</strong></li><li><strong>每一轮选择：阅读器多次向标签群发送命令，每次命令都会把标签群分成两组，多次分组，最后得到此轮唯一的一个标签。</strong></li><li><strong>对剩余的标签群继续上述操作。每轮选中一个标签，直至选完所有标签。</strong></li></ul><p><strong>算法基本命令</strong></p><ul><li><strong>请求</strong> <strong>Request (SN)：携带一个参数</strong> <strong>SN，当标签收到该命令时，将自身的</strong> <strong>SN</strong> <strong>与收到的</strong> <strong>SN</strong> <strong>对比，若自身</strong> <strong>SN</strong> <strong>小于或等于收到的</strong> <strong>SN，则向阅读器回复标签SN。</strong></li><li><strong>休眠</strong> <strong>Sleep (SN)：携带一个参数</strong> <strong>SN，若标签自身的</strong> <strong>SN</strong> <strong>与收到的</strong> <strong>SN</strong> <strong>相等，则被阅读器选中，完成数据传送后，进入休眠状态。</strong></li></ul><h5 id="BSA-算法步骤："><a href="#BSA-算法步骤：" class="headerlink" title="BSA 算法步骤："></a><strong>BSA</strong> <strong>算法步骤</strong>：</h5><p><strong>阅读器发出请求序列号</strong> <strong>SN，属于</strong> <strong>{ tag |</strong> <strong>SNtag</strong> <strong>&lt;&#x3D; SN}</strong> <strong>的标签回复自身序列号</strong></p><p>1.<strong>阅读器第一次发送请求Request命令；参数设为最大序列号（11 … 11），因此所有标签向阅读器回复自身。</strong></p><p>2.<strong>当存在两个以上的标签同时回复阅读器时，必然发生碰撞，设这些标签序列号出现不一致的最高位为</strong> <strong>C（碰撞位），阅读器更新自身序列号：第</strong> <strong>C</strong> <strong>位置0，高于该位的置为这些标签序列号相同的前</strong> <strong>C - 1</strong> <strong>位，低于该位的置</strong> <strong>1。阅读器发送Request命令，参数采用新序列号。</strong></p><p>3.<strong>标签接收到新一轮的请求序列号， 只有序列号小于或等于此序列号的标签，才向阅读器回复自身序列号。</strong></p><p>4.<strong>循环执行</strong> <strong>2 - 3，依次排除序列号较大的标签，选出一个序列号最小的标签；阅读器与此标签通信，结束后发送休眠</strong> <strong>Sleep</strong> <strong>命令使其休眠，即对阅读器发送的请求命令不进行响应。</strong></p><p><strong>重复上述过程，可以按照序列号从小到大的次序，完成所有标签的识别和读取。</strong></p><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-2-RFID/image-20230924203147938.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="BAS"></p><h4 id="动态二进制搜索算法-FBSA"><a href="#动态二进制搜索算法-FBSA" class="headerlink" title="动态二进制搜索算法 FBSA"></a><strong>动态二进制搜索算法</strong> <strong>FBSA</strong></h4><p>传统二进制搜索算法，每次传输的数据是全部长度的序列号，造成了识别所需时间和所消耗功率的浪费。</p><p>动态二进制树搜索算法FBSA，其改进思路是把数据分成两部分，阅读器和标签双方各自传送其中的一部分数据，阅读器只发送前面一致部分，标签只发送其余的比特位（阅读传送部分+ 标签传送部分&#x3D;** 序列号总长度）。因此总的传输量减小一半，缩短防碰撞执行时间</p><p>FBSA的主要命令和传统BSA算法一样，只是传输策略上有所不同。</p><h5 id="FBSA-算法步骤"><a href="#FBSA-算法步骤" class="headerlink" title="FBSA 算法步骤"></a><strong>FBSA</strong> <strong>算法步骤</strong></h5><p>1.<strong>阅读器第一次发送请求</strong> <strong>Request</strong> <strong>命令；参数设为最大序列号（11 … 11），所有标签回复其自身的序列号。</strong></p><p>2.<strong>阅读器检测到碰撞位，将最高碰撞位（C）置</strong> <strong>0。阅读器发送Request命令，只传输</strong> <strong>C</strong> <strong>~</strong> <strong>N</strong> <strong>的位作为下一次的请求序列号。</strong></p><p>3.<strong>标签接收到新一轮的请求序列号，只有序列号与</strong> <strong>C</strong> <strong>~</strong> <strong>N</strong> <strong>位相同（序列号 ≤ 请求序列号）的标签，才会把其剩余的序列号（1</strong> <strong>~</strong> <strong>C-1）回复给阅读器。</strong></p><p>4.<strong>循环执行</strong> <strong>2 - 3，选出一个序列号最小的标签；阅读器与此标签通信，结束后发送休眠</strong> <strong>Sleep</strong> <strong>命令使其休眠，即对阅读器发送的请求命令不进行响应。</strong></p><p>5.<strong>重复上述过程，可以按照序列号从小到大的次序，完成所有标签的识别和读取。</strong></p><h5 id="图例：-BSA-算法及-FBSA算法"><a href="#图例：-BSA-算法及-FBSA算法" class="headerlink" title="图例： BSA 算法及 FBSA算法"></a><strong>图例：</strong> <strong>BSA</strong> <strong>算法及</strong> <strong>FBSA算法</strong></h5><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-2-RFID/image-20230924203234633.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="TU"></p><h4 id="基于随机二进制树的防冲突算法"><a href="#基于随机二进制树的防冲突算法" class="headerlink" title="基于随机二进制树的防冲突算法"></a><strong>基于随机二进制树的防冲突算法</strong></h4><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-2-RFID/image-20230924203414081.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="TU"></p><ul><li><strong>基于</strong> <strong>B</strong> <strong>树算法</strong> <strong>（ISO&#x2F;IEC 18000-6</strong> <strong>中</strong> <strong>Type B</strong> <strong>标准）</strong></li><li><strong>需要每个标签维持一个计数器（初始值为</strong> <strong>0）。</strong></li><li><strong>标签在每一个时隙开始时，检查计数器值，决定是否响应：</strong><ul><li><strong>如果计数器为</strong> <strong>0</strong> <strong>则立即响应发送自己的标识符号，</strong></li><li><strong>否则，标签在该时隙不响应。</strong></li><li><strong>标签被成功识别后将进入沉默状态，对以后时隙的阅读器命令均不响应。</strong></li></ul></li><li><strong>如果阅读器收到有冲突响应，则广播</strong> <strong>FAIL</strong> <strong>命令。</strong></li><li><strong>当标签收到</strong> <strong>FAIL</strong> <strong>命令后，查看并调整自己的计数器</strong><ul><li><strong>如果计数器不为</strong> <strong>0，则把计数器加</strong> <strong>1，推后发送时间</strong></li><li><strong>反之，生成</strong> <strong>1</strong> <strong>或</strong> <strong>0</strong> <strong>的随机数，并加到计数器（产生1的标签退出下一个时隙的竞争，产生</strong> <strong>0</strong> <strong>的标签继续下一时隙的竞争）</strong></li></ul></li><li><strong>如果阅读器收到的响应数为</strong> <strong>0，则广播</strong> <strong>Success</strong> <strong>命令。</strong></li><li><strong>如果只有一个标签的计数器为</strong> <strong>0，则阅读器感知到无冲突，于是发送</strong> <strong>Read</strong> <strong>命令（包含</strong> <strong>ID），与该标签完成数据交换后，阅读器广播</strong> <strong>Success</strong> <strong>命令。</strong></li><li><strong>收到</strong> <strong>Success</strong> <strong>命令的所有标签将计数器减</strong> <strong>1</strong> <strong>。</strong></li><li><strong>如果全部标签都成功发送数据，则结束算法。</strong></li></ul><p><strong>B</strong> <strong>树算法示例</strong>:</p><table><thead><tr><th><strong>角色</strong></th><th><strong>命令</strong></th><th>时隙<strong>1</strong></th><th>时隙  2</th><th>时隙3</th><th>时隙 4</th><th>时隙5</th><th>时隙5</th><th>时隙 <strong>7</strong></th><th>时隙5</th><th>时隙5</th></tr></thead><tbody><tr><td><strong>阅读器</strong></td><td><strong>Group_Select</strong></td><td></td><td></td><td><strong>Read</strong></td><td></td><td><strong>Read</strong></td><td><strong>Read</strong></td><td></td><td><strong>Read</strong></td><td><strong>Read</strong></td></tr><tr><td><strong>标签1</strong></td><td></td><td><strong>0</strong></td><td><strong>0</strong></td><td><strong>0</strong></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td><strong>标签2</strong></td><td></td><td><strong>0</strong></td><td><strong>1</strong></td><td><strong>2</strong></td><td><strong>1</strong></td><td><strong>2</strong></td><td><strong>1</strong></td><td><strong>0</strong></td><td><strong>1</strong></td><td><strong>0</strong></td></tr><tr><td><strong>标签3</strong></td><td></td><td><strong>0</strong></td><td><strong>0</strong>  <strong>( 1 ? )</strong></td><td><strong>1</strong></td><td><strong>0</strong></td><td><strong>1</strong></td><td><strong>0</strong></td><td></td><td></td><td></td></tr><tr><td><strong>标签4</strong></td><td></td><td><strong>0</strong></td><td><strong>0</strong>  <strong>( 1 ? )</strong></td><td><strong>1</strong></td><td><strong>0</strong></td><td><strong>0</strong></td><td></td><td></td><td></td><td></td></tr><tr><td><strong>标签5</strong></td><td></td><td><strong>0</strong></td><td><strong>1</strong></td><td><strong>2</strong></td><td><strong>1</strong></td><td><strong>2</strong></td><td><strong>1</strong></td><td><strong>0</strong></td><td><strong>0</strong></td><td></td></tr><tr><td></td><td></td><td><strong>冲突</strong></td><td><strong>冲突</strong></td><td><strong>发送1</strong></td><td><strong>冲突</strong></td><td><strong>发送4</strong></td><td><strong>发送3</strong></td><td><strong>冲突</strong></td><td><strong>发送5</strong></td><td><strong>发送2</strong></td></tr></tbody></table><h3 id="防冲突算法的性能对比"><a href="#防冲突算法的性能对比" class="headerlink" title="防冲突算法的性能对比"></a><strong>防冲突算法的性能对比</strong></h3><p><strong>基于ALOHA的防冲突算法</strong></p><ul><li><strong>标签“饿死”</strong></li><li><strong>最坏情况，识别时延趋于+∞</strong></li><li><strong>低负载情况，识别时延小</strong></li><li><strong>结果可进行统计性分析</strong></li><li><strong>标签需要可写存储区</strong></li></ul><p><strong>基于确定性二进制（BSA、FBSA、查询二进制树）的防冲突算法</strong></p><ul><li><strong>标签在确定时间内可识别，不存在“饿死”</strong></li><li><strong>识别时延受标签ID分布及长度影响</strong></li><li><strong>标签不需要可写存储区</strong></li></ul><p><strong>基于随机二进制树的防冲突算法</strong></p><ul><li><strong>存在标签“饿死”</strong></li><li><strong>识别时延受标签ID分布及长度影响</strong></li><li><strong>标签需要可写存储区</strong></li></ul><h3 id="RFID分类及应用"><a href="#RFID分类及应用" class="headerlink" title="RFID分类及应用"></a><strong>RFID分类及应用</strong></h3><p><strong>无源RFID的有效识别距离通常较短，一般用于近距离的接触式识别。无源RFID主要工作在较低频段125KHz、13.56MKHz等，其典型应用包括：公交卡、二代身份证（高频频段，通讯协议</strong> <strong>ISO14443B）、校园卡、食堂餐卡等。</strong></p><p><strong>有源RFID的远距性、高效性，使得它在一些需要高性能、大范围的射频识别应用场合里必不可少。一个典型的有源RFID标签能在百米之外主动与射频识别阅读器建立联系，读取率可达1,700read&#x2F;sec。有源RFID主要工作在900MHz、2.45GHz、5.8GHz等较高频段，且具有可以同时识别多个标签的功能。其典型应用包括：高速公路电子不停车收费系统等。</strong></p><p><strong>半有源RFID，又称作低频激活触发技术。无源RFID自身不供电，但有效识别距离太短。有源RFID识别距离足够长，但需外接电源，体积较大。而半有源RFID就是为这一矛盾而妥协的产物。在通常情况下，半有源RFID产品处于休眠状态，仅对标签中保持数据的部分进行供电，因此耗电量较小，可维持较长时间。当标签进入射频识别阅读器识别范围后，阅读器先以125KHz低频信号在小范围内精确激活标签使之进入工作状态，再通过2.4GHz微波与其进行信息传递。也即是说，先利用低频信号精确定位，再利用高频信号快速传输数据。其通常应用场景为：在一个高频信号所能所覆盖的大范围中，在不同位置安置多个低频阅读器用于激活半有源RFID产品。这样既完成了定位，又实现了信息的采集与传递。</strong></p><h3 id="RFID的通信协议"><a href="#RFID的通信协议" class="headerlink" title="RFID的通信协议"></a><strong>RFID的通信协议</strong></h3><p><strong>RFID</strong> <strong>空中接口</strong></p><p><strong>规范阅读器与标签之间的信息交互，实现不同厂商设备之间的互联互通。</strong></p><table><thead><tr><th><strong>协议</strong></th><th><strong>内容及适用范围</strong></th></tr></thead><tbody><tr><td><strong>ISO&#x2F;IEC</strong> <strong>18000-1</strong></td><td><strong>参考结构和标准化的参数定义。规范协议中应共同遵守的阅读器与标签的通信参数表、知识产权基本规则等</strong></td></tr><tr><td><strong>ISO&#x2F;IEC</strong> <strong>18000-2</strong></td><td><strong>适用于</strong> <strong>125 – 134 KHz</strong></td></tr><tr><td><strong>ISO&#x2F;IEC</strong> <strong>18000-3</strong></td><td><strong>适用于</strong> <strong>13.56 MHz</strong></td></tr><tr><td><strong>ISO&#x2F;IEC</strong> <strong>18000-4</strong></td><td><strong>适用于</strong> <strong>2.45 GHz</strong></td></tr><tr><td><strong>ISO&#x2F;IEC</strong>  <strong>18000-6</strong></td><td><strong>适用于</strong> <strong>860 – 930 MHz</strong></td></tr><tr><td><strong>ISO&#x2F;IEC</strong> <strong>18000-7</strong></td><td><strong>适用于</strong>  <strong>433.92</strong>  <strong>MHz</strong></td></tr></tbody></table><p><strong>RFID</strong> <strong>数据标准</strong></p><ul><li><strong>主要规定数据的表示形式。</strong></li><li><strong>ISO&#x2F;IEC 15961</strong> <strong>规定阅读器与应用软件之间的接口，侧重于交换数据的标准方式，这样应用软件可以完成对标签数据的读取、写入、修改、删除等操作。</strong></li><li><strong>ISO&#x2F;IEC 15962</strong> <strong>规定数据的编码、压缩、逻辑内存映射格式，以及如何将标签中的数据转化为对应用软件有意义的形式。</strong></li></ul><h4 id="ISO-x2F-IEC-18000-6-协议"><a href="#ISO-x2F-IEC-18000-6-协议" class="headerlink" title="ISO&#x2F;IEC 18000-6 协议"></a><strong>ISO&#x2F;IEC 18000-6</strong> <strong>协议</strong></h4><p><strong>规定了阅读器与标签之间的物理接口、协议和命令，以及防冲突仲裁机制等</strong></p><ul><li><strong>物理层：</strong> <strong>RFID</strong> <strong>频率。数据编码方式、调制格式、数据传输速率等</strong></li><li><strong>标签标识层： 阅读器读写标签的各种指令</strong></li></ul><table><thead><tr><th><strong>参数</strong></th><th><strong>Type</strong> <strong>B</strong></th><th><strong>Type C</strong></th></tr></thead><tbody><tr><td><strong>调制方式</strong></td><td><strong>ASK</strong></td><td><strong>SSB-ASK, DSB-ASK, PR-ASK</strong></td></tr><tr><td><strong>前向链路编码</strong></td><td><strong>曼切斯特编码</strong></td><td><strong>PIE</strong> <strong>编码</strong></td></tr><tr><td><strong>返向链路编码</strong></td><td><strong>FM0</strong></td><td><strong>FM0</strong> <strong>或</strong> <strong>Miller</strong>  <strong>子载波</strong></td></tr><tr><td><strong>标签唯一标识号长度</strong></td><td><strong>64</strong> <strong>位</strong></td><td><strong>16 – 496</strong> <strong>位</strong></td></tr><tr><td><strong>数据速率</strong></td><td><strong>10</strong> <strong>kbps</strong> <strong>或</strong>  <strong>40 kbps</strong></td><td><strong>26.7 kbps – 128 kbps</strong></td></tr><tr><td><strong>标签容量</strong></td><td><strong>2048</strong> <strong>位</strong></td><td><strong>最大</strong> <strong>512</strong> <strong>位</strong></td></tr><tr><td><strong>防冲突算法</strong></td><td><strong>自适应二进制树（B树）</strong></td><td><strong>随机时隙反碰撞（Q算法）</strong></td></tr></tbody></table><h5 id="部分-ISO-x2F-IEC-18000-6B-命令表"><a href="#部分-ISO-x2F-IEC-18000-6B-命令表" class="headerlink" title="部分 ISO&#x2F;IEC 18000-6B 命令表"></a><strong>部分</strong> <strong>ISO&#x2F;IEC 18000-6B</strong> <strong>命令表</strong></h5><table><thead><tr><th><strong>命令码</strong></th><th><strong>类型</strong></th><th><strong>命令名称</strong></th><th><strong>备注</strong></th></tr></thead><tbody><tr><td><strong>00</strong></td><td><strong>强制</strong></td><td><strong>GROUP_SELECT_EQ</strong></td><td><strong>选择标签作为识别对象</strong></td></tr><tr><td><strong>08</strong></td><td><strong>强制</strong></td><td><strong>FAIL</strong></td><td><strong>失败命令</strong></td></tr><tr><td><strong>09</strong></td><td><strong>强制</strong></td><td><strong>SUCCESS</strong></td><td><strong>成功命令</strong></td></tr><tr><td><strong>0A</strong></td><td><strong>强制</strong></td><td><strong>INT</strong></td><td><strong>初始化</strong></td></tr><tr><td><strong>0C</strong></td><td><strong>强制</strong></td><td><strong>READ</strong></td><td><strong>从标签读数据</strong></td></tr><tr><td><strong>0D</strong></td><td><strong>可选</strong></td><td><strong>WRITE</strong></td><td><strong>向标签写数据</strong></td></tr><tr><td><strong>0F</strong></td><td><strong>可选</strong></td><td><strong>LOCK</strong></td><td></td></tr></tbody></table><h3 id="RFID-典型应用领域"><a href="#RFID-典型应用领域" class="headerlink" title="RFID 典型应用领域"></a><strong>RFID</strong> <strong>典型应用领域</strong></h3><p><strong>1、物流</strong></p><p><strong>物流仓储是RFID最有潜力的应用领域之一，可应用的过程包括：物流过程中的货物追踪、信息自动采集、仓储管理应用、港口应用、邮政包裹、快递等。</strong></p><p><strong>2、交通</strong></p><p><strong>出租车管理、公交车枢纽管理、铁路机车识别等。</strong></p><p><strong>3、身份识别</strong></p><p><strong>RFID技术由于具有快速读取与难伪造性，所以被广泛应用于个人的身份识别证件中。如电子护照、我国第二代身份证、学生证等其他各种电子证件。</strong></p><p><strong>4、防伪</strong></p><p><strong>RFID具有很难伪造的特性，但是如何应用于防伪还需要政府和企业的积极推广。可以应用的领域包括贵重物品（烟、酒、药品）的防伪和票证的防伪等。</strong></p><p><strong>5、资产管理</strong></p><p><strong>可应用于各类资产的管理，包括贵重物品、数量大相似性高的物品或危险品等。随着标签价格的降低，RFID几乎可以管理所有的物品。</strong></p><p><strong>6、食品</strong></p><p><strong>可应用于水果、蔬菜、生鲜、食品等管理。需要在标签的设计及应用模式上有所创新。</strong></p><h2 id="NFC-近场通讯"><a href="#NFC-近场通讯" class="headerlink" title="NFC 近场通讯"></a><strong>NFC</strong> <strong>近场通讯</strong></h2><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-2-RFID/image-20230924204155131.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="图"></p><p><strong>NFC</strong> <strong>（Near Field Communication）即近场无线通讯，是一种非接触式识别和互联技术，可以在移动设备、消费类电子产品、PC和智能控件工具间进行近距离无线通信。</strong></p><p><strong>NFC</strong> <strong>技术起源于</strong> <strong>RFID，但是与</strong> <strong>RFID</strong> <strong>相比有一定的区别</strong></p><p>–<strong>NFC</strong> <strong>将非接触读卡器、非接触卡和点对点功能整合进一块单芯片，而</strong> <strong>RFID</strong> <strong>必须由阅读器和标签组成</strong></p><p>–<strong>NFC</strong> <strong>技术则强调的是信息交互，而</strong> <strong>RFID</strong> <strong>只能实现信息的读取以及判定</strong></p><p><strong>NFC设备的功能定位</strong></p><p>–<strong>NFC</strong> <strong>设备内置</strong> <strong>NFC</strong> <strong>芯片，组成</strong> <strong>RFID</strong> <strong>模块的一部分，可以当作</strong> <strong>RFID</strong> <strong>无源标签使用进行支付费用；</strong></p><p>–<strong>也可以当作</strong> <strong>RFID</strong> <strong>读写器，用作数据交换与采集，还可以进行</strong> <strong>NFC</strong> <strong>设备之间的数据通信。</strong></p><h3 id="NFC-与-RFID-的区别"><a href="#NFC-与-RFID-的区别" class="headerlink" title="NFC 与 RFID 的区别"></a><strong>NFC</strong> <strong>与</strong> <strong>RFID</strong> <strong>的区别</strong></h3><ul><li><strong>工作频段</strong><ul><li><strong>NFC</strong> <strong>的工作频段为</strong> <strong>13.56MHz，而</strong> <strong>RFID</strong> <strong>有低频，高频（13.56MHz）及超高频。</strong></li></ul></li><li><strong>工作有效距离</strong><ul><li><strong>NFC</strong> <strong>的工作距离理论上为</strong> <strong>0</strong> <strong>~</strong> <strong>20 cm，但是在产品实现上，由于采用了特殊功率抑制技术，使其工作距离只有</strong> <strong>0</strong> <strong>~</strong> <strong>10 cm</strong> <strong>，业务更具有安全性。</strong></li><li><strong>相对于</strong> <strong>RFID</strong> <strong>来说</strong> <strong>NFC</strong> <strong>具有距离近、带宽高、能耗低等特点。</strong></li><li><strong>RFID</strong> <strong>具有不同的频率，其工作距离在几厘米到几十米不等。</strong></li></ul></li><li><strong>工作模式</strong><ul><li><strong>NFC</strong> <strong>同时支持读写模式和卡模式；支持点对点</strong> <strong>P2P</strong> <strong>模式。</strong></li><li><strong>RFID</strong> <strong>的读卡器和非接触卡是独立的两个实体，模式不能切换&#x2F;并存，不支持</strong> <strong>P2P。</strong></li></ul></li><li><strong>兼容性</strong><ul><li><strong>NFC设备都工作于13.56MHz，并与现有非接触智能卡技术兼容，NFC兼容性更好 。</strong></li><li><strong>RFID</strong> <strong>标准较多，统一较为复杂。</strong></li></ul></li><li><strong>应用领域</strong><ul><li><strong>RFID</strong> <strong>更多的应用在生产，物流，跟踪和资产管理上，更擅长在长距离识别、批量识别</strong></li><li><strong>NFC</strong> <strong>工作在门禁，公交卡，手机支付等领域，更多应用于消费类电子设备相互通讯。</strong></li></ul></li><li><strong>标准协议</strong><ul><li><strong>NFC</strong> <strong>的底层通讯协议兼容高频</strong> <strong>RFID</strong> <strong>的底层通信标准，即兼容</strong> <strong>ISO14443&#x2F;ISO15693</strong> <strong>。</strong></li><li><strong>NFC</strong> <strong>技术还定义了比较完整的上层协议，如</strong> <strong>LLCP，NDEF</strong> <strong>和</strong> <strong>RTD</strong> <strong>等。</strong></li></ul></li></ul><h4 id="RFID、NFC-相关标准"><a href="#RFID、NFC-相关标准" class="headerlink" title="RFID、NFC 相关标准"></a><strong>RFID、NFC</strong> <strong>相关标准</strong></h4><p>1.<strong>ISO&#x2F;IEC</strong></p><p><strong>RFID</strong> <strong>技术符合</strong> <strong>ISO14443、ISO15693</strong> <strong>标准</strong></p><ul><li><strong>ISO14443</strong> <strong>和</strong> <strong>ISO 15693</strong> <strong>二者皆以</strong> <strong>13.56MHz</strong> <strong>交变信号为载波频率；</strong></li><li><strong>ISO15693</strong> <strong>读写距离较远，与应用系统的天线形状和发射功率有关；</strong></li><li><strong>ISO14443</strong> <strong>读写距离稍近，应用较广泛，第二代电子身份证采用</strong> <strong>ISO14443 TYPE B</strong> <strong>；</strong></li><li><strong>传输速率为</strong> <strong>106kbits&#x2F;s，它们的不同主要在于载波的调制深度及位的编码方式。</strong></li></ul><p><strong>NFC</strong> <strong>技术符合</strong> <strong>ISO18092、ISO21481</strong> <strong>标准，兼容</strong> <strong>ISO14443、ISO15693</strong> <strong>等射频标准</strong></p><ul><li><strong>ISO18092</strong> <strong>标准定义了13.56MHz</strong> <strong>的</strong> <strong>NFC</strong> <strong>相关协议内容；</strong></li><li><strong>ISO18092</strong> <strong>后来增加了对</strong> <strong>ISO15693</strong> <strong>的兼容，形成新的</strong> <strong>NFC</strong> <strong>标准 即</strong> <strong>ISO21481；</strong></li><li><strong>NFC</strong> <strong>的传输速率有</strong> <strong>106kbps、212kbps、424kbps。</strong></li></ul><p><strong>ISO7816</strong> <strong>是接触式智能卡的标准。</strong></p><p>2.<strong>ECMA340、ECMA352</strong></p><ul><li><strong>ECMA（European Computer Manufacturers Association）是欧洲的标准组织</strong></li><li><strong>ECMA340</strong> <strong>是</strong> <strong>ISO18092</strong> <strong>的前身，它被</strong> <strong>ISO</strong> <strong>接收后成为了</strong> <strong>ISO18092；</strong></li><li><strong>ECMA352</strong> <strong>是</strong> <strong>ISO21481</strong> <strong>的前身。</strong></li></ul><p>3.<strong>NFC Forum</strong></p><ul><li><strong>行业标准，将</strong> <strong>ISO14443、ISO18092</strong> <strong>及</strong> <strong>JIS X6319-4（Felica）融合用于支持</strong> <strong>NFC-A&#x2F;B&#x2F;F</strong> <strong>。</strong></li><li><strong>其中</strong> <strong>NFC</strong> <strong>的模式有读写模式、卡模拟模式以及点对点模式</strong></li></ul><h4 id="NFC-技术架构"><a href="#NFC-技术架构" class="headerlink" title="NFC 技术架构"></a><strong>NFC</strong> <strong>技术架构</strong></h4><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-2-RFID/image-20230924204451446.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="架构"></p><h4 id="NFC-各种标签类型的属性"><a href="#NFC-各种标签类型的属性" class="headerlink" title="NFC 各种标签类型的属性"></a><strong>NFC</strong> <strong>各种标签类型的属性</strong></h4><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-2-RFID/image-20230924204507055.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="属性"></p>]]></content>
    
    
    <categories>
      
      <category>学习资料</category>
      
    </categories>
    
    
    <tags>
      
      <tag>课件笔记</tag>
      
      <tag>物联网技术与应用</tag>
      
      <tag>IoT</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>IoT__第2章__感知识别__2.1_自动识别技术</title>
    <link href="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-1-%E8%87%AA%E5%8A%A8%E8%AF%86%E5%88%AB%E6%8A%80%E6%9C%AF/"/>
    <url>/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-1-%E8%87%AA%E5%8A%A8%E8%AF%86%E5%88%AB%E6%8A%80%E6%9C%AF/</url>
    
    <content type="html"><![CDATA[<h1 id="第二章-物联网感知识别"><a href="#第二章-物联网感知识别" class="headerlink" title="第二章 物联网感知识别"></a><strong>第二章 物联网感知识别</strong></h1><h2 id="2-1-自动识别"><a href="#2-1-自动识别" class="headerlink" title="2.1  自动识别"></a><strong>2.1</strong>  <strong>自动识别</strong></h2><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-1-%E8%87%AA%E5%8A%A8%E8%AF%86%E5%88%AB%E6%8A%80%E6%9C%AF/image-20230924003613516.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="auto"></p><h3 id="2-1-1-自动识别技术概述"><a href="#2-1-1-自动识别技术概述" class="headerlink" title="2.1.1 自动识别技术概述"></a><strong>2.1.1</strong> <strong>自动识别技术概述</strong></h3><p><strong>识别：对有关事务进行归类和定性</strong></p><p><strong>自动识别技术是一种机器自动数据采集技术</strong></p><ul><li><strong>应用一定的识别装置，自动地获取被识别物品的相关信息，并传递给后台进行数据处理</strong></li><li><strong>自动识别是用机器来实现类似人对各种事物或现象的检测与分析，并做出辨识的过程</strong></li><li><strong>需要：经验、标准、规则</strong></li></ul><p><strong>自动识别技术标准组织</strong></p><ul><li><strong>国际自动识别制造商协会</strong> <strong>Association for Automatic Identification and Mobility,  AIM Global</strong></li><li><strong>中国自动识别技术协会</strong>  <strong>AIM China</strong></li></ul><h4 id="自动识别技术的分类"><a href="#自动识别技术的分类" class="headerlink" title="自动识别技术的分类"></a>自动识别技术的分类</h4><p>•<strong>数据采集技术</strong></p><ul><li><strong>特点：需要特定的载体存放信息</strong></li><li><strong>光存储识别 （条码识别、二维码识别、答题卡识别）</strong></li><li><strong>磁存储识别（磁条、非接触磁卡、磁光存储识别）</strong></li><li><strong>电存储识别（射频识别、IC卡识别）</strong></li></ul><p>•<strong>特征提取技术</strong></p><ul><li><strong>特点：根据事物本身的行为特征来判决信息</strong></li><li><strong>静态特征 （指纹、虹膜、面部、光学字符识别</strong> <strong>OCR</strong> <strong>）</strong></li><li><strong>动态特征 （语音、步态、表情）</strong></li><li><strong>属性特征 （化学、物理、生物、联合感觉）</strong></li></ul><h4 id="自动识别系统的构成"><a href="#自动识别系统的构成" class="headerlink" title="自动识别系统的构成"></a>自动识别系统的构成</h4><p>一般自动识别系统模型:</p><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-1-%E8%87%AA%E5%8A%A8%E8%AF%86%E5%88%AB%E6%8A%80%E6%9C%AF/image-20230924003806842.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="normal"></p><p>基于特征提取的自动识别系统模型</p><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-1-%E8%87%AA%E5%8A%A8%E8%AF%86%E5%88%AB%E6%8A%80%E6%9C%AF/image-20230924005709203.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="特征"></p><h3 id="2-1-2-条形码识别"><a href="#2-1-2-条形码识别" class="headerlink" title="2.1.2 条形码识别"></a><strong>2.1.2</strong> <strong>条形码识别</strong></h3><p><strong>最“古老”的自动识别技术</strong></p><p><strong>条形码是由一组规则排列的条、空以及对应的字符组成的标记。普通的条形码在使用过程中仅作为识别信息。</strong></p><p><strong>一个完整的条码的组成次序依次为：</strong></p><p><strong>左侧空白区（静区）、起始符、数据符、（中间分割符，主要用于EAN码）、（校验符）、终止符、右侧空白区（静区）</strong></p><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-1-%E8%87%AA%E5%8A%A8%E8%AF%86%E5%88%AB%E6%8A%80%E6%9C%AF/image-20230924005830237.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="条形码"></p><h4 id="条形码的分类"><a href="#条形码的分类" class="headerlink" title="条形码的分类"></a><strong>条形码的分类</strong></h4><p>按照长度： 定长、非定长条形码</p><p>依据排列方式： 连续型、非连续型条形码</p><p>按照扫描方式： 双向、单向条形码</p><p>按照单元模块方式： 宽窄调节码、模块组合码</p><p>一维条形码（条形码）、二维条形码（二维码）</p><h4 id="条形码：基本概念"><a href="#条形码：基本概念" class="headerlink" title="条形码：基本概念"></a><strong>条形码：基本概念</strong></h4><ul><li><strong>模块：构成条码的基本单位是模块，模块是指条码中最窄的条或空，模块的宽度通常以</strong> <strong>mm</strong> <strong>或</strong> <strong>mil（千分之一英寸）为单位。</strong></li><li><strong>单元：构成条码的一个条或空称为一个单元，一个单元包含的模块数是由编码方式决定的，有些码制中，如</strong> <strong>EAN</strong> <strong>码，所有单元由一个或多个模块组成（模块组合法）；而另一些码制，如</strong> <strong>39</strong> <strong>码中，所有单元只有两种宽度，即宽单元和窄单元，其中的窄单元即为一个模块（宽度调节法）。</strong> </li><li><strong>密度：单位长度的条码所表示的字符个数。模块尺寸越小，密度越大，所以密度值通常以模块尺寸的值来表示（如</strong> <strong>5 mil）。通常</strong> <strong>7.5 mil</strong> <strong>以下的条码称为高密度条码，15 mil</strong> <strong>以上的条码称为低密度条码。</strong></li><li><strong>宽窄比：对于只有两种宽度单元的码制，宽单元与窄单元的比值称为宽窄比，一般为2-3左右（常用的有2：1，3：1）。宽窄比较大时，阅读设备更容易分辨宽单元和窄单元，因此比较容易阅读。</strong></li></ul><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-1-%E8%87%AA%E5%8A%A8%E8%AF%86%E5%88%AB%E6%8A%80%E6%9C%AF/image-20230924005959213.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="例子"></p><ul><li><strong>对比度（PCS）：条码符号的光学指标，PCS值越大则条码的光学特性越好。</strong><ul><li><strong>PCS＝(RL - RD) &#x2F; RL</strong> <strong>× 100%</strong> <strong>（RL:条形码反射率，RD:空气反射率）</strong></li></ul></li><li><strong>条码长度：从条码起始符前缘到终止符后缘的长度。</strong></li><li><strong>条码密度：单位长度的条码所表示的字符个数。</strong></li><li><strong>双向条码：条码的两端都可以作为扫描起点的。</strong></li><li><strong>中间分隔符：在条码符号中，位于两个相邻的条码符号之间且不代表任何信息的空。</strong></li><li><strong>连续性条码：在条码字符中，两个相邻的条码字符之间没有中间分隔符的条码。</strong></li><li><strong>非连续性条码：在条码字符中，两个相邻的条码字符之间存在中间分隔符的条码。</strong></li></ul><h4 id="条形码的编码方法"><a href="#条形码的编码方法" class="headerlink" title="条形码的编码方法"></a><strong>条形码的编码方法</strong></h4><p><strong>宽度调节法</strong></p><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-1-%E8%87%AA%E5%8A%A8%E8%AF%86%E5%88%AB%E6%8A%80%E6%9C%AF/image-20230924011055121.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="width"></p><p>条形码中条与空的宽窄设置不同，用宽单元表示二进制的“1”，而用窄单元表示二进制的“0”，宽窄单元之比控制在2～3之间。印刷精度要求低。</p><p><strong>模块组合法 &#x2F; 色度调节法</strong></p><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-1-%E8%87%AA%E5%8A%A8%E8%AF%86%E5%88%AB%E6%8A%80%E6%9C%AF/image-20230924011119214.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="c"></p><p>条形码符号中，条与空是由标准宽度的模块组成的。一个标准宽度的条模块表示二进制的“1”，而一个标准宽度的空模块表示二进制的“0”。印刷精度要求高。</p><h5 id="EAN-13-条形码-（模块组合法、非连续）"><a href="#EAN-13-条形码-（模块组合法、非连续）" class="headerlink" title="EAN-13 条形码  （模块组合法、非连续）"></a><strong>EAN-13</strong> <strong>条形码</strong>  <strong>（模块组合法、非连续）</strong></h5><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-1-%E8%87%AA%E5%8A%A8%E8%AF%86%E5%88%AB%E6%8A%80%E6%9C%AF/image-20230924011149094.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="example"></p><p>起始部分: 由11条线组成，从左到右依次为8条白线、1条黑线、1条白线、1条黑线</p><p>第一数据部分: 由42条线组成，按照一定算法形成，包含了左侧数据符（d1～d6）的信息</p><p>中间部分: 由5条线组成，从左到右依次为1条白线、1条黑线、1条白线、1条黑线、1条白线</p><p>第二数据部分: 由42条线组成，和第一数据部分一样由一定算法形成，包含右侧数据符（d7～d12）数字的信息</p><p>结尾部分: 由11条线组成，从左至右分别是1条黑线、1条白线、1条黑线、8条白线</p><h5 id="25码-（宽度调节法、连续）"><a href="#25码-（宽度调节法、连续）" class="headerlink" title="25码 （宽度调节法、连续）"></a>25码 （宽度调节法、连续）</h5><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-1-%E8%87%AA%E5%8A%A8%E8%AF%86%E5%88%AB%E6%8A%80%E6%9C%AF/image-20230924011221938.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="25"></p><h5 id="39码-（宽度调节法、连续）"><a href="#39码-（宽度调节法、连续）" class="headerlink" title="39码 （宽度调节法、连续）"></a>39码 （宽度调节法、连续）</h5><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-1-%E8%87%AA%E5%8A%A8%E8%AF%86%E5%88%AB%E6%8A%80%E6%9C%AF/image-20230924011233551.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="39"></p><h5 id="UPC-条形码"><a href="#UPC-条形码" class="headerlink" title="UPC 条形码"></a><strong>UPC</strong> <strong>条形码</strong></h5><p>Universal Product Code</p><p>UPC-A 码 </p><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-1-%E8%87%AA%E5%8A%A8%E8%AF%86%E5%88%AB%E6%8A%80%E6%9C%AF/image-20230924011259843.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="UPC-A"></p><p>UPC-E 码</p><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-1-%E8%87%AA%E5%8A%A8%E8%AF%86%E5%88%AB%E6%8A%80%E6%9C%AF/image-20230924011313444.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="UPC-E"></p><h5 id="ISBN-x2F-ISSN"><a href="#ISBN-x2F-ISSN" class="headerlink" title="ISBN &#x2F; ISSN"></a><strong>ISBN &#x2F; ISSN</strong></h5><p>国际标准书号  International Standard Book Number</p><p>国际标准连续出版物号 International Standard Serial Number</p><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-1-%E8%87%AA%E5%8A%A8%E8%AF%86%E5%88%AB%E6%8A%80%E6%9C%AF/image-20230924011347429.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="ex"></p><p><strong>ISBN</strong> <strong>号包含的信息</strong>:</p><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-1-%E8%87%AA%E5%8A%A8%E8%AF%86%E5%88%AB%E6%8A%80%E6%9C%AF/image-20230924012525848.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="实例"></p><p>978 表示用于 ISBN 国家 &#x2F; 语言  出版商   图书编号   检查码</p><h5 id="EAN（欧洲商品编号）条形码"><a href="#EAN（欧洲商品编号）条形码" class="headerlink" title="EAN（欧洲商品编号）条形码"></a><strong>EAN（欧洲商品编号）条形码</strong></h5><p>UPC超集</p><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-1-%E8%87%AA%E5%8A%A8%E8%AF%86%E5%88%AB%E6%8A%80%E6%9C%AF/image-20230924012644704.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="EAN-13 码"></p><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-1-%E8%87%AA%E5%8A%A8%E8%AF%86%E5%88%AB%E6%8A%80%E6%9C%AF/image-20230924012653021.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="EAN-8 码"></p><p>UCC&#x2F;EAN-128码（连续型、非定长）</p><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-1-%E8%87%AA%E5%8A%A8%E8%AF%86%E5%88%AB%E6%8A%80%E6%9C%AF/image-20230924012706785.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="long"></p><h4 id="条形码阅读器工作原理：-扫描-译码"><a href="#条形码阅读器工作原理：-扫描-译码" class="headerlink" title="条形码阅读器工作原理： 扫描 + 译码"></a><strong>条形码阅读器工作原理：</strong> <strong>扫描</strong> <strong>+</strong> <strong>译码</strong></h4><p><strong>激光扫描仪通过一个激光二极管发出一束光线，照射到一个旋转的棱镜或来回摆动的镜子上，反射后的光线穿过阅读窗照射到条码表面，光线经过条或空的反射后返回阅读器，由一个镜子进行采集、聚焦，通过光电转换器转换成电信号，该信号将通过扫描期或终端上的译码软件进行译码。</strong></p><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-1-%E8%87%AA%E5%8A%A8%E8%AF%86%E5%88%AB%E6%8A%80%E6%9C%AF/image-20230924012815063.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="过程"></p><h5 id="条形码阅读器产品和应用"><a href="#条形码阅读器产品和应用" class="headerlink" title="条形码阅读器产品和应用"></a><strong>条形码阅读器产品和应用</strong></h5><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-1-%E8%87%AA%E5%8A%A8%E8%AF%86%E5%88%AB%E6%8A%80%E6%9C%AF/image-20230924012845779.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="应用"></p><h4 id="典型条形码制比较"><a href="#典型条形码制比较" class="headerlink" title="典型条形码制比较"></a><strong>典型条形码制比较</strong></h4><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-1-%E8%87%AA%E5%8A%A8%E8%AF%86%E5%88%AB%E6%8A%80%E6%9C%AF/image-20230924013022584.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="table"></p><h3 id="2-1-3-二维码"><a href="#2-1-3-二维码" class="headerlink" title="2.1.3 二维码"></a><strong>2.1.3</strong> <strong>二维码</strong></h3><ul><li><strong>二维码利用某种特定的几何图形按一定规律在平面（二维方向上）分布的黑白相间的图形记录数据符号信息；</strong></li><li><strong>在代码编制上，使用若干个与</strong> <strong>0、1</strong> <strong>二进制相对应的几何形体来表示文字数值信息，通过图象输入设备或光电扫描设备自动识读以实现信息自动处理。</strong></li><li><strong>二维码具有条码技术的一些共性：</strong><ul><li><strong>每种码制有其特定的字符集</strong></li><li><strong>每个字符占有一定的宽度</strong></li><li><strong>具有一定的校验功能等</strong></li></ul></li><li><strong>同时还具有对不同行的信息自动识别功能、以及处理图形旋转变化等特点。</strong></li></ul><h4 id="二维码符号"><a href="#二维码符号" class="headerlink" title="二维码符号"></a><strong>二维码符号</strong></h4><p>•<strong>目前，世界上应用最多的二维码符号有Aztec Code、PDF147、Data Matrix、QR Code、Code16K</strong> <strong>等。</strong></p><p><strong>国际自动识别制造商协会（AIM）</strong></p><p><strong>美国标准化协会（ANSI）</strong></p><p><strong>ISO&#x2F;IEC</strong></p><p><strong>中国物品编码中心</strong></p><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-1-%E8%87%AA%E5%8A%A8%E8%AF%86%E5%88%AB%E6%8A%80%E6%9C%AF/image-20230924013203695.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="aztec"></p><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-1-%E8%87%AA%E5%8A%A8%E8%AF%86%E5%88%AB%E6%8A%80%E6%9C%AF/image-20230924013211603.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="pdf147"></p><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-1-%E8%87%AA%E5%8A%A8%E8%AF%86%E5%88%AB%E6%8A%80%E6%9C%AF/image-20230924013219950.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="data matrix"></p><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-1-%E8%87%AA%E5%8A%A8%E8%AF%86%E5%88%AB%E6%8A%80%E6%9C%AF/image-20230924013228419.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="code16k"></p><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-1-%E8%87%AA%E5%8A%A8%E8%AF%86%E5%88%AB%E6%8A%80%E6%9C%AF/image-20230924013235410.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="qrcode"></p><h4 id="二维码的分类"><a href="#二维码的分类" class="headerlink" title="二维码的分类"></a><strong>二维码的分类</strong></h4><p>§<strong>行排式</strong></p><ul><li><strong>又称堆积式或层叠式二维码，是在一维条形码的基础上按需要将其堆积成多行而成</strong></li><li><strong>PDF417、49码、Code 16K</strong> <strong>条码</strong></li></ul><p>§<strong>矩阵式</strong></p><ul><li><strong>用点阵表示二进制</strong> <strong>0&#x2F;1</strong> <strong>的序列</strong></li><li><strong>Code One、QR码、Data Matrix、Vericode、田字码、汉信码、龙贝码</strong></li></ul><p>§<strong>邮政码</strong></p><ul><li><strong>通过不同高度的条进行编码，主要用于邮政编码</strong></li><li><strong>Postnet、BPO 4-State</strong></li></ul><p>§<strong>彩码</strong></p><ul><li><strong>在传统二维码的基础上添加色彩元素而形成，也称为三维码</strong></li></ul><p>§<strong>复合码</strong></p><ul><li><strong>各种条码类型的组合</strong></li><li><strong>EAN.UCC：一维码对主要标识、二维码对附加数据如批号、有效期等编码</strong></li></ul><h5 id="PDF417码：行排式二维码-Portable-Data-File"><a href="#PDF417码：行排式二维码-Portable-Data-File" class="headerlink" title="PDF417码：行排式二维码 Portable Data File"></a><strong>PDF417码：行排式二维码</strong> <strong>Portable Data</strong> <strong>File</strong></h5><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-1-%E8%87%AA%E5%8A%A8%E8%AF%86%E5%88%AB%E6%8A%80%E6%9C%AF/image-20230924013350837.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="pdf417"></p><p>PDF417条形码中每个数据字符包括4个条和4个空，每个条或空由1～6个模块组成，一个数据字符中，4个条和4个空的总模块数为17，故名PDF417</p><h5 id="QR-码：矩阵式二维码"><a href="#QR-码：矩阵式二维码" class="headerlink" title="QR 码：矩阵式二维码"></a><strong>QR</strong> <strong>码：矩阵式二维码</strong></h5><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-1-%E8%87%AA%E5%8A%A8%E8%AF%86%E5%88%AB%E6%8A%80%E6%9C%AF/image-20230924013703762.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="ex"></p><ul><li><strong>快速响应矩阵（Quick Response Code, QR）</strong></li><li><strong>国标：GB&#x2F;T 18284 - 2000</strong></li><li><strong>使用最为广泛的二维码</strong></li><li><strong>超高速识读、全方位识读、高效表示汉字</strong></li></ul><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-1-%E8%87%AA%E5%8A%A8%E8%AF%86%E5%88%AB%E6%8A%80%E6%9C%AF/image-20230924013421175.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="ex"></p><h5 id="QR-码符号版本"><a href="#QR-码符号版本" class="headerlink" title="QR 码符号版本"></a><strong>QR</strong> <strong>码符号版本</strong></h5><p><strong>QR</strong> <strong>码符号共有40种版本</strong></p><ul><li><strong>版本1：21 x 21</strong></li><li><strong>版本2：25 x 25</strong></li><li><strong>每个版本增加4个模块</strong></li><li><strong>版本40：177 x</strong> <strong>177</strong></li></ul><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-1-%E8%87%AA%E5%8A%A8%E8%AF%86%E5%88%AB%E6%8A%80%E6%9C%AF/image-20230924013738095.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="QR"></p><h5 id="汉信码：矩阵式二维码"><a href="#汉信码：矩阵式二维码" class="headerlink" title="汉信码：矩阵式二维码"></a><strong>汉信码：矩阵式二维码</strong></h5><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-1-%E8%87%AA%E5%8A%A8%E8%AF%86%E5%88%AB%E6%8A%80%E6%9C%AF/image-20230924124831416.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="汉信"></p><h5 id="彩码"><a href="#彩码" class="headerlink" title="彩码"></a><strong>彩码</strong></h5><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-1-%E8%87%AA%E5%8A%A8%E8%AF%86%E5%88%AB%E6%8A%80%E6%9C%AF/image-20230924192715046.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="color"></p><h4 id="二维码的生成过程"><a href="#二维码的生成过程" class="headerlink" title="二维码的生成过程"></a><strong>二维码的生成过程</strong></h4><ul><li><strong>数据分析</strong></li><li><strong>数据编码</strong></li><li><strong>纠错</strong></li><li><strong>构造最终信息</strong></li><li><strong>在矩阵中布置模块</strong></li><li><strong>掩模</strong></li><li><strong>添加格式信息和版本信息</strong></li></ul><h4 id="一维条形码与二维码的比较"><a href="#一维条形码与二维码的比较" class="headerlink" title="一维条形码与二维码的比较"></a><strong>一维条形码与二维码的比较</strong></h4><ul><li><strong>一维条形码特点：</strong><ul><li><strong>可直接显示内容为英文、数字、简单符号；</strong></li><li><strong>贮存数据不多，主要依靠计算机中的关联数据库；</strong></li><li><strong>保密性能不高；</strong></li><li><strong>损污后可读性差。</strong></li></ul></li><li><strong>二维码特点：</strong><ul><li><strong>可直接显示英文、中文、数字、符号、图形；</strong></li><li><strong>贮存数据量大，可存放1K字符，可用扫描仪直接读取内容，无需另接数据库；</strong></li><li><strong>保密性高（可加密）；</strong></li><li><strong>安全级别最高时，损污50%仍可读取完整信息。</strong></li></ul></li></ul><h4 id="QR-码结构图"><a href="#QR-码结构图" class="headerlink" title="QR 码结构图"></a><strong>QR 码结构图</strong></h4><p><strong>QR 码由编码区域和包括寻像图形、分隔符、定位图形和校正图形在内的功能图形组成。</strong></p><p><strong>QR 码结构图如下图所示：</strong> </p><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-1-%E8%87%AA%E5%8A%A8%E8%AF%86%E5%88%AB%E6%8A%80%E6%9C%AF/image-20230924192853645.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="st"></p><blockquote><p><strong>二维码的特点：</strong></p><ul><li><strong>存储大容量信息</strong></li><li><strong>在小空间内打印</strong></li><li><strong>有效表现各种字母</strong></li><li><strong>对变脏和破损的纠错能力强</strong></li><li><strong>从任意方向读取</strong></li><li><strong>可以数据分割与合并</strong></li></ul></blockquote><h4 id="二维码识别原理"><a href="#二维码识别原理" class="headerlink" title="二维码识别原理"></a><strong>二维码识别原理</strong></h4><p><strong>定位校正图形：</strong></p><p><strong>根据 3 个位置探测图像估计右下角校正符，共同定位该图形。</strong></p><p><strong>透视变换：</strong></p><p><strong>根据 3 个定位中心点和校正符中心点，和理想 4 个点的坐标，获取单应性矩阵，再通过透视变换获取标准正方形图像。</strong></p><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-1-%E8%87%AA%E5%8A%A8%E8%AF%86%E5%88%AB%E6%8A%80%E6%9C%AF/image-20230924192956842.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="定位"></p><p><strong>译码和纠错</strong>：<strong>译码是对二维码版本信息、格式信息、数据和纠错码进行解码和对比。将数据区转为0和1的比特流，并用Reed-Solomon纠错算法对比特流校验和纠错。判断QR码编码格式后译码，这样得到了二维码包含的数据。</strong></p><p><strong>常规的QR码识别过程容易受到环境影响而难以识别，往往需要一些预处理改善图像质量和识别环境。</strong></p><p><strong>图像灰度化</strong></p><p><strong>去噪</strong></p><p><strong>畸变矫正</strong></p><p><strong>二值化</strong></p><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-1-%E8%87%AA%E5%8A%A8%E8%AF%86%E5%88%AB%E6%8A%80%E6%9C%AF/image-20230924193024754.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="工业"></p><h4 id="常见的工业领域应用问题"><a href="#常见的工业领域应用问题" class="headerlink" title="常见的工业领域应用问题"></a><strong>常见的工业领域应用问题</strong></h4><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-1-%E8%87%AA%E5%8A%A8%E8%AF%86%E5%88%AB%E6%8A%80%E6%9C%AF/image-20230924193044564.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="平衡"></p><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-1-%E8%87%AA%E5%8A%A8%E8%AF%86%E5%88%AB%E6%8A%80%E6%9C%AF/image-20230924193052570.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="问题"></p><h4 id="二维码检测定位技术（例）"><a href="#二维码检测定位技术（例）" class="headerlink" title="二维码检测定位技术（例）"></a><strong>二维码检测定位技术（例）</strong></h4><p><strong>更高的检测精度、复杂环境应用、防止图像失真、具有鲁棒性</strong></p><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-1-%E8%87%AA%E5%8A%A8%E8%AF%86%E5%88%AB%E6%8A%80%E6%9C%AF/image-20230924193120160.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="photo"></p><h3 id="2-1-3-IC卡识别"><a href="#2-1-3-IC卡识别" class="headerlink" title="2.1.3  IC卡识别"></a><strong>2.1.3  IC卡识别</strong></h3><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-1-%E8%87%AA%E5%8A%A8%E8%AF%86%E5%88%AB%E6%8A%80%E6%9C%AF/image-20230924193147038.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="IC"></p><h4 id="CPU卡：-按与外界数据交换界面"><a href="#CPU卡：-按与外界数据交换界面" class="headerlink" title="CPU卡： 按与外界数据交换界面"></a><strong>CPU卡： 按与外界数据交换界面</strong></h4><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-1-%E8%87%AA%E5%8A%A8%E8%AF%86%E5%88%AB%E6%8A%80%E6%9C%AF/image-20230924193259076.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="分类"></p><p>接触式IC卡的多个金属触点为卡芯片与外界的信息传输媒介，成本低，实施相对简便；非接触式IC卡则不用触点，而是借助无线收发传送信息，因此在前者难以胜任的交通运输等诸多场合有较多应用。</p><h3 id="2-1-4-光学字符识别"><a href="#2-1-4-光学字符识别" class="headerlink" title="2.1.4  光学字符识别"></a><strong>2.1.4</strong>  <strong>光学字符识别</strong></h3><p>光学字符识别（optical character recognition，OCR）： 采用电子设备（如扫描仪或数码相机）检查纸上打印的字符，通过检测暗亮的模式确定其形状，然后用字符识别方法将形状翻译成计算机文字的过程，即对文本资料进行扫描，然后对图像文件进行分析处理，获取文字及版面信息的过程。</p><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-1-%E8%87%AA%E5%8A%A8%E8%AF%86%E5%88%AB%E6%8A%80%E6%9C%AF/image-20230924193340804.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="光学字符识别流程图"></p><h3 id="2-1-5-语音识别"><a href="#2-1-5-语音识别" class="headerlink" title="2.1.5 语音识别"></a><strong>2.1.5</strong> <strong>语音识别</strong></h3><p>语音识别：采用数字信号处理技术自动提取及决定语言信号中最基本有意义的信息，同时也包括利用音律特征等个人特征识别说话人。</p><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-1-%E8%87%AA%E5%8A%A8%E8%AF%86%E5%88%AB%E6%8A%80%E6%9C%AF/image-20230924193403444.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="voice"></p><h3 id="2-1-6-生物特征识别"><a href="#2-1-6-生物特征识别" class="headerlink" title="2.1.6 生物特征识别"></a><strong>2.1.6</strong> <strong>生物特征识别</strong></h3><p>概念：</p><p> 通过计算机与光学、声学、生物传感器和生物统计学原理等高科技手段密切结合，利用人体固有的生理特性（如指纹、指静脉、人脸、虹膜等）和行为特征（如笔迹、声音、步态等）来进行个人身份的鉴定</p><p>分类：</p><ul><li>指纹识别</li><li>掌纹识别</li><li>静脉识别</li><li>虹膜识别</li><li>人脸识别</li><li>声音识别</li></ul><h4 id="指纹识别"><a href="#指纹识别" class="headerlink" title="指纹识别"></a><strong>指纹识别</strong></h4><p>从实用角度看，指纹识别是优于其他生物识别技术的身份鉴别方法。因为指纹具有各不相同、终生基本不变的特点，且目前的指纹识别系统已达到操作方便、准确可靠、价格适中的阶段，正逐步应用于民用市场。</p><p>指纹识别的处理流程：</p><p>–通过特殊的光电转换设备和计算机图像处理技术，对活体指纹进行采集、分析和比对，可以迅速、准确地鉴别出个人身份。系统一般主要包括对指纹图像采集、指纹图像处理、特征提取、特征值的比对与匹配等过程。</p><h5 id="指纹的总体特征"><a href="#指纹的总体特征" class="headerlink" title="指纹的总体特征"></a><strong>指纹的总体特征</strong></h5><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-1-%E8%87%AA%E5%8A%A8%E8%AF%86%E5%88%AB%E6%8A%80%E6%9C%AF/image-20230924193526268.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="特征"></p><h4 id="静脉识别"><a href="#静脉识别" class="headerlink" title="静脉识别"></a><strong>静脉识别</strong></h4><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-1-%E8%87%AA%E5%8A%A8%E8%AF%86%E5%88%AB%E6%8A%80%E6%9C%AF/image-20230924193557136.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="静脉"></p><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-1-%E8%87%AA%E5%8A%A8%E8%AF%86%E5%88%AB%E6%8A%80%E6%9C%AF/image-20230924193612708.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="静脉"></p><h4 id="虹膜识别"><a href="#虹膜识别" class="headerlink" title="虹膜识别"></a><strong>虹膜识别</strong></h4><p>•<strong>虹膜识别是当前应用最方便精确的生物识别技术，虹膜的高度独特性和稳定性是其用于身份鉴别的基础。</strong></p><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-1-%E8%87%AA%E5%8A%A8%E8%AF%86%E5%88%AB%E6%8A%80%E6%9C%AF/image-20230924193637586.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="虹膜"></p><h5 id="虹膜识别的高识别率"><a href="#虹膜识别的高识别率" class="headerlink" title="虹膜识别的高识别率"></a><strong>虹膜识别的高识别率</strong></h5><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-1-%E8%87%AA%E5%8A%A8%E8%AF%86%E5%88%AB%E6%8A%80%E6%9C%AF/image-20230924193718196.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="识别率对比"></p><p><strong>虹膜识别的特点：</strong></p><ul><li><strong>生物活性:</strong> <strong>虹膜处在巩膜的保护下，生物活性强。</strong></li><li><strong>非接触性:</strong> <strong>无需用户接触设备，对人身没有侵犯。</strong></li><li><strong>唯一性:</strong>  <strong>形态完全相同虹膜的可能性低于其他组织。</strong></li><li><strong>稳定性:</strong>  <strong>虹膜定型后终身不变，一般疾病不会对虹膜组织造成损伤。</strong></li><li><strong>防伪性:</strong> <strong>不可能在对视觉无严重影响的情况下用外科手术改变虹膜特征。</strong></li><li><strong>识别率极高，仅次于DNA识别。</strong></li></ul><h4 id="人脸识别"><a href="#人脸识别" class="headerlink" title="人脸识别"></a><strong>人脸识别</strong></h4><p>人脸识别（human face recognition）是基于人的面部特征信息进行身份识别。其准确性要低于虹膜、指纹识别，但它具有非强制性、非接触性、操作简单、隐蔽性好等特点，因此成为最容易被接受的生物特征识别方式。</p><p>人脸识别过程：</p><ul><li>建立人脸的面像档案：制作面像文件，并生成面纹编码进行存储</li><li>获取当前的人体面像，并以此生成面纹编码</li><li>用当前的面纹编码与档案库存中的面纹编码进行检索对比</li></ul><h5 id="人脸识别涉及到的技术模块"><a href="#人脸识别涉及到的技术模块" class="headerlink" title="人脸识别涉及到的技术模块"></a><strong>人脸识别涉及到的技术模块</strong></h5><p><strong>人脸检测</strong></p><p>在动态场景、复杂背景中判断是否存在面像，并分离出面像。</p><ul><li>参考模板法、人脸规则法、样品学习法、肤色模型法、特征脸法</li></ul><p><strong>人脸跟踪</strong></p><p>在检测之后，在后续帧中继续捕获人脸的运动轨迹及大小变化。</p><ul><li>基于模型跟踪、运动信息跟踪、人脸局部特征跟踪、神经网络跟踪</li></ul><p><strong>人脸比对</strong> </p><p>对被检测到的面像进行身份确认，即在面像库中进行目标检索，找出最佳匹配。面像的描述决定了面像识别的具体方法与性能。</p><ul><li>特征向量、面纹模板</li></ul><h5 id="人脸识别的特征提取"><a href="#人脸识别的特征提取" class="headerlink" title="人脸识别的特征提取"></a><strong>人脸识别的特征提取</strong></h5><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-1-%E8%87%AA%E5%8A%A8%E8%AF%86%E5%88%AB%E6%8A%80%E6%9C%AF/image-20230924193856486.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="难点"></p><h4 id="声音识别"><a href="#声音识别" class="headerlink" title="声音识别"></a><strong>声音识别</strong></h4><p>通过对采集到的语音信号进行分析和处理，提取相应的特征以识别说话人的身份。</p><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-1-%E8%87%AA%E5%8A%A8%E8%AF%86%E5%88%AB%E6%8A%80%E6%9C%AF/image-20230924193923197.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="流程"></p><h3 id="2-1-7-图像识别、机器视觉"><a href="#2-1-7-图像识别、机器视觉" class="headerlink" title="2.1.7 图像识别、机器视觉"></a><strong>2.1.7</strong> <strong>图像识别、机器视觉</strong></h3><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-1-%E8%87%AA%E5%8A%A8%E8%AF%86%E5%88%AB%E6%8A%80%E6%9C%AF/image-20230924193956563.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="无其它内容"></p>]]></content>
    
    
    <categories>
      
      <category>学习资料</category>
      
    </categories>
    
    
    <tags>
      
      <tag>课件笔记</tag>
      
      <tag>物联网技术与应用</tag>
      
      <tag>IoT</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>IoT__第1章__物联网概述</title>
    <link href="/IoT-%E7%AC%AC1%E7%AB%A0-%E7%89%A9%E8%81%94%E7%BD%91%E6%A6%82%E8%BF%B0/"/>
    <url>/IoT-%E7%AC%AC1%E7%AB%A0-%E7%89%A9%E8%81%94%E7%BD%91%E6%A6%82%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="物联网技术与应用"><a href="#物联网技术与应用" class="headerlink" title="物联网技术与应用"></a>物联网技术与应用</h1><h3 id="物物互联"><a href="#物物互联" class="headerlink" title="物物互联"></a><strong>物物互联</strong></h3><p>•物联网概念在2005年国际电信联盟（ITU）发布的《ITU互联网报告2005：物联网》中被正式提出：</p><p>”它通过泛在网络，借助物体识别技术（如射频识别）、传感技术、嵌入式智能技术、小型化技术（如纳米结构），将世界万物连接在一起，通过感知世界、认识世界、改造世界，进而推动整个世界发展。</p><p><img src="/IoT-%E7%AC%AC1%E7%AB%A0-%E7%89%A9%E8%81%94%E7%BD%91%E6%A6%82%E8%BF%B0/image-20230923223303067.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="物物互联：连接物理世界与虚拟世界"></p><h3 id="物联网是一项技术吗-……"><a href="#物联网是一项技术吗-……" class="headerlink" title="物联网是一项技术吗 ……"></a>物联网是一项技术吗 ……</h3><p><img src="/IoT-%E7%AC%AC1%E7%AB%A0-%E7%89%A9%E8%81%94%E7%BD%91%E6%A6%82%E8%BF%B0/image-20230923223334523.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="image-20230923223334523"></p><p><strong>来源多样，主线复杂</strong></p><p>物联网不是某项具体的技术，而是很多推动万物互联趋势的支撑技术的有机集合。</p><p><img src="/IoT-%E7%AC%AC1%E7%AB%A0-%E7%89%A9%E8%81%94%E7%BD%91%E6%A6%82%E8%BF%B0/image-20230923223401700.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="本科专业"></p><blockquote><p>虽然这里是软工。。。</p></blockquote><p><img src="/IoT-%E7%AC%AC1%E7%AB%A0-%E7%89%A9%E8%81%94%E7%BD%91%E6%A6%82%E8%BF%B0/image-20230923223447346.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="应避免“盲人摸象”现象"></p><h1 id="物联网-IoT-Internet-of-Things"><a href="#物联网-IoT-Internet-of-Things" class="headerlink" title="物联网  IoT (Internet of Things)"></a>物联网  IoT (Internet of Things)</h1><ul><li>概述</li><li>感知识别</li><li>传感网络</li><li>支撑管理</li><li>广域连接</li><li>综合应用</li></ul><h2 id="第一章-物联网概述"><a href="#第一章-物联网概述" class="headerlink" title="第一章 物联网概述"></a><strong>第一章 物联网概述</strong></h2><h3 id="1-1发展起源和背景"><a href="#1-1发展起源和背景" class="headerlink" title="1.1发展起源和背景"></a>1.1<strong>发展起源和背景</strong></h3><p><img src="/IoT-%E7%AC%AC1%E7%AB%A0-%E7%89%A9%E8%81%94%E7%BD%91%E6%A6%82%E8%BF%B0/image-20230923223637490.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="直接截取的课件。。。"></p><h4 id="IoT-起源：-普适计算"><a href="#IoT-起源：-普适计算" class="headerlink" title="IoT 起源： 普适计算"></a><strong>IoT</strong> <strong>起源： 普适计算</strong></h4><p>•1988年，Xerox PARC 研究中心的 Mark Weiser 提出普适计算的概念。</p><p>–1991年，在  <em>Scientific American</em> 上发表 “The Computer for the 21st Century” ，正式提出了普适计算 Ubiquitous Computing</p><p>–”The most profound technologies are those that disappear. They weave themselves into the fabric of everyday life until they are indistinguishable from it.”</p><p>•1999年，IBM也提出 Pervasive Computing的概念，即为无所不在的、随时随地可以进行计算的一种方式。强调计算资源普存于环境当中，人们可以随时随地获得需要的信息和服务。</p><p>•1999年，欧洲 ISTAG 提出了环境智能（Ambient Intelligence）的概念。提法不同，但是含义一致。</p><h5 id="普适计算的特点："><a href="#普适计算的特点：" class="headerlink" title="普适计算的特点："></a><strong>普适计算的特点</strong>：</h5><ul><li>当时的计算领域新浪潮，是多技术的融合，突破桌面计算的模式，将计算和互联技术普及到日常生活中</li><li>倡导发展可以广泛部署的微小计算设备，并与已有的互联网技术结合，实现移动、无缝、透明、泛在的计算服务，又称为不可见计算（Invisible Computing）</li><li>强调和环境融为一体的计算概念，计算机本身从人们的视线里消失。 能够在任何时间、任何地点、以任何方式进行信息的获取与处理</li><li>模式转变：（互联网）让人围绕着网络运行 à 让微小系统形成的网络围绕着人运转</li><li>然而，普适设备大多是已有计算系统的延伸和拓展，集聚化、智能化程度较低，而且服务对象主要是个体，缺乏突破性应用场景，未能大规模推广</li><li>将互联网推广到物理世界的一种初步尝试</li></ul><h4 id="IoT-起源：无线传感网（WSN-Wireless-Sensor-Network）"><a href="#IoT-起源：无线传感网（WSN-Wireless-Sensor-Network）" class="headerlink" title="IoT 起源：无线传感网（WSN: Wireless Sensor Network）"></a><strong>IoT</strong> <strong>起源：无线传感网（WSN: Wireless Sensor Network）</strong></h4><p><img src="/IoT-%E7%AC%AC1%E7%AB%A0-%E7%89%A9%E8%81%94%E7%BD%91%E6%A6%82%E8%BF%B0/image-20230923223804215.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="智能化"></p><p><img src="/IoT-%E7%AC%AC1%E7%AB%A0-%E7%89%A9%E8%81%94%E7%BD%91%E6%A6%82%E8%BF%B0/image-20230923223809626.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="点到网"></p><p><img src="/IoT-%E7%AC%AC1%E7%AB%A0-%E7%89%A9%E8%81%94%E7%BD%91%E6%A6%82%E8%BF%B0/image-20230923223837109.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="sys"></p><h4 id="物联网的起源和发展"><a href="#物联网的起源和发展" class="headerlink" title="物联网的起源和发展"></a><strong>物联网的起源和发展</strong></h4><ul><li>本世纪初，泛在网络 Ubiquitous Networks: 互联网和移动通信的融合与拓展</li><li>2006年，Cyber-Physical Systems (CPS) ：相比传感网系统，注重实现开放、可控、闭环的计算支持</li><li>2009年，美国工商业领袖“圆桌会议”，IBM提出“智慧地球”概念</li><li>2009年，“感知中国”战略启动<ul><li>–前期：中科院、科工委、高校、中电等预研攻关</li><li>–传感器网络被列入国家重大科技计划三“新一代移动通信网络”</li><li>–初期行业应用，与运营商合作探讨三步走</li><li>–2019年被视为中国物联网元年，收到全社会关注</li><li>–物联网被正式列入国家五大新兴战略性产业之一</li></ul></li><li>2016年，十三五规划建议提出实施“互联网+”行动计划</li><li>…… ……</li></ul><h5 id="物联网发展并提升至战略高度"><a href="#物联网发展并提升至战略高度" class="headerlink" title="物联网发展并提升至战略高度"></a><strong>物联网发展并提升至战略高度</strong></h5><p>•《中华人民共和国国民经济和社会发展第十四个五年规划和2035年远景目标纲要》（2021年）要求，在信息领域重点发展云计算、大数据、物联网、工业互联网、区块链、人工智能（AI）、虚拟现实（VR） &#x2F; 增强现实（AR）等七大产业。</p><p>•《物联网新型基础设施建设三年行动计划（2021—2023）》（2021年）提出，到2023年国内主要城市初步建成物联网新型基础设施。</p><p>物联网是一个<strong>动态的全球网络化基础设施</strong>，它具有基于标准和互操作通信协议的自组织能力，其中物理的和虚拟的“物”具有身份标识、物理属性、虚拟的特性和智能的接口，并与信息网络无缝整合。物联网将与媒体互联网、服务互联网和企业互联网一起，构成未来互联网。</p><h4 id="物联网过去、现在与发展"><a href="#物联网过去、现在与发展" class="headerlink" title="物联网过去、现在与发展"></a><strong>物联网过去、现在与发展</strong></h4><p><img src="/IoT-%E7%AC%AC1%E7%AB%A0-%E7%89%A9%E8%81%94%E7%BD%91%E6%A6%82%E8%BF%B0/image-20230923224405341.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="历史"></p><h3 id="1-2概念和特点"><a href="#1-2概念和特点" class="headerlink" title="1.2概念和特点"></a>1.2<strong>概念和特点</strong></h3><h4 id="物联网概念"><a href="#物联网概念" class="headerlink" title="物联网概念"></a><strong>物联网概念</strong></h4><ul><li>1998，MIT的Kevin Ashton首次提及 Internet of Things<ul><li>将RFID技术与传感器技术应用于日常物品中将会创建一个“物联网”，这项技术将带来人们对机器理解的新纪</li></ul></li><li>2003年，美国&lt;技术评论&gt;：传感网技术将是未来改变人们生活的十大技术之首。</li><li>2005,ITU发布《ITU互联网报告2005：物联网》<ul><li>物联网是通过RFID和智能计算等技术实现全世界设备互连的</li></ul></li><li>2008，欧委会的CERP-IOT工程给出新的物联网定<ul><li>物联网是物理和数字世界融合的网络，每个物理实体都有一个数字的身份；物体具有上下文感知能力―他们可以感知、沟通与互动。他们对待物理事件进行即时反映，对物理实体的信息进行即时传送；使得实时作出决定成为可能</li></ul></li><li>早期的维基百科<ul><li>所谓“物联网”（Internet of Things），指的是将各种信息传感设备，如射频识别（RFID）装置、红外感应器、全球定位系统、激光扫描器等种种装置与互联网结合起来而形成的一个巨大网络。</li></ul></li></ul><h5 id="物联网的其他定义"><a href="#物联网的其他定义" class="headerlink" title="物联网的其他定义"></a>物联网的其他定义</h5><p><img src="/IoT-%E7%AC%AC1%E7%AB%A0-%E7%89%A9%E8%81%94%E7%BD%91%E6%A6%82%E8%BF%B0/image-20230923225159018.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="p"></p><h4 id="物联网的系统化概念"><a href="#物联网的系统化概念" class="headerlink" title="物联网的系统化概念"></a><strong>物联网的系统化概念</strong></h4><p>物联网的系统化概念由中国提出，整合了美国CPS (Cyber-Physical Systems)、欧盟 IoT（Internet of Things) 和 日本 U-Japan 等概念。是一个基于互联网、传统电信网等信息载体，让所有（能被独立寻址的）普通物理对象实现被感知和互联互通的网络。物理环境感知化、普通对象设备化、自治终端互联化和普适服务智能化是其重要特征。</p><h4 id="IoT-Internet-of-Things-物联网"><a href="#IoT-Internet-of-Things-物联网" class="headerlink" title="IoT (Internet-of-Things)  物联网"></a>IoT (Internet-of-Things)  物联网</h4><p><strong>全面感知：利用传感器、RFID、卫星、微波，及其它各种感知设备随时随地采集各种动态对象，全面感知世界。</strong></p><p><strong>可靠传送：利用无线网、移动网、工控网等网络将感知的信息进行实时传送。</strong></p><p><strong>协同处理：对多维、多源信息进行融合处理，协同决策。</strong></p><p><strong>智能控制：对物体实现智能化的控制和管理，达到人与物的沟通。</strong></p><p><img src="/IoT-%E7%AC%AC1%E7%AB%A0-%E7%89%A9%E8%81%94%E7%BD%91%E6%A6%82%E8%BF%B0/image-20230923225428059.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="IoT"></p><h4 id="物联网应用-vs-互联网应用"><a href="#物联网应用-vs-互联网应用" class="headerlink" title="物联网应用 vs. 互联网应用"></a>物联网应用 vs. 互联网应用</h4><p><strong>互联网应用：</strong>人们想要在互联网上了解某种信息，需要有人去收集、发布这个信息到互联网上，才可供人们浏览。人需要在环路中做大量工作，并难以动态了解其变化。</p><p><strong>物联网应用</strong>：物联网通过各种感知设备，如射频识别、传感器、红外等，将信息传送到接收器，再通过互联网传送，通过高层应用进行信息处理，以实现远程监视、自动报警、控制、诊断和维护，进而实现“管理、控制、营运”的一体化。</p><p><img src="/IoT-%E7%AC%AC1%E7%AB%A0-%E7%89%A9%E8%81%94%E7%BD%91%E6%A6%82%E8%BF%B0/image-20230923225735601.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="HOME"></p><h4 id="几种网络概念之间的关系"><a href="#几种网络概念之间的关系" class="headerlink" title="几种网络概念之间的关系"></a><strong>几种网络概念之间的关系</strong></h4><p><img src="/IoT-%E7%AC%AC1%E7%AB%A0-%E7%89%A9%E8%81%94%E7%BD%91%E6%A6%82%E8%BF%B0/image-20230923225749817.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="包含和侧重"></p><h3 id="1-3体系结构"><a href="#1-3体系结构" class="headerlink" title="1.3体系结构"></a>1.3<strong>体系结构</strong></h3><p>传感网（物联网）三层体系架构 （2007-2009）</p><p><img src="/IoT-%E7%AC%AC1%E7%AB%A0-%E7%89%A9%E8%81%94%E7%BD%91%E6%A6%82%E8%BF%B0/image-20230923225943098.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="3F"></p><p><strong>物联网四层模型（例）</strong></p><p><img src="/IoT-%E7%AC%AC1%E7%AB%A0-%E7%89%A9%E8%81%94%E7%BD%91%E6%A6%82%E8%BF%B0/image-20230923230007346.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="4F"></p><p>• <strong>To be continued …</strong></p>]]></content>
    
    
    <categories>
      
      <category>学习资料</category>
      
    </categories>
    
    
    <tags>
      
      <tag>课件笔记</tag>
      
      <tag>物联网技术与应用</tag>
      
      <tag>IoT</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>大三开学，感觉时间好快e</title>
    <link href="/%E5%A4%A7%E4%B8%89%E5%BC%80%E5%AD%A6%EF%BC%8C%E6%84%9F%E8%A7%89%E6%97%B6%E9%97%B4%E5%A5%BD%E5%BF%ABe/"/>
    <url>/%E5%A4%A7%E4%B8%89%E5%BC%80%E5%AD%A6%EF%BC%8C%E6%84%9F%E8%A7%89%E6%97%B6%E9%97%B4%E5%A5%BD%E5%BF%ABe/</url>
    
    <content type="html"><![CDATA[<h3 id="牢骚"><a href="#牢骚" class="headerlink" title="牢骚"></a>牢骚</h3><p>2021年入学，有时候还觉得疫情如在昨天（第一波是在高二的时候了），结果一转眼都大三了，工作考研什么的都挺急了，自己进入大学以来还是感觉学到的太少了，特别是现在是学的嵌入式方向和互联网就业的学生比前后端一窍不通，和硬件学生比也不会画板子设计电路，什么白银卡住了。我的同学舍友有自己开发游戏的，有b站做up百万播放量的，还有准备北欧留学的，还有卷acm的，总之和他们相比总有一种自己没做什么实事的感觉。自己总该找点什么东西来做，可能才有点用。</p><h3 id="学习计划"><a href="#学习计划" class="headerlink" title="学习计划"></a>学习计划</h3><p>目前计划自学一下python，配合这学期的课程做点什么东西，还有教资考试也得提上日程，毕竟父母都是教师，又在师范学校，多拿一个证以后混不下去了，回老家躺平摆烂也有用。</p><p>其他的，这学期应该还是会在博客做笔记整理，上学期部分专业课成绩还是有提升的，对我这种人来说知识还得靠重复记忆才行，还有这学期有建模和算法课，要是脑袋转不过来就惨了，上课摸鱼还得戒掉才行，课上课后都得发力。</p><p>还计划这个大三参加一些学科竞赛刷点奖，不然可能真就保不了研了，如果已经既定保不了研，按就业形势来看，如果实习不顺利到大四还得准备考。。。</p><h3 id="Others"><a href="#Others" class="headerlink" title="Others"></a>Others</h3><p>这个博客的评论区崩了，有时间还得修修</p><p>暑假忙着做暑期课程的项目和摸鱼，鸽了好久，也没更新，寄</p><p>github上的<a href="https://github.com/Emokable/ADEwatch">项目地址</a>，只是作了个存档</p>]]></content>
    
    
    <categories>
      
      <category>杂谈</category>
      
    </categories>
    
    
    <tags>
      
      <tag>总结</tag>
      
      <tag>学习</tag>
      
      <tag>生活</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机组成原理-L012-Mcore</title>
    <link href="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L012-Mcore/"/>
    <url>/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L012-Mcore/</url>
    
    <content type="html"><![CDATA[<h1 id="计算机组成与实践-多核处理器"><a href="#计算机组成与实践-多核处理器" class="headerlink" title="计算机组成与实践 -多核处理器"></a><strong>计算机组成与实践</strong> -<strong>多核处理器</strong></h1><h1 id="一-简介"><a href="#一-简介" class="headerlink" title="一.简介"></a>一.简介</h1><h3 id="指令级并行的局限"><a href="#指令级并行的局限" class="headerlink" title="指令级并行的局限"></a><strong>指令级并行的局限</strong></h3><p>将每个时钟周期处理3<del>6条指令的处理器提升一倍的性能，即每个时钟周期处理6</del>12条指令，需要该处理器每个时钟周期完成：</p><ul><li>处理3~4个存储访问</li><li>决策2~3个分支指令</li><li>重命名并访问20多个寄存器</li><li>提取12~24条指令</li></ul><blockquote><p>实现上述性能的复杂度可能意味着牺牲最高时钟频率</p></blockquote><h1 id="二-Amdahl定律"><a href="#二-Amdahl定律" class="headerlink" title="二.Amdahl定律"></a>二.Amdahl定律</h1><table><thead><tr><th>Amdahl定律</th></tr></thead><tbody><tr><td>加速比 S  &#x3D; 1&#x2F;(1 –  a + a&#x2F;n)</td></tr></tbody></table><p>a：可并行计算部分的占比</p><p>n：并行处理节点个数</p><p>加速之前的执行时间 To</p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L012-Mcore/image-20230607002814617.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="时间占比图"></p><p>加速之后的执行时间 Tp &#x3D; To  * （1 – a + a&#x2F;n）</p><p><strong>例子1</strong></p><p>如果希望在100个处理器上获得90的加速比，请问在原始计算负载中顺序执行部分最多占多少？</p><blockquote><p>答：假设可并行执行部分占比为a，根据加速比公式</p><p>​    s &#x3D; 1 &#x2F; (1 – a + a&#x2F;n)</p><p>​    90 &#x3D; 1 &#x2F; (1 – a + a&#x2F;100)</p><p>​    a &#x3D; 0.999</p><p>​    因此，顺序执行部分最多占0.1%</p></blockquote><h3 id="标量v-s-向量"><a href="#标量v-s-向量" class="headerlink" title="标量v.s 向量"></a><strong>标量v.s 向量</strong></h3><ul><li>标量处理器一次只能处理一个数据</li><li>向量处理器能够处理向量型并行计算<ul><li>如果希望在100个处理器上获得90的加速比，标量在原始程序中的占比要少于0.1%</li><li>由Amdahl定律可知，要在100个处理器上获得线性加速比，原始计算不能包含标量</li></ul></li></ul><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L012-Mcore/image-20230607002934659.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="左标量，计算只能一次处理一个数据"></p><p><strong>例子2</strong></p><p>执行两个加法：一个加法是10个标量的求和，另一个加法是一对10×10二维矩阵的求和。假设目前只有矩阵求和可以并行，使用10个和40个处理器达到的加速比分别是多少？</p><p>答：</p><p>​10个处理器加速比是110t&#x2F;20t&#x3D;5.5</p><p>​    40个处理器加速比是110t&#x2F;12.5t&#x3D;8.8</p><blockquote><p>这里的t是周期的意思，加速比是没加速花费的总时间和加速后的时间之比</p></blockquote><h1 id="三-线程级并行"><a href="#三-线程级并行" class="headerlink" title="三.线程级并行"></a><strong>三.线程级并行</strong></h1><h3 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a><strong>多线程</strong></h3><p>继续进行指令级并行（ILP）变得越来越复杂和困难</p><p>探索线程级并行（Thread-level parallelism，TLP）</p><blockquote><p>多道程序间的TLP（独立运行的串行程序）</p><p>多线程应用的TLP（程序运行采用多线程）</p></blockquote><p>多线程利用线程级并行提高单个处理器的效率</p><h4 id="线程例子"><a href="#线程例子" class="headerlink" title="线程例子"></a><strong>线程例子</strong></h4><ul><li>浏览器软件<ul><li>一个线程显示图片</li><li>一个线程从网络中检索数据</li></ul></li><li>文字处理软件<ul><li>一个线程显示图形</li><li>一个线程读取键盘输入</li><li>一个线程进行拼写检查</li></ul></li><li>web服务器<ul><li>一个线程接收访问请求</li><li>接收到请求后，创建一个线程提供服务</li><li>多个线程处理成千上万的用户请求</li></ul></li></ul><h4 id="硬件多线程"><a href="#硬件多线程" class="headerlink" title="硬件多线程"></a><strong>硬件多线程</strong></h4><table><thead><tr><th><strong>硬件多线程</strong></th></tr></thead><tbody><tr><td>在线程阻塞时处理器可以切换到另一个线程的实现</td></tr></tbody></table><ul><li>通过执行与造成阻塞的指令不相关的指令来隐藏阻塞开销的方法</li><li>处理器必须为每个线程复制独立的状态<ul><li>寄存器文件、PC、指令缓存等</li></ul></li><li>缓存、TLBs、BHT、BTB等可以共享</li><li>存储器自身可以通过虚拟存储器机制实现共享</li><li>硬件必须支持高效的线程切换</li></ul><table><thead><tr><th>细粒度多线程（fine-grained multithreading)</th></tr></thead><tbody><tr><td>每条指令之后都进行线程切换</td></tr></tbody></table><ul><li>多线程直接交叉执行，交叉以循环方式进行</li><li>处理器能够在每个时钟周期进行切换</li><li>☺可同时隐藏由短阻塞和长阻塞引起的吞吐量损失</li><li>☹降低了单个线程的执行速度</li></ul><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L012-Mcore/image-20230607003421004.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="sun"></p><h5 id="Niagara整数流水线"><a href="#Niagara整数流水线" class="headerlink" title="Niagara整数流水线"></a>Niagara整数流水线</h5><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L012-Mcore/image-20230607003514006.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="8细粒"></p><table><thead><tr><th>**粗粒度多线程（coarse-grained **multithreading</th></tr></thead><tbody><tr><td>仅在高开销阻塞时进行线程切换，如最后一级缓存缺失</td></tr></tbody></table><ul><li>☺几乎不会降低单个线程的执行速度</li><li>☹隐藏吞吐量损失能力受限，特别是短阻塞</li><li>☹线程切换时，必须清空流水线，并填充流水线</li><li>适合用来降低高开销阻塞带来的性能损失</li></ul><h4 id="同时多线程（SMT）"><a href="#同时多线程（SMT）" class="headerlink" title="同时多线程（SMT）"></a><strong>同时多线程（SMT）</strong></h4><table><thead><tr><th><strong>同时多线程（simultaneous  multithreading，SMT）</strong></th></tr></thead><tbody><tr><td>硬件多线程的变种，使用多发射动态调度流水线处理器的资源来挖掘线程级并行，并同时保持指令级并行</td></tr></tbody></table><ul><li>多发射处理器中通常有单线程难以充分利用的多个并行功能单元</li><li>借助于寄存器重命名和动态调度，不需要考虑相关性，即可以发射来自不同线程的多条指令</li><li>每个线程需要单独的重命名表（RUUs），或者需要指明一个表项属于哪个线程</li><li>Intel Pentium 4的SMT称为超线程（hyperthreading）：支持两个线程</li></ul><h4 id="4个线程运行在超标量处理器（4路）"><a href="#4个线程运行在超标量处理器（4路）" class="headerlink" title="4个线程运行在超标量处理器（4路）"></a><strong>4个线程运行在超标量处理器（4路）</strong></h4><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L012-Mcore/image-20230607004021046.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="chu"></p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L012-Mcore/image-20230607004033109.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="粗粒度/细粒度/同时多线程"></p><blockquote><p>粗的就是到高阻塞才调度，细是每条指令，smt是不需要开销的每条指令轮换</p></blockquote><h1 id="四-多核"><a href="#四-多核" class="headerlink" title="四.多核"></a><strong>四.多核</strong></h1><table><thead><tr><th><strong>多处理器</strong></th></tr></thead><tbody><tr><td>至少两个处理器的计算机系统</td></tr></tbody></table><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L012-Mcore/image-20230607004340664.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="多核"></p><p>通过任务级并行（task-level parallelism）或进程级并行实现高吞吐量（process-level parallelism）</p><p>将单个程序运行在多个处理器上实现性能的提升，并行处理程序（parallel processing program）</p><h3 id="多核处理器"><a href="#多核处理器" class="headerlink" title="多核处理器"></a><strong>多核处理器</strong></h3><ul><li>很多科学问题需要更快速的计算机，可以通过集群（cluster）完成</li><li>集群：通过局域网连接的一组计算机，其作用等同于一个大型的多处理器</li><li>例如搜索引擎、web服务器、电子邮件服务器和数据库</li></ul><table><thead><tr><th><strong>主要挑战</strong></th></tr></thead><tbody><tr><td>如何构建易于正确编写并行处理程序的软硬件系统</td></tr></tbody></table><h4 id="需要解决的关键问题"><a href="#需要解决的关键问题" class="headerlink" title="需要解决的关键问题"></a><strong>需要解决的关键问题</strong></h4><table><thead><tr><th>1、如何共享数据？</th></tr></thead><tbody><tr><td>多处理器共享一个物理地址空间</td></tr></tbody></table><table><thead><tr><th>2、如何合作处理任务？</th></tr></thead><tbody><tr><td>处理器通过存储器中的共享变量进行通信（load、store）</td></tr></tbody></table><p>通过同步机制访问共享数据，最多一个处理器进行访问</p><table><thead><tr><th><strong>两种类型</strong></th></tr></thead><tbody><tr><td>统一存储访问（Uniform Memory  Access, UMA）</td></tr><tr><td>非统一存储访问（Non-uniform Memory Access, NUMA）</td></tr></tbody></table><h4 id="简单并行处理程序"><a href="#简单并行处理程序" class="headerlink" title="简单并行处理程序"></a><strong>简单并行处理程序</strong></h4><p>10个处理器求和</p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L012-Mcore/image-20230607004538519.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="需要每层同步"></p><h4 id="进程同步"><a href="#进程同步" class="headerlink" title="进程同步"></a><strong>进程同步</strong></h4><ul><li>通过多进程合作完成一项任务</li><li>使用锁变量（信号量）实现进程合作与同步，需要架构提供仲裁机制</li><li>仲裁机制决定哪个处理器获得锁变量的访问权</li><li>单总线提供仲裁机制，只能通过单总线访问存储器</li><li>处理器获得总线，共享数据需要加锁，可以通过原子交换实现</li></ul><h4 id="自旋锁同步"><a href="#自旋锁同步" class="headerlink" title="自旋锁同步"></a><strong>自旋锁同步</strong></h4><p>一个处理器成功获得锁变量表示成功将1写入锁变量，其他处理器获得返回值0</p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L012-Mcore/image-20230607004642755.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="自旋"></p><p><strong>例子</strong></p><p>假设对100000个数字进行求和，运行在100个处理器上</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs prolog">sum[<span class="hljs-symbol">Pn</span>] = <span class="hljs-number">0</span>;<br>for (i = <span class="hljs-number">1000</span>*<span class="hljs-symbol">Pn</span>; i&lt;<span class="hljs-number">1000</span>*(<span class="hljs-symbol">Pn</span>+<span class="hljs-number">1</span>); i = i + <span class="hljs-number">1</span>)<br>sum[<span class="hljs-symbol">Pn</span>] = sum[<span class="hljs-symbol">Pn</span>] + <span class="hljs-symbol">A</span>[i];<br><span class="hljs-symbol">Repeat</span><br>   synch(); //synchronize first <br>   if (half<span class="hljs-comment">%2 != 0 &amp;&amp; Pn == 0) &#123; </span><br>        sum[<span class="hljs-number">0</span>] = sum[<span class="hljs-number">0</span>] + sum[half<span class="hljs-number">-1</span>]; <br>   &#125; <br>   half = half/<span class="hljs-number">2</span> <br>   if (<span class="hljs-symbol">Pn</span>&lt;half) &#123; <br>        sum[<span class="hljs-symbol">Pn</span>] = sum[<span class="hljs-symbol">Pn</span>] + sum[<span class="hljs-symbol">Pn</span>+half] <br>   &#125; <br>until (half == <span class="hljs-number">1</span>); //final sum in sum[<span class="hljs-number">0</span>]<br><br></code></pre></td></tr></table></figure><h4 id="Synch-例子"><a href="#Synch-例子" class="headerlink" title="Synch()例子"></a><strong>Synch()例子</strong></h4><p>Synch()：生产者-消费者模型下，消费者处理器在提取数据之前必须先同步</p><p>路障同步（Barrier）：处理器需要在路障处等待，直到满足条件</p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L012-Mcore/image-20230607004746635.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="路障捏"></p><h4 id="自旋锁实现路障"><a href="#自旋锁实现路障" class="headerlink" title="自旋锁实现路障"></a><strong>自旋锁实现路障</strong></h4><p>arrive、depart是自旋锁，arrive初始化未锁定，depart初始化锁定</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs delphi"><span class="hljs-function"><span class="hljs-keyword">procedure</span> <span class="hljs-title">synch</span><span class="hljs-params">()</span> <span class="hljs-comment">&#123; </span></span><br><span class="hljs-comment"><span class="hljs-function">    lock(arrive); </span></span><br><span class="hljs-comment"><span class="hljs-function">    count = count + 1; // count the processors as</span></span><br><span class="hljs-comment"><span class="hljs-function">    if (count &lt; n) &#123; // they arrive at barrier </span></span><br><span class="hljs-comment"><span class="hljs-function">           unlock(arrive) </span></span><br><span class="hljs-comment"><span class="hljs-function">    &#125;</span> <span class="hljs-title">else</span> <span class="hljs-comment">&#123;</span></span><br><span class="hljs-comment"><span class="hljs-function">           unlock(depart);</span></span><br><span class="hljs-comment"><span class="hljs-function">    &#125;</span> </span><br><span class="hljs-function">    <span class="hljs-title">lock</span><span class="hljs-params">(depart)</span>;</span> <br>    count = count - <span class="hljs-number">1</span>; <span class="hljs-comment">// count the processors as </span><br>    <span class="hljs-keyword">if</span> (count &gt; <span class="hljs-number">0</span>) <span class="hljs-comment">&#123; // they leave barrier </span><br><span class="hljs-comment">          unlock(depart) </span><br><span class="hljs-comment">    &#125;</span> <span class="hljs-keyword">else</span> <span class="hljs-comment">&#123; </span><br><span class="hljs-comment">          unlock(arrive); </span><br><span class="hljs-comment">    &#125;</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="消息传递多核处理器（MPP）"><a href="#消息传递多核处理器（MPP）" class="headerlink" title="消息传递多核处理器（MPP）"></a><strong>消息传递多核处理器（MPP）</strong></h3><table><thead><tr><th>1、如何共享数据？</th></tr></thead><tbody><tr><td>多处理器通过相互传递消息实现数据共享</td></tr></tbody></table><table><thead><tr><th>2、如何合作处理任务？</th></tr></thead><tbody><tr><td>通过消息传递（send和receive）实现处理器间合作</td></tr></tbody></table><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L012-Mcore/image-20230607004901229.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="多核-不共享内存"></p><p><strong>例子</strong></p><p>给每个处理器分配1000个数据进行求和</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash">Sum = 0;<br><span class="hljs-keyword">for</span> (i = 0; i&lt;1000; i = i + 1)<br><span class="hljs-built_in">sum</span> = <span class="hljs-built_in">sum</span> + A[i];<br>//将所有处理器计算结果相加 ，send(x,y)将数据y发送给处理器x<br><br>half = 100; l<br>imit = 100; <br>repeat &#123; <br>    half = (half+1)/2; //dividing line <br>    <span class="hljs-keyword">if</span> (Pn&gt;= half &amp;&amp; Pn&lt;<span class="hljs-built_in">limit</span>) send(Pn-half,<span class="hljs-built_in">sum</span>);<br>    <span class="hljs-keyword">if</span> (Pn&lt;(<span class="hljs-built_in">limit</span>/2)) <span class="hljs-built_in">sum</span> = <span class="hljs-built_in">sum</span> + receive(); <br>    <span class="hljs-built_in">limit</span> = half; <br>&#125; until (half == 1); //final <span class="hljs-built_in">sum</span> <span class="hljs-keyword">in</span> P0’s <span class="hljs-built_in">sum</span><br><br></code></pre></td></tr></table></figure><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L012-Mcore/image-20230607005019757.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="消息传递"></p><h1 id="五-小结"><a href="#五-小结" class="headerlink" title="五.小结"></a><strong>五.小结</strong></h1><p>多核处理器基础</p><ol><li>如何共享数据？</li><li>如何合作处理任务？</li><li>架构的可扩展性如何？</li></ol><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L012-Mcore/image-20230607005121724.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="m"></p>]]></content>
    
    
    <categories>
      
      <category>学习资料</category>
      
    </categories>
    
    
    <tags>
      
      <tag>课件笔记</tag>
      
      <tag>计算机组成原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机组成原理-L011-vm</title>
    <link href="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L011-vm/"/>
    <url>/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L011-vm/</url>
    
    <content type="html"><![CDATA[<h1 id="计算机组成与实践-虚拟存储器（Virtual-Memory）"><a href="#计算机组成与实践-虚拟存储器（Virtual-Memory）" class="headerlink" title="计算机组成与实践 -虚拟存储器（Virtual Memory）"></a><strong>计算机组成与实践</strong> -<strong>虚拟存储器（Virtual Memory）</strong></h1><h2 id="一-简介"><a href="#一-简介" class="headerlink" title="一.简介"></a>一.简介</h2><p>存储器的存储容量可能小于可寻址空间</p><ul><li>32-bit地址可以寻址4GB空间</li><li>内存地址可能只有1GB</li></ul><blockquote><p>系统可以同时运行多个程序，如果这些程序运行所需的存储空间大于实际内存容量，系统该如何运行？</p></blockquote><p>术语：</p><ul><li>运行的程序称为一个进程（process）或线程（thread）</li><li>操作系统控制进程</li></ul><h3 id="虚拟存储器（Virtual-Memory）"><a href="#虚拟存储器（Virtual-Memory）" class="headerlink" title="虚拟存储器（Virtual Memory）"></a><strong>虚拟存储器（Virtual Memory）</strong></h3><ul><li>将主存用作辅助存储器的高速缓存的技术</li><li>程序拥有自己的虚拟地址空间，存储频繁访问的代码与数据</li><li>根据局部性原理而设计</li></ul><blockquote><p>虚拟存储器优势：</p><p>​运行时，CPU和OS将虚拟地址（Virtual Address）转换成物理地址（Physical Address）</p><p>​实现多个程序共享存储器</p><p>​允许运行超过主存容量的程序</p><p>​代码重定位（Code Relocation）：代码可以加载进内存的任何地方</p></blockquote><h3 id="例子：从存储层次结构来看"><a href="#例子：从存储层次结构来看" class="headerlink" title="例子：从存储层次结构来看"></a><strong>例子：从存储层次结构来看</strong></h3><ul><li>假设内存容量为1GB，此时已经使用了1GB容量，在程序运行时需要额外的存储空间</li><li>把内存中的一块数据（100MB）移出到硬盘</li><li>此时，内存有100MB的空闲（free）存储空间</li><li>如果稍后，需要使用被替换出去那块数据</li><li>需要把内存中其他的数据块移出到硬盘，以获得100MB的空闲存储空间将原来的数据载入</li></ul><h3 id="两个程序共享物理存储"><a href="#两个程序共享物理存储" class="headerlink" title="两个程序共享物理存储"></a><strong>两个程序共享物理存储</strong></h3><p>程序的地址空间被划分成页（pages）或片段（segments）</p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L011-vm/image-20230607001556446.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="共享"></p><h3 id="虚拟存储器架构"><a href="#虚拟存储器架构" class="headerlink" title="虚拟存储器架构"></a><strong>虚拟存储器架构</strong></h3><p>部分进程临时存放在硬盘，一旦需要运行就载入内存</p><p>载入由操作系统执行，应用程序不需要知道虚拟存储器的存在</p><p>存储管理单元（MMU）将虚拟地址转换成物理地址</p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L011-vm/image-20230607001627575.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="存储器架构"></p><h1 id="二-虚拟存储器"><a href="#二-虚拟存储器" class="headerlink" title="二.虚拟存储器"></a>二.<strong>虚拟存储器</strong></h1><h3 id="地址转换"><a href="#地址转换" class="headerlink" title="地址转换"></a><strong>地址转换</strong></h3><p>存储器的数据传输单元为页（page）</p><ul><li>页大小：4KB ~ 16 KB</li><li>与缓存块大小设计类似</li><li>页太小：花费较长时间在磁盘寻址页</li><li>页太大：页中部分存储空间空闲</li></ul><p>在磁盘中寻址数据需要花费较长时间，一旦找到数据，能以每秒几MB的速度进行数据传输</p><p>如果页太大，页中部分存储空间空闲，造成内存中很大一部分存储空间的浪费</p><ul><li>虚拟地址到物理地址的转换由软硬件协同完成</li><li>存储访问请求首先需要进行地址转换</li><li>处理器请求的虚拟地址：<ul><li>高位字段代表虚拟页号（virtual page number）</li><li>低位字段代表页偏移（page offset）</li></ul></li></ul><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L011-vm/image-20230607001744207.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="va-pa"></p><h3 id="页表映射"><a href="#页表映射" class="headerlink" title="页表映射"></a><strong>页表映射</strong></h3><table><thead><tr><th><strong>页表（Page Table）</strong></th></tr></thead><tbody><tr><td>保存着虚拟地址和物理地址之间转换关系的表  Ø以虚拟页号为索引  Ø指向页表首地址的寄存器：页表寄存器（  page table register ）  页在内存中：页表中的对应项将包含虚页对应的物理页号及状态信息  页不在内存中：页表可以指向磁盘的交换区（swap space）中的地址</td></tr></tbody></table><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L011-vm/image-20230607001826178.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="页表"></p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L011-vm/image-20230607001839671.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="页表地址转换"></p><h4 id="缺页（page-fault）代价"><a href="#缺页（page-fault）代价" class="headerlink" title="缺页（page fault）代价"></a><strong>缺页（page fault）代价</strong></h4><ul><li>缺页时需要从磁盘提取页到内存<ul><li>一次缺页处理将花费数百万个时钟周期</li><li>由OS代码处理</li></ul></li><li>缺页处理<ul><li>用发生缺页的虚拟地址找到PTE</li><li>在磁盘中定位该页的位置</li><li>在页表中选择一页进行替换<ul><li>如果选择的页为脏页，则先写回磁盘</li></ul></li><li>将该页读入内存，并更新页表</li><li>恢复程序运行</li></ul></li><li>最小化缺页率<ul><li>采用全相联映射</li><li>优化的替换算法</li></ul></li></ul><h4 id="页替换与写"><a href="#页替换与写" class="headerlink" title="页替换与写"></a><strong>页替换与写</strong></h4><ul><li>降低缺页率，可以采用LRU替换策略<ul><li>采用引用位（Reference bit）或者使用位（use bit）表示对某一页的访问</li><li>引用位由OS周期性的置0</li><li>引用位为0表示该页最近没有使用</li></ul></li><li>写磁盘需要百万个时钟周期<ul><li>采用写回机制</li><li>页被写后脏页位置1</li></ul></li></ul><h3 id="虚拟存储下的数据访问"><a href="#虚拟存储下的数据访问" class="headerlink" title="虚拟存储下的数据访问"></a><strong>虚拟存储下的数据访问</strong></h3><p>程序每次访存至少需要两次</p><ul><li>获得物理地址</li><li>获得数据</li></ul><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L011-vm/image-20230607002029325.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="虚存访问"></p><h4 id="加快地址转换：TLB"><a href="#加快地址转换：TLB" class="headerlink" title="加快地址转换：TLB"></a><strong>加快地址转换：TLB</strong></h4><ul><li>CPU中特殊的地址转换Cache：快表（Translation Look-aside Buffer，TLB）</li><li>减少页表访问</li></ul><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L011-vm/image-20230607002101466.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="加上TLB的流程"></p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L011-vm/image-20230607002122018.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="映射机制"></p><h3 id="TLB"><a href="#TLB" class="headerlink" title="TLB"></a><strong>TLB</strong></h3><ul><li>与cache设计类似，可以是全相联、组相联、直接映射</li><li>容量比cache小，因此访问速度比cache 块</li><li>一般不超过512表项</li><li>TLB缺失<ul><li>如果页在内存中，缺失可以处理<ul><li>从内存中提取PTE到TLB</li><li>可以由硬件处理<ul><li>更复杂的页表结构</li></ul></li><li>或者由软件处理<ul><li>采用特殊的异常处理程序</li></ul></li></ul></li><li>如果页不在内存中，发生缺页（page fault）</li></ul></li></ul><h4 id="TLB与Cache"><a href="#TLB与Cache" class="headerlink" title="TLB与Cache"></a><strong>TLB与Cache</strong></h4><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L011-vm/image-20230607002304350.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="再加上cache"></p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L011-vm/image-20230607002314817.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="流程图"></p><h4 id="结合TLB的事件组合"><a href="#结合TLB的事件组合" class="headerlink" title="结合TLB的事件组合"></a><strong>结合TLB的事件组合</strong></h4><p>TLB&#x2F;Cache缺失：页&#x2F;块不在“缓存”中</p><p>缺页：页不在内存中</p><table><thead><tr><th><strong>TLB</strong></th><th><strong>Page  Table</strong></th><th><strong>Cache</strong></th><th><strong>是否可能发生？何种情况下发生？</strong></th></tr></thead><tbody><tr><td>Hit</td><td>Hit</td><td>Hit</td><td>是，全部命中是最好的情况</td></tr><tr><td>Hit</td><td>Hit</td><td>Miss</td><td>是，查找TLB找到物理地址后，缓存缺失</td></tr><tr><td>Miss</td><td>Hit</td><td>Hit</td><td>是，TLB缺失但能从页表找到物理地址</td></tr><tr><td>Miss</td><td>Hit</td><td>Miss</td><td>是，TLB缺失但能从页表找到物理地址，缓存缺失</td></tr><tr><td>Miss</td><td>Miss</td><td>Miss</td><td>是，缺页</td></tr><tr><td>Hit</td><td>Miss</td><td>Miss&#x2F;  Hit</td><td>否，TLB保存了页表的部分表项，不存在表项在TLB而不在页表的情况</td></tr><tr><td>Miss</td><td>Miss</td><td>Hit</td><td>否，如果缺页，数据不在内存，因此不可能在缓存</td></tr></tbody></table><h1 id="四-小结"><a href="#四-小结" class="headerlink" title="四.小结"></a>四.小结</h1><h4 id="存储器层次结构"><a href="#存储器层次结构" class="headerlink" title="存储器层次结构"></a><strong>存储器层次结构</strong></h4><ul><li>存储器层次结构共用许多原理</li><li>每个存储层次需要解决以下问题：<ul><li>数据放置问题</li><li>如何查找数据</li><li>发生缺失时的替换策略</li><li>写操作机制</li></ul></li></ul><h4 id="虚拟地址保护"><a href="#虚拟地址保护" class="headerlink" title="虚拟地址保护"></a><strong>虚拟地址保护</strong></h4><ul><li>程序可以共享部分虚拟地址空间<ul><li>需要防止非法修改和访问</li><li>需要OS支撑</li></ul></li><li>需要硬件支撑<ul><li>支撑两种模式：用户态和内核态</li><li>内核态指令</li><li>页表和其他状态信息只能在内核态访问</li><li>系统调用提供两种模式间的切换</li></ul></li></ul><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a><strong>小结</strong></h4><p>虚拟存储器是管理主存和磁盘之间数据缓存的一级存储器层次</p><p>允许单个程序在主存有限的容量内扩展地址空间</p><p>支持多个活跃的进程共享主存</p><p>需要将虚拟地址转换成物理地址</p>]]></content>
    
    
    <categories>
      
      <category>学习资料</category>
      
    </categories>
    
    
    <tags>
      
      <tag>课件笔记</tag>
      
      <tag>计算机组成原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>嵌入式系统设计ch6-程序设计与分析</title>
    <link href="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1ch6-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/"/>
    <url>/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1ch6-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h1 id="嵌入式系统设计-程序设计与分析"><a href="#嵌入式系统设计-程序设计与分析" class="headerlink" title="嵌入式系统设计-程序设计与分析"></a>嵌入式系统设计-程序设计与分析</h1><h2 id="一-嵌入式程序设计"><a href="#一-嵌入式程序设计" class="headerlink" title="一.嵌入式程序设计"></a>一.嵌入式程序设计</h2><h3 id="自然语言描述"><a href="#自然语言描述" class="headerlink" title="自然语言描述"></a>自然语言描述</h3><ul><li>直接使用语言文字描述设计过程</li><li>一般会结合其他方法使用</li></ul><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1ch6-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/image-20230528214238378.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="tu"></p><h3 id="形式化描述"><a href="#形式化描述" class="headerlink" title="形式化描述"></a>形式化描述</h3><p>通过严谨的数学语言、逻辑和公式描述</p><p>对开发工程师的知识背景要求严格</p><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1ch6-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/image-20230528214332855.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="形式化描述"></p><h3 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a>伪代码</h3><ul><li>伪代码是一种常用的描述程序设计方法</li><li>能够较为清晰地描述思路</li><li>通常使用伪代码设计核心部分</li></ul><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1ch6-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/image-20230528214407610.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="伪代码"></p><h3 id="结构图"><a href="#结构图" class="headerlink" title="结构图"></a>结构图</h3><ul><li>结构图<ul><li>结构图( structure chart)是一种自顶向下的模块化设计工具</li><li>系统由不同模块和线组成，用小方块表示模块，线表示模块之间的关系。</li><li>结构图用于高层设计或体系结构设计</li><li>帮助程序员划分大型软件，递归地将问题分解成可以理解的小问题</li></ul></li></ul><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1ch6-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/image-20230528214501986.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="树状"></p><p>结构图</p><ul><li>树状结构图</li><li>非树状结构图</li></ul><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1ch6-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/image-20230528214535525.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="非树状"></p><h3 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h3><p>流程图( flow chart)</p><ul><li>流程图是描述一个程序的工作流程或过程</li><li>使用方框表示步骤、菱形表示判断、带箭头的线表示执行流程</li><li>流程图表示对给定问题的解决方案</li><li>常用于分析、设计、记录或者管理的流程中</li></ul><p>例：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">for</span><span class="hljs-params">( A ; B ; C)</span></span><br><br>D<br></code></pre></td></tr></table></figure><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1ch6-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/image-20230528214946481.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="流程图"></p><h3 id="状态图-States-diagram"><a href="#状态图-States-diagram" class="headerlink" title="状态图( States diagram)"></a>状态图( States diagram)</h3><ul><li>状态图关注系统某一对象在生命周期内的特性和特性的变化，以及引起特性变化的时间和动作等</li><li>状态（state）是指在生命周期中某个特性，具有一定的时间稳定性，即会在一段时间内保持相对稳定。</li><li>转移( transition) 两个状态之间的变迁，表示在指定事件发生后，在特定的条件下，对象执行特定的动作从源状态转移到目标状态</li><li>转移由源状态、目标状态、触发事件、警戒条件和转移动作组成</li></ul><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1ch6-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/image-20230528215818235.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="状态图"></p><p>例：给定一个电话座机，打电话包含哪几种状态？并画出状态图</p><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1ch6-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/image-20230528215839235.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="是状态自动机吗？"></p><h4 id="控制-x2F-数据流图（CDFG）"><a href="#控制-x2F-数据流图（CDFG）" class="headerlink" title="控制&#x2F;数据流图（CDFG）"></a>控制&#x2F;数据流图（CDFG）</h4><p>数据流图（Data flow graph, DFG）</p><p>无条件程序模型，不能表示控制</p><p>基本语句块：</p><ul><li>无条件代码段</li><li>只有一个入口和出口</li><li>可操作的最大顺序语句序列</li></ul><p>单赋值形式：一个变量只能在赋值运算符左边出现一次</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">x</span> = a + b<span class="hljs-comment">;</span><br><span class="hljs-attr">y</span> = c - d<span class="hljs-comment">;</span><br><span class="hljs-attr">z</span> = x * y<span class="hljs-comment">;</span><br><span class="hljs-attr">y</span> = b + d<span class="hljs-comment">;</span><br><br></code></pre></td></tr></table></figure><p>两类结点</p><p>◼圆形结点：表示操作</p><p>◼方形结点：表示值</p><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1ch6-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/image-20230528220529867.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="DFG"></p><p>部分序：</p><p>▪<strong>a+b, c-d; b+d, x*y</strong></p><p>▪操作<strong>a+b</strong>和 <strong>c-d</strong>可以用任何顺序执行</p><p>▪操作<strong>b+d</strong>和<strong>x*y</strong>可以用任何顺序执行</p><h4 id="CDFG"><a href="#CDFG" class="headerlink" title="CDFG"></a>CDFG</h4><p>CDFG: 表示控制与数据的图</p><p>用数据流图表示组件，添加控制部分</p><p>CDFG有两种类型的节点</p><p>判断节点：描述的全部控制类型</p><p>数据流节点：一个完整的表示基本语句块的数据流图</p><p><strong>数据流节点</strong></p><ul><li>封装一个数据流图</li><li>在节点中完成写操作</li></ul><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1ch6-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/image-20230528220704006.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="DATA"></p><p><strong>判断节点</strong></p><p>◼ 描述控制类型</p><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1ch6-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/image-20230528220731093.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="CONTROL"></p><p>EX:</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs scss">if (cond1) <span class="hljs-built_in">bb1</span>();<br>else <span class="hljs-built_in">bb2</span>();<br><span class="hljs-built_in">bb3</span>();<br>switch (test1) &#123;<br>case c1: <span class="hljs-built_in">bb4</span>(); break;<br>case c2: <span class="hljs-built_in">bb5</span>(); break;<br>case c3: <span class="hljs-built_in">bb6</span>(); break;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1ch6-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/image-20230528220757073.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="SWITCH"></p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs gcode">for <span class="hljs-comment">(i=0; i&lt;N; i++)</span><br>loop_body<span class="hljs-comment">()</span>;<br>等价=&gt;<br>i=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span> <span class="hljs-comment">(i&lt;N)</span> &#123;<br>loop_body<span class="hljs-comment">()</span>; <br>i++; <br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1ch6-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/image-20230528220842074.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="for"></p><h3 id="嵌入式程序模型"><a href="#嵌入式程序模型" class="headerlink" title="嵌入式程序模型"></a>嵌入式程序模型</h3><p>有限状态机：响应系统</p><p>循环缓冲区：数字信号处理</p><p>队列：数字信号处理</p><h4 id="有限状态机（FSM）"><a href="#有限状态机（FSM）" class="headerlink" title="有限状态机（FSM）"></a>有限状态机（FSM）</h4><p>状态机具有离散动态的系统模型</p><ul><li>一种常用的状态机叫做有限状态机，表示状态数目是有限的</li><li>状态机建模适用于对时间驱动的系统，给定不同输入信号，系统根据这些输入信号做出不同响应</li><li>状态来表示系统的内部特性，状态的变化是基于输入的变化</li></ul><p>状态图是对状态机的一种图形表示</p><p>MOORE机、MEALY机 ???</p><p>应用:</p><ul><li>面向控制的代码</li><li>响应式系统</li><li>非周期性采样作为输入</li></ul><h5 id="EX-座位安全带控制器"><a href="#EX-座位安全带控制器" class="headerlink" title="EX:座位安全带控制器"></a>EX:座位安全带控制器</h5><blockquote><p>需求：</p><p>有人坐到座椅上，在规定时间内若没有系好安全带，就启动蜂鸣器</p><p>输入：</p><p>◼ seat: 是否有人坐；</p><p>◼ belt: 是否系安全带；</p><p>◼ timer: 定长计时器；</p><p>输出：</p><p>◼ 蜂鸣器</p><p>◼ 定时器</p><p>状态：</p><p>◼ state: 机器当前状态 </p></blockquote><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1ch6-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/image-20230528221226990.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="座位"></p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs pf"><span class="hljs-comment">#define IDLE 0</span><br><span class="hljs-comment">#define SEATED 1</span><br><span class="hljs-comment">#define BELTED 2</span><br><span class="hljs-comment">#define BUZZER 3</span><br>switch (<span class="hljs-keyword">state</span>) &#123;<br>case IDLE: <br>if (seat) &#123; <span class="hljs-keyword">state</span> = SEATED; <br>timer_on = TRUE; &#125;<br>break;<br>case SEATED: <br>if (belt) <span class="hljs-keyword">state</span> = BELTED;<br>else if (timer) <span class="hljs-keyword">state</span> = BUZZER;<br>break;<br>…<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="循环缓冲区"><a href="#循环缓冲区" class="headerlink" title="循环缓冲区"></a>循环缓冲区</h4><p>面向流的程序设计</p><p>数据流：按规律到达并需要在限定时间内处理</p><ul><li>FIR滤波器：面向流处理</li><li>有限脉冲响应（FIR）滤波器</li><li>乘积求和</li></ul><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1ch6-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/image-20230528222011572.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="累乘"></p><p>循环缓冲区</p><ul><li>固定数目</li><li>处理流数据的一种数据结构</li></ul><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1ch6-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/image-20230528222134158.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="什么滑动窗口"></p><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1ch6-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/image-20230528222254919.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="循环"></p><p>▪pos:当前采样的位置；</p><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1ch6-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/image-20230528222312124.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="移动"></p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-meta">#<span class="hljs-keyword">define</span> CMAX 6 <span class="hljs-comment">/* filter order */</span> </span><br><span class="hljs-type">int</span> circ[<span class="hljs-built_in">CMAX</span>]; <span class="hljs-comment">/* circular buffer */</span> <br><span class="hljs-type">int</span> pos; <span class="hljs-comment">/* position of current sample */</span> <br><br><span class="hljs-type">void</span> circ_init() &#123; <br><span class="hljs-type">int</span> i; <br><span class="hljs-keyword">for</span> (i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-built_in">CMAX</span>; i++) <span class="hljs-comment">/* set values to 0 */</span> <br>circ[i] = <span class="hljs-number">0</span>; <br>pos=<span class="hljs-built_in">CMAX</span><span class="hljs-number">-1</span>; <span class="hljs-comment">/* start at tail so first element at 0 */</span> <br>&#125;<br><span class="hljs-type">void</span> circ_update(<span class="hljs-type">int</span> xnew) &#123; <br><span class="hljs-comment">/* compute the new head value with wrap around; the pos </span><br><span class="hljs-comment">pointer moves from 0 to CMAX-1 */</span> <br>pos = ((pos == <span class="hljs-built_in">CMAX</span><span class="hljs-number">-1</span>) ? <span class="hljs-number">0</span> : (pos+<span class="hljs-number">1</span>)); <br><span class="hljs-comment">/* insert the new value at the new head */</span> <br>circ[pos] = xnew; <br>&#125;<br><span class="hljs-type">int</span> circ_get(<span class="hljs-type">int</span> i) &#123; <br><span class="hljs-type">int</span> ii; <br><span class="hljs-comment">/* compute the buffer position */</span> <br>ii = ((pos+<span class="hljs-number">1</span>)% <span class="hljs-built_in">CMAX</span> + (i<span class="hljs-number">-1</span>)) % <span class="hljs-built_in">CMAX</span>; <br><span class="hljs-keyword">return</span> circ[ii]; <span class="hljs-comment">/* return the value */</span> <br>&#125;<br></code></pre></td></tr></table></figure><h4 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h4><ul><li>生产者&#x2F;消费者</li><li>弹性缓冲区<ul><li>数据无法预料到达或离开的时间</li><li>构建队列的方法：<ul><li>链表</li><li>数组</li></ul></li></ul></li></ul><p><strong>生产者-消费者系统</strong></p><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1ch6-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/image-20230528222441589.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="队列法"></p><p>p1,p2是两个算法处理块</p><p>数据从单行缓存区的队列中发送到处理块中</p><p>数据q12是p1产生的数据，p2消费的数据</p><h2 id="二-嵌入式C语言编程"><a href="#二-嵌入式C语言编程" class="headerlink" title="二.嵌入式C语言编程"></a>二.嵌入式C语言编程</h2><p>C语言开发的嵌入式程序，其有如下优点：</p><p>◼表现能力和处理能力极强。它具有丰富的运算符和数据类型，便于实现各类复杂的数据结构</p><p>◼可读性强，易于调试和维护。采用自顶向下的设计方法，层次清晰，便于按模块方式组织程序</p><p>◼可移植性强。具有非处理器特定代码的特点</p><p>◼运算速度快，编译效率高。具有功能丰富的库函数，而且可以直接实现对系统硬件的控制</p><h3 id="嵌入式C语言编程方法"><a href="#嵌入式C语言编程方法" class="headerlink" title="嵌入式C语言编程方法"></a>嵌入式C语言编程方法</h3><p>嵌入式程序开发是硬件实现与软件编程相结合的开发过程。其开发的过程包括</p><p>◼了解开发板上的硬件属性</p><p>◼考察I&#x2F;O等外设的连线</p><p>◼采用模块化编程的思想。将整个系统分解成许多小模块，针对每个小模块进行编程</p><p>◼设计程序流程框架，根据流程框架整合各个模块形成完整系统</p><p>◼整合模块进行编译，若无问题，编译后生成的hex文件，下载到开发板中调试，排查其软硬件的问题</p><h3 id="嵌入式C语言元素"><a href="#嵌入式C语言元素" class="headerlink" title="嵌入式C语言元素"></a>嵌入式C语言元素</h3><p>嵌入式C语言编程通常具有三个方面的结构化元素</p><ul><li>预处理声明、定义和 include语句</li><li>主函数</li></ul><p><strong>While(TURE)</strong></p><p><strong>{</strong></p><p><strong>……</strong></p><p><strong>}</strong></p><ul><li>函数、异常和中断服务函数<ul><li>外设的访问通常基于忙等、中断、DMA的访问</li></ul></li></ul><h4 id="预处理声明、定义和-include语句"><a href="#预处理声明、定义和-include语句" class="headerlink" title="预处理声明、定义和 include语句"></a>预处理声明、定义和 include语句</h4><ol><li>用于包含文件的 include语句：include是一个用于包含某个文件内容的预处理语句，将给定文件的代码导</li></ol><p>入（粘贴）到当前文件中</p><ul><li>系统定义：#include <em>&lt;*filename*&gt;</em></li><li>用户定义：#include “filename”</li><li>以头文件(.h文件)的形式</li><li>可为后期的调试带来便利</li></ul><ol start="2"><li>预处理语句</li></ol><p>◼给编译器传达指示，提高程序的可读性</p><p>◼预处理语句 #define</p><p>​◼ 预处理全局变量</p><p><strong>#define GPLOH-MODER *(unsigned int*(GPIOH_BASE+0x00)</strong></p><p>​◼ 预处理常量</p><p><strong>#define TRUE</strong></p><ol start="3"><li>条件编译语句：</li></ol><p>◼#ifdef 说明当满足某条件时对一组语句编译，条件不满足时编译另一组语句的功能</p><p>◼采用条件编译指令，可以减少被编译的语句，从而减少目标代码的长度</p><p>◼在一个文件中，给出芯片不同系列的代码，使用不同编译器，…</p><p><strong>#ifdef</strong> <strong>标识符</strong></p><p>​<strong>程序段1</strong> </p><p><strong>#else</strong> </p><p>​<strong>程序段2</strong> </p><p><strong>#endif</strong></p><p>◼ 它的作用是当“标识符”已经被定义(一般是用#define定义)，则对#ifdef 下的程序段进行编译，否则编译#else下的程序段</p><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1ch6-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/image-20230528222925991.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="条件编译"></p><ol start="4"><li>import, extern, export声明</li></ol><p>◼C语言混合编程中</p><p>◼ extern，import表明变量或者函数是定义在其他文件中</p><p>◼ 表示本程序用到变量提供给其他模块调用</p><p>◼常用在多个源文件编译的程序中</p><p>◼在一个文件中定义全局变量，而在另一文件中用 extern对全局变量引用。编译器知道是在别处定义的外部变量</p><p>◼通过extern定义外部函数，其中extern可以省略，若函数不能被其他文件引用，在函数定义前加static</p><p>◼在程序连接时从其他文件中找此外部变量</p><p><strong>extern int value1;</strong></p><p><strong>extern int p(void);</strong> </p><ol start="5"><li>typedef 类型别名</li></ol><p>◼ 定义一种类型的别名，用 typedef 来定义与平台无关的类型</p><p>◼ 提高可移植性。当跨平台时，只要改 typedef 本身就行，不用对其他源码做任何修改</p><p>◼例，定义一个叫REAL 的浮点类型，表示最高精度的类型</p><p>◼在支持双精度的目标平台一上</p><p><strong>typedef long double REAL;</strong></p><p>◼在不支持 long double 的目标平台二上，改为：</p><p><strong>typedef double REAL;</strong></p><p>◼在连 double 都不支持的目标平台三上，改为：</p><p><strong>typedef float REAL;</strong></p><p>◼typedef 定义一种类型的新别名，在结构体、枚举类型中非常常见</p><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1ch6-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/image-20230528223106699.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="typedef"></p><ol start="6"><li>结构体：</li></ol><p>◼结构体是由具有相同或不同类型的数据项构成的数据集合</p><p>◼结构体可以被声明为变量、指针或数组等，以实现较复杂的数据结构</p><p>◼结构体指针作为函数的参数，可提高程序的可扩展性。</p><p>​◼例，串口，它的初始化由几个属性決定，若不使用结构体，一般的方法如下：</p><p><strong>void USART_Init(u16 usart, u32 Baudrate, u16 wordlengh,</strong> </p><p><strong>u16 stopbites, u16 parity, u8 mode)</strong></p><p>​◼将串口有关的参数组合到一个结构体里面</p><p><strong>void USART_Init(u16 usart,USART_InitTypeDef uart_initdef)</strong></p><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1ch6-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/image-20230528223601644.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="struct"></p><ol start="7"><li>位运算操作</li></ol><p>◼在嵌入式系统编程中，位运算比其他运算更常用</p><p>◼嵌入式系统涉及到很多有关硬件寄存器的操作</p><p>◼硬件寄存器由若干位组成，对配置、读写等属性控制</p><p>◼C语言没有专门对指定位操作的语法，在进行位操作的时候，需要对指令进行简单的组合来完成此功能</p><p>◼C语言位运算操作符有6个：&amp;, |, ~, ^, &lt;&lt;, &gt;&gt;</p><p>◼例：</p><p>​◼判断 x 第 n 位是否为1；</p><p><strong>if x &amp; (1 &lt;&lt; n)</strong></p><p>​◼对于单个或多个位置 0 或置 1 的操作</p><p><strong>GPIOH_MODER&amp; &#x3D;~(0x03 &lt;&lt; (2*10));</strong> </p><p><strong>GPIOH_MODER |&#x3D; (01 &lt;&lt; 2*10);</strong></p><p>​◼获取寄存器 x 的第 3∼7 位的值</p><p><strong>x &#x3D; (x &amp; (0x1f &lt;&lt; 3)) &gt;&gt; 3;</strong></p><p>​◼给寄存器 a 的 bit3∼bit7 赋值 0xc</p><p><strong>a &#x3D; (a &amp; (~(0x1f &lt;&lt; 3)))| (0xc &lt;&lt; 3);</strong></p><p>​◼给寄存器 a 的 bit3 ∼ bit7 加上 0xd</p><p><strong>tmp &#x3D; (a &amp; (0x1f &lt;&lt; 3)) &gt;&gt; 3;</strong></p><p><strong>tmp +&#x3D; 0xd;</strong></p><p><strong>a &#x3D; a &amp; (~(0x1f &lt;&lt; 3));</strong></p><p><strong>a |&#x3D; tmp &lt;&lt; 3;</strong></p><p>◼给寄存器 a 的 bit3 ∼ bit7 赋值 4 和 bit8 ∼ bit12 赋值 7</p><p><strong>a &#x3D; (a &amp; (~0x1f &lt;&lt; 3)) | (4 &lt;&lt; 3);</strong></p><p><strong>a &#x3D; (a &amp; (~0x1f &lt;&lt; 8)) | (7 &lt;&lt; 8)；</strong></p><h2 id="三-编译及优化技术"><a href="#三-编译及优化技术" class="headerlink" title="三.编译及优化技术"></a>三.编译及优化技术</h2><ul><li>编译是将一种语言转换成另一种语言的过程</li><li>翻译和优化两个阶段<ul><li>翻译即将高级语言解释为机器识别的语言</li><li>优化是指将机器识别的语言进行修改以提升其执行性能的过程</li></ul></li></ul><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1ch6-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/image-20230528223827928.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="编译优化"></p><h3 id="代码翻译："><a href="#代码翻译：" class="headerlink" title="代码翻译："></a>代码翻译：</h3><ul><li>词法分析：将字符流分组为一个词（token）</li><li>语法分析：根据语法规则形成语法树</li><li>语义分析：确保组成部分有意义</li><li>中间代码：显式中间抽象表示</li><li>符号表的生成：记录使用的标识符及其各种属性信息的一个数据结构</li><li>代码生成：生成目标代码</li></ul><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1ch6-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/image-20230528223927611.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="translate"></p><h4 id="代码优化"><a href="#代码优化" class="headerlink" title="代码优化"></a>代码优化</h4><ul><li>代码优化过程改进中间代码，产生执行速度更快的机器代码</li><li>优化阶段包括机器无关的优化和与具体机器特征相关的指令集优化<ul><li>机器无关的优化涉及程序的逻辑结构、数据表示以及变量计算等方面</li><li>指令集优化是和CPU的流水线以及高速缓存相关的优化</li></ul></li></ul><p>代码翻译</p><ul><li>源程序翻译过程包括词法分析、语法分析和语义分析。</li><li>在典型应用中，大量代码都是由算术表达式和逻辑表达式构成。</li><li>在词法分析中，表达式扫描后的空格被删除。经过词法分析，几组分类的记号被生成，这些分组的字符将被存储到一个字符表中。</li><li>语法分析也叫层次分析，各个记号被进一步分组，根据语法规则产生记号之间的依赖，形成语法树，相当于代码生成的层次结构。</li><li>表达式x&#x3D;4 *a+5 *(b-c)的语法树如图所示。</li></ul><blockquote><p>例：表达式x&#x3D;4 *a+5 *(b-c)经过词法分析，得到的单词和记号有：</p><p>◼ 标识符：x </p><p>◼ 赋值符号：&#x3D; </p><p>◼ 数字：4 </p><p>◼ 乘号操作符：* </p><p>◼ 标识符：a </p><p>◼ 加法操作符：+ </p><p>◼ 数字：5 </p><p>◼ 乘法操作符：* </p><p>◼ 标识符：（</p><p>◼ 标识符：b </p><p>◼ 减法操作符：− </p><p>◼ 标识符：c </p><p>◼ 标识符：）</p></blockquote><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1ch6-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/image-20230528224537160.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="语法树"></p><p>▪表达式x&#x3D;4* a+5*(b-c)代码生成，采用的数据流模型</p><p>若是ARM</p><ul><li>寄存器选择</li><li>变量放入寄存器</li><li>存放中间结果的寄存器</li></ul><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1ch6-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/image-20230528224644879.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="数据流"></p><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1ch6-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/image-20230528224700914.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="汇编"></p><h4 id="控制结构的翻译"><a href="#控制结构的翻译" class="headerlink" title="控制结构的翻译"></a>控制结构的翻译</h4><ul><li>控制语句除了有表达式，还存在大量的控制流程<ul><li>如if语句中包含布尔表达式。</li></ul></li><li>控制流本身翻译成中间代码也是必不可缺的。</li><li>通过CDFG图表示控制结构并进行翻译<ul><li>遍历条件表达式。根据数据流图方式生成该表达式中变量加载等信息的代码</li><li>测试判定表达式。编译器会为判定表达式创建能够在分支中测试的条件代码和标记</li><li>在各个分支指令中运用表达式翻译方法生成相应代码</li><li>通过遍历，得到汇编代码</li></ul></li></ul><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs abnf">if (a &gt; b)<br>x <span class="hljs-operator">=</span> a<span class="hljs-comment">;</span><br>else<br>x <span class="hljs-operator">=</span> b<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1ch6-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/image-20230528224853537.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="控制代码"></p><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1ch6-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/image-20230528224910289.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="1"></p><h4 id="过程的翻译"><a href="#过程的翻译" class="headerlink" title="过程的翻译"></a>过程的翻译</h4><ul><li><p>每次过程调用，将建立过程参数并执行调用，之后还要返回到原来代码位置。</p></li><li><p>过程调用包括保存现场、运行过程及恢复现场，使用过程栈</p><ul><li>过程栈从高位地址到低位地址建立。</li><li>栈指针(sp)定义了当前栈帧在内存中的结束地址，</li><li>帧指针(fp)定义了当前栈帧在内存中的起始地址。</li><li>过程通过栈指针将相关数据保存在栈中，运行过程结束后，从栈中取出数据恢复原代码的环境</li></ul></li><li><p>需要代码做</p><ul><li>调用和返回</li><li>传递参数和返回结果</li></ul></li><li><p>参数和结果被返回到堆栈中</p></li><li><p>对ARM</p><ul><li>R0-R3用来传递程序的前4个参数</li><li>R0 用来保存返回值</li></ul></li></ul><blockquote><p>APCS（ARM过程调用标准）</p><p>▪ r0-r3传递参数给过程，额外的参数放到栈中；</p><p>▪ r0 保持返回的值</p><p>▪ r4-r7保留寄存器的值</p><p>▪ r11是帧指针fp，指向栈底；r13是栈指针sp</p><p>▪ r10是指示栈界限的寄存器，以判断栈是否溢出</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">int <span class="hljs-function"><span class="hljs-title">fun</span> <span class="hljs-params">(int i)</span></span> <br>&#123; int a = <span class="hljs-number">2</span>; <br><span class="hljs-keyword">return</span> a * i;&#125;<br>int main (void) <br>&#123;int i = <span class="hljs-number">25</span>; <br><span class="hljs-function"><span class="hljs-title">fun</span><span class="hljs-params">(i)</span></span>; <br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<br></code></pre></td></tr></table></figure><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs armasm">; fun <span class="hljs-meta">function</span> &lt; fun &gt; <br><span class="hljs-keyword">PUSH</span> &#123; <span class="hljs-built_in">fp</span> &#125; <br><span class="hljs-keyword">ADD</span> <span class="hljs-built_in">FP</span>, <span class="hljs-built_in">SP</span>, # <span class="hljs-number">0</span> <br><span class="hljs-keyword">STR</span> <span class="hljs-built_in">R0</span>, [ <span class="hljs-built_in">FP</span>, #− <span class="hljs-number">16</span> ] <br><span class="hljs-keyword">MOV</span> <span class="hljs-built_in">R3</span>, # <span class="hljs-number">2</span> <br><span class="hljs-keyword">STR</span> <span class="hljs-built_in">R3</span>, [ <span class="hljs-built_in">FP</span>, #−<span class="hljs-number">8</span> ] <br><span class="hljs-keyword">LDR</span> <span class="hljs-built_in">R3</span>, [ <span class="hljs-built_in">FP</span>, #−<span class="hljs-number">8</span> ] <br><span class="hljs-keyword">LDR</span> <span class="hljs-built_in">R2</span>, [ <span class="hljs-built_in">FP</span>, #− <span class="hljs-number">16</span> ] <br><span class="hljs-keyword">MUL</span> R <span class="hljs-number">3</span>,R <span class="hljs-number">2</span>, <span class="hljs-built_in">R3</span> <br><span class="hljs-keyword">MOV</span> <span class="hljs-built_in">R0</span>, <span class="hljs-built_in">R3</span> <br><span class="hljs-keyword">SUB</span> <span class="hljs-built_in">SP</span>, <span class="hljs-built_in">FP</span>, # <span class="hljs-number">0</span> <br><span class="hljs-keyword">POP</span> &#123;<span class="hljs-built_in">FP</span>&#125; <br><span class="hljs-keyword">BX</span> <span class="hljs-built_in">LR</span> <br>; main <span class="hljs-meta">function</span> &lt;main &gt; <br><span class="hljs-keyword">PUSH</span> &#123; <span class="hljs-built_in">FP</span>, <span class="hljs-built_in">LR</span>&#125; <br><span class="hljs-keyword">ADD</span> <span class="hljs-built_in">FP</span>, <span class="hljs-built_in">SP</span>, <span class="hljs-number">#4</span> <br><span class="hljs-keyword">SUB</span> <span class="hljs-built_in">SP</span>, <span class="hljs-built_in">SP</span>, <span class="hljs-number">#8</span> <br><span class="hljs-keyword">MOV</span> <span class="hljs-built_in">R3</span>, # <span class="hljs-number">25</span> <br><span class="hljs-keyword">STR</span> <span class="hljs-built_in">R3</span>, [ <span class="hljs-built_in">FP</span>, #−<span class="hljs-number">8</span> ]<br><span class="hljs-keyword">LDR</span> <span class="hljs-built_in">R0</span>, [ <span class="hljs-built_in">FP</span>, #−<span class="hljs-number">8</span> ]<br><span class="hljs-keyword">BL</span> <span class="hljs-number">822</span>c &lt; fun &gt;<br><span class="hljs-keyword">MOV</span> <span class="hljs-built_in">R3</span>, # <span class="hljs-number">0</span><br><span class="hljs-keyword">MOV</span> <span class="hljs-built_in">R0</span>, <span class="hljs-built_in">R3</span><br><span class="hljs-keyword">SUB</span> <span class="hljs-built_in">SP</span>, <span class="hljs-built_in">FP</span>, <span class="hljs-number">#4</span><br><span class="hljs-keyword">POP</span> &#123;<span class="hljs-built_in">FP</span>, <span class="hljs-built_in">PC</span>&#125;<br></code></pre></td></tr></table></figure><h4 id="编译过程的代码优化"><a href="#编译过程的代码优化" class="headerlink" title="编译过程的代码优化"></a>编译过程的代码优化</h4><p>机器无关的优化，主要是软件方面的优化，修改源程序从而提高代码的性能</p><p>机器相关的优化，如指令集的选择，寄存器的分配，高速缓存优化，流水线的优化等</p><h5 id="指令选择与调度"><a href="#指令选择与调度" class="headerlink" title="指令选择与调度"></a>指令选择与调度</h5><ul><li>对语法树生成的指令代码进行优化<ul><li>效率更高的指令替换中间代码生成指令</li><li>指令重排来改变流水线的性能。</li></ul></li><li>指令集的丰富程度决定了可选指令的范围，要求指令集的一</li><li>致性和完整性</li><li>指令调度就是选择指令的过程<ul><li>本地调度是不能跨基本块边界移动</li><li>全局调度则可跨越基本块的指令调度</li><li>模调度对内循环不同迭代次数来消除流水线气泡的一种技术</li><li>跟踪调度跟踪最常执行的控制流路径实现优化<ul><li>超级块调度则是跟踪调度的一种简化版本。</li></ul></li></ul></li></ul><h5 id="寄存器分配"><a href="#寄存器分配" class="headerlink" title="寄存器分配"></a>寄存器分配</h5><ul><li>CPU的寄存器是有限的<ul><li>若无可用寄存器，续借助内存完成计算</li></ul></li><li>最优的寄存器分配方案是一个NP完全问题<ul><li>某些寄存器有特殊用途或者其使用必须遵循一定约束</li><li>寄存器数目是有限的，这又增加了问题的复杂度</li></ul></li></ul><h5 id="计算次序的选择"><a href="#计算次序的选择" class="headerlink" title="计算次序的选择"></a>计算次序的选择</h5><p>计算执行的次序也会影响目标代码的效率</p><ul><li>计算次序的选择所影响的是寄存器分配问题</li><li>计算次序是更上层的改进</li></ul><p><strong>a&#x3D;b+c ;</strong> </p><p><strong>y&#x3D;d + 2;</strong> </p><p><strong>z&#x3D;c + 3;</strong> </p><p><strong>x&#x3D;a+b ;</strong></p><p>◼ <strong>需要5个寄存器</strong></p><p><strong>a&#x3D;b+c ;</strong> </p><p><strong>x&#x3D;a+b ;</strong> </p><p><strong>y&#x3D;d + 2;</strong> </p><p><strong>z&#x3D;c + 3;</strong></p><p>◼ <strong>需要4个寄存器</strong></p><h5 id="窥孔优化"><a href="#窥孔优化" class="headerlink" title="窥孔优化"></a>窥孔优化</h5><ul><li>窥孔优化是一种局部优化方法，通过检査目标指令的短序列（称为窥孔），用更小更短的指令序列代替这些指令以提高目标程序的性能</li><li>窥孔优化的特征是每次改进可能又为进一步的改进带来机会，且由于占用内存较小而执行速度很快</li><li>窥孔优化常用方法包括冗余加载和保存、删除死代码、控制流优化、强度削弱以及机器语言的使用</li></ul><p>冗余加载和保存</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-keyword">ADR</span> <span class="hljs-built_in">r4</span> , a <br><span class="hljs-keyword">LDR</span> <span class="hljs-built_in">r0</span> , [<span class="hljs-built_in">r4</span>] <br><span class="hljs-keyword">STR</span> <span class="hljs-built_in">r0</span> , [<span class="hljs-built_in">r4</span>]<br></code></pre></td></tr></table></figure><p>▪删除死代码</p><p>删除死代码</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs gauss"><span class="hljs-meta"># <span class="hljs-keyword">define</span> DEBUG 0</span><br><br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">DEBUG</span>)<br><br><span class="hljs-built_in">dbg</span>(p1) ;<br></code></pre></td></tr></table></figure><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1ch6-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/image-20230528225716536.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="窥孔优化-删除"></p><p>控制流优化</p><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1ch6-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/image-20230528225909363.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="控制流"></p><p>强度削弱：目标机器上用时间开销小的等价操作代替时间开销大的操作</p><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1ch6-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/image-20230528225938957.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="左移"></p><p>机器语言的使用</p><ul><li>内嵌的汇编代码，是很典型机器语言的使用<ul><li>有些场合纯 C 语言无法实现<ul><li>例如，协处理器指令、软中断指令、特殊定制指令</li></ul></li><li>提高效率</li></ul></li></ul><h2 id="四-程序性能分析与优化"><a href="#四-程序性能分析与优化" class="headerlink" title="四.程序性能分析与优化"></a>四.程序性能分析与优化</h2><ul><li>程序执行时间<ul><li>程序的执行时间是最重要的嵌入式系统性能评价指标，尤其是对时间关键的实时嵌入式系统。</li></ul></li><li>软件分析方法<ul><li>软件分析的方法通常采用插桩技术，在程序关键代码处插入一段能采集当前程序执行性能的代码。</li><li>当程序执行时，可实际测量出程序的性能信息</li><li>问题：在源程序中插入一段代码尽管不影响源程序的执行结果，但这使得测试环境不够真实，同时在数据导入和导出时会产生额外的开销</li></ul></li><li>硬件分析方式</li><li>在总线上的计时器监控程序运行时的总线信息，采样或者实时检测的方式，测量程序的真实执行时间采用硬件测量的方式在速度上是有优势的</li><li>问题：<ul><li>通用性差，程序在不同的硬件环境中执行可能得到差别较大的执行时间</li><li>数据完备性和准确性无法得到保证</li><li>会造成系统长时间的负载，导致资源的浪费</li></ul></li></ul><h3 id="程序执行时间–静态动态分析"><a href="#程序执行时间–静态动态分析" class="headerlink" title="程序执行时间–静态动态分析"></a>程序执行时间–静态动态分析</h3><ul><li><p>静态分析方法指在不通过程序执行的情况下，静态分析程序的结构和语句，获得程序执行时间的方法</p></li><li><p>平均执行时间( Average Case Execution Time,ACET)</p><ul><li>典型数据期望的典型执行时间</li></ul></li><li><p>最坏执行时间( Best Case Execution Time,BCET)</p><ul><li>程序花费在任何输入序列中的最长运行时间</li><li>对有时限要求的系统是非常重要的</li></ul></li><li><p>最好执行时间( Worst Case Execution Time,WCET)</p><ul><li>程序花费在任何输入序列中的最短运行时间</li><li>测量多速率实时系统时非常重要</li></ul></li><li><p>动态分析方法是收集程序运行时的性能信息，以找到具有性能优化潜力的热点代码</p></li><li><p>动态分析需要大量运行时的信息以确保数据的准确性</p></li><li><p>在一定的阈值内，同时需要额外的测量开销，最常用的动态分析方法是软件测试</p></li></ul><h4 id="代码级分析方法"><a href="#代码级分析方法" class="headerlink" title="代码级分析方法"></a>代码级分析方法</h4><ul><li>代码级分析方法就是针对源程序结构本身的性能分析方法，是编译器最常用的优化技术</li><li>通过对程序本身的控制结构、数据流等关系进行分析，分析程序本身的执行路径，通过程序路径的指令周期来共同计算程序的执行时间</li><li>程序路径分析使用整数线性规划(ILP)的方法来隐式的解决路径问题，使用一个约束条件集合描述程序的结构及其行为的某些方面</li></ul><p>枚举法用于简单具有有限确定执行路径的方法</p><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1ch6-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/image-20230528230843421.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="枚举"></p><p>控制&#x2F;数据流图(CDFG)：</p><p>循环结构程序路径的确定</p><ul><li>循环初始模块执行一次</li><li>判断执行了N+1次</li><li>循环体和循环变量各执行了N次</li></ul><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">for (i<span class="hljs-operator">=</span><span class="hljs-number">0</span><span class="hljs-comment">; i&lt;N; i++) </span><br>&#123;a[i]<span class="hljs-operator">=</span> b[i]*c[i]<span class="hljs-comment">; &#125;</span><br></code></pre></td></tr></table></figure><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1ch6-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/image-20230528230943058.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="代码级"></p><h3 id="程序执行时间"><a href="#程序执行时间" class="headerlink" title="程序执行时间"></a>程序执行时间</h3><ul><li>指令的执行时间<ul><li>CPU厂商通常提供了某些操作指令的CPU周期数表</li></ul></li><li>高速缓存的影响</li><li>流水线技术对执行时间的影响</li><li>执行时间的分析有很多方法，关键是分析程序的哪个部分比较耗时，优化就从这里开始</li></ul><h3 id="性能优化–与机器无关的性能优化"><a href="#性能优化–与机器无关的性能优化" class="headerlink" title="性能优化–与机器无关的性能优化"></a>性能优化–与机器无关的性能优化</h3><h4 id="循环优化"><a href="#循环优化" class="headerlink" title="循环优化"></a>循环优化</h4><p>代码移出</p><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1ch6-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/image-20230528231121940.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="移出"></p><p>归纳变量共享和强度削减</p><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1ch6-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/image-20230528231140898.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="归纳"></p><p>循环展开</p><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1ch6-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/image-20230528231158598.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="一次当两次"></p><p>循环合并</p><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1ch6-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/image-20230528231219388.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="二合一"></p><h4 id="算法与数据结构的优化"><a href="#算法与数据结构的优化" class="headerlink" title="算法与数据结构的优化"></a>算法与数据结构的优化</h4><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1ch6-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/image-20230528231240119.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="直接换成数组可还行"></p><h4 id="过程调用的优化"><a href="#过程调用的优化" class="headerlink" title="过程调用的优化"></a>过程调用的优化</h4><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1ch6-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/image-20230528231538412.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="过程"></p><h3 id="性能优化–与机器相关的性能优化"><a href="#性能优化–与机器相关的性能优化" class="headerlink" title="性能优化–与机器相关的性能优化"></a>性能优化–与机器相关的性能优化</h3><h4 id="寄存器调度"><a href="#寄存器调度" class="headerlink" title="寄存器调度"></a>寄存器调度</h4><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk">w=a*b; <span class="hljs-regexp">/*阶 段1*/</span> <br>x=c+d; <span class="hljs-regexp">/*阶 段2*/</span> <br>y=w+e ; <span class="hljs-regexp">/*阶 段3*/</span> <br>z=a<span class="hljs-regexp">/b ; /</span>* 阶 段<span class="hljs-number">4</span>*/<br></code></pre></td></tr></table></figure><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1ch6-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/image-20230528231632770.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="周期"></p><p>生命周期图↑</p><p>每个变量的生命周期为</p><p>a 持续第 1<em>∼</em>4 阶段； d 持续第 2 阶段； x 持续第 2 阶段；</p><p>b 持续第 1<em>∼</em>4 阶段； e 持续第 3 阶段； y 持续第 3 阶段；</p><p>c 持续第 2 阶段； w 持续第 1<em>∼</em>3 阶段； z 持续第 4 阶段。</p><p> 需要6个寄存器</p><p>优化后： </p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk">w=a*b; <span class="hljs-regexp">/*阶 段1*/</span> <br>x=a<span class="hljs-regexp">/b; /</span>*阶 段<span class="hljs-number">2</span>*/ <br>y=w+e; <span class="hljs-regexp">/*阶 段3*/</span> <br>z=c+d; <span class="hljs-regexp">/*阶 段4*/</span><br></code></pre></td></tr></table></figure><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1ch6-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/image-20230528231710076.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="优化后"></p><p>需要4个寄存器</p><h4 id="高速缓存优化"><a href="#高速缓存优化" class="headerlink" title="高速缓存优化"></a>高速缓存优化</h4><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1ch6-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/image-20230528231856410.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="图"></p><h3 id="程序功耗分析与优化"><a href="#程序功耗分析与优化" class="headerlink" title="程序功耗分析与优化"></a>程序功耗分析与优化</h3><ul><li>功耗是嵌入式系统性能的另一个重要指标，是基于电池供电的最重要性能指标之一。</li><li>功耗的优化<ul><li>时钟控制、使用功耗敏感的处理器、低电压以及无用电路子部件的关闭</li></ul></li><li>软件控制功耗<ul><li>对系统设置不同的模式，如空闲时的休眠状态、运行时的运行状态等。</li><li>改变处理器的时钟频率（降频）</li><li>采用动态功耗管理的策略降低非关键任务的功耗</li></ul></li></ul><h4 id="功耗的测量评估"><a href="#功耗的测量评估" class="headerlink" title="功耗的测量评估"></a>功耗的测量评估</h4><p>通过循环体测量</p><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1ch6-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/image-20230528232037019.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="循环"></p><p>从指令级的角度对程序的功耗进行评估</p><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1ch6-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/image-20230528232118191.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="指令集"></p><h4 id="程序功耗分析与优化-1"><a href="#程序功耗分析与优化-1" class="headerlink" title="程序功耗分析与优化"></a>程序功耗分析与优化</h4><ul><li>硬件相关的功耗优化<ul><li>有效使用寄存器</li><li>分析高速缓存的行为来避免或减少缓存冲突</li><li>存储模式中采用页模式访问</li></ul></li><li>轮询机制优化<ul><li>程序在等待访问外设时可能会采用轮询的方法，轮询会让处理器重复地执行几条指令，会带来大量的能量浪费。通常的做法是使用一些替代的方法，如对外设的访问使用中断的方式替代</li><li>客户服务器协作模型中，将客户端不停地査询服务，改为服务器主动推服务给客户端，这是一种很有用的机制，能大大降低功耗</li></ul></li></ul><h4 id="程序尺寸分析与优化"><a href="#程序尺寸分析与优化" class="headerlink" title="程序尺寸分析与优化"></a>程序尺寸分析与优化</h4><ul><li>程序尺寸是指编译后生成的二进制代码的大小</li><li>优化程序尺寸通常从两方面来考虑：指令和数据<ul><li>指令正确高效的调度，是缩小代码尺寸的基本措施。</li></ul></li><li>方法–模板匹配<ul><li>模板匹配是指令集映射的核心</li><li>对于一个给定的指令序列，通过模板匹配将该序列进行最优的覆盖</li></ul></li></ul><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1ch6-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/image-20230528233207025.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="模板匹配"></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul><li>嵌入式程序的设计方法</li><li>程序模型</li><li>汇编语言和C语言编程技术</li><li>编译及优化技术</li><li>嵌入式软件的性能分析</li></ul>]]></content>
    
    
    <categories>
      
      <category>学习资料</category>
      
    </categories>
    
    
    <tags>
      
      <tag>课件笔记</tag>
      
      <tag>嵌入式程序设计</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机组成原理-L010-cache</title>
    <link href="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L010-cache/"/>
    <url>/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L010-cache/</url>
    
    <content type="html"><![CDATA[<h1 id="计算机组成与实践-缓存（Cache）"><a href="#计算机组成与实践-缓存（Cache）" class="headerlink" title="计算机组成与实践 -缓存（Cache）"></a><strong>计算机组成与实践</strong> -<strong>缓存（Cache）</strong></h1><h2 id="一-简介"><a href="#一-简介" class="headerlink" title="一.简介"></a>一.<strong>简介</strong></h2><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L010-cache/image-20230523100509867.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="示意图"></p><p>缓存是基于局部性原理设计的存储器体系层次，能够有效的提升数据访问速度</p><h4 id="麒麟990-5G芯片"><a href="#麒麟990-5G芯片" class="headerlink" title="麒麟990 5G芯片"></a>麒麟990 5G芯片</h4><p>8核：2个Cortex-A76（2.86GHz），2个Cortex-A76（2.36GHz），4个Cortex-A55（1.95GHz）</p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L010-cache/image-20230523095910296.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="huawei"></p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L010-cache/image-20230523095921416.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="990"></p><h3 id="缓存-内存映射"><a href="#缓存-内存映射" class="headerlink" title="缓存-内存映射"></a>缓存-内存映射</h3><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L010-cache/image-20230523100554128.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="映射"></p><ul><li>内存单元到缓存行间的对于关系</li><li>缓存行（Cache line）&#x3D;缓存块（Cache block）</li><li>设计点：<ul><li>可以快速判断缓存命中或缺失</li><li>充分利用容量有限的缓存，提高命中率</li></ul></li></ul><table><thead><tr><th align="left"><strong>硬件设计需要解决的问题</strong></th></tr></thead><tbody><tr><td align="left">1、如何判断数据是否在缓存中</td></tr><tr><td align="left">2、如果在缓存中，如何找到该数据</td></tr></tbody></table><h3 id="缓存行"><a href="#缓存行" class="headerlink" title="缓存行"></a><strong>缓存行</strong></h3><p>缓存容量远小于内存容量</p><p>多对一映射</p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L010-cache/image-20230523100729681.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="多对一"></p><h2 id="二-直接映射（Direct-Mapping）"><a href="#二-直接映射（Direct-Mapping）" class="headerlink" title="二.直接映射（Direct Mapping）"></a>二.<strong>直接映射（Direct Mapping）</strong></h2><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L010-cache/image-20230523100856419.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="存储形式"></p><ul><li>每个缓存块中有2^4&#x3D;16 bytes</li><li>2^7&#x3D;128个缓存块</li><li>2^(7+5）&#x3D;4096个内存块</li></ul><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L010-cache/image-20230523100927956.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="memory to cache"></p><ul><li>缓存块号&#x3D;（内存块地址）mod（缓存中块总数）<ul><li>内存块j映射到 （j mod 128）缓存块</li></ul></li><li>如果标签相同，则缓存命中</li></ul><table><thead><tr><th><strong>地址分为3个字段</strong></th></tr></thead><tbody><tr><td>块号字段决定存储在内存的哪个块</td></tr><tr><td>标签字段用于区分不同的内存块（内存块到缓存块是多对一的关系）</td></tr><tr><td>字节偏移字段用于选择需要访问的数据（字或字节等）</td></tr></tbody></table><p><strong>例如：给出地址（t,b,w）(16-bit)</strong></p><p>1、用t与缓存块b中的tag作比较，确定该数据是否在缓存中</p><p>2、如果不相同，缓存缺失（Cache miss），用内存块（t,b）(12-bit)替换缓存块b</p><p><strong>CPU需要访问数据，其地址为[A7B4]&#x3D;1010011110110100</strong></p><p>1、检索缓存块1111011，查看其tag是否为10100</p><p>2、如果是，命中</p><p>3、如果不是，从内存读取该块到缓存块1111011中，并更新tag为10100</p><h4 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h4><p>假设缓存有4个块，每个缓存块大小为1 word，初始时为空，给出以下内存块地址：0,1,2,3,4,3,4,15，计算缓存命中率</p><table><thead><tr><th>INDEX</th><th>TAG</th><th>DATA</th></tr></thead><tbody><tr><td>00</td><td></td><td></td></tr><tr><td>01</td><td></td><td></td></tr><tr><td>10</td><td></td><td></td></tr><tr><td>11</td><td></td><td></td></tr></tbody></table><p>块地址有16个，需要4bit，index占2bit，那么tag位也占4-2&#x3D;2bit，index&#x3D;n%4, tag&#x3D;n&#x2F;4</p><p>0-index00-tag00      4-index00-tag014hit</p><p>1-index01-tag00</p><p>2-index10-tag00</p><p>3-index11-tag00  3hit15-index11-tag11   总共hit 2次命中率25%</p><h3 id="MIP中的直接映射缓存"><a href="#MIP中的直接映射缓存" class="headerlink" title="MIP中的直接映射缓存"></a><strong>MIP中的直接映射缓存</strong></h3><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L010-cache/image-20230523101414345.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="DIR"></p><p>缓存块大小为1 word（4 bytes）</p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L010-cache/image-20230523101436520.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="DIR2"></p><p>缓存块大小为4 word（16 bytes）</p><h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a><strong>例子</strong></h4><p>假设缓存有2个块，每个缓存块大小为2-word，初始时为空，给出以下内存块地址：0,1,2,3,4,3,4,15，计算缓存命中率</p><table><thead><tr><th>INDEX</th><th>TAG</th><th>DATA(1)</th><th>DATA(2)</th></tr></thead><tbody><tr><td>00</td><td></td><td></td><td></td></tr><tr><td>01</td><td></td><td></td><td></td></tr></tbody></table><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L010-cache/image-20230523101654410.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="ANS"></p><p>16&#x3D;2^4,index占了2bit，tag也是2bit，不过是一次取2word比如0-1，2-3，4-5,index就是（n&#x2F;2）%2，tag就是(n&#x2F;2)&#x2F;2</p><p> 8次访问，4次命中，命中率为50%</p><h3 id="MIPS缓存设计"><a href="#MIPS缓存设计" class="headerlink" title="MIPS缓存设计"></a><strong>MIPS缓存设计</strong></h3><p>缓存需要存储数据以及与其对应的标签</p><ul><li>2^n个块的直接映射缓存，n个bit用于索引</li><li>大小为2^m个字（ 2^(m+2) 个字节）的缓存块，m个bit用于寻址块中的字</li><li>2 bit用于寻址一个字中的字节</li></ul><table><thead><tr><th><strong>标签字段的大小</strong></th></tr></thead><tbody><tr><td>32  -（n  + m + 2）</td></tr></tbody></table><table><thead><tr><th><strong>直接映射缓存中存储的总的bit</strong></th></tr></thead><tbody><tr><td>2^n ×（块大小 + 标签字段大小 + 有效位大小）</td></tr></tbody></table><h4 id="练习-1"><a href="#练习-1" class="headerlink" title="练习"></a>练习</h4><blockquote><p>假设一个直接映射的cache，有16 KB的数据，块大小为4 words，地址为32 bits，那么该cache总共需要多少位？</p><p>4word&#x3D;16Bytes ，字节寻址块偏移位4bits，块数目16KB&#x2F;16Bytes&#x3D;1024&#x3D;2^10 ,直接用10bit来索引,tag&#x3D;32-10-4&#x3D;18bits</p><p>CacheSize&#x3D;Number*(1 valid bit +tag + Blocksize)&#x3D;2^10 *（1bits+18bits +32bits * 4）&#x3D; 147Kb</p><p>思考了一下：这里的16KB都是缓存块存的数据部分大小，因此求出的块数目2^10，就是index&#x3D;10，通过32bits地址和2bits块内偏移可以直接得出tag&#x3D;18，那么顺势也能得到总共有2^(18+10)个内存块，对这2^28个内存块求tag和index也是÷和%得到（这样就和前面的串起来了）</p></blockquote><p>老师的版本：16KB&#x3D;4096words，根据块大小有4096&#x2F;4&#x3D;1024个块</p><p>每个块存有是4*32&#x3D;128bits数据</p><p>标签字大小：32-（10+2+2）&#x3D;18bits</p><p>每个块有1bit有效位，总cache大小2^10(128+18+1)&#x3D;147Kb</p><h2 id="三-组相联映射（Associative-Mappin）"><a href="#三-组相联映射（Associative-Mappin）" class="headerlink" title="三.组相联映射（Associative Mappin）"></a>三.<strong>组相联映射（Associative Mappin）</strong></h2><h3 id="全相联映射"><a href="#全相联映射" class="headerlink" title="全相联映射"></a><strong>全相联映射</strong></h3><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L010-cache/image-20230523103331651.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="全相连"></p><ul><li>每个缓存块中有2^4&#x3D;16 bytes</li><li>128个缓存块</li><li>2^12&#x3D;4096个内存块</li></ul><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L010-cache/image-20230523103431604.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="全"></p><p><strong>内存块可以映射到任意的缓存块</strong>（没有对应吧关系）</p><p>128个缓存块的标签需要与地址的标签位进行并行的比较（硬件实现）</p><p><strong>CPU需要访问数据，其地址为[A7B4]&#x3D;1010011110110100</strong></p><p>1、查看其tag是否为101001111011</p><p>2、如果是，命中</p><p>3、如果不是，从内存读取该块到任意空闲缓存块（如果没有空闲缓存块，就采用缓存替换策略进行替换），并更新tag为101001111011</p><h3 id="组相联映射"><a href="#组相联映射" class="headerlink" title="组相联映射"></a><strong>组相联映射</strong></h3><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L010-cache/image-20230523103515048.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="组相联"></p><p>每个缓存块中有2^4&#x3D;16 bytes</p><p>128个缓存块分为2^6&#x3D;64个组</p><p>2^12&#x3D;4096个内存块</p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L010-cache/image-20230523103613077.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="组相联"></p><p>结合了直接映射与全相联映射的特点</p><p>缓存组号&#x3D;（内存块地址）mod（缓存中组总数）；内存块j映射到 （j mod 64）缓存组</p><p>每组有K个块称为<strong>K路组相联缓存</strong></p><h4 id="2路相联映射（每组两个块-是两个块而不是每组两个数据，数据是和字节偏移对应的）"><a href="#2路相联映射（每组两个块-是两个块而不是每组两个数据，数据是和字节偏移对应的）" class="headerlink" title="2路相联映射（每组两个块-是两个块而不是每组两个数据，数据是和字节偏移对应的）"></a><strong>2路相联映射</strong>（每组两个块-是两个块而不是每组两个数据，数据是和字节偏移对应的）</h4><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L010-cache/image-20230523103657398.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="2way"></p><p>2路组相联（2-way set associative）：</p><p>CPU需要访问数据，其地址为[A7B4]&#x3D;1010011110110100</p><p>1、检测缓存组111011</p><ul><li>缓存块1110110</li><li>缓存块1110111</li></ul><p>2、检测缓存组中是否其中一个缓存块的标签为101001</p><p>3、如果是，命中</p><p>4、如果不是，从内存读取该块到缓存组111011中空闲的缓存块（如果没有空闲缓存块，就采用缓存替换策略进行替换），并更新tag为101001</p><h4 id="MIPS中的组相联映射缓存"><a href="#MIPS中的组相联映射缓存" class="headerlink" title="MIPS中的组相联映射缓存"></a><strong>MIPS中的组相联映射缓存</strong></h4><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L010-cache/image-20230523103738074.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="组相联"></p><h2 id="四-替换策略"><a href="#四-替换策略" class="headerlink" title="四.替换策略"></a>四.<strong>替换策略</strong></h2><h3 id="处理缓存的读请求"><a href="#处理缓存的读请求" class="headerlink" title="处理缓存的读请求"></a><strong>处理缓存的读请求</strong></h3><ul><li>适用于I cache和D cache</li><li>命中<ul><li>顺利读取数据</li></ul></li><li>缺失<ul><li>阻塞流水线</li><li>从下层存储层级获取请求的数据</li><li>数据保存至缓存，读取请求的字</li><li>恢复流水线运行</li></ul></li></ul><h3 id="处理缓存写命中"><a href="#处理缓存写命中" class="headerlink" title="处理缓存写命中"></a><strong>处理缓存写命中</strong></h3><p>D cache</p><table><thead><tr><th><strong>策略1：写直达（Write-Through）</strong></th></tr></thead><tbody><tr><td>保持缓存和内存数据的一致性</td></tr><tr><td>将数据同时写回到缓存和下层存储层级</td></tr><tr><td>加入写缓缓冲（write  buffer），只有写缓冲满时才停止写回缓存</td></tr></tbody></table><table><thead><tr><th><strong>策略2：写回(Write-Back）</strong></th></tr></thead><tbody><tr><td>只将数据写回到缓存</td></tr><tr><td>只有需要将缓存块驱逐（evicted）时，才写回到下层存储层级</td></tr><tr><td>每个缓存块需要1  bit 脏块（dirty）标记</td></tr></tbody></table><h3 id="处理缓存写缺失"><a href="#处理缓存写缺失" class="headerlink" title="处理缓存写缺失"></a><strong>处理缓存写缺失</strong></h3><table><thead><tr><th><strong>策略1：带写缓冲的写直达缓存</strong></th></tr></thead><tbody><tr><td>没有写分配（No-write  allocate）：内存块更新后，不重新载入缓存</td></tr><tr><td>跳过缓存更新，但是需要将该缓存块置位无效</td></tr><tr><td>将写回数据写入写缓冲</td></tr></tbody></table><table><thead><tr><th><strong>策略2：写回缓存</strong></th></tr></thead><tbody><tr><td>写分配</td></tr><tr><td>更新缓存中的数据，包括标签和数据</td></tr><tr><td>不需要写命中检测</td></tr></tbody></table><h3 id="没有写分配的写直达缓存"><a href="#没有写分配的写直达缓存" class="headerlink" title="没有写分配的写直达缓存"></a><strong>没有写分配的写直达缓存</strong></h3><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L010-cache/image-20230523104254506.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="没有写分配"></p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L010-cache/image-20230523104314788.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="2"></p><h3 id="替换算法"><a href="#替换算法" class="headerlink" title="替换算法"></a><strong>替换算法</strong></h3><ul><li>直接映射：不需要选择替换的块</li><li>组相联映射：<ul><li>首先映射到有效位为0的项</li><li>如果没有，在该组的项中挑选一个项替换</li></ul></li><li>最近最少使用（Least-recently used，LRU）<ul><li>替换很长时间没有使用的块</li><li>不适用于超过4路的组相联映射</li></ul></li><li>随机替换<ul><li>当相联度较高时，与LRU性能类似</li></ul></li></ul><p><strong>缓存例子</strong></p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-built_in">short</span> A[<span class="hljs-number">10</span>][<span class="hljs-number">4</span>];<br><span class="hljs-built_in">int</span>   <span class="hljs-keyword">sum</span>=<span class="hljs-number">0</span>;<br><span class="hljs-built_in">int</span>   j,i;<br><span class="hljs-built_in">double</span> mean;<br><br><span class="hljs-comment">//forward loop</span><br><span class="hljs-keyword">for</span> (j=<span class="hljs-number">0</span>;j&lt;=<span class="hljs-number">9</span>;j++)<br>     <span class="hljs-keyword">sum</span> +=A[j][<span class="hljs-number">0</span>];<br><span class="hljs-comment">//backward loop</span><br><span class="hljs-keyword">for</span> (i=<span class="hljs-number">9</span>;i&gt;=<span class="hljs-number">0</span>;i--)<br>     A[i][<span class="hljs-number">0</span>]=A[i][<span class="hljs-number">0</span>]/mean;<br></code></pre></td></tr></table></figure><p>数据缓存大小为8 块</p><p>A [ 10 ] [4]存储地址空间为7A00-7A27</p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L010-cache/image-20230523104605859.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="tu"></p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L010-cache/image-20230523104644075.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="table"></p><p>假设采用16 bit地址，并且1 字大小为1 byte（也就是说没有字节偏移位）</p><ul><li>直接映射：13 bits 标签，3 bits 块号</li><li>全相联：16 bits标签</li><li>2路组相联：15 bits 标签，1 bit组号</li></ul><h3 id="直接映射"><a href="#直接映射" class="headerlink" title="直接映射"></a><strong>直接映射</strong></h3><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L010-cache/image-20230523104721334.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="direct"></p><ul><li>只有两个缓存块被使用（注意看，都是A[X] [0],只看上面标红的地址7A00&amp;7A04）,读图以列为状态单位，从左往右读，比如j&#x3D;0时，cache里块0装A00;j&#x3D;1时，块0还是A00，块4新写入A10</li><li>缓存利用率低</li></ul><h3 id="全相联映射-1"><a href="#全相联映射-1" class="headerlink" title="全相联映射"></a><strong>全相联映射</strong></h3><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L010-cache/image-20230523104817036.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="all"></p><p>使用LRU替换策略</p><h3 id="2路组相联"><a href="#2路组相联" class="headerlink" title="2路组相联"></a><strong>2路组相联</strong></h3><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L010-cache/image-20230523104855835.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="2way"></p><p>只有一半的缓存块被使用</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a><strong>分析</strong></h3><ul><li>全相联映射缓存最好，组相联缓存次之，直接映射缓存最差</li><li>通常情况使用组相联映射，并采用LRU替换策略</li><li>较大的cache 块能更好地利用空间局部性以降低缺失率</li><li>在固定块大小的cache中<ul><li>较大块-&gt;块的数量减少</li><li>地址映射的竞争增大-&gt;增加缺失率(用直接映射来思考，块数量少了，一个缓存块需要对应的内存块就更多了，竞争大)</li><li>较大块-&gt;空间局部性降低</li></ul></li></ul><h2 id="五-小结"><a href="#五-小结" class="headerlink" title="五.小结"></a><strong>五.小结</strong></h2><ul><li>缓存结构<ul><li>直接映射、全相联映射、组相联映射</li></ul></li><li>替换策略<ul><li>随机替换、LRU</li></ul></li><li>缓存命中与缺失代价</li></ul>]]></content>
    
    
    <categories>
      
      <category>学习资料</category>
      
    </categories>
    
    
    <tags>
      
      <tag>课件笔记</tag>
      
      <tag>计算机组成原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ARM体系结构与编程-第4章-ARM程序设计基础-伪指令2</title>
    <link href="/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC4%E7%AB%A0-ARM%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%80-%E4%BC%AA%E6%8C%87%E4%BB%A42/"/>
    <url>/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC4%E7%AB%A0-ARM%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%80-%E4%BC%AA%E6%8C%87%E4%BB%A42/</url>
    
    <content type="html"><![CDATA[<h1 id="ARM体系结构与编程"><a href="#ARM体系结构与编程" class="headerlink" title="ARM体系结构与编程"></a>ARM体系结构与编程</h1><h2 id="第4章-ARM程序设计基础"><a href="#第4章-ARM程序设计基础" class="headerlink" title="第4章 ARM程序设计基础"></a><strong>第4章</strong> ARM程序设计基础</h2><h2 id="4-2-汇编语言的语句格式"><a href="#4-2-汇编语言的语句格式" class="headerlink" title="4.2 汇编语言的语句格式"></a>4.2 汇编语言的语句格式</h2><ul><li>ARM（Thumb）汇编语言的语句格式为：</li><li><strong>{标号}  {指令或伪指令}  {；注释}</strong></li><li>标号必须从一行的行头开始，并且符号中不能包含空格。</li><li>指令不能从一行的行头开始，即在一行语句中，指令的前面必须有空格或者标号。</li><li>在汇编语言程序设计中，每一条指令的助记符可以全部用大写、或全部用小写，但不允许在一条指令中大、小写混用。</li><li>寄存器可以大写或小写。</li><li>伪指令有些必须在一行的开头顶格书写，另外一些必须留有空格。</li><li>注释以分号“；”开头，到行末结束。</li><li>如果一条语句太长，可将该长语句分为若干行来书写，在行的末尾用“****”表示下一行与本行为同一条语句。</li><li>在源程序中，语句之间可以插入空行，增强可读性。</li></ul><p><strong>常数：数值、布尔值、字符或字符串</strong></p><ul><li>数字：十进制数、十六进制数</li><li>布尔值：{TRUE&#x2F;FALSE}</li><li>字符：由左右单引号组成</li><li>字符串：由左右双引号括住多个字符或空格组成</li></ul><p><img src="/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC4%E7%AB%A0-ARM%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%80-%E4%BC%AA%E6%8C%87%E4%BB%A42/image-20230521221151411.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="主视图"></p><p><strong>汇编语言的源程序主要由指令、伪指令、语句标号和注释组成。</strong></p><ul><li>指令：一条指令一般是一个简短的汇编语句行，由指令助记符和操作数、操作寄存器或语句标号组成。</li><li>伪指令：<ul><li>通过伪指令把设计意图表达给编译器，编译器依据这些伪指令，组织、编译和连接程序；</li><li>大多数伪指令在编译后都不留痕迹。</li></ul></li><li>语句标号：语句标号的主要作用有两个：<ul><li>一是表达地址；</li><li>二是为一段语句命名，以方便记忆和阅读。</li></ul></li><li>注释：注释是为了方便阅读和记忆。</li></ul><h3 id="4-2-1-在汇编语言程序中常用的符号"><a href="#4-2-1-在汇编语言程序中常用的符号" class="headerlink" title="4.2.1 在汇编语言程序中常用的符号"></a><strong>4.2.1</strong> <strong>在汇编语言程序中常用的符号</strong></h3><ul><li>在汇编语言程序设计中，经常使用各种符号代替地址、变量和常量等，以增加程序的可读性。</li><li>尽管符号的命名由编程者决定，但并不是任意的，必须遵循以下的约定：<ul><li><strong>符号由大小写字母、数字以及下划线组成；</strong></li><li><strong>局部标号以数字开头，其他的符号都不能以数字开头；</strong></li><li><strong>符号区分大小写，同名的大、小写符号会被编译器认为是两个不同的符号；</strong></li><li><strong>符号在其作用范围内必须唯一；</strong></li><li><strong>自定义的符号名不能与系统的保留字相同；</strong></li><li><strong>符号名不应与指令或伪指令同名。</strong></li></ul></li></ul><h4 id="1、-程序中的变量"><a href="#1、-程序中的变量" class="headerlink" title="1、 程序中的变量"></a>1、 程序中的变量</h4><ul><li>程序中的变量是指其值在程序的运行过程中可以改变的量。ARM（Thumb）汇编程序所支持的变量有数字变量、逻辑变量和字符串变量。</li><li>数字变量用于在程序的运行中保存数字值，但注意数字值的大小不应超出数字变量所能表示的范围。</li><li>逻辑变量用于在程序的运行中保存逻辑值，逻辑值只有两种取值情况：真{true}或假{false}。</li><li>字符串变量用于在程序的运行中保存一个字符串，但注意字符串的长度不应超出字符串变量所能表示的范围。</li><li>在ARM（Thumb）汇编语言程序设计中，可使用GBLA、GBLL、GBLS伪指令声明全局变量；使用LCLA、LCLL、LCLS伪指令声明局部变量；并可使用SETA、SETL和SETS对其进行初始化。</li></ul><h4 id="2、-程序中的常量"><a href="#2、-程序中的常量" class="headerlink" title="2、 程序中的常量"></a>2、 程序中的常量</h4><ul><li>程序中的常量是指其值在程序的运行过程中不能被改变的量。ARM（Thumb）汇编程序所支持的常量有数字常量、逻辑常量和字符串常量。<ul><li>数字常量一般为32位的整数，当作为无符号数时，其取值范围为0～232-1；当作为有符号数时，其取值范围为-2^31～2^31-1。</li><li>逻辑常量只有两种取值情况：真或假。</li><li>字符串常量为一个固定的字符串，一般用于程序运行时的信息提示。</li></ul></li><li>使用EQU来定义数字常量。</li></ul><h4 id="3、-程序中的变量替换"><a href="#3、-程序中的变量替换" class="headerlink" title="3、 程序中的变量替换"></a>3、 程序中的变量替换</h4><ul><li>程序中的变量可通过替换操作取得一个常量。</li><li>替换操作符为“**$**”。<ul><li>如果在数字变量前面有一个代换操作符“$”，编译器会将该数字变量的值转换为十六进制的字符串，并将该十六进制的字符串替换“$”后的数字变量。</li><li>如果在逻辑变量前面有一个替换操作符“$”，编译器会将该逻辑变量替换为它的取值（真或假）。</li><li>如果在字符串变量前面有一个替换操作符“$”，编译器会将该字符串变量的值替换“$”后的字符串变量。</li></ul></li><li>使用示例：</li></ul><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs armasm"> <span class="hljs-meta">LCLS</span> <span class="hljs-built_in">S1</span> ；定义局部字符串变量<span class="hljs-built_in">S1</span>和<span class="hljs-built_in">S2</span><br><br> <span class="hljs-meta">LCLS</span> <span class="hljs-built_in">S2</span> <br><br> <span class="hljs-built_in">S1</span> <span class="hljs-meta">SETS</span> “Test！”<br><br> <span class="hljs-built_in">S2</span> <span class="hljs-meta">SETS</span> “This is a $<span class="hljs-built_in">S1</span>” <br><br>；字符串变量<span class="hljs-built_in">S2</span>的值为“This is a Test！”<br></code></pre></td></tr></table></figure><ul><li><p>变量替换的特殊情况：</p><ul><li>如果需要字符$，则用$$来表示。</li><li>包含在两个竖线（|）之间的$不进行变量替换，但如果竖线是在双引号内，则将进行变量替换。</li><li>使用“**.**”来表示变量名称的结束。</li><li></li><li></li><li></li></ul><p>例如</p></li><li><p>&#96;&#96;&#96;<br> STR1  SETS  “STRING”<br> STR2  SETS  “THISISA$STR1.INSETENCE”</p><figure class="highlight nestedtext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs nestedtext"><br>  <span class="hljs-comment">#### 4、标号</span><br><br>标号是表示程序中的指令或数据地址的符号，主要有三种：<br><br><span class="hljs-bullet">-</span> <span class="hljs-string">基于PC的标号</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">是位于目标指令前或者程序中数据定义伪操作前的标号。</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">被处理成PC值加上或减去一个数字常量。</span><br><span class="hljs-bullet">-</span> <span class="hljs-string">基于寄存器的标号</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">通常用MAP和FIELD伪操作定义，或用EQU伪操作定义。</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">被处理成寄存器的值加上或减去一个数字常量。</span><br><span class="hljs-bullet">-</span> <span class="hljs-string">绝对地址</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">绝对地址是一个32位的数字量。</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">寻址范围为0～231-1，即可以寻址整个内存空间。</span><br><br><span class="hljs-comment">#### 5、局部标号</span><br><br>局部标号主要在局部范围使用。<br><br>局部标号定义的语法格式：<br><br></code></pre></td></tr></table></figure></li></ul><p>N{routname}</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs excel"><br><span class="hljs-built_in">N</span>为<span class="hljs-number">0</span>－<span class="hljs-number">99</span>的数字,routname为当前作用范围的名称。<br><br>局部变量引用的语法格式：<br><br></code></pre></td></tr></table></figure><pre><code class="hljs">    %&#123;F|B&#125;&#123;A|T&#125;   N&#123;routname&#125;</code></pre><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs clean"><br>### **<span class="hljs-number">4.2</span><span class="hljs-number">.2</span>** **汇编语言程序中的表达式和运算符**<br><br>在汇编语言程序设计中，也经常使用各种表达式，表达式一般由变量、常量、运算符和括号构成。<br><br>常用的表达式有数字表达式、逻辑表达式和字符串表达式，其运算次序遵循如下的优先级：<br><br>- 优先级相同的双目运算符的运算顺序为从左到右。<br>- 相邻的单目运算符的运算顺序为从右到左，且单目运算符的优先级高于其他运算符。<br>- 括号运算符的优先级最高。<br><br>#### <span class="hljs-number">1</span>、 数字表达式及运算符<br><br>数字表达式一般由数字常量、数字变量、数字运算符和括号构成。与数字表达式相关的运算符如下：<br><br> “＋”、“－”、“×”、“/” 及“MOD”算术运算符<br><br> 以上的算术运算符分别代表加、减、乘、除和取余数运算。例如，以X和Y表示两个数字表达式，则：<br><br></code></pre></td></tr></table></figure><p>X＋Y;表示X与Y的和<br>X－Y;表示X与Y的差<br>X×Y;表示X与Y的乘积<br>X&#x2F;Y;表示X除以Y的商<br>X：MOD：Y;表示X除以Y的余数</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><br>“<span class="hljs-keyword">ROL</span>”、“<span class="hljs-keyword">ROR</span>”、“<span class="hljs-keyword">SHL</span>”及“<span class="hljs-keyword">SHR</span>”移位运算符<br><br> 以X和Y表示两个数字表达式，以上的移位运算符代表的运算如下：<br><br></code></pre></td></tr></table></figure><pre><code class="hljs">X：ROL：Y;表示将X循环左移Y位X：ROR：Y;表示将X循环右移Y位X：SHL：Y;表示将X左移Y位X：SHR：Y;表示将X右移Y位</code></pre><figure class="highlight tp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs tp"><br>“<span class="hljs-keyword">AND</span>”、“<span class="hljs-keyword">OR</span>”、“NOT”及“EOR”按位逻辑运算符<br><br> 以<span class="hljs-keyword">X</span>和<span class="hljs-keyword">Y</span>表示两个数字表达式，以上的**按位**逻辑运算符代表的运算如下：<br><br></code></pre></td></tr></table></figure><p>X：AND：Y;表示将X和Y按位作逻辑与的操作<br>X：OR：Y;表示将X和Y按位作逻辑或的操作<br>：NOT：Y;表示将Y按位作逻辑非的操作<br>X：EOR：Y;表示将X和Y按位作逻辑异或的操作</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs clean"><br>#### <span class="hljs-number">2</span>、 逻辑表达式及运算符<br><br>逻辑表达式一般由逻辑量、逻辑运算符和括号构成，其表达式的运算结果为真或假。与逻辑表达式相关的运算符如下：<br><br> “=”、“&gt;”、“&lt;”、“&gt;=”、“&lt;= ”、“/=”、“ &lt;&gt;” 运算符<br><br>以X和Y表示两个逻辑表达式，以上的运算符代表的运算如下<br><br></code></pre></td></tr></table></figure><pre><code class="hljs">X = Y;表示X等于YX &gt; Y;表示X大于YX &lt; Y;表示X小于YX &gt;= Y;表示X大于等于YX &lt;= Y;表示X小于等于YX /= Y;表示X不等于YX &lt;&gt; Y;表示X不等于Y</code></pre><figure class="highlight tp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs tp"><br>“LAND”、“LOR”、“LNOT”及“LEOR”运算符<br><br> 以<span class="hljs-keyword">X</span>和<span class="hljs-keyword">Y</span>表示两个逻辑表达式，以上的逻辑运算符代表的运算如下：<br><br></code></pre></td></tr></table></figure><p>X：LAND：Y;表示将X和Y作逻辑与的操作<br>X：LOR：Y;表示将X和Y作逻辑或的操作<br>：LNOT：Y;表示将Y作逻辑非的操作<br>X：LEOR：Y;表示将X和Y作逻辑异或的操作</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs clean"><br>操作结果为&#123;FALSE&#125;或&#123;TRUE&#125;<br><br>#### <span class="hljs-number">3</span>、 字符串表达式及运算符<br><br>字符串表达式一般由字符串常量、字符串变量、运算符和括号构成。编译器所支持的字符串最大长度为<span class="hljs-number">512</span>字节。常用的与字符串表达式相关的运算符如下：<br><br>**LEN运算符**<br><br> LEN运算符返回字符串的长度（字符数），以X表示字符串表达式，其语法格式如下：<br><br></code></pre></td></tr></table></figure><pre><code class="hljs">：LEN：X</code></pre><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs autoit"><br>**<span class="hljs-built_in">CHR</span>运算符**<br><br><span class="hljs-built_in">CHR</span>运算符将<span class="hljs-number">0</span>～<span class="hljs-number">255</span>之间的整数转换为一个ASCII字符，以M表示某一个整数，其语法格式如下：<br><br></code></pre></td></tr></table></figure><pre><code class="hljs">：CHR：M</code></pre><figure class="highlight hsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs hsp"><br>**<span class="hljs-keyword">STR</span>运算符**<br><br><span class="hljs-keyword">STR</span>运算符将将一个数字表达式或逻辑表达式转换为一个字符串。对于数字表达式，<span class="hljs-keyword">STR</span>运算符将其转换为一个以十六进制组成的字符串；对于逻辑表达式，<span class="hljs-keyword">STR</span>运算符将其转换为字符串T或F，其语法格式如下：<br><br></code></pre></td></tr></table></figure><pre><code class="hljs">：STR：X</code></pre><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css"><br> 其中，X为一个数字表达式或逻辑表达式。<br><br>**<span class="hljs-attribute">LEFT</span>运算符**<br><br> <span class="hljs-attribute">LEFT</span>运算符返回某个字符串左端的一个子串，其语法格式如下：<br><br></code></pre></td></tr></table></figure><pre><code class="hljs">X：LEFT：Y</code></pre><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css"><br> 其中：X为源字符串，Y为一个整数，表示要返回的字符个数。<br><br>**<span class="hljs-attribute">RIGHT</span>运算符**<br><br> 与<span class="hljs-attribute">LEFT</span>运算符相对应，<span class="hljs-attribute">RIGHT</span>运算符返回某个字符串右端的一个子串，其语法格式如下：<br><br></code></pre></td></tr></table></figure><pre><code class="hljs">X：RIGHT：Y</code></pre><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs stata"><br> 其中：X为源字符串，Y为一个整数，表示要返回的字符个数。<br><br><span class="hljs-comment">**CC运算符**</span><br><br> <span class="hljs-keyword">CC</span>运算符用于将两个字符串连接成一个字符串，其语法格式如下：<br><br></code></pre></td></tr></table></figure><pre><code class="hljs">X：CC：Y</code></pre><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs clean"><br> 其中：X为源字符串<span class="hljs-number">1</span>，Y为源字符串<span class="hljs-number">2</span>，CC运算符将Y连接到X的后面。<br><br>#### <span class="hljs-number">4</span>、 与寄存器和程序计数器（PC）相关的表达式及运算符<br><br> 常用的与寄存器和程序计数器（PC）相关的表达式及运算符如下：<br><br> **BASE运算符**<br><br>BASE运算符返回基于寄存器的表达式中寄存器的编号，其语法格式如下：<br><br></code></pre></td></tr></table></figure><p> ：BASE：X</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs delphi"><br> 其中，X为与寄存器相关的表达式。<br><br>**<span class="hljs-keyword">INDEX</span>运算符**<br><br> <span class="hljs-keyword">INDEX</span>运算符返回基于寄存器的表达式中相对于其基址寄存器的偏移量，其语法格式如下：<br><br></code></pre></td></tr></table></figure><p> ：INDEX：X</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs clean"><br> 其中，X为与寄存器相关的表达式。<br><br>####  <span class="hljs-number">5</span>、 其他常用运算符<br><br>**？运算符**<br><br> ？运算符返回某代码行所生成的可执行代码的长度，例如：<br><br></code></pre></td></tr></table></figure><pre><code class="hljs">?X</code></pre><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><br> 返回定义符号X的代码行所生成的可执行代码的字节数。<br><br>**<span class="hljs-keyword">DEF</span>运算符**<br><br> <span class="hljs-keyword">DEF</span>运算符判断是否定义某个符号，例如：<br><br></code></pre></td></tr></table></figure><pre><code class="hljs">：DEF：X</code></pre><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs gherkin"><br> 如果符号X已经定义，则结果为真，否则为假。<br><br>操作符运算顺序<br><br>|<span class="hljs-string">      </span>|<span class="hljs-string"> 单目操作                 </span>|<span class="hljs-string"> 备注           </span>|<br>|<span class="hljs-string"> ---- </span>|<span class="hljs-string"> ------------------------ </span>|<span class="hljs-string"> -------------- </span>|<br>|<span class="hljs-string"> 1    </span>|<span class="hljs-string"> *、/、MOD                </span>|<span class="hljs-string"> 乘除和取模     </span>|<br>|<span class="hljs-string"> 2    </span>|<span class="hljs-string"> SHL、SHR、ROR、ROL       </span>|<span class="hljs-string"> 移位运算       </span>|<br>|<span class="hljs-string"> 3    </span>|<span class="hljs-string"> +、-、AND、OR、EOR       </span>|<span class="hljs-string"> 加减和逻辑运算 </span>|<br>|<span class="hljs-string"> 4    </span>|<span class="hljs-string"> ==、&gt;、&gt;=、&lt;、&lt;=、/=、&lt;&gt; </span>|<span class="hljs-string"> 各种逻辑运算   </span>|<br>|<span class="hljs-string"> 5    </span>|<span class="hljs-string"> LAND、LOR、LEOR          </span>|<span class="hljs-string"> 逻辑运算       </span>|<br><br><span class="hljs-comment">## 4.3 汇编语言的程序结构</span><br><br><span class="hljs-comment">### **4.3.1** **汇编语言的程序结构**</span><br><br>在ARM（Thumb）汇编语言程序中，以程序<span class="hljs-symbol">*</span><span class="hljs-symbol">*</span>段<span class="hljs-symbol">*</span><span class="hljs-symbol">*</span>为单位组织代码。段是相对独立的指令或数据序列，具有特定的名称。<br><br>段可以分为代码段和数据段，代码段的内容为执行代码，数据段存放代码运行时需要用到的数据。<br><br>一个汇编程序至少应该有一个代码段，当程序较长时，可以分割为多个代码段和数据段，多个段在程序编译链接时最终形成一个可执行的映象文件。<br><br>可执行映象文件通常由以下几部分构成：<br><br>- <span class="hljs-symbol">*</span><span class="hljs-symbol">*</span>一个或多个代码段，代码段的属性为只读。<span class="hljs-symbol">*</span><span class="hljs-symbol">*</span><br>- <span class="hljs-symbol">*</span><span class="hljs-symbol">*</span>零个或多个包含初始化数据的数据段，数据段的属性为可读写。<span class="hljs-symbol">*</span><span class="hljs-symbol">*</span><br>- <span class="hljs-symbol">*</span><span class="hljs-symbol">*</span>零个或多个不包含初始化数据的数据段，数据段的属性为可读写<span class="hljs-symbol">*</span><span class="hljs-symbol">*</span><br><br>链接器根据系统默认或用户设定的规则，将各个段安排在存储器中的相应位置。因此源程序中段之间的相对位置与可执行的映象文件中段的相对位置一般不会相同。<br><br>文件应该按功能构成，尽可能把一个功能完整地编辑在同一个文件中，这样便于调试和修改。<br><br>尽量减少一个文件与其他文件之间的关联，尽量减少文件的入口和出口，这样使程序条理更加清晰。<br><br>一个文件中代码段和数据段地设立不要过多，应该把夹在代码段中的数据缓冲区尽可能的集中在一起。<br><br>最好把Thumb指令设计为单独的段，并把ARM指令段和Thumb指令段分开存储。<br><br>数据存储区也要按功能划分，特权模式和用户模式程序使用不同的存储区块，以便对这些存储区块进行属性定义。<br><br>以下是一个汇编语言源程序的基本结构：<br><br></code></pre></td></tr></table></figure><pre><code class="hljs">    AREAInit，CODE，READONLY</code></pre><p>     ENTRY<br>start<br>     LDRR0，&#x3D;0x3FF5000<br>     LDRR1，0xFF<br>     STRR1，[R0]<br>     LDRR0，&#x3D;0x3FF5008<br>     LDRR1，0x01<br>     STRR1，[R0]<br>     ………<br>     END</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><br>&gt; 在汇编语言程序中，用<span class="hljs-meta">AREA</span>伪指令定义一个段，并说明所定义段的相关属性，本例定义一个名为Init的代码段，属性为只读。<span class="hljs-meta">ENTRY</span>伪指令标识程序的入口点，接下来为指令序列，程序的末尾为<span class="hljs-meta">END</span>伪指令，该伪指令告诉编译器源文件的结束，每一个汇编源程序都必须有一条<span class="hljs-meta">END</span>伪指令，指示源程序的结束。<br><br><span class="hljs-comment">### **4.3.2** **汇编语言的子程序调用**</span><br><br>在<span class="hljs-meta">ARM</span>汇编语言程序中，子程序的调用一般是通过**BL**指令来实现的。在程序中，使用指令：<br><br></code></pre></td></tr></table></figure><p> BL 子程序名</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><br> 即可完成子程序的调用。<br><br>该指令在执行时完成如下操作：<br><br>- 将子程序的返回地址存放在连接寄存器<span class="hljs-built_in">LR</span>中，同时将程序计数器<span class="hljs-built_in">PC</span>指向子程序的入口点。<br>- 当子程序执行完毕需要返回调用处时，只需要将存放在<span class="hljs-built_in">LR</span>中的返回地址重新拷贝给程序计数器<span class="hljs-built_in">PC</span>即可。<br><br>在调用子程序的同时，也可以完成参数的传递和从子程序返回运算的结果，通常可以使用寄存器<span class="hljs-built_in">R0</span>～<span class="hljs-built_in">R3</span>完成。<br><br><br><br>以下是使用BL指令调用子程序的汇编语言源程序的基本结构：<br><br></code></pre></td></tr></table></figure><pre><code class="hljs">AREAInit，CODE，READONLENTRY</code></pre><p>  start<br>     LDRR0，&#x3D;0x3FF5000<br>     LDRR1，0xFF<br>     STRR1，[R0]<br>     LDRR0，&#x3D;0x3FF5008<br>     LDRR1，0x01<br>     STRR1，[R0]<br>     BLPRINT_TEXT<br>     ;………<br>  PRINT_TEXT<br>     ;………<br>     ;………</p><pre><code class="hljs"> MOVPC，LR</code></pre><p>         <br>   END</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs clean"><br>### **<span class="hljs-number">4.3</span><span class="hljs-number">.3</span>** **汇编语言程序示例**<br><br>以下是一个基于S3C4510B的串行通讯程序，在此仅说明一个完整汇编语言程序的基本结构：<br><br></code></pre></td></tr></table></figure><pre><code class="hljs">; *********************************************************************;   Software Engineering Institute East China Normal University;    Description:  This example shows the UART communication！;    Author:   BBsitman;    Date:;**********************************************************************UARTLCON0EQU0x3FFD000</code></pre><p>    UARTCONT0EQU0x3FFD004<br>    UARTSTAT0EQU 0x3FFD008<br>    UTXBUF0EQU0x3FFD00C<br>    UARTBRD0EQU0x3FFD014<br>        AREA Init,CODE,READONLY<br>        ENTRY<br>    ;   **************************************************<br>    ;   LED Display<br>    ;   **************************************************<br>        LDRR1,&#x3D;0x3FF5000<br>        LDRR0,&#x3D;&amp;ff<br>        STRR0,[R1]<br>        LDRR1,&#x3D;0x3FF5008<br>        LDRR0,&#x3D;&amp;ff<br>        STRR0,[R1]<br>    ;   *************************************************<br>    ;   UART0 line control register<br>    ;   *************************************************<br>        LDRR1,&#x3D;UARTLCON0<br>        LDRR0,&#x3D;0x03<br>        STRR0,[R1]<br>    ;   **************************************************<br>    ;   UART0 control regiser<br>    ;   **************************************************<br>        LDRR1,&#x3D;UARTCONT0<br>        LDRR0,&#x3D;0x9<br>        STRR0,[R1]<br>    ;   **************************************************<br>    ;   UART0 baud rate divisor regiser<br>    ;   Baudrate&#x3D;19200，对应于50MHz的系统工作频率<br>    ;  ***************************************************<br>        LDRR1,&#x3D;UARTBRD0<br>        LDRR0,&#x3D;0x500<br>        STRR0,[R1]<br>    ;  ***************************************************<br>    ;  Print the messages!<br>    ;  ***************************************************<br>    LOOP<br>        LDRR0,&#x3D;Line1<br>        BLPrintLine<br>        LDRR0,&#x3D;Line2<br>        BLPrintLine<br>        LDRR0,&#x3D;Line3<br>        BLPrintLine<br>        LDRR0,&#x3D;Line4<br>        BLPrintLine<br>        LDRR1,&#x3D;0x7FFFFF<br>    LOOP1<br>        SUBSR1,R1,#1<br>        BNELOOP1<br>        BLOOP<br>    ;  ***************************************************<br>    ; Print line<br>    ; ***************************************************<br>    PrintLine<br>        MOVR4,LR<br>        MOVR5,R0<br>    Line<br>        LDRBR1,[R5],#1<br>        ANDR0,R1,#&amp;FF<br>        TSTR0,#&amp;FF<br>        MOVEQPC,R4<br>        BLPutByte<br>        BLine<br>    PutByte<br>        LDRR3,&#x3D;UARTSTAT0<br>        LDRR2,[R3]<br>        TSTR2,#&amp;40<br>        BEQPutByte<br>        LDRR3,&#x3D;UTXBUF0<br>        STRR0,[R3]<br>        MOVPC,LR<br>    Line1 DCB  &amp;A,&amp;D,”******************************************************************”,0<br>    Line2 DCB&amp;A,&amp;D,”Chinese Academy of Sciences,Institute of Automation,Complex System Lab.”,0<br>    Line3 DCB&amp;A,&amp;D,”ARM Development Board Based on Samsung ARM S3C4510B.”,0<br>    Line4 DCB  &amp;A,&amp;D,&amp;A,&amp;D,&amp;A,&amp;D,&amp;A,&amp;D,&amp;A,&amp;D,&amp;A,&amp;D,&amp;A,&amp;D,&amp;A,&amp;D,&amp;A,&amp;D,&amp;A,&amp;D,&amp;A,&amp;D,&amp;A,&amp;D,&amp;A<br>     DCB&amp;D,&amp;A,&amp;D,&amp;A,&amp;D,0<br>    END</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><br><span class="hljs-comment">## 4.4 本章小节</span><br><br>本章介绍了<span class="hljs-meta">ARM</span>程序设计的一些基本概念，以及在汇编语言程序设计中常见的伪指令、汇编语言的基本语句格式等，汇编语言程序的基本结构等，这些问题均为程序设计中的基本问题，要求理解并掌握。<br><br>练习:<br><br><span class="hljs-number">1</span>、用LDM/STM实现一块连续内存单元之间的数据传输（块复制）。<br><br>- <span class="hljs-built_in">R12</span>指向数据块的起始地址，<span class="hljs-built_in">r14</span>指向数据块的结束地址，<span class="hljs-built_in">r13</span>指向目的处的起始地址。<br><br><span class="hljs-number">2</span>、函数的调用与返回<br><br>- 以题<span class="hljs-number">1</span>块拷贝的功能模块作为函数体，写出该函数原型；<br>- 写出函数blockcopy调用的相关代码。<br><br><span class="hljs-number">3</span>、利用<span class="hljs-meta">ARM</span>指令具有条件执行的功能写出下列C代码对应的汇编代码。要求按照<span class="hljs-meta">ARM</span>汇编程序语法书写。<br><br></code></pre></td></tr></table></figure><p>int a&#x3D;1,b&#x3D;4;<br>if (a&gt;b)<br>   a&#x3D;b+1;<br>else<br>   b&#x3D;a+1;<br>return a-b;</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs"><br></code></pre></td></tr></table></figure><p>int i,a[10]&#x3D;{0,1,2,3,4,5,6,7,8,9};<br>for (i&#x3D;0;i&lt;10;i++)<br>   a[i]&#x3D;a[i]+i;</p><pre><code class="hljs"></code></pre>]]></content>
    
    
    <categories>
      
      <category>学习资料</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ARM体系结构与编程</tag>
      
      <tag>课件笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机组成原理-L09-memory</title>
    <link href="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L09-memory/"/>
    <url>/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L09-memory/</url>
    
    <content type="html"><![CDATA[<h1 id="计算机组成与实践-存储体系结构"><a href="#计算机组成与实践-存储体系结构" class="headerlink" title="计算机组成与实践 -存储体系结构"></a><strong>计算机组成与实践</strong> -<strong>存储体系结构</strong></h1><h2 id="一-简介"><a href="#一-简介" class="headerlink" title="一.简介"></a>一.<strong>简介</strong></h2><h3 id="计算机主要组成部件"><a href="#计算机主要组成部件" class="headerlink" title="计算机主要组成部件"></a><strong>计算机主要组成部件</strong></h3><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L09-memory/image-20230509224246838.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="组件"></p><h3 id="存储“墙”问题"><a href="#存储“墙”问题" class="headerlink" title="存储“墙”问题"></a><strong>存储“墙”问题</strong></h3><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L09-memory/image-20230509224627637.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="发展限制"></p><h4 id="存储器发展"><a href="#存储器发展" class="headerlink" title="存储器发展"></a><strong>存储器发展</strong></h4><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L09-memory/image-20230509224648379.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="发展"></p><h4 id="存储系统"><a href="#存储系统" class="headerlink" title="存储系统"></a><strong>存储系统</strong></h4><p>存储器容量由寻址策略决定</p><table><thead><tr><th><strong>例如：</strong></th></tr></thead><tbody><tr><td>采用16位地址，寻址空间大小为2^16&#x3D;65536存储单元</td></tr></tbody></table><p>大多数存储器是字节可寻址（byte-addressable）</p><p>每个存储单元的大小为1字节</p><p>大多数计算机以字为单位（word）检索或存储数据</p><p>常用缩写：</p><blockquote><p>1K ≈ 2^10（Kilo）</p><p>1M ≈ 2^20（Mega）</p><p>1G ≈ 2^30（Giga）</p><p>1T ≈ 2^40（Tera）</p></blockquote><h4 id="主存访问模式"><a href="#主存访问模式" class="headerlink" title="主存访问模式"></a><strong>主存访问模式</strong></h4><p>数据传输通过</p><ul><li>MAR：地址寄存器</li><li>MDR：数据寄存器</li></ul><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L09-memory/image-20230509225449676.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="交互"></p><h4 id="主存的基本结构"><a href="#主存的基本结构" class="headerlink" title="主存的基本结构"></a><strong>主存的基本结构</strong></h4><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L09-memory/image-20230509225512428.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="贮存结构"></p><h4 id="存储系统设计"><a href="#存储系统设计" class="headerlink" title="存储系统设计"></a><strong>存储系统设计</strong></h4><p>处理器的运行速度远快于存储访问速度</p><ul><li>小容量访问速度快，大容量访问速度慢</li><li>设计缓存存储常用数据加速存储访问速度</li></ul><p>内存容量有限：</p><ul><li>使用虚拟存储器增加内存容量</li><li>内存管理单元（memory management unit，MMU）进行虚拟地址与物理地址之间的转换</li></ul><h4 id="局部性原理"><a href="#局部性原理" class="headerlink" title="局部性原理"></a><strong>局部性原理</strong></h4><p>程序局部性的访问地址空间</p><table><thead><tr><th><strong>时间局部性（Temporal locality）</strong></th></tr></thead><tbody><tr><td>如果某个数据项被访问，那么在不久的将来它可能再次被访问</td></tr></tbody></table><p>例如，loop循环中的指令</p><table><thead><tr><th><strong>空间局部性（Spatial locality）</strong></th></tr></thead><tbody><tr><td>如果某个数据项被询问，与它地址相邻的数据项可能很快也将被访问</td></tr></tbody></table><p>例如，顺序的指令执行，数组数据等</p><h5 id="利用局部性原理"><a href="#利用局部性原理" class="headerlink" title="利用局部性原理"></a><strong>利用局部性原理</strong></h5><ul><li>存储层次结构（Memory hierarchy）</li><li>所有数据存储在磁盘</li><li>最近访问的数据（相邻数据）从磁盘拷贝到较小的DRAM存储器<ul><li>主存（Main memory）</li></ul></li><li>最近经常访问的数据（相邻数据）从DRAM拷贝到更小的SRAM存储器<ul><li>缓存（Cache）</li></ul></li></ul><h4 id="存储体系结构"><a href="#存储体系结构" class="headerlink" title="存储体系结构"></a><strong>存储体系结构</strong></h4><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L09-memory/image-20230509230258739.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="tu"></p><h4 id="计算机的存储器是如何运作的"><a href="#计算机的存储器是如何运作的" class="headerlink" title="计算机的存储器是如何运作的"></a><strong>计算机的存储器是如何运作的</strong></h4><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L09-memory/image-20230509230312003.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="tt"></p><p><a href="https://www.bilibili.com/video/av19939336/">https://www.bilibili.com/video/av19939336/</a></p><h4 id="相关术语"><a href="#相关术语" class="headerlink" title="相关术语"></a><strong>相关术语</strong></h4><table><thead><tr><th><strong>随机访问存储器（Random Access Memory, RAM）</strong></th></tr></thead><tbody><tr><td>根据地址访问存储空间中的单元  Ø存储空间中的任意地址的访问时间相同</td></tr></tbody></table><table><thead><tr><th><strong>块（Block）</strong></th></tr></thead><tbody><tr><td>缓存中数据交换的最小单元</td></tr></tbody></table><p>命中率（Hit Rate）：在高层存储器中找到目标数据的存储访问比例</p><p>缺失率（Miss Rate）：在高层存储器中不能找到目标数据的存储访问比例，Miss Rate &#x3D; 1 - Hit Rate</p><table><thead><tr><th><strong>命中时间（Hit Time）</strong></th></tr></thead><tbody><tr><td>访问某存储器层次结构所需的时间，包括了判断当前访问是命中还是缺失所需的时间</td></tr></tbody></table><table><thead><tr><th><strong>缺失代价（Miss Penalty）</strong></th></tr></thead><tbody><tr><td>将相应的块从低层存储器器替换到高层存储器所需的时间，包括访问块、将数据逐层传输、将数据插入缺失的层和将目标块传递给请求者的时间</td></tr></tbody></table><p>命中时间 &lt;&lt; 缺失代价</p><h4 id="带宽和延迟"><a href="#带宽和延迟" class="headerlink" title="带宽和延迟"></a><strong>带宽和延迟</strong></h4><ul><li>带宽（Bandwidth）<ul><li>描述数据传输时每秒传输的数据量（bits or bytes）</li></ul></li><li>延迟（Latency）<ul><li>发出访问信号到开始传输第一个字的时间</li><li>以时钟周期为单位</li></ul></li></ul><h2 id="二-寄存器"><a href="#二-寄存器" class="headerlink" title="二.寄存器"></a>二.<strong>寄存器</strong></h2><h3 id="基于反馈的存储"><a href="#基于反馈的存储" class="headerlink" title="基于反馈的存储"></a><strong>基于反馈的存储</strong></h3><p>给两个反相器加上反馈信号</p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L09-memory/image-20230509230512552.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="中间可以稳定输出1信号"></p><p>通常称为交叉耦合反相器（Cross-coupled Inverter）</p><p>稳定存储1 bit数据的方式</p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L09-memory/image-20230509230537433.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="0/1"></p><h3 id="S-R锁存器（latch）"><a href="#S-R锁存器（latch）" class="headerlink" title="S-R锁存器（latch）"></a><strong>S-R锁存器（latch）</strong></h3><ul><li><p>用或非门替换反相器</p></li><li><p><strong>S-R锁存器（set-reset Latch）</strong></p><blockquote><p>这个是数电讲过的东西吧</p></blockquote></li></ul><table><thead><tr><th><strong>锁存器（latch）</strong></th></tr></thead><tbody><tr><td>一种存储元件，它的输出与内部存储的状态一致，并且当时钟有效时，只要输入发生变化，存储状态就会随之发生变化。</td></tr></tbody></table><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L09-memory/image-20230509230624503.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="锁存器"></p><table><thead><tr><th>input</th><th></th><th>output</th></tr></thead><tbody><tr><td>A</td><td>B</td><td>(A+B) ̅</td></tr><tr><td>0</td><td>0</td><td>1</td></tr><tr><td>1</td><td>0</td><td>0</td></tr><tr><td>0</td><td>1</td><td>0</td></tr><tr><td>1</td><td>1</td><td>0</td></tr></tbody></table><p>根据不同的R，S输入，Q的值</p><ul><li>R&#x3D;S&#x3D;0：Q&#x3D;1(其实是保持上次信号，Q不一定是1)</li><li>S&#x3D;0，R&#x3D;1：Q&#x3D;0</li><li>S&#x3D;1，R&#x3D;0：Q&#x3D;1</li><li>R&#x3D;S&#x3D;1：亚稳定状态</li></ul><blockquote><p>S是set，置位1</p><p>R是reset，复位0</p></blockquote><h3 id="D锁存器"><a href="#D锁存器" class="headerlink" title="D锁存器"></a>D锁存器</h3><p>D锁存器：</p><ul><li>两个输入：要存储的数据D，时钟信号C</li><li>两个输出：输出信号Q，其反向信号Q ̅</li><li>当输入时钟C有效时，锁存器称为打开状态，此时输出信号Q 的值为输入信号D 的值。</li><li>当输入时钟无效时，锁存器处于关闭状态，输出信号Q 等于锁存器最后一次打开时所存储的数据。</li></ul><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L09-memory/image-20230509231108004.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="D锁存器"></p><h3 id="D触发器（flip-flop）"><a href="#D触发器（flip-flop）" class="headerlink" title="D触发器（flip-flop）"></a><strong>D触发器（flip-flop）</strong></h3><table><thead><tr><th><strong>触发器（flip-flop）</strong></th></tr></thead><tbody><tr><td>一种存储元件，它的输出与内部存储的状态一致，并且内部状态只在时钟的边沿发生变化。</td></tr></tbody></table><ul><li>下降沿触发的D触发器<ul><li>第一个锁存器称为主锁存器，第二个锁存器称为从锁存器</li><li>当输入时钟C有效时，主锁存器打开，输入数据D。</li><li>当输入时钟C被拉低时，主锁存器关闭，但第二个锁存器打开，并且主锁存器的输出作为第二个锁存器的输入信号。</li></ul></li></ul><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L09-memory/image-20230509231211938.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="D"></p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L09-memory/image-20230509231230264.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="Q"></p><h3 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a><strong>寄存器</strong></h3><p>D触发器构造寄存器</p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L09-memory/image-20230509231254101.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="寄存器构造"></p><h2 id="三-随机访问存储器（RAM）"><a href="#三-随机访问存储器（RAM）" class="headerlink" title="三.随机访问存储器（RAM）"></a>三.<strong>随机访问存储器（RAM）</strong></h2><h3 id="静态随机存储器（SRAM）"><a href="#静态随机存储器（SRAM）" class="headerlink" title="静态随机存储器（SRAM）"></a><strong>静态随机存储器（SRAM）</strong></h3><ul><li>存储1 bit数据需要6个晶体管</li><li>大多数芯片使用SRAM</li><li>一对弱交叉耦合反相器</li><li>数据存储在交叉耦合反相器</li></ul><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L09-memory/image-20230509231428108.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="SRAM"></p><blockquote><p>X地址译码线（行选通）</p><p>Y地址译码线（列选通）</p><p>T1、T2保存数据；<br>T3、T4补充电荷；</p><p>T5、T6、T7、T8开关作用</p></blockquote><h4 id="静态存储器结构"><a href="#静态存储器结构" class="headerlink" title="静态存储器结构"></a><strong>静态存储器结构</strong></h4><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L09-memory/image-20230509231506116.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="结构"></p><ul><li>N位地址，寻址2n个存储单元，2n&#x2F;2+1根译码线</li><li>一行存储1 block数据（word line），列地址（bit line）选择请求访问的字节或字</li></ul><blockquote><p>按块存取，而非字节（具体取字节在内存中）</p></blockquote><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L09-memory/image-20230509231623323.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="配套"></p><h3 id="动态随机存储器（DRAM）"><a href="#动态随机存储器（DRAM）" class="headerlink" title="动态随机存储器（DRAM）"></a><strong>动态随机存储器（DRAM）</strong></h3><h4 id="1-T-DRAM存储单元"><a href="#1-T-DRAM存储单元" class="headerlink" title="1-T DRAM存储单元"></a><strong>1-T DRAM存储单元</strong></h4><ul><li>1个晶体管</li><li>需要一个存储电容（Capacitor）</li><li>提高存储密度</li><li>电容存储数据，有电荷为1，否则是0</li></ul><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L09-memory/image-20230509231818691.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="1-T"></p><h4 id="动态存储器结构"><a href="#动态存储器结构" class="headerlink" title="动态存储器结构"></a><strong>动态存储器结构</strong></h4><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L09-memory/image-20230509231851657.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="block"></p><h4 id="DRAM技术"><a href="#DRAM技术" class="headerlink" title="DRAM技术"></a><strong>DRAM技术</strong></h4><ul><li>存储单元使用电容保存电荷的方式来存储数据<ul><li>使用一个晶体管对电容进行访问</li><li>必须周期性的刷新才能保持数据<ul><li>读出内容再写回</li><li>对一整行数据进行刷新</li></ul></li></ul></li></ul><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L09-memory/image-20230509232024945.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="dram"></p><h4 id="DRAM的优化"><a href="#DRAM的优化" class="headerlink" title="DRAM的优化"></a><strong>DRAM的优化</strong></h4><ul><li>DRAM中的bit以矩形数组的结构组织排列<ul><li>DRAM访问一整行数据</li><li>突发模式（burst mode）：减少从行中连续访问字的开销</li></ul></li><li>双倍数据速率（Double data rate, DDR）DRAM<ul><li>在时钟的上升沿和下降沿传输数据，以获得双倍的数据带宽</li></ul></li><li>四倍数据速率（Quad data rate, QDR）DRAM<ul><li>将DDR的传输数据线路分为输入和输出，以获得四倍的数据带宽</li></ul></li></ul><h4 id="影响DRAM性能的因素"><a href="#影响DRAM性能的因素" class="headerlink" title="影响DRAM性能的因素"></a><strong>影响DRAM性能的因素</strong></h4><ul><li>行缓冲器（Row buffer）<ul><li>允许同时访问和刷新多个字的数据</li></ul></li><li>同步DRAM（Synchronous DRAM）<ul><li>以突发方式连续访问数据时，不需要发送所有字的地址</li><li>增加带宽</li></ul></li><li>DRAM划分存储块（banking）<ul><li>支持多个存储块的并发访问</li><li>增加带宽</li></ul></li></ul><h3 id="1到4代内存规格变化"><a href="#1到4代内存规格变化" class="headerlink" title="1到4代内存规格变化"></a><strong>1到4代内存规格变化</strong></h3><table><thead><tr><th><strong>内存规格</strong></th><th><strong>时钟频率</strong></th><th><strong>数据传输率</strong></th><th><strong>数据传输带宽</strong></th></tr></thead><tbody><tr><td>SDRAM-133</td><td>133MHz</td><td>133MT&#x2F;s</td><td>1.06GB&#x2F;s</td></tr><tr><td>DDR-266</td><td>133MHz</td><td>266MT&#x2F;s</td><td>2.1GB&#x2F;s</td></tr><tr><td>DDR2-533</td><td>133MHz</td><td>533MT&#x2F;s</td><td>4.2GB&#x2F;s</td></tr><tr><td>DDR3-1066</td><td>133MHz</td><td>1066MT&#x2F;s</td><td>8.5GB&#x2F;s</td></tr><tr><td>DDR3-1600</td><td>200MHz</td><td>1600MT&#x2F;s</td><td>12.8GB&#x2F;s</td></tr><tr><td>DDR4-2133</td><td>133MHz</td><td>2133MT&#x2F;s</td><td>21.3GB&#x2F;s</td></tr><tr><td>DDR4-3200</td><td>200MHz</td><td>3200MT&#x2F;s</td><td>25.6GB&#x2F;s</td></tr></tbody></table><h2 id="四-交叉存取（Interleaving）"><a href="#四-交叉存取（Interleaving）" class="headerlink" title="四.交叉存取（Interleaving）"></a>四.<strong>交叉存取（Interleaving）</strong></h2><h3 id="存储控制器（Memory-Controller）"><a href="#存储控制器（Memory-Controller）" class="headerlink" title="存储控制器（Memory Controller）"></a><strong>存储控制器（Memory Controller）</strong></h3><ul><li>控制处理器与存储器间交互</li><li>DRAM需要频繁刷新， 并且使用时分复用信号减少引脚数</li><li>SRAM管理简单，通常不需要存储控制器</li></ul><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L09-memory/image-20230509233656913.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="控制器"></p><p>RAS（CAS）：行（列）地址选通，CS：片选信号</p><h3 id="存储控制器"><a href="#存储控制器" class="headerlink" title="存储控制器"></a><strong>存储控制器</strong></h3><ul><li>存储控制器接收处理器发送的访问地址和R&#x2F;W信号</li><li>生成RAS和CAS信号</li><li>在RAS信号的控制下，部分高位地址作为行地址，选通存储结构中的某一行</li><li>在CAS信号的控制下，部分低位地址作为列地址，在选通的某一行存储结构中的选通某一列</li><li>根据地址选中相应的存储模块后，建立处理器与存储器间的数据线路</li><li>DRAM需要频繁刷新，但是刷新开销少于总存储访问时间的1%</li></ul><h3 id="存储模块交叉"><a href="#存储模块交叉" class="headerlink" title="存储模块交叉"></a><strong>存储模块交叉</strong></h3><ul><li>处理器和缓存访问速度快，内存访问慢</li><li>可以通过交叉访问几个存储模块来隐藏访问延迟</li><li>每个存储模块都有自己的地址缓冲寄存器（Address Buffer Register，ABR）和数据缓冲寄存器（Data Buffer Register，DBR）</li></ul><h4 id="存储模块交叉存取"><a href="#存储模块交叉存取" class="headerlink" title="存储模块交叉存取"></a><strong>存储模块交叉存取</strong></h4><p>处理器和缓存访问速度快，内存访问慢</p><p>可以通过交叉访问几个存储模块来隐藏访问延迟</p><p>每个存储模块都有自己的地址缓冲寄存器（Address Buffer Register，ABR）和数据缓冲寄存器（Data Buffer Register，DBR）</p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L09-memory/image-20230509233830558.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="2"></p><p><strong>哪种策略更好？</strong></p><p>两个或多个兼容的存储模块</p><p>在一个存储模块中，采用多个并行访问的片</p><table><thead><tr><th><strong>例如：</strong></th></tr></thead><tbody><tr><td>8个存储模块，每个模块有8个片，实现8×8&#x3D;64 bit的存储器总线</td></tr></tbody></table><p>交叉存储可以在类似双通道内存架构中实现</p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L09-memory/image-20230509233907811.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="2"></p><h3 id="非交叉存储V-S-交叉存储"><a href="#非交叉存储V-S-交叉存储" class="headerlink" title="非交叉存储V.S.交叉存储"></a><strong>非交叉存储V.S.交叉存储</strong></h3><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L09-memory/image-20230509233923890.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="vs"></p><h4 id="交叉存取例子"><a href="#交叉存取例子" class="headerlink" title="交叉存取例子"></a><strong>交叉存取例子</strong></h4><p>假设指令访问数据缓存发生read miss，需要从内存将数据读入缓存</p><p>缓存块大小为8 bytes</p><p>假设发送地址到内存花费1 个时钟周期，从内存发送数据花费1个时钟周期</p><p>此外，内存的访问延迟为6个时钟周期，即从接收到地址到发送第一个字节需要6个时钟周期</p><p>访问相同行的字节的延迟为4个时钟周期</p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L09-memory/image-20230509233958395.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="读取"></p><h4 id="非交叉存取"><a href="#非交叉存取" class="headerlink" title="非交叉存取"></a><strong>非交叉存取</strong></h4><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L09-memory/image-20230509234019380.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="非"></p><p>访问第一个字节需要6 cycles</p><p>假设所有随后的字节都在同一行，每个需要4 cycles</p><table><thead><tr><th><strong>非交叉存取</strong></th></tr></thead><tbody><tr><td>1+6+7×4+1&#x3D;  36 cycles</td></tr></tbody></table><h4 id="4个模块交叉存取"><a href="#4个模块交叉存取" class="headerlink" title="4个模块交叉存取"></a><strong>4个模块交叉存取</strong></h4><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L09-memory/image-20230509234104125.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="4"></p><table><thead><tr><th><strong>交叉存取</strong></th></tr></thead><tbody><tr><td>1+6+1×8&#x3D;  15 cycles</td></tr></tbody></table><h4 id="课题练习"><a href="#课题练习" class="headerlink" title="课题练习"></a><strong>课题练习</strong></h4><p>如果只有2个模块交叉存取，传输8 bytes数据，需要多少个时钟周期？</p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L09-memory/image-20230509234129094.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="4-8"></p><table><thead><tr><th><strong>交叉存取</strong></th></tr></thead><tbody><tr><td>1+6+2×3+1×8&#x3D;  21 cycles</td></tr></tbody></table><h2 id="五-二级存取器"><a href="#五-二级存取器" class="headerlink" title="五.二级存取器"></a>五.<strong>二级存取器</strong></h2><ul><li>长期的非易失性存储</li><li>存储体系结构的底层：访问速度慢、容量大、便宜</li><li>带有磁性图层的可旋转的圆盘</li><li>通过可移动的读&#x2F;写头来访问数据</li></ul><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L09-memory/image-20230509235235024.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="磁盘"></p><h3 id="闪存（Flash-Storage）"><a href="#闪存（Flash-Storage）" class="headerlink" title="闪存（Flash Storage）"></a><strong>闪存（Flash Storage）</strong></h3><p>磁盘替代者</p><p>固态硬盘（SSD）：基于闪存</p><p>非易失性，比磁盘快100~1000倍</p><p>磨损问题：采用磨损均衡技术</p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L09-memory/image-20230509235345912.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="flash"></p><h2 id="六-小结"><a href="#六-小结" class="headerlink" title="六.小结"></a>六.<strong>小结</strong></h2><ul><li>处理器速度与存储器的访问速度间不匹配问题——存储墙</li><li>通用RAM类型：<ul><li>SRAM、DRAM、SDRAM、DDR SDRAM</li></ul></li><li>局部性原理：时间局部性和空间局部性</li><li>存储体系结构：<ul><li>寄存器-&gt;缓存-&gt;内存-&gt;磁盘-&gt;磁带</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>学习资料</category>
      
    </categories>
    
    
    <tags>
      
      <tag>课件笔记</tag>
      
      <tag>计算机组成原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ARM体系结构与编程-第4章-ARM程序设计基础-伪指令1</title>
    <link href="/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC4%E7%AB%A0-ARM%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%80-%E4%BC%AA%E6%8C%87%E4%BB%A41/"/>
    <url>/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC4%E7%AB%A0-ARM%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%80-%E4%BC%AA%E6%8C%87%E4%BB%A41/</url>
    
    <content type="html"><![CDATA[<h1 id="ARM体系结构与编程"><a href="#ARM体系结构与编程" class="headerlink" title="ARM体系结构与编程"></a>ARM体系结构与编程</h1><h2 id="第4章-ARM程序设计基础"><a href="#第4章-ARM程序设计基础" class="headerlink" title="第4章 ARM程序设计基础"></a><strong>第4章</strong> ARM程序设计基础</h2><p>ARM编译器一般都支持汇编语言的程序设计和C&#x2F;C++语言的程序设计，以及两者的混合编程。本章介绍ARM程序设计的一些基本概念，如ARM汇编语言的伪指令、汇编语言的语句格式和汇编语言的程序结构等。</p><p>本章的主要内容：</p><ul><li>ARM编译器所支持的伪指令</li><li>汇编语言的语句格式</li><li>汇编语言的程序结构</li><li>相关的程序示例</li></ul><h2 id="4-1-ARM汇编器所支持的伪指令"><a href="#4-1-ARM汇编器所支持的伪指令" class="headerlink" title="4.1 ARM汇编器所支持的伪指令"></a>4.1 ARM汇编器所支持的伪指令</h2><p>在ARM汇编语言程序里，有一些特殊指令助记符，这些助记符与指令系统的助记符不同，没有相对应的操作码，通常称这些特殊指令助记符为<strong>伪指令</strong>，他们所完成的操作称为<strong>伪操作</strong>。</p><p>伪指令在源程序中的作用是为完成汇编程序作各种准备工作的，这些伪指令仅在汇编过程中起作用，一旦汇编结束，伪指令的使命就完成。</p><p>伪指令的两个基本特征：</p><ul><li>伪指令是一条指令；</li><li>伪指令不是一条真正的指令，通常没有指令代码。</li></ul><p>在ARM的汇编程序中，有如下几种伪指令：</p><ul><li>符号定义伪指令</li><li>数据定义伪指令</li><li>汇编控制伪指令</li><li>宏指令</li><li>其他伪指令</li></ul><h3 id="4-1-1-符号定义（Symbol-Definition）伪指令"><a href="#4-1-1-符号定义（Symbol-Definition）伪指令" class="headerlink" title="4.1.1 符号定义（Symbol Definition）伪指令"></a>4.1.1 符号定义（Symbol Definition）伪指令</h3><p>符号定义伪指令用于定义ARM汇编程序中的变量、对变量赋值以及定义寄存器的别名等操作。常见的符号定义伪指令有如下几种：</p><ul><li>用于定义全局变量的GBLA、GBLL和GBLS。</li><li>用于定义局部变量的LCLA、LCLL和LCLS。</li><li>用于对变量赋值的SETA、SETL、SETS。</li><li>为通用寄存器列表定义名称的RLIST。</li></ul><ol><li><h4 id="GBLA、GBLL和GBLS"><a href="#GBLA、GBLL和GBLS" class="headerlink" title="GBLA、GBLL和GBLS"></a>GBLA、GBLL和GBLS</h4></li></ol><p>语法格式：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-symbol">GBLA</span>（<span class="hljs-meta">GBLL</span>或<span class="hljs-meta">GBLS</span>） 全局变量名<br></code></pre></td></tr></table></figure><p>GBLA、GBLL和GBLS伪指令用于定义一个ARM程序中的全局变量，并将其初始化。其中：</p><ul><li>GBLA伪指令用于定义一个全局的数字变量，并初始化为0；</li><li>GBLL伪指令用于定义一个全局的逻辑变量，并初始化为F（假）；</li><li>GBLS伪指令用于定义一个全局的字符串变量，并初始化为空；</li></ul><p>由于以上三条伪指令用于定义全局变量，因此在整个程序范围内变量名必须唯一。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs abnf">使用示例：<br>GBLATest1<span class="hljs-comment">;定义一个全局的数字变量，</span><br><span class="hljs-comment">;变量名为Test1</span><br>Test1SETA<span class="hljs-number">0</span>xaa<span class="hljs-comment">;将该变量赋值为0xaa</span><br>GBLLTest2<span class="hljs-comment">;定义一个全局的逻辑变量，</span><br><span class="hljs-comment">;变量名为Test2</span><br>Test2SETL&#123;TRUE&#125;<span class="hljs-comment">;将该变量赋值为真</span><br>GBLSTest3<span class="hljs-comment">;定义一个全局的字符串变量，</span><br><span class="hljs-comment">;变量名为Test3</span><br>Test3SETS“Testing”   <span class="hljs-comment">;将该变量赋值为“Testing”</span><br><br></code></pre></td></tr></table></figure><ol start="2"><li><h4 id="LCLA、LCLL和LCLS"><a href="#LCLA、LCLL和LCLS" class="headerlink" title="LCLA、LCLL和LCLS"></a>LCLA、LCLL和LCLS</h4></li></ol><p>语法格式：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-symbol">LCLA</span>（<span class="hljs-meta">LCLL</span>或<span class="hljs-meta">LCLS</span>） 局部变量名<br></code></pre></td></tr></table></figure><p>LCLA、LCLL和LCLS伪指令用于定义一个ARM程序中的局部变量，并将其初始化。其中：</p><ul><li>LCLA伪指令用于定义一个局部的数字变量，并初始化为0；</li><li>LCLL伪指令用于定义一个局部的逻辑变量，并初始化为F（假）；</li><li>LCLS伪指令用于定义一个局部的字符串变量，并初始化为空；</li></ul><p>以上三条伪指令用于声明局部变量，在其作用范围内变量名必须唯一。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs abnf">使用示例：<br>LCLATest4<span class="hljs-comment">;声明一个局部的数字变量，</span><br><span class="hljs-comment">;变量名为Test4</span><br>Test3SETA<span class="hljs-number">0</span>xaa<span class="hljs-comment">;将该变量赋值为0xaa</span><br>LCLLTest5<span class="hljs-comment">;声明一个局部的逻辑变量，</span><br><span class="hljs-comment">;变量名为Test5</span><br>Test4SETL&#123;TRUE&#125; <span class="hljs-comment">;将该变量赋值为真</span><br>LCLSTest6<span class="hljs-comment">;定义一个局部的字符串变量，</span><br><span class="hljs-comment">;变量名为Test6</span><br>Test6SETS“Testing” <span class="hljs-comment">;将该变量赋值为“Testing”</span><br><br></code></pre></td></tr></table></figure><ol start="3"><li><h4 id="SETA、SETL和SETS"><a href="#SETA、SETL和SETS" class="headerlink" title="SETA、SETL和SETS"></a>SETA、SETL和SETS</h4></li></ol><p>语法格式：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs armasm">变量名 <span class="hljs-meta">SETA</span>（<span class="hljs-meta">SETL</span>或<span class="hljs-meta">SETS</span>） 表达式<br></code></pre></td></tr></table></figure><p>伪指令SETA、SETL、SETS用于给一个已经定义的全局变量或局部变量赋值。</p><ul><li>SETA伪指令用于给一个数学变量赋值；</li><li>SETL伪指令用于给一个逻辑变量赋值；</li><li>SETS伪指令用于给一个字符串变量赋值；</li><li>其中，变量名为已经定义过的全局变量或局部变量，表达式为将要赋给变量的值。</li></ul><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs abnf">使用示例：<br>LCLATest3 <span class="hljs-comment">;声明一个局部的数字变量，</span><br><span class="hljs-comment">;变量名为Test3</span><br>Test3SETA<span class="hljs-number">0</span>xaa <span class="hljs-comment">;将该变量赋值为0xaa</span><br>LCLLTest4 <span class="hljs-comment">;声明一个局部的逻辑变量，</span><br><span class="hljs-comment">;变量名为Test4</span><br>Test4SETL&#123;TRUE&#125; <span class="hljs-comment">;将该变量赋值为真</span><br>LCLSTest6 <span class="hljs-comment">;定义一个局部的字符串变量， ;变量名为Test6</span><br>Test5SETS“Testing” <span class="hljs-comment">;将该变量赋值为“Testing”</span><br><br></code></pre></td></tr></table></figure><ol start="4"><li><h4 id="RLIST"><a href="#RLIST" class="headerlink" title="RLIST"></a>RLIST</h4></li></ol><p>语法格式：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs armasm">名称 <span class="hljs-meta">RLIST</span>   &#123;寄存器列表&#125;<br></code></pre></td></tr></table></figure><p>RLIST伪指令可用于对一个通用寄存器列表定义名称，使用该伪指令定义的名称可在ARM指令LDM&#x2F;STM中使用。</p><p><strong>在LDM&#x2F;STM</strong>指令中，列表中的寄存器访问次序为根据寄存器的编号由低到高，而与列表中的寄存器排列次序无关。</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs armasm">使用示例：<br>RegList  <span class="hljs-meta">RLIST</span>   &#123;<span class="hljs-built_in">R0</span>-<span class="hljs-built_in">R5</span>，<span class="hljs-built_in">R8</span>，<span class="hljs-built_in">R10</span>&#125;<br><span class="hljs-comment">;将寄存器列表名称定义为RegList，</span><br><span class="hljs-comment">;可在ARM指令LDM/STM中通过</span><br><span class="hljs-comment">;该名称访问寄存器列表。</span><br></code></pre></td></tr></table></figure><h3 id="4-1-2-数据定义（Data-Definition）伪指令"><a href="#4-1-2-数据定义（Data-Definition）伪指令" class="headerlink" title="4.1.2 数据定义（Data Definition）伪指令"></a>4.1.2 数据定义（Data Definition）伪指令</h3><p>数据定义伪指令一般用于为特定的数据分配存储单元，同时可完成已分配存储单元的初始化。常见的数据定义伪指令有如下几种：</p><ul><li>DCB       用于分配一片连续的<strong>字节</strong>存储单元并用指定 的数据初始化。</li><li>DCW（DCWU）用于分配一片连续的<strong>半字</strong>存储单元并用指定的 数据初始化。</li><li>DCD（DCDU） 用于分配一片连续的<strong>字</strong>存储单元并用指定的数 据初始化。</li><li>DCFD（DCFDU） 用于为双精度的浮点数分配一片连续的字存 储单元并用指定的数据初始化。</li><li>DCFS（DCFSU）用于为单精度的浮点数分配一片连续的字存 储单元并用指定的数据初始化。</li><li>DCQ（DCQU）用于分配一片以8字节为单位的连续的存储单元 并用指定的数据初始化。</li><li>SPACE 用于分配一片连续的存储单元</li><li>MAP 用于定义一个结构化的内存表首地址</li><li>FIELD 用于定义一个结构化的内存表的数据域</li></ul><ol><li><h4 id="DCB"><a href="#DCB" class="headerlink" title="DCB"></a>DCB</h4></li></ol><p>语法格式：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs armasm">标号 <span class="hljs-meta">DCB</span> 表达式&#123;,表达式&#125;……<br></code></pre></td></tr></table></figure><p>DCB伪指令用于分配一片连续的字节存储单元并用伪指令中指定的表达式初始化。其中，表达式可以为0～255的数字或字符串。</p><p>DCB也可用“&#x3D;”代替。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">使用示例：<br><span class="hljs-built_in">string</span>DCB“This <span class="hljs-keyword">is</span> a test！”<br><span class="hljs-built_in">string</span>=“This <span class="hljs-keyword">is</span> a test！”<br>;分配一片连续的字节存储单元并初始化。<br></code></pre></td></tr></table></figure><ol start="2"><li><h4 id="DCW（或DCWU）"><a href="#DCW（或DCWU）" class="headerlink" title="DCW（或DCWU）"></a>DCW（或DCWU）</h4></li></ol><p>语法格式：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs armasm">标号 <span class="hljs-meta">DCW</span>（或<span class="hljs-meta">DCWU</span>） 表达式&#123;,表达式&#125;…..<br></code></pre></td></tr></table></figure><p>DCW（或DCWU）伪指令用于分配一片连续的半字存储单元并用伪指令中指定的表达式初始化。其中，表达式可以为程序标号或数字表达式。</p><p>用DCW分配的字存储单元是半字对齐的，而用DCWU分配的字存储单元并不严格半字对齐。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">使用示例：<br> DataTest DCW <span class="hljs-number">1</span>，<span class="hljs-number">2</span>，<span class="hljs-number">3</span><br> <span class="hljs-comment">;分配一片连续的半字存储单元并初始化</span><br></code></pre></td></tr></table></figure><ol start="3"><li><h4 id="DCD（或DCDU）"><a href="#DCD（或DCDU）" class="headerlink" title="DCD（或DCDU）"></a>DCD（或DCDU）</h4></li></ol><p>语法格式：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs armasm">标号  <span class="hljs-meta">DCD</span>（或<span class="hljs-meta">DCDU</span>） 表达式&#123;,表达式&#125;…..<br></code></pre></td></tr></table></figure><p>DCD（或DCDU）伪指令用于分配一片连续的字存储单元并用伪指令中指定的表达式初始化。其中，表达式可以为程序标号或数字表达式。</p><p>DCD也可用“&amp;”代替。</p><p>用DCD分配的字存储单元是字对齐的，而用DCDU分配的字存储单元并不严格字对齐。</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs 1c">使用示例：<br><br> DataTest DCD   <span class="hljs-number">4</span>，<span class="hljs-number">5</span>，<span class="hljs-number">6</span> <br><br> DataTest <span class="hljs-meta">&amp;   4，5，6 </span><br><br> ;分配一片连续的字存储单元并初始化。<br></code></pre></td></tr></table></figure><ol start="4"><li><h4 id="DCFD（或DCFDU）"><a href="#DCFD（或DCFDU）" class="headerlink" title="DCFD（或DCFDU）"></a>DCFD（或DCFDU）</h4></li></ol><p>语法格式：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs armasm">标号 <span class="hljs-meta">DCFD</span>（或<span class="hljs-meta">DCFDU</span>） 表达式&#123;,表达式&#125;…..<br></code></pre></td></tr></table></figure><p>DCFD（或DCFDU）伪指令用于为双精度的浮点数分配一片连续的字存储单元并用伪指令中指定的表达式初始化。每个双精度的浮点数占据两个字单元。</p><p>用DCFD分配的字存储单元是字对齐的，而用DCFDU分配的字存储单元并不严格字对齐。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">使用示例：<br> FDataTest   DCFD <span class="hljs-number">2</span>E115，-<span class="hljs-number">5</span>E7 <br>  <span class="hljs-comment">;分配一片连续的字存储单元并初始化为指定的双精度数。</span><br></code></pre></td></tr></table></figure><ol start="5"><li><h4 id="DCFS（或DCFSU）"><a href="#DCFS（或DCFSU）" class="headerlink" title="DCFS（或DCFSU）"></a>DCFS（或DCFSU）</h4></li></ol><p>语法格式：</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml">标号 DCFS（或DCFSU）表达式</span><span class="hljs-template-variable">&#123;,表达式&#125;</span><span class="language-xml">…..</span><br></code></pre></td></tr></table></figure><p>DCFS（或DCFSU）伪指令用于为单精度的浮点数分配一片连续的字存储单元并用伪指令中指定的表达式初始化。每个单精度的浮点数占据一个字单元。</p><p>用DCFS分配的字存储单元是字对齐的，而用DCFSU分配的字存储单元并不严格字对齐。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">使用示例：<br> FDataTest  DCFS <span class="hljs-number">2</span>E5，-<span class="hljs-number">5</span>E－<span class="hljs-number">7</span> <br><span class="hljs-comment">;分配一片连续的字存储单元并初始化为指定的单精度数。</span><br></code></pre></td></tr></table></figure><ol start="6"><li><h4 id="DCQ-或DCQU）"><a href="#DCQ-或DCQU）" class="headerlink" title="DCQ(或DCQU）"></a>DCQ(或DCQU）</h4></li></ol><p>语法格式：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs armasm">标号 <span class="hljs-meta">DCQ</span>（或<span class="hljs-meta">DCQU</span>） 表达式&#123;,表达式&#125;…..<br></code></pre></td></tr></table></figure><p>DCQ（或DCQU）伪指令用于分配一片以8个字节为单位的连续存储区域并用伪指令中指定的表达式初始化。</p><p>用DCQ分配的存储单元是字对齐的，而用DCQU分配的存储单元并不严格字对齐。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">使用示例：<br> DataTest   DCQ <span class="hljs-number">100</span> <br> <span class="hljs-comment">;分配一片连续的存储单元并初始化为指定的值。</span><br></code></pre></td></tr></table></figure><ol start="7"><li><h4 id="SPACE"><a href="#SPACE" class="headerlink" title="SPACE"></a>SPACE</h4></li></ol><p>语法格式：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs armasm">标号 <span class="hljs-meta">SPACE</span> 表达式<br></code></pre></td></tr></table></figure><p>SPACE伪指令用于分配一片连续的存储区域并初始化为0。其中，表达式为要分配的字节数。</p><p>SPACE也可用“％”代替。</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tap">使用示例：<br>DataSpace SPACE<span class="hljs-number"> 100 </span><br>DataSpace %<span class="hljs-number"> 100 </span> <br>;分配连续100字节的存储单元并初始化为0。<br></code></pre></td></tr></table></figure><ol start="8"><li><h4 id="MAP"><a href="#MAP" class="headerlink" title="MAP"></a>MAP</h4></li></ol><p>语法格式：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-built_in">MAP</span> 表达式&#123;，基址寄存器&#125;<br></code></pre></td></tr></table></figure><p>MAP伪指令用于定义一个结构化的内存表的首地址。</p><p>MAP也可用“＾”代替。</p><p>表达式可以为程序中的标号或数学表达式，基址寄存器为可选项。</p><p>当基址寄存器选项不存在时，表达式的值即为内存表的首地址；</p><p>当该选项存在时，内存表的首地址为表达式的值与基址寄存器的和。</p><p>MAP伪指令通常与FIELD伪指令配合使用来定义结构化的内存表。</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs armasm">使用示例：<br> <span class="hljs-meta">MAP</span> <span class="hljs-number">0x100</span>，<span class="hljs-built_in">R0</span> <br> ^ <span class="hljs-number">0x100</span>，<span class="hljs-built_in">R0</span>  <br> <span class="hljs-comment">;定义结构化内存表首地址的值为0x100＋R0。</span><br></code></pre></td></tr></table></figure><ol start="9"><li><h4 id="FILED"><a href="#FILED" class="headerlink" title="FILED"></a>FILED</h4></li></ol><p>语法格式：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs armasm">标号 <span class="hljs-meta">FIELD</span> 表达式<br></code></pre></td></tr></table></figure><p>FIELD伪指令用于定义一个结构化内存表中的数据域。</p><p>FILED也可用“#”代替。</p><p>表达式的值为当前数据域在内存表中所占的字节数。</p><p>FIELD伪指令常与MAP伪指令配合使用来定义结构化的内存表。MAP伪指令定义内存表的首地址，FIELD伪指令定义内存表中的各个数据域，并可以为每个数据域指定一个标号供其他的指令引用。</p><p>注意MAP和FIELD伪指令仅用于定义数据结构，并不实际分配存储单元。</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">使用示例：<br> MAP <span class="hljs-number">0x100</span> <span class="hljs-comment">;定义结构化内存表首地址的值为0x100。</span><br> A FIELD <span class="hljs-number">16</span> <span class="hljs-comment">;定义A的长度为16字节，位置为0x100</span><br> <span class="hljs-keyword">B </span><span class="hljs-comment"># 32 ;定义B的长度为32字节，位置为0x110</span><br> S FIELD <span class="hljs-number">256</span> <span class="hljs-comment">;定义S的长度为256字节，位置为0x130</span><br></code></pre></td></tr></table></figure><h3 id="4-1-3-汇编控制（Assembly-Control）伪指令"><a href="#4-1-3-汇编控制（Assembly-Control）伪指令" class="headerlink" title="4.1.3 汇编控制（Assembly Control）伪指令"></a>4.1.3 汇编控制（Assembly Control）伪指令</h3><p>汇编控制伪指令用于控制汇编程序的执行流程，常用的汇编控制伪指令包括以下几条：</p><ul><li>IF、ELSE、ENDIF</li><li>WHILE、WEND</li><li>MACRO、MEND</li><li>MEXIT</li></ul><ol><li><h4 id="IF、ELSE、ENDIF"><a href="#IF、ELSE、ENDIF" class="headerlink" title="IF、ELSE、ENDIF"></a>IF、ELSE、ENDIF</h4></li></ol><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs armasm">语法格式：<br><span class="hljs-meta">IF</span>逻辑表达式<br>指令序列<span class="hljs-number">1</span><br><span class="hljs-meta">ELSE</span><br>指令序列<span class="hljs-number">2</span><br><span class="hljs-meta">ENDIF</span><br></code></pre></td></tr></table></figure><ul><li>IF、ELSE、ENDIF伪指令能根据条件的成立与否决定是否执行某个指令序列。当IF后面的逻辑表达式为真，则执行指令序列1，否则执行指令序列2。其中，ELSE及指令序列2可以没有，此时，当IF后面的逻辑表达式为真，则执行指令序列1，否则继续执行后面的指令。</li><li>IF、ELSE、ENDIF伪指令可以嵌套使用。</li></ul><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cmake">使用示例：<br>    GBLL<span class="hljs-keyword">Test</span>;声明一个全局的逻辑变量，变量名为<span class="hljs-keyword">Test</span><br>    ……<br>    <span class="hljs-keyword">IF</span><span class="hljs-keyword">Test</span> = <span class="hljs-keyword">TRUE</span><br>  指令序列<span class="hljs-number">1</span><br>    <span class="hljs-keyword">ELSE</span><br> 指令序列<span class="hljs-number">2</span><br>    <span class="hljs-keyword">ENDIF</span><br></code></pre></td></tr></table></figure><ol start="2"><li><h4 id="WHILE、WEND"><a href="#WHILE、WEND" class="headerlink" title="WHILE、WEND"></a>WHILE、WEND</h4></li></ol><p>语法格式：</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs autoit"><span class="hljs-keyword">WHILE</span> 逻辑表达式<br>指令序列<br><span class="hljs-keyword">WEND</span><br></code></pre></td></tr></table></figure><p>WHILE、WEND伪指令能根据条件的成立与否决定是否循环执行某个指令序列。当WHILE后面的逻辑表达式为真，则执行指令序列，该指令序列执行完毕后，再判断逻辑表达式的值，若为真则继续执行，一直到逻辑表达式的值为假。</p><p>WHILE、WEND伪指令可以嵌套使用。</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs armasm">使用示例：<br>    <span class="hljs-meta">GBLA</span>  counter <span class="hljs-comment">;声明一个全局的数学变量，变量名为;counter</span><br><span class="hljs-symbol">counter</span><span class="hljs-meta">SETA</span>   <span class="hljs-number">1</span> <span class="hljs-comment">;初始化循环控制计数器</span><br>    ……<br>    <span class="hljs-meta">WHILE</span>  counter &lt; <span class="hljs-number">10</span><br>  指令序列<br><span class="hljs-symbol">counter</span> <span class="hljs-meta">SETA</span>   counter +<span class="hljs-number">1</span><br>    <span class="hljs-meta">WEND</span><br></code></pre></td></tr></table></figure><ol start="3"><li><h4 id="MACRO、MEND-CF-P-129"><a href="#MACRO、MEND-CF-P-129" class="headerlink" title="MACRO、MEND (CF.P.129)"></a>MACRO、MEND (CF.P.129)</h4></li></ol><p>语法格式：</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs crystal">MACRO<br><span class="hljs-variable">$标</span>号宏名<span class="hljs-variable">$参</span>数<span class="hljs-number">1</span>，<span class="hljs-variable">$参</span>数<span class="hljs-number">2</span>，……<br>指令序列<br>MEND<br></code></pre></td></tr></table></figure><p>MACRO、MEND伪指令可以将一段代码定义为一个整体，称为宏指令，然后就可以在程序中通过宏指令多次调用该段代码。其中，$标号在宏指令被展开时，标号会被替换为用户定义的符号，</p><p>宏指令可以使用一个或多个参数，当宏指令被展开时，这些参数被相应的值替换。</p><p>宏指令的使用方式和功能与子程序有些相似，子程序可以提供模块化的程序设计、节省存储空间并提高运行速度。但在使用子程序结构时需要保护现场，从而增加了系统的开销，因此，在代码较短且需要传递的参数较多时，可以使用宏指令代替子程序。</p><p>包含在MACRO和MEND之间的指令序列称为<strong>宏定义体</strong>，在宏定义体的第一行应声明宏的原型（包含宏名、所需的参数），然后就可以在汇编程序中通过宏名来调用该指令序列。在源程序被编译时，汇编器将宏调用展开，用宏定义中的指令序列代替程序中的宏调用，并将实际参数的值传递给宏定义中的形式参数。</p><p>MACRO、MEND伪指令可以嵌套使用。</p><ol start="4"><li><h4 id="MEXIT"><a href="#MEXIT" class="headerlink" title="MEXIT"></a>MEXIT</h4></li></ol><p>语法格式：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">MEXIT</span><br></code></pre></td></tr></table></figure><p>MEXIT用于从宏定义中跳转出去</p><p><img src="/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC4%E7%AB%A0-ARM%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%80-%E4%BC%AA%E6%8C%87%E4%BB%A41/image-20230508215635871.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="图"></p><h3 id="4-1-4-其他常用的伪指令"><a href="#4-1-4-其他常用的伪指令" class="headerlink" title="4.1.4 其他常用的伪指令"></a>4.1.4 其他常用的伪指令</h3><p>还有一些其他的伪指令，在汇编程序中经常会被使用，包括以下几条：</p><ul><li>AREA</li><li>ALIGN</li><li>CODE16、CODE32</li><li>ENTRY</li><li>END</li><li>EQU</li><li>EXPORT（或GLOBAL）</li><li>IMPORT</li><li>EXTERN</li><li>GET（或INCLUDE）</li><li>INCBIN</li><li>RN</li><li>ROUT</li></ul><ol><li><h4 id="AREA"><a href="#AREA" class="headerlink" title="AREA"></a>AREA</h4></li></ol><p>语法格式：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">AREA</span>段名属性<span class="hljs-number">1</span>，属性<span class="hljs-number">2</span>，……<br></code></pre></td></tr></table></figure><p>AREA伪指令用于定义一个代码段或数据段。其中，段名若以数字开头，则该段名需用“|”括起来，如|1_test|。</p><p>属性字段表示该代码段（或数据段）的相关属性，多个属性用逗号分隔。常用的属性如下：</p><ul><li>CODE属性：用于定义代码段，默认为READONLY。</li><li>DATA属性：用于定义数据段，默认为READWRITE。</li><li>READONLY属性：指定本段为只读，代码段默认为READONLY。</li><li>READWRITE属性：指定本段为可读可写，数据段的默认属性为READWRITE。</li><li>ALIGN属性：使用方式为ALIGN&#x3D;expression。在默认时，ELF（可执行连接文件）的代码段和数据段是按字对齐的，表达式的取值范围为0～31，相应的对齐方式为<strong>2<strong><strong>expression</strong></strong>次方</strong>。</li><li>COMMON属性：该属性定义一个通用的段，不包含任何的用户代码和数据。各源文件中同名的COMMON段共享同一段存储单元。</li></ul><p>一个汇编语言程序至少要包含一个段，当程序太长时，也可以将程序分为多个代码段和数据段。</p><p>段的常用属性：</p><ul><li>每个段都有一个名字，段名字可以重复使用，编译器将同名段作为一个段的不同部分；</li><li>指令（代码）段定义为CODE，数据段定义为DATA，这个属性一般不能忽略。<ul><li>代码段可以存放数据，如数据缓区LTORG或分配内存单元DCD等，但数据段不能存放指令；</li></ul></li><li>代码段的属性通常是READONLY， 数据段的属性通常是READWRITE。</li></ul><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs armasm">使用示例：<br>  <span class="hljs-meta">AREA</span> Init，<span class="hljs-meta">CODE</span>，<span class="hljs-meta">READONLY</span><br>  指令序列<br>  ；该伪指令定义了一个代码段，段名为Init，属性为只读<br></code></pre></td></tr></table></figure><ol start="2"><li><h4 id="ALIGN"><a href="#ALIGN" class="headerlink" title="ALIGN"></a>ALIGN</h4></li></ol><p>语法格式：</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml">ALIGN</span><span class="hljs-template-variable">&#123;表达式&#123;，偏移量&#125;</span><span class="language-xml">&#125;</span><br></code></pre></td></tr></table></figure><p>ALIGN伪指令可通过添加填充字节的方式，使当前位置满足一定的对其方式。其中，表达式的值用于指定对齐方式，可能的取值为2的幂，如1、2、4、8、16等。若未指定表达式，则将当前位置对齐到下一个字的位置。偏移量也为一个数字表达式，若使用该字段，则当前位置的对齐方式为：2的表达式次幂＋偏移量。</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs armasm">使用示例：<br>   <span class="hljs-meta">AREA</span> Init，<span class="hljs-meta">CODE</span>，<span class="hljs-meta">READONLY</span>，<span class="hljs-meta">ALIGN</span>＝<span class="hljs-number">3</span> <br> <span class="hljs-comment">;指定后面的指令为8字节对齐。</span><br>   指令序列<br>   <span class="hljs-meta">ALIGN</span> <span class="hljs-number">4</span> <span class="hljs-comment">;指定后面的指令是4字节对齐的</span><br> <span class="hljs-meta">END</span><br></code></pre></td></tr></table></figure><ol start="3"><li><h4 id="CODE16、CODE32"><a href="#CODE16、CODE32" class="headerlink" title="CODE16、CODE32"></a>CODE16、CODE32</h4></li></ol><p>语法格式：(<strong>注意：这两条伪指令并不能实现ARM状态的切换。</strong>)</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-symbol">CODE16</span>（或<span class="hljs-meta">CODE32</span>）<br></code></pre></td></tr></table></figure><p>CODE16伪指令通知编译器，其后的指令序列为16位的Thumb指令。</p><p>CODE32伪指令通知编译器，其后的指令序列为32位的ARM指令。</p><p>若在汇编源程序中同时包含ARM指令和Thumb指令时，可用CODE16伪指令通知编译器其后的指令序列为16位的Thumb指令，CODE32伪指令通知编译器其后的指令序列为32位的ARM指令。</p><p>因此，<strong>在使用ARM指令和Thumb</strong>指令混合编程的代码里，可用这两条伪指令进行切换，但注意他们只通知编译器其后指令的类型，并不能对处理器进行状态的切换</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs armasm">使用示例：<br>    <span class="hljs-meta">AREA</span>Init，<span class="hljs-meta">CODE</span>，<span class="hljs-meta">READONLY</span><br>     ……<br>     <span class="hljs-meta">CODE32</span>  ；通知编译器其后的指令为<span class="hljs-number">32</span>位的<span class="hljs-meta">ARM</span>指令<br>     <span class="hljs-keyword">LDR</span><span class="hljs-built_in">R0</span>，＝NEXT＋<span class="hljs-number">1</span>  ；将跳转地址放入寄存器<span class="hljs-built_in">R0</span><br>     <span class="hljs-keyword">BX</span><span class="hljs-built_in">R0</span>；程序跳转到新的位置执行，并将处理器切换到<span class="hljs-meta">Thumb</span>工作状态<br>     ……<br>     <span class="hljs-meta">CODE16</span> ；通知编译器其后的指令为<span class="hljs-number">16</span>位的<span class="hljs-meta">Thumb</span>指令<br><span class="hljs-symbol">NEXT</span><span class="hljs-keyword">LDR</span><span class="hljs-built_in">R3</span>，＝<span class="hljs-number">0x3FF</span><br>     ……<br>     <span class="hljs-meta">END</span>；程序结束<br></code></pre></td></tr></table></figure><ol start="4"><li><h4 id="ENTRY"><a href="#ENTRY" class="headerlink" title="ENTRY"></a>ENTRY</h4></li></ol><p>语法格式：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada"><span class="hljs-keyword">ENTRY</span><br></code></pre></td></tr></table></figure><p>ENTRY伪指令用于指定汇编程序的入口点。在一个完整的汇编程序中至少要有一个ENTRY（也可以有多个，当有多个ENTRY时，程序的真正入口点由链接器指定），但在一个源文件里最多只能有一个ENTRY（可以没有）。</p><p>在只有一个入口时，编译程序会把这个入口的地址定义为系统复位后的程序起始点。</p><p>程序入口应该定义在源文件的第1条有效语句之前。</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs armasm">使用示例：<br>  <span class="hljs-meta">AREA</span> Init，<span class="hljs-meta">CODE</span>，<span class="hljs-meta">READONLY</span><br>  <span class="hljs-meta">ENTRY</span> ；指定应用程序的入口点<br><br> ……<br></code></pre></td></tr></table></figure><ol start="5"><li><h4 id="END"><a href="#END" class="headerlink" title="END"></a>END</h4></li></ol><p>语法格式：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada"><span class="hljs-keyword">END</span><br></code></pre></td></tr></table></figure><p>END伪指令用于通知编译器已经到了源程序的结尾。</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs armasm">使用示例：<br>  <span class="hljs-meta">AREA</span>   Init，<span class="hljs-meta">CODE</span>，<span class="hljs-meta">READONLY</span><br>  ……<br>  <span class="hljs-meta">END</span> ；指定应用程序的结尾<br></code></pre></td></tr></table></figure><ol start="6"><li><h4 id="EQU"><a href="#EQU" class="headerlink" title="EQU"></a>EQU</h4></li></ol><p>语法格式：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs armasm">名称<span class="hljs-meta">EQU</span>表达式&#123;，类型&#125;<br></code></pre></td></tr></table></figure><p>EQU伪指令用于为程序中的常量、标号等定义一个等效的字符名称，类似于C语言中的＃define。</p><p>EQU可用“*”代替。</p><p>名称为EQU伪指令定义的字符名称，当表达式为32位的常量时，可以指定表达式的数据类型，可以有以下三种类型：</p><ul><li>CODE16</li><li>CODE32</li><li>DATA</li></ul><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs armasm">使用示例：<br>Test<span class="hljs-meta">EQU</span><span class="hljs-number">50</span>；定义标号Test的值为<span class="hljs-number">50</span><br><span class="hljs-keyword">Addr</span>*<span class="hljs-number">0x55</span>，<span class="hljs-meta">CODE32</span><br>；定义Addr的值为<span class="hljs-number">0x55</span>，且该处为<span class="hljs-number">32</span>位的<span class="hljs-meta">ARM</span>指令<br></code></pre></td></tr></table></figure><ol start="7"><li><h4 id="EXPORT（或GLOBAL）"><a href="#EXPORT（或GLOBAL）" class="headerlink" title="EXPORT（或GLOBAL）"></a>EXPORT（或GLOBAL）</h4></li></ol><p>语法格式：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">EXPORT</span>标号   &#123;[WEAK]&#125;<br></code></pre></td></tr></table></figure><p>EXPORT伪指令用于在程序中声明一个全局的标号，该标号可在其他的文件中引用。</p><p>EXPORT可用GLOBAL代替。</p><p>标号在程序中区分大小写，[WEAK]选项声明其他的同名标号优先于该标号被引用。</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs armasm">使用示例：<br>    <span class="hljs-meta">AREA</span>Init，<span class="hljs-meta">CODE</span>，<span class="hljs-meta">READONLY</span><br>    <span class="hljs-meta">EXPORT</span>  Stest；声明一个可全局引用的标号Stest<br>    ……<br>    <span class="hljs-meta">END</span><br></code></pre></td></tr></table></figure><h4 id="8-IMPORT"><a href="#8-IMPORT" class="headerlink" title="8.IMPORT"></a>8.IMPORT</h4><p>语法格式：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">IMPORT 标号  &#123;<span class="hljs-selector-attr">[WEAK]</span>&#125;<br></code></pre></td></tr></table></figure><p>IMPORT伪指令用于通知编译器要使用的标号在其他的源文件中定义，但要在当前源文件中引用，而且无论当前源文件是否引用该标号，该标号均会被加入到当前源文件的符号表中。</p><p>标号在程序中区分大小写，[WEAK]选项表示当所有的源文件都没有定义这样一个标号时，编译器也不给出错误信息，在多数情况下将该标号置为0，若该标号为B或BL指令引用，则将B或BL指令置为NOP操作。</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs armasm">使用示例：<br>     <span class="hljs-meta">AREA</span>Init，<span class="hljs-meta">CODE</span>，<span class="hljs-meta">READONLY</span><br>     <span class="hljs-meta">IMPORT</span>  Main；通知编译器当前文件要引用标号<span class="hljs-comment">;Main，但Main在其他源文件中定义</span><br>     ……<br>     <span class="hljs-meta">END</span><br></code></pre></td></tr></table></figure><h4 id="9-EXTERN"><a href="#9-EXTERN" class="headerlink" title="9 EXTERN"></a>9 EXTERN</h4><p>语法格式：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">EXTERN标号&#123;<span class="hljs-selector-attr">[WEAK]</span>&#125;<br></code></pre></td></tr></table></figure><p>EXTERN伪指令用于通知编译器要使用的标号在其他的源文件中定义，但要在当前源文件中引用，如果当前源文件实际并未引用该标号，该标号就不会被加入到当前源文件的符号表中。</p><p>标号在程序中区分大小写，[WEAK]选项表示当所有的源文件都没有定义这样一个标号时，编译器也不给出错误信息，在多数情况下将该标号置为0，若该标号为B或BL指令引用，则将B或BL指令置为NOP操作。</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs armasm">使用示例：<br>    <span class="hljs-meta">AREA</span>Init，<span class="hljs-meta">CODE</span>，<span class="hljs-meta">READONLY</span><br>    <span class="hljs-meta">EXTERN</span>Main；通知编译器当前文件要引用标号Main，但<span class="hljs-comment">;Main在其他源文件中定义</span><br>    ……<br>    <span class="hljs-meta">END</span><br></code></pre></td></tr></table></figure><h4 id="10、-GET（或INCLUDE）"><a href="#10、-GET（或INCLUDE）" class="headerlink" title="10、 GET（或INCLUDE）"></a>10、 GET（或INCLUDE）</h4><p>语法格式：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">GET</span>文件名<br></code></pre></td></tr></table></figure><p>GET伪指令用于将一个源文件包含到当前的源文件中，并将被包含的源文件在当前位置进行汇编处理。</p><p>可以使用INCLUDE代替GET。</p><p>汇编程序中常用的方法是在某源文件中定义一些宏指令，用EQU定义常量的符号名称，用MAP和FIELD定义结构化的数据类型，然后用GET伪指令将这个源文件包含到其他的源文件中。使用方法与C语言中的“include”相似。</p><p>GET伪指令只能用于包含源文件，包含目标文件需要使用INCBIN伪指令</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs armasm">使用示例：<br>  <span class="hljs-meta">AREA</span>Init，<span class="hljs-meta">CODE</span>，<span class="hljs-meta">READONLY</span><br>    <span class="hljs-meta">GET</span><span class="hljs-built_in">a1</span>.s；通知编译器当前源文件包含源文件<span class="hljs-built_in">a1</span>.s<br>    <span class="hljs-meta">GET</span>C：\<span class="hljs-built_in">a2</span>.s ；通知编译器当前源文件包含源文件C：\ <span class="hljs-built_in">a2</span>.s<br>    ……<br>    <span class="hljs-meta">END</span><br></code></pre></td></tr></table></figure><h4 id="11、INCBIN"><a href="#11、INCBIN" class="headerlink" title="11、INCBIN"></a>11、INCBIN</h4><p>语法格式：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">INCBIN</span>文件名<br></code></pre></td></tr></table></figure><p>INCBIN伪指令用于将一个<strong>目标文件或数据文件</strong>包含到当前的源文件中，被包含的文件不作任何变动的存放在当前文件中，编译器从其后开始继续处理。</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs armasm">使用示例：<br>    <span class="hljs-meta">AREA</span>Init，<span class="hljs-meta">CODE</span>，<span class="hljs-meta">READONLY</span><br>    <span class="hljs-meta">INCBIN</span><span class="hljs-built_in">a1</span>.dat；通知编译器当前源文件包含文件；<span class="hljs-built_in">a1</span>.dat<br>    <span class="hljs-meta">INCBIN</span> C：\<span class="hljs-built_in">a2</span>.txt；通知编译器当前源文件包含文件；C:\<span class="hljs-built_in">a2</span>.txt<br>    ……<br>    <span class="hljs-meta">END</span><br></code></pre></td></tr></table></figure><h4 id="12、-RN"><a href="#12、-RN" class="headerlink" title="12、 RN"></a>12、 RN</h4><p>语法格式：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">名称RN表达式<br></code></pre></td></tr></table></figure><p>RN伪指令用于给一个寄存器定义一个别名。采用这种方式可以方便程序员记忆该寄存器的功能。其中，名称为给寄存器定义的别名，表达式为寄存器的编码。</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs armasm">使用示例：<br>    TempRN<span class="hljs-built_in">R0</span>  ；将<span class="hljs-built_in">R0</span>定义一个别名Temp<br></code></pre></td></tr></table></figure><h4 id="13、ROUT"><a href="#13、ROUT" class="headerlink" title="13、ROUT"></a>13、ROUT</h4><p>语法格式：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs armasm">&#123;名称&#125;<span class="hljs-meta">ROUT</span><br></code></pre></td></tr></table></figure><p>ROUT伪指令用于给一个局部变量定义作用范围。</p><p>在程序中未使用该伪指令时，局部变量的作用范围为所在的AREA，而使用ROUT后，局部变量的作为范围为当前ROUT和下一个ROUT之间（指同一个段中）。</p><h3 id="4-1-5几条特殊的伪指令"><a href="#4-1-5几条特殊的伪指令" class="headerlink" title="4.1.5几条特殊的伪指令"></a>4.1.5<strong>几条特殊的伪指令</strong></h3><ul><li>ADR (小范围的地址读取伪指令)</li><li>ADRL(中等范围的地址读取伪指令)</li><li>LDR(大范围的地址读取伪指令)</li><li>NOP(空操作伪指令)</li></ul><h4 id="1、ADR"><a href="#1、ADR" class="headerlink" title="1、ADR"></a>1、ADR</h4><p>语法格式</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-keyword">ADR</span> &#123;cond&#125; 寄存器，表达式<br></code></pre></td></tr></table></figure><p>在汇编编译器处理源程序时，ADR伪指令被编译器替换成一条合适的指令。</p><p>通常编译器用一条ADD指令或SUB指令来实现该ADR伪指令的功能。</p><p>ADR伪指令中的地址是基于PC或寄存器的，所以ADR读取到的地址与位置无关。</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs armasm">使用示例：<br>start <span class="hljs-keyword">MOV</span> <span class="hljs-built_in">r0</span>,<span class="hljs-number">#10</span><br>   <span class="hljs-keyword">ADR</span> <span class="hljs-built_in">r4</span>,start  <span class="hljs-comment">;本指令被替换成一条SUB指令</span><br><span class="hljs-keyword">SUB</span> <span class="hljs-built_in">r4</span>,<span class="hljs-built_in">pc</span>,<span class="hljs-number">#0xc</span><br></code></pre></td></tr></table></figure><p><img src="/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC4%E7%AB%A0-ARM%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%80-%E4%BC%AA%E6%8C%87%E4%BB%A41/image-20230508222951368.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="ex"></p><h4 id="2、ADRL"><a href="#2、ADRL" class="headerlink" title="2、ADRL"></a>2、ADRL</h4><p>语法格式</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-keyword">ADRL</span> &#123;cond&#125; 寄存器，表达式<br></code></pre></td></tr></table></figure><p>将基于PC或基于寄存器的地址值读取到寄存器中。</p><p>在汇编编译器处理源程序时，ADR伪指令被编译器替换成两条合适的指令。</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs avrasm">使用示例：<br>start <span class="hljs-keyword">MOV</span> <span class="hljs-built_in">r0</span>,<span class="hljs-meta">#10</span><br>   ADRL <span class="hljs-built_in">r4</span>,start +<span class="hljs-number">60000</span> <span class="hljs-comment">;本指令被替换成以下两条指令</span><br>   <br>    *<span class="hljs-keyword">ADD</span> <span class="hljs-built_in">r4</span>,pc,<span class="hljs-meta">#0xe800</span><br>   *<span class="hljs-keyword">ADD</span> <span class="hljs-built_in">r4</span>,<span class="hljs-built_in">r4</span>,<span class="hljs-meta">#0x254</span><br></code></pre></td></tr></table></figure><h4 id="3、LDR"><a href="#3、LDR" class="headerlink" title="3、LDR"></a>3、LDR</h4><blockquote><p><strong>注意：唯一一条ARM指令与伪指令同名的指令。</strong></p></blockquote><p>语法格式</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c">LDR &#123;cond&#125; 寄存器，=[表达式<span class="hljs-string">|标号]</span><br></code></pre></td></tr></table></figure><p>将一个32位的常数或者一个地址值读取到寄存器中。</p><p>当表达式表示的地址值没有超过MOV或MVN指令中地址的取值范围时，用合适的MOV或MVN指令来代替该指令；否则将标签表示的数值放在数据缓冲区中，同时用一条基于PC的LDR指令读取该数值。</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs armasm">使用示例：<br><span class="hljs-keyword">LDR</span> <span class="hljs-built_in">R1</span>,<span class="hljs-number">=0xFF0</span> 汇编后变换成：<span class="hljs-keyword">MOV</span> <span class="hljs-built_in">R1</span>,<span class="hljs-number">0xFF0</span><br><span class="hljs-keyword">LDR</span> <span class="hljs-built_in">R1</span>,<span class="hljs-number">=0xFFFFFF00</span> 汇编后变换成：<br><br><span class="hljs-keyword">LDR</span> <span class="hljs-built_in">R1</span>,[<span class="hljs-built_in">PC</span>,OFFSET_TO LPOOL]<br>……..<br>LPOOL <span class="hljs-meta">DCD</span> <span class="hljs-number">0xFFFFFF00</span><br></code></pre></td></tr></table></figure><h4 id="4、NOP"><a href="#4、NOP" class="headerlink" title="4、NOP"></a>4、NOP</h4><p>语法格式</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-keyword">NOP</span><br></code></pre></td></tr></table></figure><p>NOP伪指令将被替换成ARM中的空操作，如MOV R0,R0</p><p>NOP伪指令不影响CPSR中的条件标志位。</p>]]></content>
    
    
    <categories>
      
      <category>学习资料</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ARM体系结构与编程</tag>
      
      <tag>课件笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ARM体系结构与编程-第3章-ARM微处理器的指令系统5-Thumb</title>
    <link href="/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC3%E7%AB%A0-ARM%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F5-Thumb/"/>
    <url>/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC3%E7%AB%A0-ARM%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F5-Thumb/</url>
    
    <content type="html"><![CDATA[<h1 id="ARM体系结构与编程"><a href="#ARM体系结构与编程" class="headerlink" title="ARM体系结构与编程"></a><strong>ARM体系结构与编程</strong></h1><h1 id="3-6-1-Thumb-指令的特点"><a href="#3-6-1-Thumb-指令的特点" class="headerlink" title="3.6.1 Thumb 指令的特点"></a>3.6.1 Thumb 指令的特点</h1><ul><li>Thumb指令的代码密度高；</li><li>Thumb指令集是ARM指令集的一个子集，不是一个完整的体系结构；<ul><li>不能用Thumb指令编制一个完整的程序。</li></ul></li><li>ARM和Thumb指令的功能是相近的；</li><li>ARM状态和Thumb状态的区别也表现在程序状态寄存器中，CPSR[5]位T就是标志位；</li><li>Thumb指令16位编码所包含的信息较ARM指令少；</li><li>Thumb指令与ARM指令一样，是32位的数据操作。</li></ul><h1 id="3-6-2Thumb指令-vs-ARM指令"><a href="#3-6-2Thumb指令-vs-ARM指令" class="headerlink" title="3.6.2Thumb指令 vs. ARM指令"></a>3.6.2Thumb指令 vs. ARM指令</h1><ul><li>Thumb指令集没有：<ul><li>和协处理器相关的指令；</li><li>数据交换指令；</li><li>乘加指令和长乘法指令；</li><li>CPSR和SPSR访问指令。</li></ul></li><li>Thumb指令增加：<ul><li>逻辑移位指令；</li><li>堆栈指令PUSH和出栈指令POP。</li></ul></li><li>Thumb指令除分支指令外，都是无条件指令。</li><li>Thumb指令通常只使用两个操作数。</li><li>Thumb没有可选的S后缀，每条指令都可以刷新条件标志位</li></ul><h1 id="3-6-3-Thumb指令集中的数据传送指令"><a href="#3-6-3-Thumb指令集中的数据传送指令" class="headerlink" title="3.6.3 Thumb指令集中的数据传送指令"></a>3.6.3 Thumb指令集中的数据传送指令</h1><p><img src="/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC3%E7%AB%A0-ARM%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F5-Thumb/image-20230508204142594.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="数据传输"></p><p>The various assembler formats are:</p><p><img src="/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC3%E7%AB%A0-ARM%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F5-Thumb/image-20230508204218350.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="格式"></p><h2 id="3-6-3-1立即数偏移的无符号字-x2F-字节传送指令"><a href="#3-6-3-1立即数偏移的无符号字-x2F-字节传送指令" class="headerlink" title="3.6.3.1立即数偏移的无符号字&#x2F;字节传送指令"></a>3.6.3.1立即数偏移的无符号字&#x2F;字节传送指令</h2><p>指令：LDR, STR, LDRB, STRB</p><ul><li>用于在寄存器和存储器之间进行无符号的字和字节传送，其地址的表达式是基址寄存器和一个立即数的偏移。</li><li>指令格式：</li></ul><figure class="highlight hsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs hsp">LDR/<span class="hljs-keyword">STR</span>  Rd, [Rb, <span class="hljs-meta">#立即数]</span><br><br>LDRB/STRB  Rd, [Rb, <span class="hljs-meta">#立即数]</span><br></code></pre></td></tr></table></figure><ul><li>Rd是源&#x2F;目标寄存器，使用范围为R0~R7；</li><li>Rb是地址基址寄存器，使用范围为R0~R7；</li><li>立即数是字传送使用7位，字节传送使用5位；</li><li>立即数偏移只能是正数或0，不能是负数；</li><li>使用事先寻址方式，不能更新；</li><li>字传送要求字对齐。</li></ul><h2 id="3-6-3-2寄存器偏移的无符号字-x2F-字节传送指令"><a href="#3-6-3-2寄存器偏移的无符号字-x2F-字节传送指令" class="headerlink" title="3.6.3.2寄存器偏移的无符号字&#x2F;字节传送指令"></a>3.6.3.2寄存器偏移的无符号字&#x2F;字节传送指令</h2><p>指令：LDR, STR, LDRB, STRB</p><ul><li>用于在寄存器和存储器之间进行无符号的字和字节传送，其地址的表达式是基址寄存器和一个寄存器的偏移。</li><li>指令格式：</li></ul><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">LDR</span>/STR  Rd,<span class="hljs-meta"> [Rb, Ri]</span><br><br><span class="hljs-attribute">LDRB</span>/STRB  Rd,<span class="hljs-meta"> [Rb, Ri]</span><br></code></pre></td></tr></table></figure><ul><li>Rd是源&#x2F;目标寄存器，使用范围为R0~R7；</li><li>Rb是地址基址寄存器，使用范围为R0~R7；</li><li>Ri是偏移寄存器，使用范围为R0~R7；</li><li>使用事先寻址方式，不能更新；</li><li>字传送要求字对齐。</li></ul><h2 id="3-6-3-3立即数偏移的无符号半字传送指令"><a href="#3-6-3-3立即数偏移的无符号半字传送指令" class="headerlink" title="3.6.3.3立即数偏移的无符号半字传送指令"></a>3.6.3.3立即数偏移的无符号半字传送指令</h2><p>指令：LDRH, STRH</p><ul><li>用于在寄存器和存储器之间进行无符号的半字传送，其地址的表达式是基址寄存器和一个立即数的偏移。</li><li>指令格式：</li></ul><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">LDRH/STRH  <span class="hljs-built_in">Rd</span>, [<span class="hljs-type">Rb</span>, <span class="hljs-comment">#立即数]</span><br></code></pre></td></tr></table></figure><ul><li>Rd是源&#x2F;目标寄存器，使用范围为R0~R7；</li><li>Rb是地址基址寄存器，使用范围为R0~R7；</li><li>立即数是6位无符号数，不得大于64；</li><li>只能加载或存储低16位；</li><li>使用事先寻址方式，不能更新；</li><li>半字传送要求半字对齐。</li></ul><h2 id="3-6-3-4寄存器偏移的无符号半字传送指令和寄存器偏移的带符号字节-x2F-半字加载指令"><a href="#3-6-3-4寄存器偏移的无符号半字传送指令和寄存器偏移的带符号字节-x2F-半字加载指令" class="headerlink" title="3.6.3.4寄存器偏移的无符号半字传送指令和寄存器偏移的带符号字节&#x2F;半字加载指令"></a>3.6.3.4寄存器偏移的无符号半字传送指令和寄存器偏移的带符号字节&#x2F;半字加载指令</h2><p>指令：LDRH, STRG, LDSB, LDSH</p><ul><li>用于在寄存器和存储器之间进行无符号的半字传送以及带符号的字节&#x2F;半字加载，其地址的表达式是基址寄存器和一个寄存器的偏移。</li><li>指令格式：</li></ul><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">LDRH</span>/STRH Rd,<span class="hljs-meta"> [Rb, Ri]</span><br><br><span class="hljs-attribute">LDSB</span>/LDSH Rd,<span class="hljs-meta"> [Rb, Ri]</span><br></code></pre></td></tr></table></figure><ul><li>Rd是源&#x2F;目标寄存器，使用范围为R0~R7；</li><li>Rb是地址基址寄存器，使用范围为R0~R7；</li><li>Ri是偏移寄存器，使用范围为R0~R7；</li><li>半字加载时，加载低16位，高位进行符号&#x2F;无符号扩展；</li><li>使用事先寻址方式，不能更新；</li><li>半字传送要求半字对齐。</li></ul><h2 id="3-6-3-5用PC和SP做基址的数据传送指令"><a href="#3-6-3-5用PC和SP做基址的数据传送指令" class="headerlink" title="3.6.3.5用PC和SP做基址的数据传送指令"></a>3.6.3.5用PC和SP做基址的数据传送指令</h2><p>指令：LDR, STR</p><ul><li>用于在寄存器和存储器之间进行无符号的数据传送，其地址表达式的基址是PC或SP。</li><li>指令格式：</li></ul><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-keyword">LDR</span>  Rd, [<span class="hljs-built_in">PC</span>, #立即数]<br><br><span class="hljs-symbol">LDR</span>/<span class="hljs-keyword">STR</span>  Rd, [<span class="hljs-built_in">SP</span>, #立即数]<br></code></pre></td></tr></table></figure><ul><li>Rd是源&#x2F;目标寄存器，使用范围为R0~R7；</li><li>SP是堆栈指针做地址基址；</li><li>PC是程序计数器做地址基址；</li><li>立即数是无符号10位的地址偏移值，小于1024；</li><li>使用事先寻址方式，不能更新；</li><li>字传送要求字对齐。</li></ul><h2 id="3-6-3-6多寄存器的数据传送指令"><a href="#3-6-3-6多寄存器的数据传送指令" class="headerlink" title="3.6.3.6多寄存器的数据传送指令"></a>3.6.3.6多寄存器的数据传送指令</h2><p>指令：LDMIA, STMIA</p><ul><li>用于在寄存器和存储器之间进行成组的数据传送，其地址表达式只用一个无偏移的基址寄存器。</li><li>指令格式：</li></ul><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-symbol">LDMIA</span>/<span class="hljs-keyword">STMIA</span> Rb！, &#123;寄存器列表&#125;<br></code></pre></td></tr></table></figure><ul><li>Rb是地址基址寄存器，使用范围为R0~R7；</li><li>！后缀是写回标志，必须使用；</li><li>寄存器列表是从R0~R7的任意组合，寄存器分隔使用逗号；</li><li>无论加载还是存储，每传送一个数据，基址地址就自动增4，属于事后更新寻址方式；</li><li>寄存器在列表中是从小到大排列，无论加载还是存储，最小寄存器总是指向最初的基址地址；</li><li>Rb可以在列表中，但Rb必须是寄存器列表中最小的，否则结果不可预测；</li><li>后缀IA是表明每传送一次数据地址自动增4。</li></ul><p><img src="/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC3%E7%AB%A0-ARM%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F5-Thumb/image-20230508205005485.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="多寄存器"></p><h2 id="3-6-3-7栈操作指令"><a href="#3-6-3-7栈操作指令" class="headerlink" title="3.6.3.7栈操作指令"></a>3.6.3.7栈操作指令</h2><p>指令：PUSH, POP</p><ul><li>用于在寄存器和存储器之间进行成组的数据传送，其地址表达式是隐含的堆栈指针。</li><li>指令格式：</li></ul><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-symbol">PUSH</span>/<span class="hljs-keyword">POP</span>  &#123;寄存器列表&#125;<br><br><span class="hljs-keyword">PUSH</span>  &#123;寄存器列表，<span class="hljs-built_in">LR</span>&#125;<br><br><span class="hljs-keyword">POP</span>  &#123;寄存器列表，<span class="hljs-built_in">PC</span>&#125;<br></code></pre></td></tr></table></figure><ul><li>LR是链接寄存器；</li><li>PC是程序计数器；</li><li>寄存器列表是从R0~R7的任意组合，寄存器分隔使用逗号；</li><li>堆栈指针是隐含的地址基址，Thumb指令中的堆栈是满栈递减的，堆栈向下增长，堆栈指针总是指向最后入栈的数据；</li><li>寄存器在列表中是从小到大排列，无论加载还是存储，最小寄存器总是指向最初的基址地址；</li><li>但使用POP指令且PC出现在列表中时，从栈区赋给PC的数据将引起程序的跳转，这只能用在子程序的返回。</li></ul><h1 id="3-6-4-Thumb指令集的分支指令"><a href="#3-6-4-Thumb指令集的分支指令" class="headerlink" title="3.6.4 Thumb指令集的分支指令"></a>3.6.4 Thumb指令集的分支指令</h1><p>Thumb指令集包含4条分支指令：</p><ul><li>无条件分支指令；</li><li>条件分支指令；</li><li>带链接分支指令；</li><li>状态切换指令</li></ul><p><img src="/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC3%E7%AB%A0-ARM%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F5-Thumb/image-20230508205124916.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="分支指令"></p><h2 id="3-6-4-1-无条件分支指令"><a href="#3-6-4-1-无条件分支指令" class="headerlink" title="3.6.4.1 无条件分支指令"></a>3.6.4.1 无条件分支指令</h2><p>无条件分支指令B能够使程序产生一次无条件跳转。</p><p>指令格式：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-keyword">B</span> 语句标号<br></code></pre></td></tr></table></figure><ul><li>语句标号通常在同一程序段内，地址范围不超过±2048字节；</li><li>以PC为基址的相对偏移跳转，跳转方向可以向前，也可以向后；</li><li>语句标号处的地址必须是半字对齐的。</li></ul><h2 id="3-6-4-2-条件分支指令"><a href="#3-6-4-2-条件分支指令" class="headerlink" title="3.6.4.2 条件分支指令"></a>3.6.4.2 条件分支指令</h2><p>条件分支指令B能够使程序产生一次有条件跳转。</p><p>指令格式：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">B</span>&#123;cond&#125; 语句标号<br></code></pre></td></tr></table></figure><ul><li>语句标号通常在同一程序段内，地址范围不超过±254字节；</li><li>cond是条件后缀，共14种；</li><li>指令满足条件时分支跳转，否则不分支；</li><li>以PC为基址的相对偏移跳转，跳转方向可以向前，也可以向后；</li><li>语句标号处的地址必须是半字对齐的</li></ul><h2 id="3-6-4-3-带链接的长分支指令"><a href="#3-6-4-3-带链接的长分支指令" class="headerlink" title="3.6.4.3 带链接的长分支指令"></a>3.6.4.3 带链接的长分支指令</h2><p>带链接的长分支指令BL能够使程序产生长跳转，同时把分支处地址保存在LR中。</p><p>指令格式：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-keyword">BL</span> 语句标号<br></code></pre></td></tr></table></figure><ul><li>语句标号是一条长跳转，地址范围可以用一个23位的带符号数值表达；</li><li>Thumb指令编码是16位，一条指令是不能实现23位的地址编码的，该语句实际分解乘两条指令来实现；</li><li>以PC为基址的相对偏移跳转，跳转方向可以向前，也可以向后；</li><li>语句标号处的地址必须是半字对齐的。</li></ul><h2 id="3-6-4-4-状态切换的分支指令"><a href="#3-6-4-4-状态切换的分支指令" class="headerlink" title="3.6.4.4 状态切换的分支指令"></a>3.6.4.4 状态切换的分支指令</h2><p>状态切换的分支指令BX能够使程序产生分支，同时使程序从一个指令状态跳转到另一个指令状态。</p><p>指令格式：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-keyword">BX</span> Rs<br><span class="hljs-keyword">BX</span> Hs<br></code></pre></td></tr></table></figure><ul><li>Rs是Thumb指令集的通用寄存器R0~R7，其中数据作为分支目标地址；</li><li>Hs是高位寄存器R8<del>R15，在Thumb指令集中用H8</del>H15表达，其中数据作为分支目标地址；</li><li>以寄存器数据作为绝对地址的分支指令，跳转方向可以向前，也可以向后；</li><li>寄存器中的地址是目标地址，其中的最低位[0]不是地址信息。当[0]为1时，表明目标地址处是Thumb指令；当[0]为0时，表明目标地址处是ARM指令，要求字对齐。</li></ul><h1 id="3-6-5-Thumb指令集的数据处理指令"><a href="#3-6-5-Thumb指令集的数据处理指令" class="headerlink" title="3.6.5 Thumb指令集的数据处理指令"></a>3.6.5 Thumb指令集的数据处理指令</h1><p>Thumb指令集中的数据处理指令包括</p><ul><li>算术运算指令</li><li>逻辑运算指令</li><li>寄存器之间的数据传送指令</li></ul><p><img src="/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC3%E7%AB%A0-ARM%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F5-Thumb/image-20230508210114196.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="thumb"></p><h2 id="3-6-5-1-使用3个寄存器（或两个寄存器、一个立即数）的加减算术运算指令"><a href="#3-6-5-1-使用3个寄存器（或两个寄存器、一个立即数）的加减算术运算指令" class="headerlink" title="3.6.5.1 使用3个寄存器（或两个寄存器、一个立即数）的加减算术运算指令"></a>3.6.5.1 使用3个寄存器（或两个寄存器、一个立即数）的加减算术运算指令</h2><p>指令格式：</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-keyword">ADD</span>/<span class="hljs-keyword">SUB</span> Rd, Rs, Rn<br><br><span class="hljs-keyword">ADD</span>/<span class="hljs-keyword">SUB</span> Rd, Rs, <span class="hljs-meta">#立即数</span><br></code></pre></td></tr></table></figure><ul><li>Rs是Thumb指令集的通用寄存器R0~R7；</li><li>Rn是Thumb指令集的通用寄存器R0~R7；</li><li>Rd是Thumb指令集的通用寄存器R0~R7，保存操作结果；</li><li>立即数是3位无符号数值，不能大于7；</li><li>会刷新程序状态寄存器的条件标志。</li></ul><h2 id="3-6-5-2-使用1个寄存器和1个立即数的数据处理指令"><a href="#3-6-5-2-使用1个寄存器和1个立即数的数据处理指令" class="headerlink" title="3.6.5.2 使用1个寄存器和1个立即数的数据处理指令"></a>3.6.5.2 使用1个寄存器和1个立即数的数据处理指令</h2><p>n共有4条指令： ADD, SUB, MOV, CMP</p><p>指令格式：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">Opcode</span> Rd, <span class="hljs-comment">#立即数</span><br></code></pre></td></tr></table></figure><ul><li>Opcode是操作指令，指ADD, SUB, MOV, CMP等4条指令；</li><li>Rd是Thumb指令集的通用寄存器R0~R7，保存操作结果；</li><li>立即数是8位无符号数值，不能大于255；</li><li>会刷新程序状态寄存器的条件标志。</li></ul><h2 id="3-6-5-3-使用2个寄存器的数据处理指令"><a href="#3-6-5-3-使用2个寄存器的数据处理指令" class="headerlink" title="3.6.5.3 使用2个寄存器的数据处理指令"></a>3.6.5.3 使用2个寄存器的数据处理指令</h2><p>共有16条指令：</p><ul><li>AND, EOR, ORR, BIC;</li><li>ADC, SBC, MUL;</li><li>CMP, CMN;</li><li>LSL, LSR, ASR, ROR;</li><li>NEG, MVN;</li><li>TST</li></ul><h3 id="3-6-5-3-1-逻辑操作指令"><a href="#3-6-5-3-1-逻辑操作指令" class="headerlink" title="3.6.5.3.1 逻辑操作指令"></a>3.6.5.3.1 逻辑操作指令</h3><p>共有4条指令： AND, EOR, ORR, BIC</p><p>指令格式：</p><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dos">Opcode <span class="hljs-built_in">Rd</span>, Rs<br></code></pre></td></tr></table></figure><ul><li>Opcode是操作指令；</li><li>Rd是Thumb指令集的通用寄存器R0~R7，保存操作结果；</li><li>Rs是源寄存器R0~R7 ；</li><li>AND, EOR, ORR指令与寄存器的顺序无关，而BIC指令是有关的；</li><li>会刷新程序状态寄存器的条件标志。</li></ul><h3 id="3-6-5-3-2-算术运算指令"><a href="#3-6-5-3-2-算术运算指令" class="headerlink" title="3.6.5.3.2 算术运算指令"></a>3.6.5.3.2 算术运算指令</h3><p>共有3条指令： ADC, SBC, MUL</p><p>指令格式：</p><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dos">Opcode <span class="hljs-built_in">Rd</span>, Rs<br></code></pre></td></tr></table></figure><ul><li>Opcode是操作指令；</li><li>Rd是Thumb指令集的通用寄存器R0~R7，保存操作结果；</li><li>Rs是源寄存器R0~R7 ；</li><li>会刷新程序状态寄存器的条件标志。</li></ul><h3 id="3-6-5-3-3-逻辑操作指令"><a href="#3-6-5-3-3-逻辑操作指令" class="headerlink" title="3.6.5.3.3 逻辑操作指令"></a>3.6.5.3.3 逻辑操作指令</h3><p>共有2条指令： CMP, CMN</p><p>指令格式：</p><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dos">Opcode <span class="hljs-built_in">Rd</span>, Rs<br></code></pre></td></tr></table></figure><ul><li>Opcode是操作指令；</li><li>Rd是Thumb指令集的通用寄存器R0~R7；</li><li>Rs是源寄存器R0~R7 ；</li><li>会刷新程序状态寄存器的条件标志。</li></ul><h3 id="3-6-5-3-4-逻辑移位操作指令"><a href="#3-6-5-3-4-逻辑移位操作指令" class="headerlink" title="3.6.5.3.4 逻辑移位操作指令"></a>3.6.5.3.4 逻辑移位操作指令</h3><p>共有4条指令： LSL, LSR, ASR, ROR</p><p>指令格式：</p><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dos">Opcode <span class="hljs-built_in">Rd</span>, Rs<br></code></pre></td></tr></table></figure><ul><li>Opcode是操作指令；</li><li>Rd是Thumb指令集的通用寄存器R0~R7，保存操作结果；</li><li>Rs是源寄存器R0~R7，其中的数值是Rd移位的位数；</li><li>会刷新程序状态寄存器的条件标志。</li></ul><h3 id="3-6-5-3-5-寄存器传送指令"><a href="#3-6-5-3-5-寄存器传送指令" class="headerlink" title="3.6.5.3.5 寄存器传送指令"></a>3.6.5.3.5 寄存器传送指令</h3><p>共有2条指令： NEG, MVN</p><p>指令格式：</p><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dos">Opcode <span class="hljs-built_in">Rd</span>, Rs<br></code></pre></td></tr></table></figure><ul><li>Opcode是操作指令；</li><li>Rd是Thumb指令集的通用寄存器R0~R7，保存操作结果；</li><li>Rs是源寄存器R0~R7 ；</li><li>会刷新程序状态寄存器的条件标志。</li></ul><h3 id="3-6-5-3-6-测试指令"><a href="#3-6-5-3-6-测试指令" class="headerlink" title="3.6.5.3.6 测试指令"></a>3.6.5.3.6 测试指令</h3><p>共有1条指令： TST</p><p>指令格式：</p><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dos">Opcode <span class="hljs-built_in">Rd</span>, Rs<br></code></pre></td></tr></table></figure><ul><li>Opcode是操作指令；</li><li>Rd是Thumb指令集的通用寄存器R0~R7；</li><li>Rs是源寄存器R0~R7 ；</li><li>会刷新程序状态寄存器的条件标志。</li></ul><h2 id="3-6-5-4-对寄存器进行移位并传送的操作指令"><a href="#3-6-5-4-对寄存器进行移位并传送的操作指令" class="headerlink" title="3.6.5.4 对寄存器进行移位并传送的操作指令"></a>3.6.5.4 对寄存器进行移位并传送的操作指令</h2><p>共有3条指令： LSL, LSR, ASR</p><p>指令格式：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">Opcode</span> Rd, Rs, <span class="hljs-comment">#立即数</span><br></code></pre></td></tr></table></figure><ul><li>Opcode是操作指令；</li><li>Rd是Thumb指令集的通用寄存器R0~R7，保存操作结果；</li><li>Rs是源寄存器R0~R7，对其中的内容进行移位；</li><li>移位位数不能大于31；</li><li>会刷新程序状态寄存器的条件标志。</li></ul><h2 id="3-6-5-5-与高位寄存器有关的数据处理指令"><a href="#3-6-5-5-与高位寄存器有关的数据处理指令" class="headerlink" title="3.6.5.5 与高位寄存器有关的数据处理指令"></a>3.6.5.5 与高位寄存器有关的数据处理指令</h2><p>共有3条指令： ADD, CMP, MOV</p><p>指令格式：</p><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dos">Opcode <span class="hljs-built_in">Rd</span>, Rs<br></code></pre></td></tr></table></figure><ul><li>Opcode是操作指令；</li><li>Rd是Thumb指令集的通用寄存器R0~R15，保存操作结果；</li><li>Rs是源寄存器R0~R15，对其中的内容进行移位；</li><li>CMP指令会刷新程序状态寄存器的条件标志。</li></ul><h2 id="3-6-5-6-使用PC和SP的加法指令"><a href="#3-6-5-6-使用PC和SP的加法指令" class="headerlink" title="3.6.5.6 使用PC和SP的加法指令"></a>3.6.5.6 使用PC和SP的加法指令</h2><p>Thumb指令中有一条对堆栈指针SP的加法指令和一条对PC的加法指令。</p><p>指令格式：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">ADD </span>Rd, PC, <span class="hljs-comment">#立即数</span><br><br><span class="hljs-keyword">ADD </span>Rd, <span class="hljs-built_in">SP</span>, <span class="hljs-comment">#立即数</span><br></code></pre></td></tr></table></figure><ul><li>Rd是Thumb指令集的通用寄存器R0~R7；</li><li>PC是程序计数器，做源寄存器；</li><li>SP是堆栈指针，做源寄存器；</li><li>立即数是一个10位的无符号数；</li><li>立即数必须字对齐；</li><li>当把PC作为源寄存器时，PC中的值是指令处的地址加4；</li><li>不影响程序条件标志位。</li></ul><h2 id="3-6-5-7-堆栈指针加偏移的加法指令"><a href="#3-6-5-7-堆栈指针加偏移的加法指令" class="headerlink" title="3.6.5.7 堆栈指针加偏移的加法指令"></a>3.6.5.7 堆栈指针加偏移的加法指令</h2><p>Thumb指令中有一条对堆栈指针SP加偏移的加法指令。</p><p>指令格式：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">ADD </span><span class="hljs-built_in">SP</span>, <span class="hljs-comment">#立即数</span><br><br><span class="hljs-keyword">ADD </span><span class="hljs-built_in">SP</span>, <span class="hljs-comment">#-立即数</span><br></code></pre></td></tr></table></figure><ul><li>SP是堆栈指针，做目标寄存器；</li><li>立即数是一个9位的无符号数；</li><li>立即数必须字对齐；</li><li>表达式中可以使用负号，堆栈指针可以向前偏移，也可以向后偏移。</li></ul><p>The various instruction formats are:</p><p><img src="/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC3%E7%AB%A0-ARM%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F5-Thumb/image-20230508212107915.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="指令格式"></p><p>Equivalent ARM instruction</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs clean">ARM instruction Thumb instruction<br><br>MOVS Rd, #&lt;#imm8&gt; ; MOV Rd, #&lt;#imm8&gt;<br>MVNS Rd, Rm ; MVN Rd, Rm<br>CMP Rn, #&lt;#imm8&gt; ; CMP Rn, #&lt;#imm8&gt;<br>CMP Rn, Rm ; CMP Rn, Rm<br>CMN Rn, Rm ; CMN Rn, Rm<br>TST Rn, Rm ; TST Rn, Rm<br>ADDS Rd, Rn, #&lt;#imm3&gt; ; ADD Rd, Rn, #&lt;#imm3&gt;<br>ADDS Rd, Rd, #&lt;#imm8&gt; ; ADD Rd, #&lt;#imm8&gt;<br>ADDS Rd, Rn, Rm ; ADD Rd, Rn, Rm<br>ADCS Rd, Rd, Rm ; ADC Rd, Rm<br>SUBS Rd, Rn, #&lt;#imm3&gt; ; SUB Rd, Rn, #&lt;#imm3&gt;<br>SUBS Rd, Rd, #&lt;#imm8&gt; ; SUB Rd, #&lt;#imm8&gt;<br>SUBS Rd, Rn, Rm ; SUB Rd, Rn, Rm<br>SBCS Rd, Rd, Rm ; SBC Rd, Rm<br>RSBS Rd, Rn, #<span class="hljs-number">0</span> ; NEC Rd, Rn<br>MOVS Rd, Rm, LSL #&lt;#sh&gt; ; LSL Rd, Rm, #&lt;#sh&gt;<br></code></pre></td></tr></table></figure><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-comment">; ARM instruction Thumb instruction</span><br><br><span class="hljs-keyword">MOVS</span> Rd, Rd, <span class="hljs-keyword">LSL</span> Rs <span class="hljs-comment">; LSL Rd, Rs</span><br><span class="hljs-keyword">MOVS</span> Rd, Rm, <span class="hljs-keyword">LSR</span> #&lt;<span class="hljs-symbol">#sh</span>&gt; <span class="hljs-comment">; LSR Rd, Rm, #&lt;#sh&gt;</span><br><span class="hljs-keyword">MOVS</span> Rd, Rd, <span class="hljs-keyword">LSR</span> Rs <span class="hljs-comment">; LSR Rd, Rs</span><br><span class="hljs-keyword">MOVS</span> Rd, Rm, <span class="hljs-keyword">ASR</span> #&lt;<span class="hljs-symbol">#sh</span>&gt; <span class="hljs-comment">; ASR Rd, Rm, #&lt;#sh&gt;</span><br><span class="hljs-keyword">MOVS</span> Rd, Rd, <span class="hljs-keyword">ASR</span> Rs <span class="hljs-comment">; ASR Rd, Rs</span><br><span class="hljs-keyword">MOVS</span> Rd, Rd, <span class="hljs-keyword">ROR</span> Rs <span class="hljs-comment">; ROR Rd, Rs</span><br><span class="hljs-keyword">ANDS</span> Rd, Rd, Rm <span class="hljs-comment">; AND Rd, Rm</span><br><span class="hljs-keyword">EORS</span> Rd, Rd, Rm <span class="hljs-comment">; EOR Rd, Rm</span><br><span class="hljs-keyword">ORRS</span> Rd, Rd, Rm <span class="hljs-comment">; ORR Rd, Rm</span><br><span class="hljs-keyword">BICS</span> Rd, Rd, Rm <span class="hljs-comment">; BIG Rd, Rm</span><br><span class="hljs-keyword">MULS</span> Rd, Rm, Rd <span class="hljs-comment">; MUL Rd, Rm</span><br></code></pre></td></tr></table></figure><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs powershell">Instructions that operate with or on the <span class="hljs-string">&#x27;Hi&#x27;</span> registers (r8 to r15), <span class="hljs-keyword">in</span> some cases <span class="hljs-keyword">in</span><br>combination with a <span class="hljs-string">&#x27;Lo&#x27;</span> register:<br><br>; ARM instruction Thumb instruction<br><br>ADD <span class="hljs-built_in">Rd</span>, <span class="hljs-built_in">Rd</span>, <span class="hljs-built_in">Rm</span> ; ADD <span class="hljs-built_in">Rd</span>, <span class="hljs-built_in">Rm</span> (<span class="hljs-number">1</span>/<span class="hljs-number">2</span> Hi regs)<br>CMP Rn, <span class="hljs-built_in">Rm</span> ; CMP Rn, <span class="hljs-built_in">Rm</span> (<span class="hljs-number">1</span>/<span class="hljs-number">2</span> Hi regs)<br>MOV <span class="hljs-built_in">Rd</span>, <span class="hljs-built_in">Rm</span> ; MOV <span class="hljs-built_in">Rd</span>, <span class="hljs-built_in">Rm</span> (<span class="hljs-number">1</span>/<span class="hljs-number">2</span> Hi regs)<br>ADD <span class="hljs-built_in">Rd</span>, PC, <span class="hljs-comment">#&lt;#imm8&gt; ; ADD Rd, PC, #&lt;#imm8&gt;</span><br>ADD <span class="hljs-built_in">Rd</span>, <span class="hljs-built_in">SP</span>, <span class="hljs-comment">#&lt;#imm8&gt; ; ADD Rd, SP, #&lt;#imm8&gt;</span><br>ADD <span class="hljs-built_in">SP</span>, <span class="hljs-built_in">SP</span>, <span class="hljs-comment">#&lt;#imm7&gt; ; ADD SP, SP, #&lt;#imm7&gt;</span><br>SUB <span class="hljs-built_in">SP</span>, <span class="hljs-built_in">SP</span>, <span class="hljs-comment">#&lt;#imm7&gt; ; SUB SP, SP, #&lt;#imm7&gt;</span><br><br></code></pre></td></tr></table></figure><h1 id="3-6-6-Thumb指令集的软件中断指令"><a href="#3-6-6-Thumb指令集的软件中断指令" class="headerlink" title="3.6.6 Thumb指令集的软件中断指令"></a>3.6.6 Thumb指令集的软件中断指令</h1><p>Thumb指令集中只有一条软件中断指令SWI，与ARM指令集是一样的。</p><p>指令格式：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">SWI </span><span class="hljs-comment">#中断参数</span><br></code></pre></td></tr></table></figure><ul><li>中断参数是一个8位的无符号数，可以是0；</li><li>执行此指令后，处理器由Thumb状态切换到ARM状态；</li><li>处理器由用户模式转换到管理模式；中断处下一条指令的地址被拷贝到链接寄存器R14，CPSR被拷贝到SPSR中，处理器把中断向量0x00000008装入PC;</li><li>中断参数不可以省略（可以为0），这个参数对指令无影响，是中断过程传递的一个参数，如中断功能号；</li><li>指令不影响条件标志位。</li></ul><p><img src="/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC3%E7%AB%A0-ARM%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F5-Thumb/image-20230508212423679.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="thumb"></p><h1 id="3-6-7-Thumb-implementation"><a href="#3-6-7-Thumb-implementation" class="headerlink" title="3.6.7 Thumb implementation"></a>3.6.7 Thumb implementation</h1><p>The biggest addition is the Thumb instruction decompressor in the instruction pipeline; this logic translates a Thumb instruction into its equivalent ARM instruction.</p><p>The Thumb decompressor performs a static translation from the 16-bit Thumb instruction into the equivalent 32-bit ARM instruction.</p><p><img src="/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC3%E7%AB%A0-ARM%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F5-Thumb/image-20230508212728045.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="图"></p><p><img src="/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC3%E7%AB%A0-ARM%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F5-Thumb/image-20230508212741020.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="图"></p>]]></content>
    
    
    <categories>
      
      <category>学习资料</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ARM体系结构与编程</tag>
      
      <tag>课件笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>嵌入式程序设计ch4-存储器系统</title>
    <link href="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1ch4-%E5%AD%98%E5%82%A8%E5%99%A8%E7%B3%BB%E7%BB%9F/"/>
    <url>/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1ch4-%E5%AD%98%E5%82%A8%E5%99%A8%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<h1 id="嵌入式程序设计ch4-存储器系统"><a href="#嵌入式程序设计ch4-存储器系统" class="headerlink" title="嵌入式程序设计ch4-存储器系统"></a>嵌入式程序设计ch4-存储器系统</h1><ul><li>存储器系统概述</li><li>嵌入式系统存储器的分类和性能分析</li><li>ARM存储器管理</li><li>新型存储器</li><li>存储保护与校验技术</li></ul><h1 id="4-1-存储器系统概述"><a href="#4-1-存储器系统概述" class="headerlink" title="4.1 存储器系统概述"></a>4.1 存储器系统概述</h1><ul><li>存储器系统嵌入式系统中不可或缺的组成部分，主要是用来存放指令和数据</li><li>嵌入式系统的主存储器由于计算机体系结构的限制，存在若干不足之处<ul><li>不能同时满足存取速度快、存储容量大和成本低的要求。</li><li>在数据访问需求和成本性能之间平衡</li></ul></li><li>嵌入式系统内部或者芯片内部<ul><li>从块到慢、容量由小到大的多级层次存储器</li><li>采用优化的控制调度算法、合理的成本、性能构成经济可用的存储器系统</li></ul></li></ul><h1 id="4-2-嵌入式系统存储器的分类和性能分析"><a href="#4-2-嵌入式系统存储器的分类和性能分析" class="headerlink" title="4.2 嵌入式系统存储器的分类和性能分析"></a>4.2 嵌入式系统存储器的分类和性能分析</h1><ul><li>嵌入式系统的存储器分为片内和片外存储器</li><li>采用分层结构<ul><li>上一层存储器当作下一层存储器的高速缓存</li></ul></li></ul><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1ch4-%E5%AD%98%E5%82%A8%E5%99%A8%E7%B3%BB%E7%BB%9F/image-20230427000543479.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="cache"></p><h2 id="按照用途分类"><a href="#按照用途分类" class="headerlink" title="按照用途分类"></a>按照用途分类</h2><ul><li>主存储器（简称内存）</li><li>辅助存储器（简称外存）</li><li>CPU高速缓存</li><li>片内寄存器</li></ul><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1ch4-%E5%AD%98%E5%82%A8%E5%99%A8%E7%B3%BB%E7%BB%9F/image-20230427000655091.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="cpu"></p><ul><li>基本结构简单. </li><li>二维阵列，行地址和列地址</li></ul><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1ch4-%E5%AD%98%E5%82%A8%E5%99%A8%E7%B3%BB%E7%BB%9F/image-20230427000730684.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="bus"></p><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1ch4-%E5%AD%98%E5%82%A8%E5%99%A8%E7%B3%BB%E7%BB%9F/image-20230427000830635.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="矩阵"></p><h2 id="存储器和存储器控制器"><a href="#存储器和存储器控制器" class="headerlink" title="存储器和存储器控制器"></a>存储器和存储器控制器</h2><ul><li>存储器芯片复杂的结构</li><li>存储器控制器连接CPU和存储器</li><li>存储器控制器屏蔽了CPU</li><li>CPU无需知道不同存储器的详细时序</li></ul><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1ch4-%E5%AD%98%E5%82%A8%E5%99%A8%E7%B3%BB%E7%BB%9F/image-20230427001407698.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="mem"></p><h3 id="存储器的组织–通道与块"><a href="#存储器的组织–通道与块" class="headerlink" title="存储器的组织–通道与块"></a>存储器的组织–通道与块</h3><ul><li>整个存储器系统可以划分为多个不同组件，每个组都有自己的存储器阵列和逻辑地址</li><li>通道：连接到一组存储器组件</li><li>控制器管理这些组件</li><li>调度问题</li><li>提供存储器并行性<ul><li>支持多通道</li><li>组(Bank)是独立的存储阵列</li></ul></li></ul><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1ch4-%E5%AD%98%E5%82%A8%E5%99%A8%E7%B3%BB%E7%BB%9F/image-20230427002331856.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="channel"></p><h3 id="分类：按照信息存取方式"><a href="#分类：按照信息存取方式" class="headerlink" title="分类：按照信息存取方式"></a>分类：按照信息存取方式</h3><ul><li><p>按照信息存取方式：RAM和ROM</p></li><li><p>RAM</p><ul><li>SRAM：静态随机存储</li><li>DRAM：动态随机存储器</li><li>DDR SDRAM：双倍速率随机存储器</li><li>SRAM 比 DRAM 运行速度要快，功耗要低，DRAM 还需要进行周期性刷新，功耗高，但DRAM存集成度更高、体积更小</li></ul></li><li><p>ROM：烧写入数据后，就不可对数据修改，无外加电源，断电后数据不会丢失</p><ul><li>MROM，掩膜 ROM，Mask ROM</li><li>PROM，可编程 ROM，Programmable ROM</li><li>EPROM，可擦可编程 ROM，Erasable Programmable ROM</li><li>EEPROM，电擦除可编程 ROM</li><li>Flash Memory，快闪存储器</li></ul></li></ul><h3 id="随机存储器RAM"><a href="#随机存储器RAM" class="headerlink" title="随机存储器RAM:"></a>随机存储器RAM:</h3><p><strong>SRAM</strong>:</p><ul><li>要始终保持上电状态，SRAM 存储的数据就可保持</li><li>较高的性能，功耗相对较低</li><li>集成度较低，体积较大，制作成本高</li><li><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1ch4-%E5%AD%98%E5%82%A8%E5%99%A8%E7%B3%BB%E7%BB%9F/image-20230427002752383.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="sram"></li><li>电路结构<ul><li>通过两个首尾相接的反相器来锁存数据的</li><li>反相器Ⅰ和Ⅱ形成正反馈，使电路总能恢复到稳定状态</li><li>N1 和 N2 叫做存取管，用来读取或者写入数据</li><li>字线（ WL）控制存取管的开启</li><li>将存储的数据从位线（ BL 和 BLB）传送至外围电路</li><li>反相器Ⅰ、Ⅱ和存取电路组成了一个 SRAM 单元（SRAM Cell）（由于该单元只能存储<strong>一位</strong>的数</li></ul></li></ul><p> <strong>DRAM:</strong></p><ul><li><p>电容存储数据，周期性刷新，功耗较高，</p></li><li><p>集成度较高，体积更小</p></li><li><p>保存信息的原理是依靠电容中存储电荷的状态，电容有电荷时，为逻辑 1；没有电荷时，为逻辑 0 </p></li><li><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1ch4-%E5%AD%98%E5%82%A8%E5%99%A8%E7%B3%BB%E7%BB%9F/image-20230427002921067.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="dram"></p></li><li><p>基本原理</p><ul><li>Storage Capacitor，即存储电容，通过存储在其中电荷多和少，表示逻辑上的 1 和 0 </li><li>Access Transistor，即访问晶体管，它的导通和截止，决定了允许或禁止对Storage Capacitor 所存储的信息的读取和改写</li><li>Wordline，即字线，它决定了 Access </li><li>Transistor 的导通或者截止。</li><li>Bitline，即位线，它是外界访问 Storage Capacitor 的唯一通道</li><li>当 Access Transistor 导通，外界可通过Bitline 对 Storage Capacitor 进行读写操作</li></ul><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1ch4-%E5%AD%98%E5%82%A8%E5%99%A8%E7%B3%BB%E7%BB%9F/image-20230427003040785.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="dram"></p><ul><li>Storage Capacitor 的 Common 端接 Vcc&#x2F;2</li><li>当 Storage Capacitor 存储信息为 1 ，另一端电压为 Vcc，其存储电荷 Q &#x3D; +Vcc&#x2F;2 &#x2F; C</li><li>当 Storage Capacitor 存储为 0 时，另一端电压为 0，其存储电荷 Q &#x3D; -Vcc&#x2F;2 &#x2F; C</li></ul></li></ul><p><strong>DDR SDRAM</strong></p><ul><li>在 SDRAM（Synchronous Dynamic RAM，同步动态随机存取存储器）的基础上进行了优化</li><li>内部具备 2 位预取机制，可交叉编址，当一个存储体输出时，另一个存储体准备数据</li><li>时钟上、下沿分别传输数据，传输带宽比单沿传输数据增加一倍</li></ul><h3 id="只读存储器ROM"><a href="#只读存储器ROM" class="headerlink" title="只读存储器ROM:"></a>只读存储器ROM:</h3><ul><li><p>掩膜式 ROM，MROM</p><ul><li>熔丝断为“0”，熔丝未断为“1”</li><li>生产厂家采用掩膜技术将程序写入存储器</li><li>依照制造工艺，分为 MOS 型和 TTL 型两类<ul><li>MOS 型 MROM 具有功耗低、速度慢</li><li>TTL 型 MROM 则具有速度快、功耗大</li></ul></li></ul></li><li><p>可编程 ROM，PROM </p><ul><li>可由用户写入操作，且只有一次写入机会</li><li>PROM 在出厂设置时，数据全设为 1，用户根据需要将某些单元写入数据 0</li></ul></li><li><p>可擦可编程 ROM，EPROM</p><ul><li><p>非易失性的存储芯片</p></li><li><p>用户可对 EPROM 芯片重复擦除和写入</p></li><li><p>用户利用紫外线透过设置的一个玻璃窗口照射内部芯片时，就可以擦除其内部存储的数据，芯片擦除的操作需要配套的 EPROM 擦除器</p></li><li><p>擦除机制特殊，窗口制作成本较高，导致 EPROM 逐渐退出市场</p><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1ch4-%E5%AD%98%E5%82%A8%E5%99%A8%E7%B3%BB%E7%BB%9F/image-20230427003452453.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="eprom"></p></li><li><p>工作原理</p><ul><li>若在漏源之间感应出正电荷，表示存入0 </li><li>若在漏源之间无正电荷，表示存入1 </li><li>当紫外线照射，电荷被泄放，恢复写入前状态</li></ul></li></ul></li><li><p>电擦除可编程 ROM，EEPROM</p><ul><li>非易失性的存储芯片</li><li>通过电信号将保存的数据全部或部分擦除，并完成在线编程</li><li>读写的速度与 RAM 相比要慢很多。与 EPROM 相比，使用更加方便</li></ul></li><li><p>原理</p><ul><li>与EPROM类似</li><li>擦除：用加电方法，进行在线擦写。擦除是固定写1</li></ul></li><li><p>快闪存储器，Flash，分为 NOR 和 NAND 闪存</p><ul><li><p>写操作只能将数据位从 1 写成 0，而不能将 0 改写为 1 </p></li><li><p>写入之前须先预操作，将预写入的数据位初始化为 1 </p></li><li><p>NOR</p></li><li><p>擦除操作以区块位单位，区块大小为 64～128KB</p></li><li><p>执行一个写入&#x2F;擦除操作的周期为 5s</p></li><li><p>可以直接运行应用程序</p></li><li><p>NAND</p><ul><li>擦除操作也是以块为单位，块大小为 8～32KB </li><li>执行相同的操作最多只需 4ms</li></ul></li><li><p>在读写时偶尔产生位反转，且无法完全避免，事后弥补</p></li><li><p>还可能出现坏块，初始化扫描并对坏块进行标记</p></li></ul></li></ul><h3 id="FLASH-NOR-amp-NAND比较"><a href="#FLASH-NOR-amp-NAND比较" class="headerlink" title="FLASH NOR&amp;NAND比较"></a>FLASH NOR&amp;NAND比较</h3><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1ch4-%E5%AD%98%E5%82%A8%E5%99%A8%E7%B3%BB%E7%BB%9F/image-20230427003947502.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="FLASH NOR&amp;NAND"></p><ul><li><p>容量：NOR型更像内存，比较贵，容量比较小；而NAND型更像硬盘，成本要低一些，容量大得多。</p></li><li><p>应用：NOR型比较适合频繁随机读写的场合，存储程序代码可直接在闪存内运行，例手机使用NOR型闪存；NAND型存储资料，如闪存盘、数码存储卡等</p></li><li><p>速度：NOR型速度很有限，频率比内存低得多，NAND型闪存类似硬盘的操作，效率也比内存慢得多，比硬盘快得多。</p></li><li><p>存储单元：NOR型闪存的基本存储单元是字节；NAND型闪存的基本存储单元是页，类似硬盘的扇区。</p></li><li><p>擦除操作：以块为单位擦除。闪存的写入操作必须在空白区域进行，如果目标区域已经有数据，必须先擦除后写入，因此擦除操作是闪存的基本操作。</p></li><li><p>寻址：NOR型有独立的地址线和数据线；NAND型闪存通过8条I&#x2F;O接口数据线传输地址信息包</p></li></ul><h3 id="存储器的主要技术指标"><a href="#存储器的主要技术指标" class="headerlink" title="存储器的主要技术指标"></a>存储器的主要技术指标</h3><ul><li>存储容量<ul><li>B，KB，MB，GB，TB</li></ul></li><li>存取时间<ul><li>CPU 对内存进行读或写操作时所需要花费的时间</li><li>存取时间的倒数来表示速度<ul><li>例：存取时间 1ns 内存，访问频率为 1&#x2F;10−9Hz &#x3D; 1000MHz</li></ul></li></ul></li><li>存储周期<ul><li>两次独立的读写操作之间所需的时间，一般为6～10ns</li></ul></li></ul><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1ch4-%E5%AD%98%E5%82%A8%E5%99%A8%E7%B3%BB%E7%BB%9F/image-20230427004350709.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="存储器"></p><ul><li>访问带宽<ul><li>内存总线所能提供的数据传输能力<ul><li>访问带宽&#x3D;存储器位数&#x2F;8 × 读取速度峰值</li><li>表示每秒从主存进出信息的最大数量</li><li>例：存取周期500ns，存储器位数16位，则带宽32MB&#x2F;S</li><li>访问带宽决定信息传输速度，是系统瓶颈的关键因素</li><li>为提高存储器带宽，可采取措施为</li><li>缩短存取周期</li><li>增加存储字长</li></ul></li></ul></li></ul><h1 id="4-3-ARM存储器管理"><a href="#4-3-ARM存储器管理" class="headerlink" title="4.3 ARM存储器管理"></a>4.3 ARM存储器管理</h1><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1ch4-%E5%AD%98%E5%82%A8%E5%99%A8%E7%B3%BB%E7%BB%9F/image-20230427004712142.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="存储器"></p><h3 id="存储器的挂载"><a href="#存储器的挂载" class="headerlink" title="存储器的挂载"></a>存储器的挂载</h3><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1ch4-%E5%AD%98%E5%82%A8%E5%99%A8%E7%B3%BB%E7%BB%9F/image-20230502215228546.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="挂载"></p><h3 id="存储映射"><a href="#存储映射" class="headerlink" title="存储映射"></a>存储映射</h3><ul><li>地址总线是 32 位，可访问4GB的地址空间</li><li>小端格式存储，可寻址空间分为 8 个主要块，</li><li>每个块为 512 MB，即0.5GB<ul><li>程序代码访问区域（0.5GB）</li><li>数据交互区域（SRAM，0.5GB）</li><li>片内外围设备（0.5GB）</li><li>外部存储空间或片外外设（2GB）</li><li>处理器内部控制（NVIC）和调试区域（0.5GB）</li></ul></li></ul><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1ch4-%E5%AD%98%E5%82%A8%E5%99%A8%E7%B3%BB%E7%BB%9F/image-20230502215748082.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="存储映射"></p><h3 id="地址分配"><a href="#地址分配" class="headerlink" title="地址分配"></a>地址分配</h3><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1ch4-%E5%AD%98%E5%82%A8%E5%99%A8%E7%B3%BB%E7%BB%9F/image-20230502215954742.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="地址分配"></p><p>内存映射-块0和块1</p><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1ch4-%E5%AD%98%E5%82%A8%E5%99%A8%E7%B3%BB%E7%BB%9F/image-20230502220022254.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="0&amp;1"></p><h3 id="FLASH"><a href="#FLASH" class="headerlink" title="FLASH"></a>FLASH</h3><ul><li>CPU 通过 AHB I-BUS 和 D-BUS 对 Flash 进行的访问</li><li>Flash 接口通过指令预取和缓存机制加速代码执行</li><li>闪存组织如下：<ul><li>主存储块被分成扇区</li><li>系统存储器，器件在系统存储器自举模式下从该存储器启动</li><li>512 OTP（一次性可编程）字节，用于存储用户数据</li><li>读写保护、BOR 层，看门狗、复位等配置的可选字节</li></ul></li></ul><h3 id="启动配置"><a href="#启动配置" class="headerlink" title="启动配置"></a>启动配置</h3><ul><li>代码区从地址0x00000000开始（I总线&#x2F;D总线访问）</li><li>数据区从地址0x20000000开始（通过系统总线访问）</li><li>带FPU的Cortex M4 CPU在I代码总线上取复位扇区，意味着只有在代码区有启动空间</li><li>支持三种启动模式：<ul><li>主闪存启动模式</li><li>系统存储器启动模式</li><li>嵌入 SRAM 启动模式</li></ul></li></ul><h1 id="4-4-新型存储器"><a href="#4-4-新型存储器" class="headerlink" title="4.4 新型存储器"></a>4.4 新型存储器</h1><ul><li>存储器可分为易失性和非易失性</li><li>易失性存储器主要SRAM 和 DRAM</li><li>非易失性存储器</li><li>闪存（Flash）</li><li>SONOS（Silicon Oxide Nitride Oxide Semiconductor，基于氮化硅存储介质）</li><li>铁电存储器（Ferroelectric Random Access Memory，FRAM）</li><li>相变存储器（Phase Change Memory，PRAM）</li><li>磁存储器（Magnetic Random Access Memory，MRAM）</li><li>阻变存储器（Resistance，RRAM）</li><li>SRAM、DRAM、FLASH、SONOS 和 FRAM 存储器是基于电荷的存储器</li><li>PRAM、MRAM 和 RRAM 是基于电阻的转变来实现对数据的存储</li></ul><h3 id="MRAM"><a href="#MRAM" class="headerlink" title="MRAM"></a>MRAM</h3><p>MRAM的基本结构是磁性隧道结</p><ul><li>底下一层薄膜是铁磁材料（钉扎层），磁自旋方向固定</li><li>中间一层是隧穿层</li><li>上面一层是自由层，其自旋方向可在外力下改变</li><li>当自由层的自旋方向和钉扎层的自旋方向一致，则隧道层处于低电阻的状态，为“0”；反之则处于高阻状态，为“1”</li><li>利用磁性隧道结的电阻变化来实现数据存储。</li></ul><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1ch4-%E5%AD%98%E5%82%A8%E5%99%A8%E7%B3%BB%E7%BB%9F/image-20230502220853046.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="MRAM"></p><p>MRAM分为传统的MRAM和STT-MRAM，是驱动自由层翻转的方式不同</p><p>传统的MRAM</p><ul><li>采用磁场驱动</li><li>结构中增加旁路引入较大的电流来产生磁场</li><li>功耗较大，集成度低</li></ul><p>STT-MRAM</p><ul><li>采用自旋极化电流驱动</li><li>不需增加旁路，功耗降低，集成度高。</li></ul><h3 id="PRAM"><a href="#PRAM" class="headerlink" title="PRAM"></a>PRAM</h3><p>三层结构</p><ul><li>上电极（Top Electrode）</li><li>具有相变特性材料的中间层</li><li>下电极（BottomElectrode）</li></ul><p> 中间是相变层，在晶化（低阻态）和非晶化（高阻态）之间转变，利用高低阻态的变化来实现存储</p><p> PRAM 器件具有 M-I-M 或 M-I-S 结构，在器件两端施加不同的电脉冲，可在晶态与非晶态之间发生转变，呈现出不同的电阻态，进行数据存储</p><p> 英特尔和美光2015年联合推出了3D Xpoint技术</p><ul><li>3D Xpoint技术的存储单元是采用的1R1D结构的PRAM，这和三星采用的1R1T结构的方向完全不同</li></ul><p> 3D Xpoint技术在非易失存储器领域实现了革命性突破。虽然其速度略微比DRAM慢，但其容量却比DRAM高，比闪存快1000倍</p><h3 id="RRAM"><a href="#RRAM" class="headerlink" title="RRAM"></a>RRAM</h3><p>RRAM与PRAM类似，中间转变层使用不同原理</p><ul><li>用电阻丝理论（Filament theory），通过在绝缘体外部偏置影响，电子在阴极生成，并通过绝缘层到达阳极</li><li>当电阻丝经过 Forming process 形成后，再控制外加的电压与电流，可以使RRAM 组件在高阻态与低阻态来回切换，利用电阻值的高低储存 0 与 1 的信号</li></ul><h1 id="4-5存储保护和校验技术"><a href="#4-5存储保护和校验技术" class="headerlink" title="4.5存储保护和校验技术"></a>4.5存储保护和校验技术</h1><p>存储保护：存储区保护和访问方式的保护</p><p>主存系统采用界限寄存器的方式进行保护：</p><ul><li>适合于单个用户占用一个或者几个连续的主存区域的场合</li></ul><p>虚拟存储系统：页表保护、段表保护和键时保护等方法实现存储保护</p><h3 id="ARM嵌入式芯片内存储保护"><a href="#ARM嵌入式芯片内存储保护" class="headerlink" title="ARM嵌入式芯片内存储保护"></a>ARM嵌入式芯片内存储保护</h3><ul><li>闪存的用户区域<strong>读保护</strong>有三个层次：<ul><li>层次0：无读保护</li><li>层次1：读保护使能</li><li>层次2：调试&#x2F;芯片保护被关闭<ul><li>所有层次1下的保护被激活</li><li>从RAM或者系统存储器bootloader启动被禁止</li><li>JTAG，SWV（single-wire viewer），ETM或者边界扫描被禁止使</li><li>用户可选字节不能被改变</li><li>当从闪存启动时，从用户代码访问闪存或者备份SRAM被允许</li></ul></li></ul></li></ul><h4 id="ARM的闪存写保护"><a href="#ARM的闪存写保护" class="headerlink" title="ARM的闪存写保护"></a>ARM的闪存写保护</h4><p>Flash 中有多达 24 个用户扇区具备写保护功能，可防止因程序指针错乱而发生意外的写操作</p><h4 id="存储保护-看门狗"><a href="#存储保护-看门狗" class="headerlink" title="存储保护-看门狗"></a>存储保护-看门狗</h4><p>实现独立的看门狗（IWDG）对Prescaler寄存器IWDG_PR，Reload寄存器IWDG_RLR的访问被写保护的</p><h4 id="存储保护-CAN寄存器保护"><a href="#存储保护-CAN寄存器保护" class="headerlink" title="存储保护-CAN寄存器保护"></a>存储保护-CAN寄存器保护</h4><ul><li>错误的配置寄存器访问会暂时干扰整个CAN网络</li><li>CAN_BTR寄存器只能在CAN硬件在初始化模式时被软件修改。</li><li>传输邮箱只能在空的时候被软件修改。</li><li>通过设置FINIT位或者关闭过滤器Bank可以修改过滤器值。 CAN_FMxR，CAN_FSxR，CAN_FFAR寄存器中的过滤器配置（尺度，模式和FIFO安排）的修改只能在CAN_FMR寄存器中的初始化模式被设置（FINIT&#x3D;1）时执行</li></ul><h4 id="存储保护-SDIO卡保护"><a href="#存储保护-SDIO卡保护" class="headerlink" title="存储保护-SDIO卡保护"></a>存储保护-SDIO卡保护</h4><p>在SDIO卡的主访问中，硬件实现了三种写保护方法：</p><ul><li>内部卡写保护（存储卡来负责）</li><li>通过机械写保护开关（SDIO卡主访问块负责）</li><li>密码保护</li></ul><h4 id="校验保护"><a href="#校验保护" class="headerlink" title="校验保护"></a>校验保护</h4><ul><li>奇偶校验</li><li>ECC校验：错误检查和纠正，Error Checking and Correcting</li><li>在ARM嵌入式芯片设计时，在FSMC&#x2F;FMC PC卡控制器中，就集成了<strong>两个ECC计算硬件块</strong>，每个块负责一个存储Bank（Bank 2 和Bank 3）</li><li>硬件计算可以用于降低CPU的工作负载，对于256，512，1024，2048，4096或者8192字节的NAND闪存读或写可以纠正1位错误和检测2位错误</li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>存储器系统的分类</li><li>ARM存储映射</li><li>新型存储器</li><li>存储保护及校验</li></ul>]]></content>
    
    
    <categories>
      
      <category>学习资料</category>
      
    </categories>
    
    
    <tags>
      
      <tag>课件笔记</tag>
      
      <tag>嵌入式程序设计</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机组成原理-L08-ILP-ARM和x86流水线</title>
    <link href="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L08-ILP-ARM%E5%92%8Cx86%E6%B5%81%E6%B0%B4%E7%BA%BF/"/>
    <url>/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L08-ILP-ARM%E5%92%8Cx86%E6%B5%81%E6%B0%B4%E7%BA%BF/</url>
    
    <content type="html"><![CDATA[<h1 id="计算机组成与实践-流水线实例"><a href="#计算机组成与实践-流水线实例" class="headerlink" title="计算机组成与实践 -流水线实例"></a><strong>计算机组成与实践</strong> -<strong>流水线实例</strong></h1><ul><li><strong>流水线实例简介</strong></li><li><strong>ARM Cortex A53</strong></li><li><strong>Intel Core i7 920</strong></li></ul><h2 id="一-流水线实例简介"><a href="#一-流水线实例简介" class="headerlink" title="一.流水线实例简介"></a>一.<strong>流水线实例简介</strong></h2><table><thead><tr><th><strong>Processor</strong></th><th><strong>ARM  A53</strong></th><th><strong>Intel  Core i7 920</strong></th></tr></thead><tbody><tr><td>市场</td><td>个人移动设备</td><td>服务器、云计算</td></tr><tr><td>设计功耗</td><td>100mW（单核频率1GHz）</td><td>130W</td></tr><tr><td>时钟频率</td><td>1.5  GHz</td><td>2.66  GHz</td></tr><tr><td>单芯片核数</td><td>4 (可配置)</td><td>4</td></tr><tr><td>是否支持浮点</td><td>是</td><td>是</td></tr><tr><td>是否多发射</td><td>动态</td><td>动态</td></tr><tr><td>峰值IPC</td><td>2</td><td>4</td></tr><tr><td>流水线级数</td><td>8</td><td>14</td></tr><tr><td>流水线调度</td><td>静态按序</td><td>动态乱序+推测式执行</td></tr><tr><td>分支预测</td><td>混合</td><td>2级</td></tr><tr><td>单核内L1  Cache</td><td>ICache：16<del>64KB     DCache：16</del>64KB</td><td>ICache：32KB     DCache：32KB</td></tr><tr><td>单核内L2  Cache</td><td>共享，128~2048KB</td><td>每个核256KB</td></tr><tr><td>共享L3  Cache</td><td>由平台决定</td><td>2~8MB</td></tr></tbody></table><h2 id="二-ARM-Cortex-A53"><a href="#二-ARM-Cortex-A53" class="headerlink" title="二.ARM Cortex A53"></a>二.<strong>ARM Cortex A53</strong></h2><ul><li>ARM Cortex-A53是一款基于ARMv8指令系统的八级流水线结构处理器。<ul><li>28nm HPM制造工艺</li><li>推出市场之初，是世界上能耗比最高、面积最小的64位应用处理器。</li></ul></li><li>流水线分为三个部分：<strong>取指、译码和执行</strong></li><li>采用动态多发射技术，每周期发射2条指令</li><li>采用静态按序流水线，指令按序发射、按序执行、按序提交</li></ul><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L08-ILP-ARM%E5%92%8Cx86%E6%B5%81%E6%B0%B4%E7%BA%BF/image-20230426171004651.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="a53"></p><p>流水线的前三级每周期取两条指令，将指令取到表项数为13的指令队列中，地址产生单元（AGU）使用混合预测器、间接转移预测器和返回栈对各类分支转移指令进行预测，尽可能保持指令队列中有足够多的指令。</p><ul><li>采用6kb大小的混合条件分支预测器</li><li>256表项的间接转移预测器，间接转移预测需要占用额外的一个流水级</li><li>一个用来预测函数返回地址的8表项返回地址栈</li></ul><p>流水线的译码阶段用来判断“指令对”内部是否存在依赖关系，并决定指令将被发送到哪类功能部件上。</p><p>指令执行阶段占用了三个流水级。</p><ul><li>Cortex-A53为load和store指令分别提供单独的执行流水线</li><li>为定点算术指令提供两条执行流水线</li><li>为定点乘法和除法操作分别提供单独的执行流水线</li><li>“指令对”中的任意一条指令都可以发射到load或者store流水线中</li><li>执行阶段的不同流水线之间具有全旁路机制。</li></ul><p>为实现浮点和SIMD指令，在指令的执行阶段增加两个流水级。使用其中一级实现浮点的乘法&#x2F;除法&#x2F;开方操作，另一流水级实现浮点的其他算术操作。</p><p>ARM Cortex-A53使用静态调度的流水线结构，依靠编译器避免结构冒险和数据依赖</p><h2 id="三-Intel-Core-i7-920"><a href="#三-Intel-Core-i7-920" class="headerlink" title="三.Intel Core i7 920"></a>三.<strong>Intel Core i7 920</strong></h2><p>x86 采用了复杂的流水线技术，在其14 级流水线中综合使用了动态多发射、乱序执行和推测执行的动态流水线调度技术。</p><table><thead><tr><th><strong>微操作</strong></th></tr></thead><tbody><tr><td>取入x86 指令，将其翻译为类MIPS 指令，Intel 称之为“微操作”</td></tr></tbody></table><p>微操作由复杂的基于推测执行的动态调度流水线执行，该流水线每个时钟周期最多可执行6 个微操作</p><table><thead><tr><th><strong>微体系结构</strong></th></tr></thead><tbody><tr><td>处理器的组织，包括主要的功能单元及它们的互连关系与流水线控制。</td></tr></tbody></table><p>使用重排序缓冲区和寄存器重命名技术来解决反相关和推测错误</p><p>寄存器重命名技术：显式地将处理器中的体系结构寄存器（architectural register）重命名为一组更大的物理寄存器集合</p><table><thead><tr><th><strong>体系结构寄存器</strong></th></tr></thead><tbody><tr><td>处理器中的可见寄存器。  如在MIPS 中有32 个整数寄存器和16 个浮点寄存器是可见的，64 位版本的x86体系结构中是16 个。</td></tr></tbody></table><ul><li>需要维护体系结构寄存器和物理寄存器之间的映射关系</li><li>能指出哪个物理寄存器才是某个体系结构寄存器的最新备份</li></ul><p>寄存器重命名提供了另一种推测错误时的恢复方法： 简单地撤销所有第一条推测错误指令后建立的所有映射。</p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L08-ILP-ARM%E5%92%8Cx86%E6%B5%81%E6%B0%B4%E7%BA%BF/image-20230426171203607.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="Intel Core i7流水线"></p><h3 id="一条x86指令的执行"><a href="#一条x86指令的执行" class="headerlink" title="一条x86指令的执行"></a><strong>一条x86指令的执行</strong></h3><p>1.取指令：处理器使用一个多级分支目标缓冲器在速度和预测准确性方面做平衡。另外还有一个返回地址栈用于加速函数返回。误预测将导致15个周期的开销。取指部件使用预测地址从指令cache中取入16字节</p><p>2.这16字节放入预译码指令缓冲器：预译码阶段将这16字节转换为独立的x86指令。因为x86指令长度可以是1 ～ 15字节不等，预译码操作必须扫描多个字节以确定指令长度，所以预译码操作非常复杂。每条x86指令放入一个18入口的指令队列。</p><p>3.微操作译码：每条x86指令被翻译为微操作。有三个译码器将x86指令直接翻译为一个微操作。而对于具有复杂语法功能的x86指令，则使用一个微代码引擎产生一个微操作序列；它可以在每个周期生成4个微操作直到必需的微操作序列生成为止。这些微操作按照x86指令顺序放入28入口的微操作缓冲器。</p><p>4.微操作缓冲器执行循环流检测：如果有一个小的指令序列（少于28条指令或长度小于256 字节）包含一个循环，循环流检测器将识别该循环，并直接从缓冲器中发射微操作，从而减少了指令预取和指令译码。</p><p>5.执行基本指令发射：在将微操作发射到保留站之前，在寄存器表中查找寄存器位置、对寄存器进行重命名、分配重排序缓冲器入口、从寄存器或重排序缓冲中取结果。</p><p>6.i7使用一个被6个功能单元共享的36入口的集中式保留站。在每个周期内最多可以向功能单元分派6个微操作。</p><p>7.各个功能单元执行微操作，执行结果不但送往寄存器提交部件，在己知指令将不再预测的情况下更新寄存器状态，还可送往任何一个等待的保留站。重排序缓冲中与指令对应的入口标记为完成。</p><p>8.当前面的一条或多条指令已经被标记为完成，则执行寄存器提交部件中未决的写操作，指令从重排序缓冲器中移走。</p>]]></content>
    
    
    <categories>
      
      <category>学习资料</category>
      
    </categories>
    
    
    <tags>
      
      <tag>课件笔记</tag>
      
      <tag>计算机组成原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机组成原理-L08-ILP</title>
    <link href="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L08-ILP/"/>
    <url>/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L08-ILP/</url>
    
    <content type="html"><![CDATA[<h1 id="计算机组成与实践-指令级并行（ILP）"><a href="#计算机组成与实践-指令级并行（ILP）" class="headerlink" title="计算机组成与实践 -指令级并行（ILP）"></a><strong>计算机组成与实践</strong> -<strong>指令级并行（ILP）</strong></h1><ul><li><strong>ILP简介</strong></li><li><strong>依赖</strong></li><li><strong>静态多发射</strong></li><li><strong>动态多发射</strong></li><li><strong>小结</strong></li></ul><h2 id="一-ILP简介"><a href="#一-ILP简介" class="headerlink" title="一.ILP简介"></a>一.<strong>ILP简介</strong></h2><h3 id="指令级并行（Instruction-Level-Parallel）"><a href="#指令级并行（Instruction-Level-Parallel）" class="headerlink" title="指令级并行（Instruction Level Parallel）"></a><strong>指令级并行（Instruction Level Parallel）</strong></h3><ul><li>流水线：并行执行多条指令</li><li>提高指令级并行<ul><li>超级流水线（Super pipelining）：增加流水级<ul><li>每级任务变少Þ 时钟周期缩短</li></ul></li></ul></li><li>多发射（multiple issue）<ul><li>复制流水线的各级Þ 多条流水线</li><li>每个时钟周期提取多条指令</li><li>CPI&lt;1，采用IPC</li><li>例如，4GHz 4路多发射：160 BIPS，峰值CPI&#x3D;0.25，峰值IPC&#x3D;4</li><li>实际上，依赖关系减少了IPC</li></ul></li></ul><h3 id="多发射（Multiple-Issue）"><a href="#多发射（Multiple-Issue）" class="headerlink" title="多发射（Multiple Issue）"></a><strong>多发射（Multiple Issue）</strong></h3><ul><li>静态多发射（VLIW）<ul><li>编译器阶段选择哪些指令为一组进行多发射</li><li>将这组指令放入发射槽（issue slots）</li><li>编译器检测并避免冒险</li></ul></li><li>动态多发射（Superscalar）<ul><li>CPU执行指令并选择哪些指令可以进行多发射</li><li>编译器可以帮助调整指令执行顺序</li><li>CPU在运行时解决冒险</li></ul></li></ul><h2 id="二-依赖"><a href="#二-依赖" class="headerlink" title="二.依赖"></a><strong>二.依赖</strong></h2><table><thead><tr><th><strong>结构冒险——资源冲突</strong></th></tr></thead><tbody><tr><td>多发射处理器会出现很多资源冲突</td></tr><tr><td>资源冲突可以通过加入更多硬件资源或流水线执行来消除</td></tr></tbody></table><table><thead><tr><th><strong>数据冒险——数据（存储）依赖</strong></th></tr></thead><tbody><tr><td>在多发射处理器中极大的限制了其指令级并行</td></tr></tbody></table><table><thead><tr><th><strong>控制冒险——过程依赖</strong></th></tr></thead><tbody><tr><td>在多发射处理器中更严峻</td></tr><tr><td>采用动态分支预测可以缓解</td></tr></tbody></table><p>通过软硬件结合的方式来缓解依赖带来的影响</p><h3 id="数据冒险"><a href="#数据冒险" class="headerlink" title="数据冒险"></a><strong>数据冒险</strong></h3><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L08-ILP/image-20230426164130460.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="数据冒险"></p><table><thead><tr><th><strong>RAW（真相关）</strong></th></tr></thead><tbody><tr><td>当前指令使用的数据是前面指令更新的数据，必须保持指令执行的顺序</td></tr></tbody></table><table><thead><tr><th><strong>WAR（反相关）</strong></th></tr></thead><tbody><tr><td>当前指令需要更新数据，而前面的指令使用的是原来的数据，必须保持指令执行的顺序</td></tr></tbody></table><table><thead><tr><th><strong>WAW（输出相关）</strong></th></tr></thead><tbody><tr><td>两条指令会相继更新数据，必须保持指令执行的顺序</td></tr></tbody></table><h3 id="课堂练习："><a href="#课堂练习：" class="headerlink" title="课堂练习："></a><strong>课堂练习：</strong></h3><p>找到下面指令的所有数据依赖，并给出其属于哪种依赖</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs avrasm">I1：<span class="hljs-keyword">ADD</span> <span class="hljs-built_in">R1</span>, <span class="hljs-built_in">R2</span>, <span class="hljs-built_in">R1</span><br><span class="hljs-symbol">I2:</span>  LW  <span class="hljs-built_in">R2</span>, <span class="hljs-number">0</span>(<span class="hljs-built_in">R1</span>)<br><span class="hljs-symbol">I3:</span>  LW  <span class="hljs-built_in">R1</span>, <span class="hljs-number">4</span>(<span class="hljs-built_in">R1</span>)<br><span class="hljs-symbol">I4:</span>  <span class="hljs-keyword">OR</span>  <span class="hljs-built_in">R3</span>, <span class="hljs-built_in">R1</span>, <span class="hljs-built_in">R2</span><br><br></code></pre></td></tr></table></figure><ul><li>RAW表示程序中数据流，即数据处理的顺序</li><li>WAR和WAW两种依赖因为寄存器数量有限（存储冲突）而产生的，即不得不重复使用同一个寄存器</li><li>存储冲突可以减少：<ul><li>增加存储资源</li><li>提供额外的寄存器，重新建立寄存器与数值之间的对应关系</li><li>超标量处理器使用硬件动态分配寄存器</li></ul></li></ul><h4 id="解决存储冲突"><a href="#解决存储冲突" class="headerlink" title="解决存储冲突"></a><strong>解决存储冲突</strong></h4><table><thead><tr><th><strong>寄存器重命名（Register Renaming）</strong></th></tr></thead><tbody><tr><td>处理器重新命名指令中的寄存器标识符</td></tr></tbody></table><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L08-ILP/image-20230426164318794.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="解决存储冲突"></p><p>硬件通过从空闲寄存器池中分配一个寄存器进行重命名</p><p>数据使用之后将寄存器释放回空闲寄存器池</p><h4 id="解决过程依赖"><a href="#解决过程依赖" class="headerlink" title="解决过程依赖"></a><strong>解决过程依赖</strong></h4><table><thead><tr><th><strong>推测（Speculation）</strong></th></tr></thead><tbody><tr><td>为了使依赖于该指令的其他指令尽快运行，推测一条指令的结果：</td></tr><tr><td>推测分支结果：如果错误则返回去执行正确指令</td></tr><tr><td>推测load指令不依赖与store指令：如果错误，返回重新load数据</td></tr></tbody></table><ul><li>必须有以下机制支持推测技术：<ul><li>检测推测是否正确<ul><li>如果正确，完成操作</li><li>如果错误，返回到该指令并执行正确的结果</li></ul></li><li>如果推测错误，必须能够恢复</li></ul></li><li>推测可以由编译器或硬件来完成</li><li>通常在静态和动态多发射中使用</li></ul><h4 id="编译器推测和硬件推测"><a href="#编译器推测和硬件推测" class="headerlink" title="编译器推测和硬件推测"></a><strong>编译器推测和硬件推测</strong></h4><ul><li>编译器推测可以调整指令执行顺序<ul><li>例如，将load放到分支之前执行</li><li>插入额外指令检测正确性，并为推测错误提供修复程序</li></ul></li><li>硬件推测可以提前执行指令<ul><li>缓存推测的结果直至推测的结果得到确认</li><li>如果推测正确，将缓存的结果写回到寄存器和存储器</li><li>如果推测错误，硬件清除缓存并重新执行正确指令</li></ul></li></ul><h2 id="三-静态多发射"><a href="#三-静态多发射" class="headerlink" title="三.静态多发射"></a><strong>三.静态多发射</strong></h2><ul><li>编译器封装多条指令并处理冒险<ul><li>将可以在同一时钟周期执行的指令封装成发射包（issue packet）</li><li>由流水线的资源数量所决定</li></ul></li><li>一条执行多个操作的长指令<ul><li>指定多个并发操作</li><li>超长指令字（ very long instruction word，VLIW）</li></ul></li></ul><h4 id="调度静态多发射"><a href="#调度静态多发射" class="headerlink" title="调度静态多发射"></a><strong>调度静态多发射</strong></h4><p>编译器处理数据冒险和控制冒险</p><ul><li>调度代码，封装发射包</li><li>发射包内指令间不能存在依赖</li><li>发射包间可以存在指令间依赖</li><li>如果需要可以封装nop操作</li></ul><h4 id="静态双发射例子"><a href="#静态双发射例子" class="headerlink" title="静态双发射例子"></a><strong>静态双发射例子</strong></h4><p>双发射包</p><ul><li>一条ALU 指令或分支指令</li><li>一条load或store指令</li><li>两条指令成对存放在64位对齐的存储区域</li></ul><table><thead><tr><th>Address</th><th>Instruction  type</th><th>Pipeline  Stages</th><th></th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>n</td><td>ALU&#x2F;branch</td><td>IF</td><td>ID</td><td>EX</td><td>MEM</td><td>WB</td><td></td><td></td></tr><tr><td>n +  4</td><td>Load&#x2F;store</td><td>IF</td><td>ID</td><td>EX</td><td>MEM</td><td>WB</td><td></td><td></td></tr><tr><td>n +  8</td><td>ALU&#x2F;branch</td><td></td><td>IF</td><td>ID</td><td>EX</td><td>MEM</td><td>WB</td><td></td></tr><tr><td>n +  12</td><td>Load&#x2F;store</td><td></td><td>IF</td><td>ID</td><td>EX</td><td>MEM</td><td>WB</td><td></td></tr><tr><td>n +  16</td><td>ALU&#x2F;branch</td><td></td><td></td><td>IF</td><td>ID</td><td>EX</td><td>MEM</td><td>WB</td></tr><tr><td>n +  20</td><td>Load&#x2F;store</td><td></td><td></td><td>IF</td><td>ID</td><td>EX</td><td>MEM</td><td>WB</td></tr></tbody></table><h4 id="静态双发射数据通路"><a href="#静态双发射数据通路" class="headerlink" title="静态双发射数据通路"></a><strong>静态双发射数据通路</strong></h4><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L08-ILP/image-20230426164752063.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="双发射"></p><h4 id="双发射中的冒险"><a href="#双发射中的冒险" class="headerlink" title="双发射中的冒险"></a><strong>双发射中的冒险</strong></h4><ul><li>EX级发射数据冒险<ul><li>单个发射通路中出现数据冒险，采用旁路</li><li>发射包中指令间存在的数据冒险<ul><li>add $0,$0,$1</li><li>lw   $2,0($0)</li><li>将这两条指令封装进不同的发射包中</li></ul></li></ul></li><li>取数使用型数据冒险<ul><li>阻塞一个时钟周期</li></ul></li><li>需要编译器技术<ul><li>指令调度（instruction Scheduling）</li><li>循环展开（Loop Unrolling）</li></ul></li></ul><h4 id="指令调度示例"><a href="#指令调度示例" class="headerlink" title="指令调度示例"></a><strong>指令调度示例</strong></h4><p>面向双发射调度下列代码</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs awk">Loop: lw    <span class="hljs-variable">$t0</span>, <span class="hljs-number">0</span>(<span class="hljs-variable">$s1</span>)     <span class="hljs-regexp">//</span> <span class="hljs-variable">$t0</span>=array element<br>addu  <span class="hljs-variable">$t0</span>, <span class="hljs-variable">$t0</span>,<span class="hljs-variable">$s2</span>    <span class="hljs-regexp">//</span> add scalar <span class="hljs-keyword">in</span> <span class="hljs-variable">$s2</span><br>sw    <span class="hljs-variable">$t0</span>, <span class="hljs-number">0</span>(<span class="hljs-variable">$s1</span>)      <span class="hljs-regexp">//</span> store result<br>addi  <span class="hljs-variable">$s1</span>, <span class="hljs-variable">$s1</span>, -<span class="hljs-number">4</span>     <span class="hljs-regexp">//</span> decrement pointer<br>bne   <span class="hljs-variable">$s1</span>, <span class="hljs-variable">$zero</span>, Loop  <span class="hljs-regexp">//</span> branch <span class="hljs-variable">$s1</span>!=<span class="hljs-number">0</span><br><br></code></pre></td></tr></table></figure><table><thead><tr><th></th><th>ALU&#x2F;branch</th><th>Load&#x2F;store</th><th>cycle</th></tr></thead><tbody><tr><td>Loop:</td><td>nop</td><td>lw   $t0, 0($s1)</td><td>1</td></tr><tr><td></td><td>addi   $s1, $s1, -4</td><td>nop</td><td>2</td></tr><tr><td></td><td>addu   $t0, $t0,$s2</td><td>nop</td><td>3</td></tr><tr><td></td><td>bne   $s1, $zero, Loop</td><td>sw    $t0, 0($s1)</td><td>4</td></tr></tbody></table><p>IPC &#x3D; 7&#x2F;6 &#x3D; 1.17 (c.f. peak IPC &#x3D; 2)</p><h4 id="循环展开"><a href="#循环展开" class="headerlink" title="循环展开"></a><strong>循环展开</strong></h4><ul><li>复制多个循环体获得更高的并行度<ul><li>减少循环控制开销</li></ul></li><li>在多个循环中使用不同寄存器<ul><li>也称为寄存器重命名（register renaming）</li><li>保持循环间的依赖关系</li></ul></li></ul><h4 id="循环展开示例"><a href="#循环展开示例" class="headerlink" title="循环展开示例"></a><strong>循环展开示例</strong></h4><table><thead><tr><th></th><th>ALU&#x2F;branch</th><th>Load&#x2F;store</th><th>cycle</th></tr></thead><tbody><tr><td>Loop:</td><td>addi   $s1, $s1, -16</td><td>lw   $t0, 0($s1)</td><td>1</td></tr><tr><td></td><td>nop</td><td>lw   $t1, 12($s1)</td><td>2</td></tr><tr><td></td><td>addu   $t0, $t0,$s2</td><td>lw   $t2, 8($s1)</td><td>3</td></tr><tr><td></td><td>addu   $t1, $t1,$s2</td><td>lw   $t3, 4($s1)</td><td>4</td></tr><tr><td></td><td>addu   $t2, $t2,$s2</td><td>sw    $t0, 16($s1)</td><td>5</td></tr><tr><td></td><td>addu   $t3, $t3,$s2</td><td>sw    $t1, 12($s1)</td><td>6</td></tr><tr><td></td><td>nop</td><td>sw    $t2, 8($s1)</td><td>7</td></tr><tr><td></td><td>bne   $s1, $zero, Loop</td><td>sw    $t3,  4($s1)</td><td>8</td></tr></tbody></table><p>IPC &#x3D; 15&#x2F;8 &#x3D; 1.875</p><h2 id="四-动态多发射"><a href="#四-动态多发射" class="headerlink" title="四.动态多发射"></a>四.<strong>动态多发射</strong></h2><table><thead><tr><th><strong>超标量（Superscalar）</strong></th></tr></thead><tbody><tr><td>硬件在运行时动态决定哪些指令同时发射和执行</td></tr></tbody></table><ul><li>超标量处理器运行机制<ul><li>取指令与发射：取指令、译码并发射到功能单元，等待执行（顺序取指令）</li><li>指令执行：一旦所需的功能单元、源操作数准备就绪，就可以执行指令</li><li>提交：当可以写回数据时，就将结果写回到寄存器或存储器</li></ul></li><li>每个周期CPU决定是发射0 条、1 条，还是多条指令</li><li>硬件保证执行的正确性</li></ul><h4 id="按序（In-Order）"><a href="#按序（In-Order）" class="headerlink" title="按序（In-Order）"></a><strong>按序（In-Order）</strong></h4><table><thead><tr><th><strong>指令提取与译码单元</strong></th></tr></thead><tbody><tr><td>需要按指令顺序取指令并译码，如此才能保持依赖</td></tr></tbody></table><table><thead><tr><th><strong>提交单元</strong></th></tr></thead><tbody><tr><td>需要按照取指令的顺序进行指令结果的写回（写回寄存器或存储器）</td></tr></tbody></table><p>一旦发生异常，只有引发异常的指令之前的指令可以更新寄存器</p><p>如果分支预测错误，分支指令之后的指令不会改变存器状态，</p><p>使用认证单元实现错误推测的恢复</p><h4 id="乱序（Out-of-Order）"><a href="#乱序（Out-of-Order）" class="headerlink" title="乱序（Out-of-Order）"></a><strong>乱序（Out-of-Order）</strong></h4><ul><li>流水线的前端（取指令、译码、发射）和后端（认证）按序运行</li><li>在指令执行时，一旦某条指令所需的源数据和功能单元准备就绪，就可以执行该指令——指令执行时乱序的</li><li>乱序执行的机制增加了指令级并行</li></ul><h4 id="按序v-s-乱序"><a href="#按序v-s-乱序" class="headerlink" title="按序v.s. 乱序"></a><strong>按序v.s. 乱序</strong></h4><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L08-ILP/image-20230426165254398.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="vs"></p><h4 id="动态流水线调度"><a href="#动态流水线调度" class="headerlink" title="动态流水线调度"></a><strong>动态流水线调度</strong></h4><ul><li>允许CPU乱序执行指令来避免阻塞<ul><li>但是按照指令顺序写回寄存器</li></ul></li></ul><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">例:<br><span class="hljs-keyword">lw </span>  $<span class="hljs-built_in">t0</span>,<span class="hljs-number">20</span>($<span class="hljs-built_in">s2</span>)<br><span class="hljs-keyword">addu </span>$<span class="hljs-built_in">t1</span>, $<span class="hljs-built_in">t0</span>, $<span class="hljs-built_in">t2</span><br><span class="hljs-keyword">sub </span> $<span class="hljs-built_in">s4</span>, $<span class="hljs-built_in">s4</span>, $<span class="hljs-built_in">t3</span><br><span class="hljs-keyword">slti </span>$<span class="hljs-built_in">t5</span>, $<span class="hljs-built_in">s4</span>, <span class="hljs-number">20</span><br><br></code></pre></td></tr></table></figure><p>在addu等待lw的时候，可以开始执行sub</p><h2 id="五-小结"><a href="#五-小结" class="headerlink" title="五.小结"></a>五.<strong>小结</strong></h2><ul><li>采用机器并行和指令级并行提高处理器性能</li><li>超流水线</li><li>静态多发射</li><li>动态多发射</li></ul>]]></content>
    
    
    <categories>
      
      <category>学习资料</category>
      
    </categories>
    
    
    <tags>
      
      <tag>课件笔记</tag>
      
      <tag>计算机组成原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ARM体系结构与编程-第3章-ARM微处理器的指令系统4-基本ARM指令的应用</title>
    <link href="/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC3%E7%AB%A0-ARM%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F4-%E5%9F%BA%E6%9C%ACARM%E6%8C%87%E4%BB%A4%E7%9A%84%E5%BA%94%E7%94%A8/"/>
    <url>/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC3%E7%AB%A0-ARM%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F4-%E5%9F%BA%E6%9C%ACARM%E6%8C%87%E4%BB%A4%E7%9A%84%E5%BA%94%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="ARM体系结构与编程"><a href="#ARM体系结构与编程" class="headerlink" title="ARM体系结构与编程"></a><strong>ARM体系结构与编程</strong></h1><h2 id="3-5-基本ARM指令的应用"><a href="#3-5-基本ARM指令的应用" class="headerlink" title="3.5 基本ARM指令的应用"></a>3.5 基本ARM指令的应用</h2><ul><li>算术逻辑运算指令的应用</li><li>跳转指令的应用</li><li>Load&#x2F;store指令的应用</li><li>批量load&#x2F;store指令的应用</li><li>信号量指令的应用</li><li>与系统相关的一些指令的应用</li></ul><h3 id="3-5-1-算术逻辑运算指令的应用"><a href="#3-5-1-算术逻辑运算指令的应用" class="headerlink" title="3.5.1 算术逻辑运算指令的应用"></a>3.5.1 算术逻辑运算指令的应用</h3><ol><li><h4 id="位操作指令应用"><a href="#位操作指令应用" class="headerlink" title="位操作指令应用"></a>位操作指令应用</h4>将r2中的高8位数据传送到r3的低8位中</li></ol><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-keyword">MOV</span> <span class="hljs-built_in">R0</span>, <span class="hljs-built_in">R2</span>, <span class="hljs-keyword">LSR</span> <span class="hljs-number">#24</span><br><br><span class="hljs-keyword">ORR</span> <span class="hljs-built_in">R3</span>, <span class="hljs-built_in">R0</span>, <span class="hljs-built_in">R3</span>, <span class="hljs-keyword">LSL</span> <span class="hljs-number">#8</span><br><br><span class="hljs-symbol">OR</span><br><br><span class="hljs-keyword">MOV</span> <span class="hljs-built_in">R0</span>, <span class="hljs-built_in">R2</span>, <span class="hljs-keyword">ROR</span> <span class="hljs-number">#24</span><br><span class="hljs-keyword">MOV</span> <span class="hljs-built_in">R3</span>, <span class="hljs-number">#0</span> / <span class="hljs-keyword">BIC</span> <span class="hljs-built_in">R3</span>, <span class="hljs-built_in">R3</span>, <span class="hljs-number">#0xFF</span><br><span class="hljs-keyword">ORR</span> <span class="hljs-built_in">R3</span>, <span class="hljs-built_in">R0</span>, <span class="hljs-built_in">R3</span><br><br></code></pre></td></tr></table></figure><ol start="2"><li><h4 id="实现乘法的指令段"><a href="#实现乘法的指令段" class="headerlink" title="实现乘法的指令段"></a>实现乘法的指令段</h4></li></ol><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-keyword">MOV</span> <span class="hljs-built_in">R0</span>, <span class="hljs-built_in">R0</span>, <span class="hljs-keyword">LSL</span> <span class="hljs-meta">#1 ;2*R0</span><br><br><span class="hljs-keyword">ADD</span> <span class="hljs-built_in">R0</span>, <span class="hljs-built_in">R0</span>, <span class="hljs-built_in">R0</span>, <span class="hljs-keyword">LSL</span> <span class="hljs-meta">#1 ;3*R0</span><br><br>RSB <span class="hljs-built_in">R0</span>, <span class="hljs-built_in">R1</span>, <span class="hljs-built_in">R0</span>, <span class="hljs-keyword">LSL</span> <span class="hljs-meta">#2 ;4*R0-R1</span><br><br><br><br><span class="hljs-keyword">MOV</span> <span class="hljs-built_in">R0</span>, <span class="hljs-built_in">R0</span>, <span class="hljs-keyword">LSL</span> <span class="hljs-meta">#n ;2^n*R0</span><br><br><span class="hljs-keyword">ADD</span> <span class="hljs-built_in">R0</span>, <span class="hljs-built_in">R0</span>, <span class="hljs-built_in">R0</span>, <span class="hljs-keyword">LSL</span> <span class="hljs-meta">#n ;(2^n+1)*R0</span><br><br>RSB <span class="hljs-built_in">R0</span>, <span class="hljs-built_in">R0</span>, <span class="hljs-built_in">R0</span>, <span class="hljs-keyword">LSL</span> <span class="hljs-meta">#n ;(2^n-1)*R0</span><br></code></pre></td></tr></table></figure><blockquote><p><strong>ARM指令的特色：两个操作在一条指令中完成。</strong></p></blockquote><ol start="3"><li><h4 id="64位数据运算"><a href="#64位数据运算" class="headerlink" title="64位数据运算"></a>64位数据运算</h4></li></ol><p>R0,R1存放64位数据的低32位和高32位；R2,R3存放64位数据的低32位和高32位：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-keyword">ADDS</span> <span class="hljs-built_in">R0</span>, <span class="hljs-built_in">R0</span>, <span class="hljs-built_in">R2</span><br><br><span class="hljs-keyword">ADC</span> <span class="hljs-built_in">R1</span>, <span class="hljs-built_in">R1</span>, <span class="hljs-built_in">R3</span> <span class="hljs-comment">;64位加法</span><br><br><br><br><span class="hljs-keyword">SUBS</span> <span class="hljs-built_in">R0</span>, <span class="hljs-built_in">R0</span>, <span class="hljs-built_in">R2</span><br><br><span class="hljs-keyword">SBC</span> <span class="hljs-built_in">R1</span>, <span class="hljs-built_in">R1</span>, <span class="hljs-built_in">R3</span>  <span class="hljs-comment">;64位减法</span><br><br><br><br><span class="hljs-keyword">CMP</span> <span class="hljs-built_in">R1</span>, <span class="hljs-built_in">R3</span><br><br><span class="hljs-keyword">CMPEQ</span> <span class="hljs-built_in">R0</span>, <span class="hljs-built_in">R2</span>  <span class="hljs-comment">;64位数据比较</span><br></code></pre></td></tr></table></figure><p><strong>注意:进位标志C在CPSR中</strong></p><ol start="4"><li><h4 id="内存中数据存储方式的转换"><a href="#内存中数据存储方式的转换" class="headerlink" title="内存中数据存储方式的转换"></a>内存中数据存储方式的转换</h4></li></ol><p>big endian&lt;–&gt;  little endian</p><p>R0&#x3D;ABCD  &lt;–&gt;  R0&#x3D;DCBA</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-keyword">EOR</span> <span class="hljs-built_in">R1</span>, <span class="hljs-built_in">R0</span>, <span class="hljs-built_in">R0</span>, <span class="hljs-keyword">ROR</span> <span class="hljs-meta">#16 ;R1=A^C,   B^D,   C^A, D^B</span><br>BIC <span class="hljs-built_in">R1</span>, <span class="hljs-built_in">R1</span>, <span class="hljs-meta">#0xFF0000 ;R1=A^C,     0,    C^A, D^B</span><br><span class="hljs-keyword">MOV</span> <span class="hljs-built_in">R0</span>, <span class="hljs-built_in">R0</span>, <span class="hljs-keyword">ROR</span> <span class="hljs-meta">#8 ;R0=  D,     A,      B,       C</span><br><span class="hljs-keyword">EOR</span> <span class="hljs-built_in">R0</span>, <span class="hljs-built_in">R0</span>, <span class="hljs-built_in">R1</span>, <span class="hljs-keyword">LSR</span> <span class="hljs-meta">#8 ;LSR: 0,   A^C,      0,     C^A</span><br><span class="hljs-comment">;R0=  D,     C,      B,       A</span><br><br></code></pre></td></tr></table></figure><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-keyword">MOV</span> <span class="hljs-built_in">R2</span>, <span class="hljs-number">#0xFF</span><span class="hljs-comment">;R2=0xFF</span><br><span class="hljs-keyword">ORR</span> <span class="hljs-built_in">R2</span>, <span class="hljs-built_in">R2</span>, <span class="hljs-number">#0xFF0000</span><span class="hljs-comment">;R2=0x00FF00FF</span><br><span class="hljs-keyword">AND</span> <span class="hljs-built_in">R1</span>, <span class="hljs-built_in">R2</span>, <span class="hljs-built_in">R0</span><span class="hljs-comment">;R1= 0 B  0 D</span><br><span class="hljs-keyword">AND</span> <span class="hljs-built_in">R0</span>, <span class="hljs-built_in">R2</span>, <span class="hljs-built_in">R0</span>, <span class="hljs-keyword">ROR</span> <span class="hljs-number">#24</span><span class="hljs-comment">;R0= 0 C  0 A</span><br><span class="hljs-keyword">ORR</span> <span class="hljs-built_in">R0</span>, <span class="hljs-built_in">R0</span>, <span class="hljs-built_in">R1</span>, <span class="hljs-keyword">ROR</span> <span class="hljs-number">#8</span><span class="hljs-comment">;R0= D C B A</span><br><br></code></pre></td></tr></table></figure><h3 id="3-5-2-跳转指令的应用"><a href="#3-5-2-跳转指令的应用" class="headerlink" title="3.5.2 跳转指令的应用"></a>3.5.2 跳转指令的应用</h3><ol><li><h4 id="子程序调用"><a href="#子程序调用" class="headerlink" title="子程序调用"></a>子程序调用</h4></li></ol><p>BL指令在指令跳转操作的同时保存当前PC寄存器值，用于从被调用的子程序中返回。</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-comment">;……</span><br><span class="hljs-keyword">BL</span> function_name<br><span class="hljs-keyword">SUB</span> <span class="hljs-built_in">R2</span>,<span class="hljs-built_in">R1</span>,<span class="hljs-built_in">R0</span><br><span class="hljs-comment">;……</span><br><br><br><span class="hljs-symbol">function_name</span><br><span class="hljs-comment">;……</span><br><span class="hljs-keyword">MOV</span> <span class="hljs-built_in">PC</span>, <span class="hljs-built_in">LR</span><br></code></pre></td></tr></table></figure><blockquote><p><strong>注意：B和BL指令的区别。</strong></p></blockquote><ol start="2"><li><h4 id="条件执行－最大公约数"><a href="#条件执行－最大公约数" class="headerlink" title="条件执行－最大公约数"></a>条件执行－最大公约数</h4></li></ol><p><img src="/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC3%E7%AB%A0-ARM%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F4-%E5%9F%BA%E6%9C%ACARM%E6%8C%87%E4%BB%A4%E7%9A%84%E5%BA%94%E7%94%A8/image-20230424213922924.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="条件执行"></p><p>最大公约数C语言代码：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">gcd</span> <span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">while</span> (a ! = b)<br><span class="hljs-keyword">if</span> (a &gt; b)<br>a = a - b;<br><span class="hljs-keyword">else</span><br>b = b - a;<br>  <span class="hljs-keyword">return</span> a;<br>&#125;<br></code></pre></td></tr></table></figure><p>最大公约数ARM汇编代码：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-symbol">gcd</span> <span class="hljs-keyword">cmp</span> <span class="hljs-built_in">r0</span>, <span class="hljs-built_in">r1</span> <span class="hljs-comment">;reached the end?</span><br><span class="hljs-keyword">beq</span> stop<br><span class="hljs-keyword">blt</span> less <span class="hljs-comment">;if r0 &gt; r1</span><br><span class="hljs-keyword">sub</span> <span class="hljs-built_in">r0</span>, <span class="hljs-built_in">r0</span>, <span class="hljs-built_in">r1</span> <span class="hljs-comment">;subtract r1 from r0</span><br><span class="hljs-keyword">b</span>   gcd<br><span class="hljs-symbol">less</span> <span class="hljs-keyword">sub</span> <span class="hljs-built_in">r1</span>, <span class="hljs-built_in">r1</span>, <span class="hljs-built_in">r0</span> <span class="hljs-comment">;subtract r0 from r1</span><br><span class="hljs-keyword">b</span>   gcd<br><span class="hljs-symbol">stop</span><span class="hljs-comment">;……</span><br></code></pre></td></tr></table></figure><p>最大公约数ARM汇编代码（条件执行）：</p><p>代码执行前r0中存放a，r1中存放b；代码执行后r0中存放a和b的最大公约数：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-symbol">gcd</span><br><span class="hljs-keyword">CMP</span> <span class="hljs-built_in">R0</span>, <span class="hljs-built_in">R1</span><br><span class="hljs-keyword">SUBGT</span> <span class="hljs-built_in">R0</span>, <span class="hljs-built_in">R0</span>, <span class="hljs-built_in">R1</span><br><span class="hljs-keyword">SUBLT</span> <span class="hljs-built_in">R1</span>, <span class="hljs-built_in">R1</span>, <span class="hljs-built_in">R0</span><br><span class="hljs-keyword">BNE</span> gcd<br><span class="hljs-keyword">MOV</span> <span class="hljs-built_in">PC</span>, <span class="hljs-built_in">LR</span><br></code></pre></td></tr></table></figure><ol start="3"><li><h4 id="条件判断语句（C语言代码）"><a href="#条件判断语句（C语言代码）" class="headerlink" title="条件判断语句（C语言代码）"></a>条件判断语句（C语言代码）</h4></li></ol><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">if</span> (a == <span class="hljs-number">0</span> || b == <span class="hljs-number">1</span>)<br><span class="hljs-attribute">c</span>= d + e;<br></code></pre></td></tr></table></figure><p>代码执行前r0中存放a，r1中存放b；代码执行后r2中存放d和e的和：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-keyword">CMP</span> <span class="hljs-built_in">R0</span>, <span class="hljs-number">#0</span><br><span class="hljs-keyword">CMPNE</span> <span class="hljs-built_in">R1</span>, <span class="hljs-number">#1</span><br><span class="hljs-keyword">ADDEQ</span> <span class="hljs-built_in">R2</span>, <span class="hljs-built_in">R3</span>, <span class="hljs-built_in">R4</span><br><br></code></pre></td></tr></table></figure><blockquote><p>注意：两个条件按顺序进行判断，如果第一个条件不成立，则后面的条件无需进行判断</p></blockquote><ol start="4"><li><h4 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h4></li></ol><p>对于一个for或while循环：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-keyword">MOV</span> <span class="hljs-built_in">R0</span>, <span class="hljs-symbol">#loopcount</span> <span class="hljs-comment">;初始化计数器</span><br><span class="hljs-symbol">loop</span><br><span class="hljs-comment">;……</span><br><span class="hljs-keyword">SUBS</span> <span class="hljs-built_in">R0</span>, <span class="hljs-built_in">R0</span>, <span class="hljs-number">#1</span><span class="hljs-comment">;计数器的更新及CPSR的更新</span><br><span class="hljs-keyword">BNE</span> loop<br><span class="hljs-comment">;……</span><br></code></pre></td></tr></table></figure><blockquote><p><strong>注意：此时SUB指令必需带后缀S。</strong></p></blockquote><ol start="5"><li><h4 id="多路分支程序语句"><a href="#多路分支程序语句" class="headerlink" title="多路分支程序语句"></a>多路分支程序语句</h4></li></ol><p>代码根据maxindex的不同值跳转不同的代码段，这里要求各目标代码段的大小都为</p><p><img src="/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC3%E7%AB%A0-ARM%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F4-%E5%9F%BA%E6%9C%ACARM%E6%8C%87%E4%BB%A4%E7%9A%84%E5%BA%94%E7%94%A8/image-20230424214306057.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="size"></p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-keyword">CMP</span> <span class="hljs-built_in">R0</span>, <span class="hljs-symbol">#maxindex</span><span class="hljs-comment">;R0中保存了跳转的索引值</span><br><span class="hljs-keyword">ADDLO</span> <span class="hljs-built_in">PC</span>, <span class="hljs-built_in">PC</span>, <span class="hljs-built_in">R0</span>, <span class="hljs-keyword">LSL</span> <span class="hljs-symbol">#RoutineSizeLog2</span><br><span class="hljs-keyword">B</span> IndexOutofRange<br>……<br><span class="hljs-symbol">Index0Handler</span><span class="hljs-comment">;索引值为0时对应的代码段</span><br>……<br><span class="hljs-symbol">Index1Handler</span><br>…..<br><span class="hljs-symbol">Index2Handler</span><br>……<br><span class="hljs-symbol">IndexOutofRange</span><br>……<br></code></pre></td></tr></table></figure><h3 id="3-5-3-load-x2F-store指令的应用"><a href="#3-5-3-load-x2F-store指令的应用" class="headerlink" title="3.5.3 load&#x2F;store指令的应用"></a>3.5.3 load&#x2F;store指令的应用</h3><ol><li><h4 id="链表操作"><a href="#链表操作" class="headerlink" title="链表操作"></a>链表操作</h4></li></ol><p>在链表中搜索与某一个数据相等的元素。链表中的每个元素包括两个字，第一个字中包含一个字节数据；第二个字中包含指向下一个链表元素的指令，当这个指针为0时表示链表结束。</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-symbol">llsearch</span><br><span class="hljs-keyword">CMP</span> <span class="hljs-built_in">R0</span>, <span class="hljs-number">#0</span><span class="hljs-comment">;R0是next pointer</span><br>LDRNEB <span class="hljs-built_in">R2</span>, [<span class="hljs-built_in">R0</span>]<br><span class="hljs-keyword">CMPNE</span> <span class="hljs-built_in">R1</span>, <span class="hljs-built_in">R2</span><span class="hljs-comment">;R1存放要搜索的数据</span><br><span class="hljs-keyword">LDRNE</span> <span class="hljs-built_in">R0</span>, [<span class="hljs-built_in">R0</span>, <span class="hljs-number">#4</span>]<br><span class="hljs-keyword">BNE</span> llsearch<br><span class="hljs-keyword">MOV</span> <span class="hljs-built_in">PC</span>, <span class="hljs-built_in">LR</span><br></code></pre></td></tr></table></figure><p><img src="/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC3%E7%AB%A0-ARM%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F4-%E5%9F%BA%E6%9C%ACARM%E6%8C%87%E4%BB%A4%E7%9A%84%E5%BA%94%E7%94%A8/image-20230424214357365.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="链表"></p><ol start="2"><li><h4 id="简单的串比较"><a href="#简单的串比较" class="headerlink" title="简单的串比较"></a>简单的串比较</h4></li></ol><p>比较两个串的大小：R0指向第一个串，R1指向第二个串。</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-symbol">strcmp</span><br><span class="hljs-keyword">LDRB</span> <span class="hljs-built_in">R2</span>, [<span class="hljs-built_in">R0</span>], <span class="hljs-number">#1</span><span class="hljs-comment">;注意字符寻址的偏移量</span><br><span class="hljs-keyword">LDRB</span> <span class="hljs-built_in">R3</span>, [<span class="hljs-built_in">R1</span>], <span class="hljs-number">#1</span><br><span class="hljs-keyword">CMP</span> <span class="hljs-built_in">R2</span>, <span class="hljs-number">#0</span><br><span class="hljs-keyword">CMPNE</span> <span class="hljs-built_in">R3</span>, <span class="hljs-number">#0</span><br><span class="hljs-keyword">BEQ</span> return<br><span class="hljs-keyword">CMP</span> <span class="hljs-built_in">R2</span>, <span class="hljs-built_in">R3</span><br><span class="hljs-keyword">BEQ</span> strcmp<br><span class="hljs-symbol">return</span><br><span class="hljs-keyword">SUB</span> <span class="hljs-built_in">R0</span>, <span class="hljs-built_in">R2</span>, <span class="hljs-built_in">R3</span><span class="hljs-comment">;比较两字符的大小</span><br><span class="hljs-keyword">MOV</span> <span class="hljs-built_in">PC</span>, <span class="hljs-built_in">LR</span><br></code></pre></td></tr></table></figure><ol start="3"><li><h4 id="长跳转"><a href="#长跳转" class="headerlink" title="长跳转"></a>长跳转</h4></li></ol><p>通过直接向PC寄存器中存取数据，程序可以实现在4GB的地址空间的任意跳转，这种跳转叫做<strong>长跳转</strong>。</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-keyword">ADD</span> <span class="hljs-built_in">LR</span>, <span class="hljs-built_in">PC</span>, <span class="hljs-number">#4</span><span class="hljs-comment">;保存返回地址，指向PC＋12处，即return_here</span><br><span class="hljs-keyword">LDR</span> <span class="hljs-built_in">PC</span>, [<span class="hljs-built_in">PC</span>, #-<span class="hljs-number">4</span>]<span class="hljs-comment">;内存寻址指向DCD</span><br><span class="hljs-meta">DCD</span> <span class="hljs-meta">function</span><br><span class="hljs-symbol">return_here</span><br>ADD<br></code></pre></td></tr></table></figure><ol start="4"><li><h4 id="多路跳转-（比较前面的5-多路分支程序语句）"><a href="#多路跳转-（比较前面的5-多路分支程序语句）" class="headerlink" title="多路跳转 （比较前面的5. 多路分支程序语句）"></a>多路跳转 （比较前面的5. 多路分支程序语句）</h4></li></ol><p>通过函数地址表实现多路转移，其中maxendex为跳转的最大索引号，R0中为跳转的索引号。</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-keyword">CMP</span> <span class="hljs-built_in">R0</span>, <span class="hljs-symbol">#maxindex</span><br><span class="hljs-keyword">LDRLO</span> <span class="hljs-built_in">PC</span>, [<span class="hljs-built_in">PC</span>, <span class="hljs-built_in">R0</span>, <span class="hljs-keyword">LSL</span> <span class="hljs-number">#2</span>]<br><span class="hljs-keyword">B</span> IndexOutofRange<br><span class="hljs-symbol">DCD</span> Handler0<span class="hljs-comment">;子程序0的入口地址</span><br><span class="hljs-symbol">DCD</span> Handler1<br><span class="hljs-symbol">DCD</span> Handler2<br><span class="hljs-comment">;……</span><br></code></pre></td></tr></table></figure><p><strong>注意：这里子程序没有限定相同的大小。</strong></p><h3 id="3-5-4-批量load-x2F-store指令的应用"><a href="#3-5-4-批量load-x2F-store指令的应用" class="headerlink" title="3.5.4 批量load&#x2F;store指令的应用"></a>3.5.4 批量load&#x2F;store指令的应用</h3><ol><li><h4 id="简单的块复制"><a href="#简单的块复制" class="headerlink" title="简单的块复制"></a>简单的块复制</h4></li></ol><p>一次将48个字数据从R12作为首地址的一段连续的内存单元复制到R13作为首地址的一段连续的内存单元。R14为源数据区末地址。</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-symbol">loop</span><br><span class="hljs-keyword">LDMIA</span> <span class="hljs-built_in">R12</span>!, &#123;<span class="hljs-built_in">R0</span>-<span class="hljs-built_in">R11</span>&#125;<span class="hljs-comment">;每次12个字</span><br><span class="hljs-keyword">STMIA</span> <span class="hljs-built_in">R13</span>!, &#123;<span class="hljs-built_in">R0</span>-<span class="hljs-built_in">R11</span>&#125;<br><span class="hljs-keyword">CMP</span> <span class="hljs-built_in">R12</span>, <span class="hljs-built_in">R14</span><span class="hljs-comment">;判断是否结束</span><br><span class="hljs-keyword">BLO</span> loop<br><br></code></pre></td></tr></table></figure><p><strong>思考：当数据块大小不是一次搬移数据的倍数时，程序如何设计？</strong></p><h5 id="LDM-x2F-STM应用实例-上机编程实践"><a href="#LDM-x2F-STM应用实例-上机编程实践" class="headerlink" title="LDM&#x2F;STM应用实例-上机编程实践"></a><strong>LDM&#x2F;STM应用实例-上机编程实践</strong></h5><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">SOURCE</span>      DCD    <span class="hljs-number">1</span>,  <span class="hljs-number">2</span>,  <span class="hljs-number">3</span>,  <span class="hljs-number">4</span>, <span class="hljs-number">5</span>,  <span class="hljs-number">6</span>,  <span class="hljs-number">7</span>,  <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span><br>                    <span class="hljs-attribute">DCD</span>   <span class="hljs-number">11</span>,<span class="hljs-number">12</span>,<span class="hljs-number">13</span>,<span class="hljs-number">14</span>,<span class="hljs-number">15</span>,<span class="hljs-number">16</span>,<span class="hljs-number">17</span>,<span class="hljs-number">18</span>,<span class="hljs-number">19</span>,<span class="hljs-number">20</span><br>                    <span class="hljs-attribute">DCD</span>   <span class="hljs-number">21</span>,<span class="hljs-number">22</span>,<span class="hljs-number">23</span>,<span class="hljs-number">24</span>,<span class="hljs-number">25</span>,<span class="hljs-number">26</span>,<span class="hljs-number">27</span>,<span class="hljs-number">28</span>,<span class="hljs-number">29</span>,<span class="hljs-number">30</span><br>                    <span class="hljs-attribute">DCD</span>   <span class="hljs-number">31</span>,<span class="hljs-number">32</span>,<span class="hljs-number">33</span>,<span class="hljs-number">34</span>,<span class="hljs-number">35</span>,<span class="hljs-number">36</span>,<span class="hljs-number">37</span>,<span class="hljs-number">38</span>,<span class="hljs-number">39</span>,<span class="hljs-number">40</span><br>                    <span class="hljs-attribute">DCD</span>   <span class="hljs-number">41</span>,<span class="hljs-number">42</span>,<span class="hljs-number">43</span>,<span class="hljs-number">44</span>,<span class="hljs-number">45</span>,<span class="hljs-number">46</span>,<span class="hljs-number">47</span>,<span class="hljs-number">48</span><br>                    <br><span class="hljs-attribute">DEST</span>           DCD   <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><ol start="2"><li><h4 id="子程序进入和退出时数据的保存和恢复"><a href="#子程序进入和退出时数据的保存和恢复" class="headerlink" title="子程序进入和退出时数据的保存和恢复"></a>子程序进入和退出时数据的保存和恢复</h4></li></ol><p>在调用子程序时，通常利用寄存器r0－r3传递参数和返回结果，这几个参数由子程序的调用者来保存，其他的子程序将要用到的寄存器在子程序入口处保存，在子程序返回前恢复这些寄存器。</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-symbol">function</span><br>STMFD <span class="hljs-built_in">R13</span>!, &#123;<span class="hljs-built_in">R4</span>-<span class="hljs-built_in">R12</span>, <span class="hljs-built_in">R14</span>&#125;<span class="hljs-comment">;函数入口</span><br><span class="hljs-comment">;……</span><br><span class="hljs-comment">;function body</span><br><span class="hljs-comment">;……</span><br><span class="hljs-keyword">LDMFD</span> <span class="hljs-built_in">R13</span>!, &#123;<span class="hljs-built_in">R4</span>-<span class="hljs-built_in">R12</span>, <span class="hljs-built_in">PC</span>&#125; <span class="hljs-comment">;函数出口</span><br></code></pre></td></tr></table></figure><h3 id="3-5-5-信号量指令的应用"><a href="#3-5-5-信号量指令的应用" class="headerlink" title="3.5.5 信号量指令的应用"></a>3.5.5 信号量指令的应用</h3><p>信号量用于实现对临界区数据访问的同步。</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-keyword">MVN</span> <span class="hljs-built_in">R2</span>, <span class="hljs-number">#0</span> <span class="hljs-comment">;set -1</span><br><span class="hljs-symbol">spinin</span><br><span class="hljs-keyword">SWP</span> <span class="hljs-built_in">R3</span>, <span class="hljs-built_in">R2</span>, [<span class="hljs-built_in">R0</span>]<span class="hljs-comment">;读取信号到R3，</span><br><span class="hljs-comment">;同时将信号设置成-1.</span><br><span class="hljs-keyword">CMN</span> <span class="hljs-built_in">R3</span>, <span class="hljs-number">#1</span><span class="hljs-comment">;判断R3是否为-1</span><br><span class="hljs-comment">;……</span><br><span class="hljs-keyword">BEQ</span> spinin<span class="hljs-comment">;其它进程访问，继续查询</span><br><span class="hljs-keyword">CMP</span> <span class="hljs-built_in">R3</span>, <span class="hljs-number">#0</span><span class="hljs-comment">;不为0时表示其它进程拥有信号量</span><br><span class="hljs-comment">;……</span><br><span class="hljs-keyword">STRNE</span> <span class="hljs-built_in">R3</span>, [<span class="hljs-built_in">R0</span>]<span class="hljs-comment">;恢复信号量的值</span><br><span class="hljs-comment">;……</span><br><span class="hljs-keyword">BNE</span> spinin<span class="hljs-comment">;重新尝试获取信号量</span><br><span class="hljs-keyword">STR</span> <span class="hljs-built_in">R1</span>, [<span class="hljs-built_in">R0</span>]<br><span class="hljs-comment">;……</span><br></code></pre></td></tr></table></figure><h3 id="3-5-6-与系统相关的一些指令的应用"><a href="#3-5-6-与系统相关的一些指令的应用" class="headerlink" title="3.5.6 与系统相关的一些指令的应用"></a>3.5.6 与系统相关的一些指令的应用</h3><ol><li><h4 id="SWI中断处理程序"><a href="#SWI中断处理程序" class="headerlink" title="SWI中断处理程序"></a>SWI中断处理程序</h4></li></ol><ul><li>SWI指令使处理器切换到特权模式，在特权模式下请求特定的系统服务（由操作系统提供）。</li><li>SWI指令执行时通常完成下面的工作：</li></ul><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">R14_svc</span> = SWI指令的下面一条指令的地址<br><span class="hljs-attribute">SPSR_svc</span> = CPSR<br><span class="hljs-attribute">CPSR</span>[<span class="hljs-number">4</span>:<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>b10011 ; supervisor mode<br><span class="hljs-attribute">CPSR</span>[<span class="hljs-number">5</span>] = <span class="hljs-number">0</span>; T<br><span class="hljs-attribute">CPSR</span>[<span class="hljs-number">6</span>] = <span class="hljs-number">1</span>; F<br><span class="hljs-attribute">CPSR</span>[<span class="hljs-number">7</span>] = <span class="hljs-number">1</span>; I<br><span class="hljs-attribute">if</span> high vectors configured then<br><span class="hljs-attribute">PC</span> = <span class="hljs-number">0</span>xFFFF0008<br><span class="hljs-attribute">else</span><br><span class="hljs-attribute">PC</span> = <span class="hljs-number">0</span>x00000008<br></code></pre></td></tr></table></figure><p>当程序执行到SWI指令时，程序跳转到0x00000008处执行，由于该处是一条跳转指令，程序接着跳转到下面中断服务程序开始处执行。</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-symbol">SWIHandler</span><br>STMFD <span class="hljs-built_in">sp</span>!, &#123;<span class="hljs-built_in">R0</span>-<span class="hljs-built_in">R3</span>, <span class="hljs-built_in">R12</span>, <span class="hljs-built_in">LR</span>&#125;<br><span class="hljs-keyword">MRS</span> <span class="hljs-built_in">R0</span>, SPSR<br><span class="hljs-keyword">TST</span> <span class="hljs-built_in">R0</span>, <span class="hljs-number">#0x20</span><br>LDRNEH <span class="hljs-built_in">R0</span>, [<span class="hljs-built_in">LR</span>, #-<span class="hljs-number">2</span>]<br><span class="hljs-keyword">BICNE</span> <span class="hljs-built_in">R0</span>, <span class="hljs-built_in">R0</span>, <span class="hljs-number">#0xFF00</span><br><span class="hljs-keyword">LDREQ</span> <span class="hljs-built_in">R0</span>, [<span class="hljs-built_in">LR</span>, #-<span class="hljs-number">4</span>]<br><span class="hljs-keyword">BICEQ</span> <span class="hljs-built_in">R0</span>, <span class="hljs-built_in">R0</span>, <span class="hljs-number">#0xFF000000</span><br><span class="hljs-keyword">CMP</span> <span class="hljs-built_in">R0</span>, <span class="hljs-symbol">#MaxSWI</span><br><span class="hljs-keyword">LDRLS</span> <span class="hljs-built_in">PC</span>, [<span class="hljs-built_in">PC</span>, <span class="hljs-built_in">R0</span>, <span class="hljs-keyword">LSL</span> <span class="hljs-number">#2</span>]<br><span class="hljs-keyword">B</span> SWIOutofRange<br><span class="hljs-comment">;switable</span><br><span class="hljs-meta">DCD</span> SWIHANDLER0<br><span class="hljs-meta">DCD</span> SWIHANDLER1<br><span class="hljs-comment">;……</span><br><span class="hljs-comment">;Code to handle SWI here</span><br><span class="hljs-comment">;……</span><br><span class="hljs-keyword">LDMFD</span> <span class="hljs-built_in">sp</span>!, &#123;<span class="hljs-built_in">R0</span>-<span class="hljs-built_in">R3</span>, <span class="hljs-built_in">R12</span>, <span class="hljs-built_in">PC</span>&#125;^<br></code></pre></td></tr></table></figure><h2 id="3-5-本章小节"><a href="#3-5-本章小节" class="headerlink" title="3.5 本章小节"></a>3.5 本章小节</h2><p>本章系统的介绍了ARM指令集中的基本指令，以及各指令的应用场合及方法，由基本指令还可以派生出一些新的指令，但使用方法与基本指令类似。与常见的如X86、MIPS体系结构的汇编指令相比较，ARM指令系统无论是从指令集本身，还是从寻址方式上，都相对复杂一些。</p><p>Thumb指令集作为ARM指令集的一个子集，其使用方法与ARM指令集类似，在此未作详细的描述，但这并不意味着Thumb指令集不如ARM指令集重要，事实上，他们各自有其自己的应用场合。</p>]]></content>
    
    
    <categories>
      
      <category>学习资料</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ARM体系结构与编程</tag>
      
      <tag>课件笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>嵌入式程序设计ch3-嵌入式总线技术</title>
    <link href="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1ch3-%E5%B5%8C%E5%85%A5%E5%BC%8F%E6%80%BB%E7%BA%BF%E6%8A%80%E6%9C%AF/"/>
    <url>/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1ch3-%E5%B5%8C%E5%85%A5%E5%BC%8F%E6%80%BB%E7%BA%BF%E6%8A%80%E6%9C%AF/</url>
    
    <content type="html"><![CDATA[<h1 id="第三章-嵌入式总线技术"><a href="#第三章-嵌入式总线技术" class="headerlink" title="第三章   嵌入式总线技术"></a>第三章   嵌入式总线技术</h1><ul><li>系统总线概述</li><li>总线结构与协议</li><li>DMA</li><li>ARM CPU总线结构</li><li>总线的性能分析</li></ul><h2 id="3-1-系统总线概述"><a href="#3-1-系统总线概述" class="headerlink" title="3.1 系统总线概述"></a>3.1 系统总线概述</h2><p>总线的定义：一种描述电子信号传输线路的物理结构形式，是一组信号线（电线）的集合</p><ul><li>一组信息传输的信号线</li><li>总线协议</li></ul><h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><p>按功能的分类</p><ul><li>数据总线 - 传输数据</li><li>地址总线 –传输地址</li><li>控制总线 –传输控制指令&#x2F;信号</li><li>扩展总线 – 不常使用的部件的扩展</li></ul><p>按信息位置：内部总线和外部总线</p><p>按时空组织特性：串行总线和并行总线</p><h2 id="3-2总线结构和协议"><a href="#3-2总线结构和协议" class="headerlink" title="3.2总线结构和协议"></a>3.2总线结构和协议</h2><p>CPU总线的结构</p><ul><li>CPU通过总线和外设进行数据交换</li><li>通常CPU是总线的主控</li></ul><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1ch3-%E5%B5%8C%E5%85%A5%E5%BC%8F%E6%80%BB%E7%BA%BF%E6%8A%80%E6%9C%AF/image-20230421144032815.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="总线"></p><h3 id="四周期握手协议-最常见的总线协议"><a href="#四周期握手协议-最常见的总线协议" class="headerlink" title="四周期握手协议-最常见的总线协议"></a>四周期握手协议-最常见的总线协议</h3><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1ch3-%E5%B5%8C%E5%85%A5%E5%BC%8F%E6%80%BB%E7%BA%BF%E6%8A%80%E6%9C%AF/image-20230421144134567.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="图"></p><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1ch3-%E5%B5%8C%E5%85%A5%E5%BC%8F%E6%80%BB%E7%BA%BF%E6%8A%80%E6%9C%AF/image-20230421144144531.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="😊"></p><ol><li><p>设备1提出请求</p></li><li><p>设备2响应该请求</p></li><li><p>一旦数据传送完成，设备发出接收完数据的信号</p></li><li><p>设备1结束请求</p></li></ol><h4 id="典型的总线"><a href="#典型的总线" class="headerlink" title="典型的总线"></a>典型的总线</h4><ul><li>Clock：时钟，用于同步总线组件</li><li>R&#x2F;W：总线的读或写使能信号</li><li>Address：地址总线，一束信号线</li><li>Data：数据总线，一束信号线</li><li>DataReady：数据就绪</li></ul><h4 id="总线读"><a href="#总线读" class="headerlink" title="总线读"></a>总线读</h4><p>▪时钟信号上升沿，设置地址使能信号，地址线上设置所需地址值 </p><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1ch3-%E5%B5%8C%E5%85%A5%E5%BC%8F%E6%80%BB%E7%BA%BF%E6%8A%80%E6%9C%AF/image-20230421144337647.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="read"> 表示读 </p><p>▪ 在第一个时钟周期后，外设将相应地址的数据传送至数据线，数据准备线使能 </p><p>▪ CPU读取数据，在第二个时钟周期末，撤去地址线上的地址，外设清除数据线上的数据值。</p><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1ch3-%E5%B5%8C%E5%85%A5%E5%BC%8F%E6%80%BB%E7%BA%BF%E6%8A%80%E6%9C%AF/image-20230421144404807.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="read"></p><h4 id="总线写"><a href="#总线写" class="headerlink" title="总线写"></a>总线写</h4><p>时钟信号上升沿，设置地址使能信号，地址线上设置所需值 </p><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1ch3-%E5%B5%8C%E5%85%A5%E5%BC%8F%E6%80%BB%E7%BA%BF%E6%8A%80%E6%9C%AF/image-20230421144555953.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="write">表示写 </p><p>▪ 在第一个时钟周期后，CPU 将数据传送至数据线，数据准备线使能 </p><p>▪ 外设向相应地址的存储单元写数据，在第二个时钟周期末，撤去地址线上的地址，并清除数据线上的数据</p><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1ch3-%E5%B5%8C%E5%85%A5%E5%BC%8F%E6%80%BB%E7%BA%BF%E6%8A%80%E6%9C%AF/image-20230421144625789.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="write"></p><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1ch3-%E5%B5%8C%E5%85%A5%E5%BC%8F%E6%80%BB%E7%BA%BF%E6%8A%80%E6%9C%AF/image-20230421144639854.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="read&amp;write"></p><h4 id="读操作的等待状态"><a href="#读操作的等待状态" class="headerlink" title="读操作的等待状态"></a>读操作的等待状态</h4><p>总线上连接的是速度比它慢的设备</p><p>▪等待状态通常用于将慢速、廉价的存储器连到总线上</p><p>▪等待状态：数据可以被读取的最早时间与真正被读取的时间之间的周期</p><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1ch3-%E5%B5%8C%E5%85%A5%E5%BC%8F%E6%80%BB%E7%BA%BF%E6%8A%80%E6%9C%AF/image-20230421144720639.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="wait time"></p><h4 id="突发状态（Brust-Transfer）"><a href="#突发状态（Brust-Transfer）" class="headerlink" title="突发状态（Brust Transfer）"></a>突发状态（Brust Transfer）</h4><p>▪收到一个地址，传输一组数据序列</p><p>▪增加一根线路：Burst，低电平有效</p><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1ch3-%E5%B5%8C%E5%85%A5%E5%BC%8F%E6%80%BB%E7%BA%BF%E6%8A%80%E6%9C%AF/image-20230421144937009.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="突发"></p><h3 id="南北桥体系下的总线"><a href="#南北桥体系下的总线" class="headerlink" title="南北桥体系下的总线"></a>南北桥体系下的总线</h3><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1ch3-%E5%B5%8C%E5%85%A5%E5%BC%8F%E6%80%BB%E7%BA%BF%E6%8A%80%E6%9C%AF/image-20230426125151078.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="bus"></p><ul><li>处理器 CPU 和北桥之间的是速度最快的处理器总线</li><li>北桥通过DRAM控制器连接高速主存</li><li>北桥与南桥之间是 PCI 总线</li><li>南桥上连接 USB 等接口和相关设备</li><li>南桥之下是ISA、 EISA等传统的慢速 I&#x2F;O 扩展总线</li></ul><h4 id="STM32F42系列芯片总线"><a href="#STM32F42系列芯片总线" class="headerlink" title="STM32F42系列芯片总线"></a>STM32F42系列芯片总线</h4><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1ch3-%E5%B5%8C%E5%85%A5%E5%BC%8F%E6%80%BB%E7%BA%BF%E6%8A%80%E6%9C%AF/image-20230421145043808.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="stm32"></p><h4 id="典型总线结构及协议"><a href="#典型总线结构及协议" class="headerlink" title="典型总线结构及协议"></a>典型总线结构及协议</h4><ul><li>ISA总线</li><li>PCI总线</li><li>APG总线</li><li>PCI-express总线</li><li>CAN总线</li><li>以太网总线</li></ul><h4 id="ISA总线"><a href="#ISA总线" class="headerlink" title="ISA总线"></a>ISA总线</h4><ul><li>1981年在IBM PC&#x2F;XT计算机中采用</li><li>有8位&#x2F;16位ISA总线规范<ul><li>8位最大传输速率8MB&#x2F;s</li></ul></li></ul><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1ch3-%E5%B5%8C%E5%85%A5%E5%BC%8F%E6%80%BB%E7%BA%BF%E6%8A%80%E6%9C%AF/image-20230421145246404.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="ex"></p><ul><li>1988年扩展到32位，形成EISA总线<ul><li>工作频率仍为8MHz</li><li>与 8 位&#x2F;16 位的 ISA 总线完全兼容</li><li>最大传输速率达到了 32MB&#x2F;s</li></ul></li><li>在 20 世纪 90 年代初，逐步被 PCI 总线取代</li><li>在工业和军事领域，ISA 总线目前仍在使用</li></ul><h4 id="PCI总线"><a href="#PCI总线" class="headerlink" title="PCI总线"></a>PCI总线</h4><ul><li>1992年Intel公司提出32位的PCI总线<ul><li>工作频率 33MHz，传输带宽为 133MB&#x2F; s</li><li>基本上满足了当时处理器与显卡、声卡、网卡、硬盘控制器等高速外围设备的通信需要</li><li>Adaptec公司的 32 位SCSI适配器</li></ul></li></ul><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1ch3-%E5%B5%8C%E5%85%A5%E5%BC%8F%E6%80%BB%E7%BA%BF%E6%8A%80%E6%9C%AF/image-20230421145410196.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="例子"></p><ul><li>PCI 1.0采用5V供电，PCI 2.0及以后3.3V供电</li><li>PCI 2.1支持66MHz工作频率</li><li>PCI 2.2引入Mini PCI，以支持笔记本</li></ul><blockquote><p>版本系列：</p><p>PCI 1.0（1992年发布）、PCI 2.0（1993年发布）、</p><p>PCI 2.1（1995年发布）、PCI 2.2（1998年发布）、</p><p>PCI 2.3（2002年发布）、PCI 3.0（2004年发布）</p></blockquote><p>为支持在服务器领域更高传输速率，1999年制定了PCI-X </p><p>PCI-X 1.0是64位、133MHz版本的PCI，保持PCI总线的兼容</p><p>PCI-X 2.0、3.0频率经历过266MHz、533MHz、甚至1GHz</p><ul><li>实际通信效率远远达不到理论值 </li><li>频率增高后通信信号串扰严重</li><li>共享式总线造成资源竞争</li></ul><p><strong>PCI-X总线特点：</strong></p><ul><li>寄存器到寄存器的信号传输方式</li><li>使用总线事务分割概念，请求和响应是分开的 <ul><li>第一个操作是请求传输</li><li>然后总线可以做其它操作</li><li>等数据准备好后，传输随后开始</li></ul></li><li>引入消息触发中断机制</li></ul><p>PCI和PCI-X总线统称并行PCI总线</p><h4 id="AGP总线-Accelerated-Graphics-Port"><a href="#AGP总线-Accelerated-Graphics-Port" class="headerlink" title="AGP总线-Accelerated Graphics Port"></a>AGP总线-Accelerated Graphics Port</h4><p>Intel1997年8月推出AGP接口和总线</p><ul><li>显卡专用的局部总线，基于PCI 2.1版总线规范扩充修改而成</li><li>工作频率为66MHz</li><li>1X模式下带宽为266MB&#x2F;s，是当时PCI总线的带宽的两倍</li><li>后来又推出了AGP 2X、AGP 4X、AGP 8X，传输速度达到了2.1GB&#x2F;s。 </li><li>专门针对显示器，后续也被淘汰，让位于PCIe</li></ul><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1ch3-%E5%B5%8C%E5%85%A5%E5%BC%8F%E6%80%BB%E7%BA%BF%E6%8A%80%E6%9C%AF/image-20230421150536817.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="最离谱的agp/pcie双插槽显卡，来自已倒闭显卡品牌希仕（未发布），HIS Radeon X1600 Pro Dual Interface"></p><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1ch3-%E5%B5%8C%E5%85%A5%E5%BC%8F%E6%80%BB%E7%BA%BF%E6%8A%80%E6%9C%AF/image-20230421151053037.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="ati"></p><h4 id="PCI-Express总线"><a href="#PCI-Express总线" class="headerlink" title="PCI-Express总线"></a>PCI-Express总线</h4><p>▪PCI Express是Intel在2001年公布的旨在取代PCI总线的第三代总线</p><p>▪ 2002年7月23日，公布了PCIe 1.0规范</p><p>▪ 2007年正式推出PCIe 2.0</p><p>▪ 2018年公布PCIe 4.0</p><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1ch3-%E5%B5%8C%E5%85%A5%E5%BC%8F%E6%80%BB%E7%BA%BF%E6%8A%80%E6%9C%AF/image-20230421151257939.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="pcie"></p><ul><li>引入道的概念<ul><li>由两个分别用于发送和接收数据的差分信号对组成，同时双向传输字节包数据</li></ul></li><li>全双工</li><li>设备之间通过双向的Link相连接，每个Link支持1到32个道</li></ul><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1ch3-%E5%B5%8C%E5%85%A5%E5%BC%8F%E6%80%BB%E7%BA%BF%E6%8A%80%E6%9C%AF/image-20230421151325457.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="tu"></p><ul><li>串行总线<ul><li>每道在每个方向上只有一对差分信号线，不需外部时钟信号可达到很高的速率</li></ul></li></ul><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1ch3-%E5%B5%8C%E5%85%A5%E5%BC%8F%E6%80%BB%E7%BA%BF%E6%8A%80%E6%9C%AF/image-20230421151349691.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="串行"></p><ul><li>支持热插拔</li></ul><h5 id="技术指标"><a href="#技术指标" class="headerlink" title="技术指标"></a>技术指标</h5><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1ch3-%E5%B5%8C%E5%85%A5%E5%BC%8F%E6%80%BB%E7%BA%BF%E6%8A%80%E6%9C%AF/image-20230421151432183.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="图表"></p><p>8b&#x2F;10b编码的特性之一是保证DC 平衡</p><ul><li>采用8b&#x2F;10b编码方式，使得发送的0、1数量保持基本一致，连续的1或0不超过5位，即每5个连续的1或0后必须插入一位0或1，从而保证信号DC平衡</li><li>128b&#x2F;130b编码是在128 bit的Payload前面加上了2 bit的同步头</li></ul><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1ch3-%E5%B5%8C%E5%85%A5%E5%BC%8F%E6%80%BB%E7%BA%BF%E6%8A%80%E6%9C%AF/image-20230421151559605.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="PCIe具有兼容性，显卡最高支持pcie4.0*16，我的主板只有3.0*16也能兼容运行"></p><h4 id="补充概念：差分信号"><a href="#补充概念：差分信号" class="headerlink" title="补充概念：差分信号"></a>补充概念：差分信号</h4><p>差分方式传输：发送端在两条信号线上传输的幅值是相等的，相位是相反的电信号</p><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1ch3-%E5%B5%8C%E5%85%A5%E5%BC%8F%E6%80%BB%E7%BA%BF%E6%8A%80%E6%9C%AF/image-20230421152024302.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="差分"></p><ul><li>接收端，将会对接收的两条信号做减法运算，这样就获得了幅值翻倍的信号</li><li>抗干扰原理是：假如两条信号都收到同样的干扰信号，接收端是两条线信号做减法，因此干扰信号基本抵消。 </li><li>两条信号线受到干扰信号相同的办法：将两根线扭在一起的“双绞线”<ul><li>电磁学定理：双绞线收到的干扰信号是同相、等幅度的 </li><li>差分信号在信号传输中用的比较多，因为抗干扰性强</li></ul></li></ul><h4 id="CAN总线-Controller-Area-Network"><a href="#CAN总线-Controller-Area-Network" class="headerlink" title="CAN总线-Controller Area Network"></a>CAN总线-Controller Area Network</h4><ul><li>德国Bosch公司开发的，后来成为国际标准ISO11898和ISO11519，是应用最广泛的现场总线之一</li><li>CAN总线协议是汽车计算机控制系统和嵌入式工业控制局域网的标准总线协议</li><li>CAN 总线定义了物理层、数据链路层和应用层三层模型结构</li><li>基于消息的异步通信，利用一对差分信号线减少设备通信线束中连接线的数量</li><li>可以点对点、一点对多点、或全局广播等方式的传送接收数据</li></ul><p>特点：</p><ul><li>采用多主控器的串行总线标准</li><li>CAN 信号由 CAN_H 和 CAN_L 双绞线构成</li><li>物理层可采用闭环或开环总线构成<ul><li>闭环结构<ul><li>遵循ISO11898标准，高速短距离网络，总线最大长度为40m，通信速度最高为1Mbps</li><li>在 CAN_H 和 CAN_L 间连接值为 120Ω 的终端匹配电阻</li></ul></li></ul></li></ul><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1ch3-%E5%B5%8C%E5%85%A5%E5%BC%8F%E6%80%BB%E7%BA%BF%E6%8A%80%E6%9C%AF/image-20230421152227939.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="闭环结构"></p><p>- </p><ul><li>开环结构<ul><li>遵循ISO11519-2标准，低速远距离网络，最大传输距离为1km，最高通信速率为125kb&#x2F;s</li><li>两根信号线是独立的、不形成闭环</li></ul></li><li>系统要求每根总线上各串联有一个 2.2kΩ 的电阻</li></ul><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1ch3-%E5%B5%8C%E5%85%A5%E5%BC%8F%E6%80%BB%E7%BA%BF%E6%8A%80%E6%9C%AF/image-20230421153009656.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="开环"></p><h5 id="Can总线收发器"><a href="#Can总线收发器" class="headerlink" title="Can总线收发器"></a>Can总线收发器</h5><p>CAN 设备是通过 CAN 收发器来连接的 </p><p>▪负责TTL逻辑电平和差分信号电平之间的转换</p><p>▪CAN控制芯片输出TTL逻辑电平到CAN收发器</p><p>▪CAN收发器通过内部将TTL逻辑电平转换为差分信号输出到CAN总线上</p><p>▪TTL电平信号：+5V等价于逻辑“1”，0V等价于逻辑“0”，这样数据通信及电平规定方式，被称做TTL</p><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1ch3-%E5%B5%8C%E5%85%A5%E5%BC%8F%E6%80%BB%E7%BA%BF%E6%8A%80%E6%9C%AF/image-20230421153105428.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="**一种可能的引脚定义**"></p><h5 id="信号定义"><a href="#信号定义" class="headerlink" title="信号定义"></a>信号定义</h5><p>信号有两种不同的信号状态</p><p>▪显性的（Dominant）：逻辑 0 </p><p>▪隐形的（Recessive）：逻辑 1 </p><p>ISO11898标准定义当CANH和CANL电平很接近甚至相等时，总线信号为隐性逻辑1，而两线电平差较大时则为显性逻辑0 </p><p>在每次传输完后不需要返回到显性逻辑0，应用不归零NRZ码位填充技术来确定信号值</p><h5 id="仲裁"><a href="#仲裁" class="headerlink" title="仲裁"></a>仲裁</h5><p>信号采用“线与”规则进行总线仲裁和定义</p><ul><li>总线上只要有一个节点将总线拉到低电平（逻辑 0）的显性状态，总线就为低电平（逻辑 0）的显性状态</li><li>只有所有节点都为高电平（逻辑1）的隐性状态，总线才为高电平（逻辑 1）的隐性状态</li></ul><h5 id="通信速率与距离"><a href="#通信速率与距离" class="headerlink" title="通信速率与距离"></a>通信速率与距离</h5><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1ch3-%E5%B5%8C%E5%85%A5%E5%BC%8F%E6%80%BB%E7%BA%BF%E6%8A%80%E6%9C%AF/image-20230421153244064.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="v"></p><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1ch3-%E5%B5%8C%E5%85%A5%E5%BC%8F%E6%80%BB%E7%BA%BF%E6%8A%80%E6%9C%AF/image-20230421153300733.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="s"></p><h5 id="CAN总线报文传输"><a href="#CAN总线报文传输" class="headerlink" title="CAN总线报文传输"></a>CAN总线报文传输</h5><p>帧格式</p><p>▪ 标准帧：11位标识符</p><p>▪ 扩展帧：29位标识符</p><p>帧类型</p><ul><li>数据帧：数据从发送器传输到接收器</li><li>远程帧：总线节点发出远程帧，请求发送同一标识符数据帧</li><li>错误帧：虽然 CAN 可靠性很高，但还可能发生错误，节点单元检测到总线错误时就发出错误帧 </li><li>过载帧：在相邻数据帧或远程帧之间提供附加的延时</li></ul><h6 id="数据帧："><a href="#数据帧：" class="headerlink" title="数据帧："></a><strong>数据帧：</strong></h6><ul><li>7个段：帧起始、仲裁段、控制段、数据段、CRC段、ACK段和帧结束</li><li>有标准格式（ID为11位）和扩展格式（ID为29位）</li></ul><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1ch3-%E5%B5%8C%E5%85%A5%E5%BC%8F%E6%80%BB%E7%BA%BF%E6%8A%80%E6%9C%AF/image-20230421153502824.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="数据帧"></p><p><strong>帧起始和帧结束：界定一个数据帧</strong></p><ul><li>帧起始为单个显性位</li><li>帧结束为 7 个连续的隐性位</li></ul><p><strong>仲裁段</strong></p><ul><li>标准帧：12位，其中ID为11位；扩展帧32为，ID为29位 </li><li>在总线上的所有节点都可监听总线上传输的数据</li><li>采用“线与”规则进行总线仲裁</li><li>若出现不匹配的位不在仲裁期间则，产生错误事件</li><li>报文的帧 ID 号码越小，优先级越高 </li><li>数据帧的远程传输请求位 RTR 为显性电平，远程帧为隐性电平，数据帧优先于远程帧</li><li>标准帧扩展标识符位 IDE 为显性电平，扩展帧的为隐性电平，则标准帧优先级比扩展帧高</li></ul><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1ch3-%E5%B5%8C%E5%85%A5%E5%BC%8F%E6%80%BB%E7%BA%BF%E6%8A%80%E6%9C%AF/image-20230421153614789.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="仲裁段"></p><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1ch3-%E5%B5%8C%E5%85%A5%E5%BC%8F%E6%80%BB%E7%BA%BF%E6%8A%80%E6%9C%AF/image-20230421153638491.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="仲裁段"></p><p>使用ID逐位仲裁方法解决竞争问题</p><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1ch3-%E5%B5%8C%E5%85%A5%E5%BC%8F%E6%80%BB%E7%BA%BF%E6%8A%80%E6%9C%AF/image-20230421153708077.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="逐位仲裁"></p><p><strong>控制段</strong></p><p>控制段：6位 </p><p>▪标准帧：标志位IDE、保留位r0、数据长度码DLC</p><p>▪扩展帧：2个保留位r1、r0、数据长度码DLC</p><p>▪ IDE：1位，扩展帧标志位 </p><p>▪DLC：4位：数据长度码，允许的字节数0-8</p><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1ch3-%E5%B5%8C%E5%85%A5%E5%BC%8F%E6%80%BB%E7%BA%BF%E6%8A%80%E6%9C%AF/image-20230421153929680.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="结构"></p><h5 id="数据段"><a href="#数据段" class="headerlink" title="数据段"></a><strong>数据段</strong></h5><p>▪为0-8个字节，传输时最高有效位先传输。</p><p><strong>CRC（循环冗余码）校验段</strong>：15+1位 </p><p>▪由帧起始段、仲裁段、控制段和数据段计算得到的15位CRC值和1位隐性电平定界符构成</p><p>▪RCR最适用于低于127位帧检查，多项式除法，其系数是模2计算</p><p><strong>ACK段</strong></p><ul><li>ACK槽：1位 <ul><li>发送节点发送隐性电平、接收正确的节点发送显性电平</li><li>总线线与结果为显性电平，发送成功，否则失败</li></ul></li><li>ACK界定符：1位 <ul><li>一个隐性电平</li></ul></li></ul><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1ch3-%E5%B5%8C%E5%85%A5%E5%BC%8F%E6%80%BB%E7%BA%BF%E6%8A%80%E6%9C%AF/image-20230421154135262.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="ack"></p><h6 id="其他帧格式"><a href="#其他帧格式" class="headerlink" title="其他帧格式"></a>其他帧格式</h6><p>远程帧：作为某数据接收器的节点，可以发送远程帧启动资源节点传输数据</p><p>​无数据段，6个段：帧起始、仲裁段、控制段、CRC段、ACK段和帧结束</p><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1ch3-%E5%B5%8C%E5%85%A5%E5%BC%8F%E6%80%BB%E7%BA%BF%E6%8A%80%E6%9C%AF/image-20230421154226268.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="远程"></p><p>错误帧：由2个域组成</p><ul><li>错误标记：不同节点提供的错误标志的叠加</li><li>错误界定符 ：连续6个连续的隐性位</li></ul><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1ch3-%E5%B5%8C%E5%85%A5%E5%BC%8F%E6%80%BB%E7%BA%BF%E6%8A%80%E6%9C%AF/image-20230421154326747.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="错误"></p><p>过载域：2个域，接收节点用来向 CAN 总线发送节点告知自身接收能力的帧，接收节点来不及处理数据了</p><ul><li>过载标志</li><li>过载界定符</li></ul><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1ch3-%E5%B5%8C%E5%85%A5%E5%BC%8F%E6%80%BB%E7%BA%BF%E6%8A%80%E6%9C%AF/image-20230421154351761.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="过载"></p><h4 id="以太网络总线"><a href="#以太网络总线" class="headerlink" title="以太网络总线"></a>以太网络总线</h4><ul><li>1980年Xerox公司和英特尔、DEC公司一起开发了基带局域网规范，后续发展成为当今局域网采用的最通用的通信协议标准。</li><li>以太网总线协议由IEEE 802.3标准定义<ul><li>物理层的连线 </li><li>电信号和媒体访问控制子层的实现方法</li><li>十兆、百兆、千兆和万兆以太网</li></ul></li><li>IEEE 802.3af定义了将未使用的接口线用于直流供电，即有源以太网</li><li>IEEE 802.3ah版本</li></ul><h5 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h5><ul><li>10Base-5使用直径0.4英寸，阻抗为50欧姆的粗同轴线缆，最大网段长度500m，采用基带传输方法，拓扑结构为总线型，以太网卡为AUI接口。</li><li>10Base-2使用直径为0.2英寸，阻抗为50欧姆的细同轴线缆，最大网段长度185m，采用基带传输方法，拓扑结构为总线型，以太网卡为BNC接口。</li><li>10Base-T使用非屏蔽双绞线线缆，最大网段程度100m，拓扑结构为星型，接口为RJ-45。 </li><li>1Base-5使用双绞线线缆，最大网段长度500m，传输速度1Mbps。 </li><li>10Broad-36使用同轴线缆（RG-59&#x2F;U CATV），网络跨度为3600m，网段最大长度为1800m，是一种宽带传输方式。</li><li>10Base-F使用光纤传输媒介，传输速率为10Mbps。</li></ul><h5 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h5><ul><li>工作原理：一种广播型的总线标准，工作过程包含侦听、发送、检测、冲突处理四个处理阶段</li><li>侦听：在节点准备发送前先侦听总线上是否有数据正在传输。</li><li>若“忙”则进入后述的“退避”处理程序，进而进一步反复进行侦听工作</li><li>若“闲”，则采用一定算法原则（例如“X-坚持”算法）决定如何发送数据</li><li>发送：当确定要发送后，通过发送单元，向总线发送数据</li><li>检测：数据发送后，也可能发生数据冲突。因此，要对数据边发送，边检测，以判断是否冲突</li><li>冲突处理：当确认发生冲突后，进入冲突处理程序</li><li>若侦听中发现线路忙，则等待一个延时后再次侦听<ul><li>冲突检测时间一般设定为 2<em>α</em>，其中 <em>α</em> 为网络中最远两个节点的传输线路延迟时间</li></ul></li><li>若发送过程中发现数据碰撞，则先发送阻塞信息连续几字节的全 1，一般为 32～48 位），强化冲突，再进行侦听工作，以待下次重新发送</li><li>涉及的算法：退避算法-截断的二进制指数退避算法<ul><li>当一个节点发现线路忙时，要等待延时时间 M，再进行侦听工作</li><li>M 取 0～（2^k − 1 ）一个随机数乘以 512 比特传输时间，其中 k 为冲突（碰撞）的次数</li><li>当M 的最大值为1023，即当 k &#x3D; 10 时获得。随后 M 始终是 0～1023 的一个随机值与 512 比特传输时间的乘积</li><li>k 增加到 16 时，就发出错误信息</li></ul></li></ul><h5 id="总线实现"><a href="#总线实现" class="headerlink" title="总线实现"></a>总线实现</h5><ul><li>将以太网总线放到用应用层、传输层、网络层、数据链路层和物理层5层定义的以太网协议栈中</li><li>与数据链路层、物理层强相关，可以作为芯片接口，也可以依据需要完全封装到芯片内。</li><li>以太网帧格式多达5种</li></ul><blockquote><p> Ethernet V1（1980年发布）</p><p> Ethernet V2（ARPA于1982年发布）</p><p> RAW 802.3（Novell公司于1983年发布）</p><p> IEEE 802.3&#x2F;802.2 SNAP（1985年发布）</p><p> IEEE 802.3&#x2F;802.2 LLC（1985年发布）</p></blockquote><blockquote><p><strong>Ethernet V2：</strong></p><p>由RFC 894定义。</p><p>▪ 前导码（7字节0x55，一串1、0间隔，用于信号同步）</p><p>▪ 帧起始定界符SFD（1字节0xD5） </p><p>▪ 目的MAC地址（6字节）</p><p>▪ 源MAC地址（6字节）</p><p>▪ 类型&#x2F;长度（2字节，其中 0～1500保留为长度域值，1536～65535保留为类型域值0x0600～0xFFFF） </p><p>▪ 数据（46～1500字节）</p><p>▪ CRC帧校验序列（4字节，使用CRC计算从目的MAC地址到数据域这部分内容而得到的校验和）</p></blockquote><h2 id="3-3DMA"><a href="#3-3DMA" class="headerlink" title="3.3DMA"></a>3.3DMA</h2><h3 id="I-x2F-O传输"><a href="#I-x2F-O传输" class="headerlink" title="I&#x2F;O传输"></a>I&#x2F;O传输</h3><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1ch3-%E5%B5%8C%E5%85%A5%E5%BC%8F%E6%80%BB%E7%BA%BF%E6%8A%80%E6%9C%AF/image-20230421155310052.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="三种"></p><ul><li>直接存储器存取：Direct Memory Access，DMA</li><li>DMA的主要作用<ul><li>将数据从一个地址空间复制到另外一个地址空间</li><li>CPU初始化DMA后，传输由DMA控制器来执行和完成</li></ul></li><li>CPU在执行DMA初始化后就可以执行其他进程</li></ul><h3 id="DMA和cpu分时使用内存"><a href="#DMA和cpu分时使用内存" class="headerlink" title="DMA和cpu分时使用内存"></a>DMA和cpu分时使用内存</h3><ul><li><strong>停止CPU访问内存</strong>：当外设要求传送一批数据时，由DMA控制器发一个信号给CPU。DMA控制器获得总线控制权后，开始进行数据传送。一批数据传送完毕后，DMA控制器通知CPU可以使用内存，并把总线控制权交还给CPU。 </li><li><strong>周期挪用</strong>：当I&#x2F;O设备没有 DMA请求时，CPU按程序要求访问内存；一旦 I&#x2F;O设备有DMA请求，则I&#x2F;O设备挪用一个或几个周期。数据输入或输出过程中实际占用了CPU时间</li><li><strong>DMA与CPU交替访问内存</strong>：一个CPU周期可分为2个周期，一个专供DMA控制器访内，另一个专供CPU访内。不需要总线使用权的申请、建立和归还过程</li></ul><h3 id="DMA访问过程"><a href="#DMA访问过程" class="headerlink" title="DMA访问过程"></a>DMA访问过程</h3><p>一个完整的DMA传输过程经过<strong>DMA请求、DMA响应、DMA传输和DMA结束</strong>四个步骤。</p><p>分时控制</p><ul><li>CPU和DMA控制器各自有自己的访问内存地址寄存器、数据寄存器和读&#x2F;写控制寄存器。</li><li>在DMA分时控制周期中，如果DMA控制器有访问内存请求，可将地址、数据等信号送到总线上。</li><li>在CPU分时控制周期中，如CPU有访问内存请求，同样传输地址、数据等信号到总线上。</li><li>分时控制采用多路控制器实现高效切换。</li></ul><h3 id="直接存储器访存（DMA）"><a href="#直接存储器访存（DMA）" class="headerlink" title="直接存储器访存（DMA）"></a>直接存储器访存（DMA）</h3><ul><li>DMA无需CPU的加入来完成数据的传输<ul><li>CPU 设置传输</li><li>DMA 直接完成设备与内存的读写操作</li></ul></li><li>需要一个DMA控制单元</li></ul><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1ch3-%E5%B5%8C%E5%85%A5%E5%BC%8F%E6%80%BB%E7%BA%BF%E6%8A%80%E6%9C%AF/image-20230421160140659.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="DMA"></p><h3 id="总线主控器（BUS-MASTERSHIP）"><a href="#总线主控器（BUS-MASTERSHIP）" class="headerlink" title="总线主控器（BUS MASTERSHIP）"></a>总线主控器（BUS MASTERSHIP）</h3><ul><li>总线主控器是能够启动总线传输的设备</li><li>缺省时，CPU是总线主控器，并初始化传输</li><li>DMA可以成为总线主控器来完成传输<ul><li>DMA 成为总线主控器时，CPU不能使用总线</li></ul></li><li>通过四周期握手协议获得总线主控器<ul><li>总线请求（Bus request） </li><li>总线授权（Bus grant）</li></ul></li></ul><h3 id="DMA控制器"><a href="#DMA控制器" class="headerlink" title="DMA控制器"></a>DMA控制器</h3><p>CPU通过DMA控制器的寄存器来控制DMA</p><p>▪ 起始地址寄存器：指明传输从何处开始</p><p>▪ 长度寄存器：指明将要传输的字的数目</p><p>▪ 状态寄存器：用于CPU操作DMA控制器</p><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1ch3-%E5%B5%8C%E5%85%A5%E5%BC%8F%E6%80%BB%E7%BA%BF%E6%8A%80%E6%9C%AF/image-20230421160450002.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="控制器"></p><h3 id="DMA操作"><a href="#DMA操作" class="headerlink" title="DMA操作"></a>DMA操作</h3><ul><li>CPU 设置 DMA寄存器，如开始地址，要读写的长度</li><li>DMA 状态寄存器允许CPU操作DMA控制器</li><li>一旦DMA成为总线主控制器，它就自动传输</li><li>可以连续传输直到传输完成</li><li>也可以使用几个总线周期</li></ul><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1ch3-%E5%B5%8C%E5%85%A5%E5%BC%8F%E6%80%BB%E7%BA%BF%E6%8A%80%E6%9C%AF/image-20230421160638232.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="操作"></p><h3 id="STM32F4系列DMA控制器结构和DMA特点"><a href="#STM32F4系列DMA控制器结构和DMA特点" class="headerlink" title="STM32F4系列DMA控制器结构和DMA特点"></a>STM32F4系列DMA控制器结构和DMA特点</h3><p>DMA是一个AMBA AHB模块，有三个AHB端口，</p><ul><li>一个从设备接口用于DMA编程</li><li>两个主设备端口用于外设和存储器访问</li></ul><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1ch3-%E5%B5%8C%E5%85%A5%E5%BC%8F%E6%80%BB%E7%BA%BF%E6%8A%80%E6%9C%AF/image-20230421160820971.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="DMA controller"></p><ul><li>两个通用的8个数据流双端口DMA控制器，支持16个数据流，每个数据流有多达8个可选通道（即硬件请求）</li><li>通道选择由软件通过寄存器DMA_SxCR[29:27]即CHSEL[2:0]设置，并允许多个外设初始化DMA请求，数</li><li>据流之间传输的数据大小是独立的</li><li>对于APB或者AHB外设，采用专用FIFO，支持最大外设访问带宽，支持猝发传输。</li><li>两个DMA控制器支持的典型外设包括SPI和I2S、I2C、USART、通用的或高级控制定时器TIMx、DAC、SDIO、</li><li>摄像头接口（DCMI）和ADC</li></ul><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1ch3-%E5%B5%8C%E5%85%A5%E5%BC%8F%E6%80%BB%E7%BA%BF%E6%8A%80%E6%9C%AF/image-20230426125616694.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="DMA1请求映射"></p><ul><li>DMA数据流&#x2F;通道：一个数据流任一时间仅有一个通道（请求）被激 活</li><li>数据流的优先级：优先级可软件配置；若相同，使用硬件优先级</li><li>源和目的地址：在 AHB 或 APB 存储器范围内并与传输尺寸对齐</li><li>传输模式：外设到存储器、存储器到外设、存储器到存储器</li><li>传输尺寸：在流控控制器时被定义；地址增加或者非增加 </li><li>源、目数据宽度：字节、半字或字；</li><li>FIFO 模式：每个数据流有独立四字 FIFO</li><li>源或者目的猝发尺寸： 单次传输、4X、8X、16X 数据单位</li><li>双缓冲器模式、流控</li></ul><h4 id="FIFO的结构"><a href="#FIFO的结构" class="headerlink" title="FIFO的结构"></a>FIFO的结构</h4><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1ch3-%E5%B5%8C%E5%85%A5%E5%BC%8F%E6%80%BB%E7%BA%BF%E6%8A%80%E6%9C%AF/image-20230421161000419.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="结构"></p><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1ch3-%E5%B5%8C%E5%85%A5%E5%BC%8F%E6%80%BB%E7%BA%BF%E6%8A%80%E6%9C%AF/image-20230421161048952.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="结构"></p><h4 id="FIFO的阈值配置"><a href="#FIFO的阈值配置" class="headerlink" title="FIFO的阈值配置"></a>FIFO的阈值配置</h4><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1ch3-%E5%B5%8C%E5%85%A5%E5%BC%8F%E6%80%BB%E7%BA%BF%E6%8A%80%E6%9C%AF/image-20230421161142764.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="阈值"></p><h3 id="节拍与数据传输"><a href="#节拍与数据传输" class="headerlink" title="节拍与数据传输"></a>节拍与数据传输</h3><ul><li>节拍：DMA请求产生一次就是一个节拍</li><li>数据的大小：1个字节、半字、字</li><li>传输的数据量，即DMA数据缓冲区大小，最大值为65535</li><li>例：单次传输，传输大小为半字，DMA请求产生一次（一个节拍）数据传输，总共传输数据 16 &#x2F; 8* 65535 &#x3D;131070Byte， 大概传输了128KByte</li><li>例：单次传输，传输大小为半字，突发4个节拍，4*126kb</li><li>例：单次传输，传输大小为半字，突发8个节拍，8*126kb</li><li>例：单次传输，传输大小为半字，突发16个节拍，8*126kb</li></ul><h3 id="DMA设置"><a href="#DMA设置" class="headerlink" title="DMA设置"></a>DMA设置</h3><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1ch3-%E5%B5%8C%E5%85%A5%E5%BC%8F%E6%80%BB%E7%BA%BF%E6%8A%80%E6%9C%AF/image-20230421161304505.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="DMA setting"></p><h3 id="DMA传输：外设到存储器传输模式"><a href="#DMA传输：外设到存储器传输模式" class="headerlink" title="DMA传输：外设到存储器传输模式"></a>DMA传输：外设到存储器传输模式</h3><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1ch3-%E5%B5%8C%E5%85%A5%E5%BC%8F%E6%80%BB%E7%BA%BF%E6%8A%80%E6%9C%AF/image-20230421161504120.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="外设到存储器"></p><ul><li>使能这种模式时，每次产生外设请求，数据流都会启动数据源到FIFO 的传输。</li><li>达到 FIFO 的阈值级别时，FIFO 的内容移出并存储到存储器中</li></ul><h3 id="DMA传输：存储器到外设传输模式"><a href="#DMA传输：存储器到外设传输模式" class="headerlink" title="DMA传输：存储器到外设传输模式"></a>DMA传输：存储器到外设传输模式</h3><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1ch3-%E5%B5%8C%E5%85%A5%E5%BC%8F%E6%80%BB%E7%BA%BF%E6%8A%80%E6%9C%AF/image-20230421161606334.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="存储器到外设"></p><ul><li>使能这种模式时，数据流会立即启动传输，从存储器填充 FIFO</li><li>发生外设请求时，FIFO 的内容移出并存储到外设</li></ul><h3 id="DMA传输：存储器到存储器传输模式"><a href="#DMA传输：存储器到存储器传输模式" class="headerlink" title="DMA传输：存储器到存储器传输模式"></a>DMA传输：存储器到存储器传输模式</h3><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1ch3-%E5%B5%8C%E5%85%A5%E5%BC%8F%E6%80%BB%E7%BA%BF%E6%8A%80%E6%9C%AF/image-20230421161648037.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="存储器到存储器"></p><ul><li>DMA 通道在没有外设请求触发的情况下实现存储器到存储器模式。 </li><li>通过将使能位 (EN) 置 1 来使能数据流，数据流填充FIFO，达到阈值后，FIFO 的内容会移出，并存储到目标中</li></ul><h3 id="DMA请求的仲裁"><a href="#DMA请求的仲裁" class="headerlink" title="DMA请求的仲裁"></a>DMA请求的仲裁</h3><p>DMA控制器嵌入一个仲裁器，基于两个AHB主设备接口上的优先级来管理8个DMA数据流请求发起外设&#x2F;存储器访问序列。</p><ul><li>优先级管理分为两个阶段：<ul><li>软件：每个数据流优先级在 DMA_SxCR 中配置。分为四个级别<ul><li>非常高优先级</li><li>高优先级</li><li>中优先级</li><li>低优先级</li></ul></li><li>硬件：如果两个请求具有相同的软件优先级，则编号低的数据流优先于编号高的数据流。例如，数据流 2 的优先级高于数据流 4</li></ul></li></ul><p>例：DMA数据流请求1和请求2同时触发的两个循环DMA请求的服务</p><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1ch3-%E5%B5%8C%E5%85%A5%E5%BC%8F%E6%80%BB%E7%BA%BF%E6%8A%80%E6%9C%AF/image-20230421161836867.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="仲裁"></p><h3 id="DMA延迟性能"><a href="#DMA延迟性能" class="headerlink" title="DMA延迟性能"></a>DMA延迟性能</h3><p>DMA 数据流的总体传输时间</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">TS</span> = TSP + TSM<br></code></pre></td></tr></table></figure><p>其中： </p><ul><li>TSP是DMA 外设端口访问和传输的总时间</li><li>TSM是 DMA 存储器端口访问和传输的总时间</li></ul><h2 id="3-4-ARM-CPU的总线结构"><a href="#3-4-ARM-CPU的总线结构" class="headerlink" title="3.4 ARM CPU的总线结构"></a>3.4 ARM CPU的总线结构</h2><h3 id="3-4-1"><a href="#3-4-1" class="headerlink" title="3.4.1"></a>3.4.1</h3><p>ARM CPU的总线发展历史</p><p>▪ ARM公司于1996年提出<strong>AMBA</strong>总线，包括ASB和APB </p><p>▪ 1999年提出AMBA 2，增加了AHB，相关协议是单时钟边沿协议</p><p>▪ 2003年提出AMBA 3，增加了AXI以获得更高性能互联，增加了ATB作为Coresight片上调试和跟踪解决方案</p><p>▪ 2010年的AMBA 4 AXI 4</p><p>▪ 2011年用AMBA 4 ACE扩展了系统一致性</p><p>▪ 2013年提出了AMBA 5 CHI ，高速传输层协议得到了重新设计，总线的拥塞控制也有改善</p><h4 id="AMBA2架构"><a href="#AMBA2架构" class="headerlink" title="AMBA2架构"></a>AMBA2架构</h4><p>AMBA 2协议规范包括四个部分：AHB、ASB、APB和Test Methodology</p><ul><li>AHB相连采用了带有主从设备的共享总线结构形式</li><li>主设备是向从设备发出读写操作的模块</li><li>从设备是接收命令并做出反应的模块</li></ul><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1ch3-%E5%B5%8C%E5%85%A5%E5%BC%8F%E6%80%BB%E7%BA%BF%E6%8A%80%E6%9C%AF/image-20230421162548145.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="AMBA2架构"></p><h3 id="3-4-2-ARM总线结构"><a href="#3-4-2-ARM总线结构" class="headerlink" title="3.4.2 ARM总线结构"></a>3.4.2 ARM总线结构</h3><h4 id="AHB总线（soc的片上系统总线）："><a href="#AHB总线（soc的片上系统总线）：" class="headerlink" title="AHB总线（soc的片上系统总线）："></a>AHB总线（soc的片上系统总线）：</h4><p>a) 最多可以支持16个主设备和任意多个从设备，如果主设备数目大于16，则需再加一层结构，通过桥接器形成多层AHB来扩展。</p><p>b) AHB主要用于重要和速度要求较高的模块（如CPU、DMA和DSP等）之间的连接。</p><p>c) 作为SoC的片上系统总线，它包括以下特性：</p><ul><li>单个时钟边沿操作；</li><li>支持多个主控制器；</li><li>非三态的实现方式；</li><li>可配置成32位-128位总线宽度；</li><li>支持猝发传输；</li><li>支持流水线操作；</li><li>支持分段传输；</li><li>支持字节、半字节和字的传输。</li></ul><p>d) AHB总线连接构成的系统由主设备、从设备和基础结构3部分组成</p><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1ch3-%E5%B5%8C%E5%85%A5%E5%BC%8F%E6%80%BB%E7%BA%BF%E6%8A%80%E6%9C%AF/image-20230421162852771.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="结构"></p><h4 id="APB总线："><a href="#APB总线：" class="headerlink" title="APB总线："></a>APB总线：</h4><p>APB桥既是APB总线上唯一的主设备，也是AHB系统总线上的从设备。从而实现AHB协议到APB协议的转换。</p><ul><li>锁存来自AHB系统总线的地址、数据和控制信号</li><li>提供二级译码以产生APB外围设备的选择信号</li></ul><p>APB主要用于低带宽的周边外设之间的连接，例如UART、IEEE 1284并口等。</p><ul><li>APB特性包括：<ul><li>两个时钟周期传输；</li><li>无需等待周期和回应信号；</li><li>控制逻辑简单；</li><li>只有四个控制信号</li></ul></li></ul><h5 id="状态转换如图"><a href="#状态转换如图" class="headerlink" title="状态转换如图"></a>状态转换如图</h5><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1ch3-%E5%B5%8C%E5%85%A5%E5%BC%8F%E6%80%BB%E7%BA%BF%E6%8A%80%E6%9C%AF/image-20230421163010958.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="apb总线"></p><ul><li>系统初始化为 IDLE（空闲）状态，此时没有传输操作，也没有选中任何从设备。</li><li>当有传输要进行时，PSELx ＝ 1，PENABLE ＝ 0 </li><li>系统进入 ENABLE 状态时，维持之前在 SETUP 状态的PADDR、PSEL、PWRITE不变，并将 PENABLE 置为 1</li></ul><h4 id="AXI总线："><a href="#AXI总线：" class="headerlink" title="AXI总线："></a>AXI总线：</h4><p>具有单向通道体系结构，使得片上的信息流只以单方向传输，减少了延时和降低了复杂性。AXI总线目前有三个版本：</p><ul><li><p>AXI4：主要面向高性能地址映射通信的需求。</p></li><li><p>AXI4-Lite：是一个简单的吞吐量地址映射性通信总线。（例，状态寄存器的通信）</p></li><li><p>AXI4-Stream：面向高速流数据传输。</p></li></ul><p>特点为：</p><ul><li><p>单方向传输：信号流只以单方向传输，从而简化时钟域间的桥接，减少逻辑门数量，还能减少通信延迟。</p></li><li><p>支持猝发操作：通过并行执行猝发操作，极大地提高了数据吞吐能力，在满足高性能要求的同时，又减少了功耗。</p></li><li><p>地址和数据路径是独立的：地址和数据路径分开，能对单一路径进行独立优化，可以根据需要控制路径时序，将时钟频率提高，以降低通信延迟。</p></li><li><p>增强的灵活性：AXI技术拥有对称的主从接口，无论在点对点或在多层系统中，都能十分方便地使用AXI技术</p></li></ul><h5 id="读操作采用两个通道来实现："><a href="#读操作采用两个通道来实现：" class="headerlink" title="读操作采用两个通道来实现："></a>读操作采用两个通道来实现：</h5><p>读地址通道从主设备发送到从设备，以便设置地址和部分控制信号</p><p>此地址的数据通过读数据通道，由从设备发送到主设备</p><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1ch3-%E5%B5%8C%E5%85%A5%E5%BC%8F%E6%80%BB%E7%BA%BF%E6%8A%80%E6%9C%AF/image-20230421163155421.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="axi"></p><h5 id="写操作采用3个独立的通道实现："><a href="#写操作采用3个独立的通道实现：" class="headerlink" title="写操作采用3个独立的通道实现："></a><strong>写操作采用3个独立的通道实现：</strong></h5><p>写地址通道从主设备发送到从设备，以便设置地址和部分控制信号</p><p>数据通过写数据通道从主设备发射到从设备，以写入此地址</p><p>写反馈通过写反馈响应通道由从设备发送到主设备，返回传输是否成功</p><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1ch3-%E5%B5%8C%E5%85%A5%E5%BC%8F%E6%80%BB%E7%BA%BF%E6%8A%80%E6%9C%AF/image-20230421163306740.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="axi总线"></p><h5 id="AXI握手机制"><a href="#AXI握手机制" class="headerlink" title="AXI握手机制"></a>AXI握手机制</h5><p>使用双向握手机制，传输在 VALID、READY同时有效时，分 3 种情况</p><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1ch3-%E5%B5%8C%E5%85%A5%E5%BC%8F%E6%80%BB%E7%BA%BF%E6%8A%80%E6%9C%AF/image-20230426130513677.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="AXI"></p><p>▪ VALID 在 READY 之前有效握手</p><p>▪ READY 在 VALID 之前有效握手</p><p>▪ VALID 和READY 同时有效握手</p><h3 id="3-4-3多层总结矩阵结构"><a href="#3-4-3多层总结矩阵结构" class="headerlink" title="3.4.3多层总结矩阵结构"></a>3.4.3多层总结矩阵结构</h3><blockquote><p>就STM32F4系列芯片来说，嵌入了多个主设备和从设备</p><p>主设备包括Cortex Mx芯核AHB总线，DMA1存储器总线，DMA2存储器总线，DMA2外设总线，以太网DMA总线，USB高速DMA总线，Chrom-ART加速器总线，LCD-TFT总线等。</p><p>从设备包括内部Flash接口，内部SRAM1和辅助内部SRAM（当可以访问SRAM2，SRAM3时的情况），AHB1外设（包括AHB-APB桥和APB外设），AHB2外设，AHB3外设（例如FMC，Quad-SPI外设）等。</p><p>采用多层总线矩阵结构来支持，保证并发访问和有效操作。</p></blockquote><p>多层总结矩阵结构</p><p>主设备：八条主控总线</p><p>从设备：七条被控总线</p><p>借助总线矩阵，实现主控总线到被控总线的访问</p><p>总线矩阵用于主控总线之间的访问仲裁管理。仲裁采用循环调度算法</p><p>借助两个 AHB&#x2F;APB 总线桥 APB1 和 APB2，可在 AHB 总线与两个 APB 总线之间实现完全同步的连接在多个高速外设同时运行期间，系统也可以实现并发访问和高效运行</p><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1ch3-%E5%B5%8C%E5%85%A5%E5%BC%8F%E6%80%BB%E7%BA%BF%E6%8A%80%E6%9C%AF/image-20230421163441026.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="多层总线"></p><h3 id="3-4-4-矩阵总线访问优先权"><a href="#3-4-4-矩阵总线访问优先权" class="headerlink" title="3.4.4 矩阵总线访问优先权"></a>3.4.4 矩阵总线访问优先权</h3><p>在矩阵总线结构中，采用了轮询调度的优先权体系来保证主设备使用极低</p><p>延迟来访问从设备，这是因为：</p><p>① 轮询调度允许总线带宽的公平分配；</p><p>② 最大延迟有上限；</p><p>③ 轮询调度粒度是1X传输</p><h2 id="3-5总线的性能分析"><a href="#3-5总线的性能分析" class="headerlink" title="3.5总线的性能分析"></a>3.5总线的性能分析</h2><ul><li>影响总线性能的因素<ul><li>传输带宽、数据位宽和工作频率</li></ul></li><li>总线的带宽<ul><li>单位时间内总线上传输的数据量</li><li>影响带宽的因素：总线位宽和工作频率<ul><li>总线的带宽＝总线的工作频率 × 总线的位宽</li><li>实际有效数据传输：传输数据的总线</li><li>有效带宽要比理论带宽窄</li></ul></li><li>总线能同时传输的二进制数据的位数</li><li>总线的位宽越宽，每个时钟数据传输率越大，总线的带宽也就越宽</li></ul></li><li>总线的工作频率</li><li>总线的工作时钟频率以兆赫兹为单位</li><li>工作频率越高，总线工作速度越快，则总线带宽越宽</li></ul><h3 id="带宽与性能"><a href="#带宽与性能" class="headerlink" title="带宽与性能"></a>带宽与性能</h3><ul><li>带宽应用到下面的部件：<ul><li>内存</li><li>总线</li><li>CPU</li></ul></li><li>系统的不同部件具有不同的时钟频率</li><li>不同的部件有不同的带宽</li></ul><h3 id="带宽与数据的传输"><a href="#带宽与数据的传输" class="headerlink" title="带宽与数据的传输"></a>带宽与数据的传输</h3><ul><li>视频一帧：1920 x 1080 x 3 &#x3D; 6 220 800bytes. <ul><li>在 1&#x2F;30 秒&#x3D;0.033 秒通过一帧</li></ul></li><li>若总线传输速度 1 byte&#x2F;10ns, 则0.062 秒每帧. <ul><li>太慢</li></ul></li><li>增加总线带宽<ul><li>增加总线的位宽</li><li>每次传输 4 bytes&#x2F;10ns, 则需要0.0155 s&#x2F;帧，达到要求</li><li>增加总线时钟的频率</li><li>总线时钟200MHz, 1byte&#x2F;5ns，则需要0.031s&#x2F;帧，达到要求</li></ul></li></ul><h3 id="总线的带宽"><a href="#总线的带宽" class="headerlink" title="总线的带宽"></a>总线的带宽</h3><ul><li>T: 总线的周期数</li><li>P: 总线时钟周期<ul><li>time&#x2F;bus_cycle</li></ul></li><li>总的传输时间: <ul><li>t &#x3D; TP</li></ul></li><li>W:基本总线位宽，字节单位. </li><li>N：传送的字节数</li><li>D: 传输W字节宽的数据消耗D个时钟周期. </li><li>额外消耗：O&#x3D;O1 + O2</li></ul><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1ch3-%E5%B5%8C%E5%85%A5%E5%BC%8F%E6%80%BB%E7%BA%BF%E6%8A%80%E6%9C%AF/image-20230426131413469.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="非突发传输"></p><p><strong>B: 一次突发传送连续执行了B次传输</strong></p><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1ch3-%E5%B5%8C%E5%85%A5%E5%BC%8F%E6%80%BB%E7%BA%BF%E6%8A%80%E6%9C%AF/image-20230426131550351.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="突发传输"></p><h3 id="基于总线的性能瓶颈"><a href="#基于总线的性能瓶颈" class="headerlink" title="基于总线的性能瓶颈"></a>基于总线的性能瓶颈</h3><p>每秒传输30帧：</p><ul><li>每帧 1920 x 1080 像素</li><li>30帧传输的字节：<ul><li>1920* 1080* 3* 30.</li></ul></li></ul><p>那么瓶颈是总线还是内存?</p><p>每个视频帧1920*1080，30帧&#x2F;秒 </p><p>总线: 频率：100 MHz bus, D&#x3D;1, O&#x3D;3,w&#x3D;2字节, </p><ul><li>Tbasic &#x3D; (1+3)1920 <em>1080 * 3&#x2F;2 &#x3D; 12.4</em>106 时钟周期 &#x3D; 0.124秒. </li><li>0.124*30&#x3D;3.72秒</li></ul><p>内存: 突发模式，B&#x3D;4, w&#x3D;2,D&#x3D;1,O&#x3D;4 ,存储器的访问时间5ns, </p><ul><li>Tmem &#x3D; (4* 1+4) 1920 * 1080* 3&#x2F;(4* 2) &#x3D; 6.2*106 时钟周期&#x3D; 0.031 秒. </li><li>0.062*30&#x3D;0.93秒</li></ul><p>瓶颈：总线</p><blockquote><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1ch3-%E5%B5%8C%E5%85%A5%E5%BC%8F%E6%80%BB%E7%BA%BF%E6%8A%80%E6%9C%AF/image-20230426131652671.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="image-20230426131652671"></p><p>算一下我电脑每秒170帧，每帧2560*1440像素,其他参数就按题目算了</p><p>Tbasic &#x3D; (1+3)2560 *1440 * 3&#x2F;2 &#x3D; 22118400 时钟周期 &#x3D;0.221184秒</p><p>0.221184*170&#x3D;37.60128s（这个周期过于离谱了吧。。。实际参数肯定不一样）</p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>总线的概念</li><li>典型总线</li><li>DMA</li><li>ARM总线结构</li><li>总线的性能分析</li></ul>]]></content>
    
    
    <categories>
      
      <category>学习资料</category>
      
    </categories>
    
    
    <tags>
      
      <tag>课件笔记</tag>
      
      <tag>嵌入式程序设计</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ARM体系结构与编程-第3章-ARM微处理器的指令系统3-特殊指令</title>
    <link href="/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC3%E7%AB%A0-ARM%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F3-%E7%89%B9%E6%AE%8A%E6%8C%87%E4%BB%A4/"/>
    <url>/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC3%E7%AB%A0-ARM%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F3-%E7%89%B9%E6%AE%8A%E6%8C%87%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<h1 id="ARM体系结构与编程"><a href="#ARM体系结构与编程" class="headerlink" title="ARM体系结构与编程"></a><strong>ARM体系结构与编程</strong></h1><h3 id="3-3-4-程序状态寄存器访问指令"><a href="#3-3-4-程序状态寄存器访问指令" class="headerlink" title="3.3.4 程序状态寄存器访问指令"></a>3.3.4 程序状态寄存器访问指令</h3><p> ARM微处理器支持程序状态寄存器访问指令，用于在程序状态寄存器和通用寄存器之间传送数据，程序状态寄存器访问指令包括以下两条：</p><ul><li>MRS 程序状态寄存器到通用寄存器的数据传送指令</li><li>MSR 通用寄存器到程序状态寄存器的数据传送指令</li></ul><p><img src="/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC3%E7%AB%A0-ARM%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F3-%E7%89%B9%E6%AE%8A%E6%8C%87%E4%BB%A4/image-20230419234742892.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="图形"></p><p><img src="/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC3%E7%AB%A0-ARM%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F3-%E7%89%B9%E6%AE%8A%E6%8C%87%E4%BB%A4/image-20230419234906400.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="MRS"></p><h4 id="1、-MRS指令"><a href="#1、-MRS指令" class="headerlink" title="1、 MRS指令"></a>1、 MRS指令</h4><p>MRS指令的格式为：</p><blockquote><p> MRS{条件}  通用寄存器，程序状态寄存器（CPSR或SPSR）</p></blockquote><p>MRS指令用于将程序状态寄存器的内容传送到通用寄存器中。</p><p>该指令一般用在以下几种情况：</p><p><strong>当需要改变程序状态寄存器的内容时，可用MRS将程序状态寄存器的内容读入通用寄存器，修改后再写回程序状态寄存器。</strong></p><p><strong>当在异常处理或进程切换时，需要保存程序状态寄存器的值，可先用该指令读出程序状态寄存器的值，然后保存</strong></p><p><img src="/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC3%E7%AB%A0-ARM%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F3-%E7%89%B9%E6%AE%8A%E6%8C%87%E4%BB%A4/image-20230419234941339.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="伪代码"></p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-keyword">MRS</span>   <span class="hljs-built_in">R0</span>，<span class="hljs-keyword">CPSR</span>   ；传送CPSR的内容到<span class="hljs-built_in">R0</span><br><span class="hljs-keyword">MRS</span>   <span class="hljs-built_in">R0</span>，SPSR   ；传送SPSR的内容到<span class="hljs-built_in">R0</span><br></code></pre></td></tr></table></figure><p><img src="/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC3%E7%AB%A0-ARM%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F3-%E7%89%B9%E6%AE%8A%E6%8C%87%E4%BB%A4/image-20230419235010621.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="MSR"></p><h4 id="2、MSR指令"><a href="#2、MSR指令" class="headerlink" title="2、MSR指令"></a>2、MSR指令</h4><p>MSR指令的格式为：</p><blockquote><p> MSR{条件}  程序状态寄存器（CPSR或SPSR）_&lt;域&gt;，操作数</p></blockquote><p>MSR指令用于将操作数的内容传送到程序状态寄存器的特定域中。</p><p>其中，操作数可以为通用寄存器或立即数</p><p><img src="/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC3%E7%AB%A0-ARM%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F3-%E7%89%B9%E6%AE%8A%E6%8C%87%E4%BB%A4/image-20230419235110574.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="MSR"></p><p>&lt; 域&gt;用于设置程序状态寄存器中需要操作的位，32位的程序状态寄存器可分为4个域：</p><ul><li>位[31：24]为条件标志位域，用<strong>f</strong>表示；</li><li>位[23：16]为状态位域，用<strong>s</strong>表示；</li><li>位[15：8]为扩展位域，用<strong>x</strong>表示；</li><li>位[7：0]为控制位域，用<strong>c</strong>表示；</li></ul><p><img src="/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC3%E7%AB%A0-ARM%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F3-%E7%89%B9%E6%AE%8A%E6%8C%87%E4%BB%A4/image-20230419235131618.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="FAKE"></p><p>该指令通常用于恢复或改变程序状态寄存器的内容，在使用时，一般要在MSR指令中指明将要操作的域。</p><p><strong>用户模式下，所有位均可以被读取，但只有条件标志位(_f)可被写。</strong></p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-keyword">MSR</span>   <span class="hljs-built_in">CPSR_c</span>，<span class="hljs-built_in">R0</span>  ；传送<span class="hljs-built_in">R0</span>的内容到<span class="hljs-keyword">CPSR</span> ，但仅仅修改CPSR中的控制位域<br><span class="hljs-keyword">MSR</span>   <span class="hljs-built_in">SPSR_f</span>，<span class="hljs-built_in">R0</span>  ；传送<span class="hljs-built_in">R0</span>的内容到SPSR ，但仅仅修改SPSR中的条件标志位域<br></code></pre></td></tr></table></figure><blockquote><p>例子</p><p>将处理器模式切换到特权模式</p><p>MRS R0, CPSR </p><p>BIC R0, R0, #0x1F</p><p>ORR R0, R0, #0x13 ;set Supervisor mode</p><p>MSR CPSR_c, R0</p></blockquote><h3 id="3-3-5-加载-x2F-存储指令"><a href="#3-3-5-加载-x2F-存储指令" class="headerlink" title="3.3.5 加载&#x2F;存储指令"></a>3.3.5 加载&#x2F;存储指令</h3><p>ARM微处理器支持加载&#x2F;存储指令用于在寄存器和存储器之间传送数据，加载指令用于将存储器中的数据传送到寄存器，存储指令则完成相反的操作。常用的加载存储指令如下：</p><table><thead><tr><th>NAME</th><th></th></tr></thead><tbody><tr><td>LDR</td><td>字数据加载指令</td></tr><tr><td>LDRB</td><td>字节数据加载指令</td></tr><tr><td>LDRH</td><td>半字数据加载指令</td></tr><tr><td>STR</td><td>字数据存储指令</td></tr><tr><td>STRB</td><td>字节数据存储指令</td></tr><tr><td>STRH</td><td>半字数据存储指令</td></tr></tbody></table><p><img src="/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC3%E7%AB%A0-ARM%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F3-%E7%89%B9%E6%AE%8A%E6%8C%87%E4%BB%A4/image-20230419235444148.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="LDR"></p><h4 id="1、LDR指令"><a href="#1、LDR指令" class="headerlink" title="1、LDR指令"></a>1、LDR指令</h4><p>LDR指令的格式为：</p><blockquote><p> LDR{条件} 目的寄存器，&lt;存储器地址&gt;</p></blockquote><ul><li>LDR指令用于从存储器中将一个32位的字数据传送到目的寄存器中。</li><li>该指令通常用于从存储器中读取32位的字数据到通用寄存器，然后对数据进行处理。</li><li>当程序计数器PC作为目的寄存器时，指令从存储器中读取的字数据被当作目的地址，从而可以实现程序流程的跳转。</li><li>该指令在程序设计中比较常用，且寻址方式灵活多样</li></ul><p><img src="/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC3%E7%AB%A0-ARM%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F3-%E7%89%B9%E6%AE%8A%E6%8C%87%E4%BB%A4/image-20230419235534274.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="FAKE"></p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-keyword">LDR</span>   <span class="hljs-built_in">R0</span>，[<span class="hljs-built_in">R1</span>]   ；将存储器地址为<span class="hljs-built_in">R1</span>的字数据读入寄存器<span class="hljs-built_in">R0</span>。<br>    <span class="hljs-keyword">LDR</span>   <span class="hljs-built_in">R0</span>，[<span class="hljs-built_in">R1</span>，<span class="hljs-built_in">R2</span>]   ；将存储器地址为<span class="hljs-built_in">R1</span>+<span class="hljs-built_in">R2</span>的字数据读入寄存器<span class="hljs-built_in">R0</span>。<br>    <span class="hljs-keyword">LDR</span>   <span class="hljs-built_in">R0</span>，[<span class="hljs-built_in">R1</span>，＃<span class="hljs-number">8</span>]     ；将存储器地址为<span class="hljs-built_in">R1</span>+<span class="hljs-number">8</span>的字数据读入寄存器<span class="hljs-built_in">R0</span>。<br>  <span class="hljs-keyword">LDR</span>   <span class="hljs-built_in">R0</span>，[<span class="hljs-built_in">R1</span>，<span class="hljs-built_in">R2</span>] ！ ；将存储器地址为<span class="hljs-built_in">R1</span>+<span class="hljs-built_in">R2</span>的字数据读入寄存器<span class="hljs-built_in">R0</span>，并将新地址<span class="hljs-built_in">R1</span>＋<span class="hljs-built_in">R2</span>写入<span class="hljs-built_in">R1</span>。<br>    <span class="hljs-keyword">LDR</span>   <span class="hljs-built_in">R0</span>，[<span class="hljs-built_in">R1</span>，＃<span class="hljs-number">8</span>] ！ ；将存储器地址为<span class="hljs-built_in">R1</span>+<span class="hljs-number">8</span>的字数据读入寄存器<span class="hljs-built_in">R0</span>，并将新地址<span class="hljs-built_in">R1</span>＋<span class="hljs-number">8</span>写入<span class="hljs-built_in">R1</span>。<br>    <span class="hljs-keyword">LDR</span>   <span class="hljs-built_in">R0</span>，[<span class="hljs-built_in">R1</span>]，<span class="hljs-built_in">R2</span>  ；将存储器地址为<span class="hljs-built_in">R1</span>的字数据读入寄存器<span class="hljs-built_in">R0</span>，并将新地址<span class="hljs-built_in">R1</span>＋<span class="hljs-built_in">R2</span>写入<span class="hljs-built_in">R1</span>。<br>    <span class="hljs-keyword">LDR</span>   <span class="hljs-built_in">R0</span>，[<span class="hljs-built_in">R1</span>，<span class="hljs-built_in">R2</span>，LSL＃<span class="hljs-number">2</span>]！ ；将存储器地址为<span class="hljs-built_in">R1</span>＋<span class="hljs-built_in">R2</span>×<span class="hljs-number">4</span>的字数据读入寄存器<span class="hljs-built_in">R0</span>，并将新地址<span class="hljs-built_in">R1</span>＋<span class="hljs-built_in">R2</span>×<span class="hljs-number">4</span>写入<span class="hljs-built_in">R1</span>。<br>    <span class="hljs-keyword">LDR</span>   <span class="hljs-built_in">R0</span>，[<span class="hljs-built_in">R1</span>]，<span class="hljs-built_in">R2</span>，LSL＃<span class="hljs-number">2</span>  ；将存储器地址为<span class="hljs-built_in">R1</span>的字数据读入寄存器<span class="hljs-built_in">R0</span>，并将新地址<span class="hljs-built_in">R1</span>＋<span class="hljs-built_in">R2</span>×<span class="hljs-number">4</span>写入<span class="hljs-built_in">R1</span>。<br></code></pre></td></tr></table></figure><p><img src="/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC3%E7%AB%A0-ARM%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F3-%E7%89%B9%E6%AE%8A%E6%8C%87%E4%BB%A4/image-20230419235623908.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="EXAPL"></p><p>为允许装载大常数，汇编器提供了一条伪指令:</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">LDR rd, =<span class="hljs-keyword">const</span><br></code></pre></td></tr></table></figure><p>它可能汇编成下列指令：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-keyword">MOV</span> or  <span class="hljs-keyword">MVN</span><br>或<br><span class="hljs-keyword">LDR</span> 指令，从数据池（Literal pools）读取常数<br></code></pre></td></tr></table></figure><p><img src="/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC3%E7%AB%A0-ARM%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F3-%E7%89%B9%E6%AE%8A%E6%8C%87%E4%BB%A4/image-20230419235842823.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="example"></p><p>推荐使用这种方法把常数装入寄存器 。</p><p><strong>地址访问</strong></p><p>LDR&#x2F;STR访问的地址由基址寄存器加上偏移量来产生。</p><p>针对word和无符号byte 的访问, 偏移量可以是：</p><p>一个无符号12-bit立即数 (如 0 - 4095 bytes).</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-keyword">LDR</span> <span class="hljs-built_in">r0</span>,[<span class="hljs-built_in">r1</span>,<span class="hljs-number">#8</span>]<br></code></pre></td></tr></table></figure><p>一个寄存器，或再加上移位（由立即数指定）</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-keyword">LDR</span> <span class="hljs-built_in">r0</span>,[<span class="hljs-built_in">r1</span>,<span class="hljs-built_in">r2</span>]<br><span class="hljs-keyword">LDR</span> <span class="hljs-built_in">r0</span>,[<span class="hljs-built_in">r1</span>,<span class="hljs-built_in">r2</span>,LSL<span class="hljs-number">#2</span>]<br></code></pre></td></tr></table></figure><p>可以是从基址寄存器上加或减去偏移量:</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-keyword">LDR</span> <span class="hljs-built_in">r0</span>,[<span class="hljs-built_in">r1</span>,#-<span class="hljs-number">8</span>]<br><span class="hljs-keyword">LDR</span> <span class="hljs-built_in">r0</span>,[<span class="hljs-built_in">r1</span>,-<span class="hljs-built_in">r2</span>]<br><span class="hljs-keyword">LDR</span> <span class="hljs-built_in">r0</span>,[<span class="hljs-built_in">r1</span>,-<span class="hljs-built_in">r2</span>,LSL<span class="hljs-number">#2</span>]<br></code></pre></td></tr></table></figure><p>对于halfword和带符号的halfword &#x2F; byte, 偏移量可以是:</p><ul><li>一个无符号8 bit 立即数 (如 0-255 bytes).</li><li>一个寄存器 (不能偏移)。</li></ul><p>可选择采用<em>pre-indexed</em>或<em>post-indexed</em>方式寻址</p><p><img src="/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC3%E7%AB%A0-ARM%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F3-%E7%89%B9%E6%AE%8A%E6%8C%87%E4%BB%A4/image-20230420000026770.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="数据传输指令"></p><p><img src="/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC3%E7%AB%A0-ARM%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F3-%E7%89%B9%E6%AE%8A%E6%8C%87%E4%BB%A4/image-20230420000042672.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="LDRB"></p><h4 id="2、LDRB指令"><a href="#2、LDRB指令" class="headerlink" title="2、LDRB指令"></a>2、LDRB指令</h4><p>LDRB指令的格式为：</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml">LDR</span><span class="hljs-template-variable">&#123;条件&#125;</span><span class="language-xml">B 目的寄存器，<span class="hljs-tag">&lt;<span class="hljs-name">存储器地址</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>LDRB指令用于从存储器中将一个8位的字节数据传送到目的寄存器中，同时将寄存器的高24位清零。</p><p>该指令通常用于从存储器中读取8位的字节数据到通用寄存器，然后对数据进行处理。</p><p>当程序计数器PC作为目的寄存器时，指令从存储器中读取的字数据被当作目的地址，从而可以实现程序流程的跳转。</p><p><img src="/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC3%E7%AB%A0-ARM%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F3-%E7%89%B9%E6%AE%8A%E6%8C%87%E4%BB%A4/image-20230420000121482.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="FAKE"></p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-keyword">LDRB</span> <span class="hljs-built_in">R0</span>，[<span class="hljs-built_in">R1</span>]   ；将存储器地址为<span class="hljs-built_in">R1</span>的字节数据读入寄存器<span class="hljs-built_in">R0</span>，并将<span class="hljs-built_in">R0</span>的高<span class="hljs-number">24</span>位清零。<br>    <span class="hljs-keyword">LDRB</span> <span class="hljs-built_in">R0</span>，[<span class="hljs-built_in">R1</span>，＃-<span class="hljs-number">8</span>]  ；将存储器地址为<span class="hljs-built_in">R1</span>-<span class="hljs-number">8</span>的字节数据读入寄存器<span class="hljs-built_in">R0</span>，并将<span class="hljs-built_in">R0</span>的高<span class="hljs-number">24</span>位清零。<br></code></pre></td></tr></table></figure><p><img src="/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC3%E7%AB%A0-ARM%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F3-%E7%89%B9%E6%AE%8A%E6%8C%87%E4%BB%A4/image-20230420000144605.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="LDHR"></p><h4 id="3、LDRH指令"><a href="#3、LDRH指令" class="headerlink" title="3、LDRH指令"></a>3、LDRH指令</h4><p>LDRH指令的格式为：</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml">LDR</span><span class="hljs-template-variable">&#123;条件&#125;</span><span class="language-xml">H 目的寄存器，<span class="hljs-tag">&lt;<span class="hljs-name">存储器地址</span>&gt;</span></span><br></code></pre></td></tr></table></figure><ul><li>LDRH指令用于从存储器中将一个16位的半字数据传送到目的寄存器中，同时将寄存器的高16位清零。</li><li>该指令通常用于从存储器中读取16位的半字数据到通用寄存器，然后对数据进行处理。</li><li>当程序计数器PC作为目的寄存器时，指令从存储器中读取的字数据被当作目的地址，从而可以实现程序流程的跳转</li></ul><p><img src="/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC3%E7%AB%A0-ARM%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F3-%E7%89%B9%E6%AE%8A%E6%8C%87%E4%BB%A4/image-20230420000218174.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="FAKE"></p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-keyword">LDRH</span> <span class="hljs-built_in">R0</span>，[<span class="hljs-built_in">R1</span>]    ；将存储器地址为<span class="hljs-built_in">R1</span>的半字数据读入寄存器<span class="hljs-built_in">R0</span>，并将<span class="hljs-built_in">R0</span>的高<span class="hljs-number">16</span>位清零。<br>     <span class="hljs-keyword">LDRH</span> <span class="hljs-built_in">R0</span>，[<span class="hljs-built_in">R1</span>，＃<span class="hljs-number">8</span>]    ；将存储器地址为<span class="hljs-built_in">R1</span>＋<span class="hljs-number">8</span>的半字数据读入寄存器<span class="hljs-built_in">R0</span>，并将<span class="hljs-built_in">R0</span>的高<span class="hljs-number">16</span>位清零。<br>     <span class="hljs-keyword">LDRH</span> <span class="hljs-built_in">R0</span>，[<span class="hljs-built_in">R1</span>，<span class="hljs-built_in">R2</span>]    ；将存储器地址为<span class="hljs-built_in">R1</span>＋<span class="hljs-built_in">R2</span>的半字数据读入寄存器<span class="hljs-built_in">R0</span>，并将<span class="hljs-built_in">R0</span>的高<span class="hljs-number">16</span>位清零<br></code></pre></td></tr></table></figure><p><img src="/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC3%E7%AB%A0-ARM%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F3-%E7%89%B9%E6%AE%8A%E6%8C%87%E4%BB%A4/image-20230420000253155.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="STR"></p><h4 id="4、STR指令"><a href="#4、STR指令" class="headerlink" title="4、STR指令"></a>4、STR指令</h4><p>STR指令的格式为：</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml">STR</span><span class="hljs-template-variable">&#123;条件&#125;</span><span class="language-xml"> 源寄存器，<span class="hljs-tag">&lt;<span class="hljs-name">存储器地址</span>&gt;</span></span><br></code></pre></td></tr></table></figure><ul><li>STR指令用于从源寄存器中将一个32位的字数据传送到存储器中。</li><li>该指令在程序设计中比较常用，且寻址方式灵活多样，使用方式可参考指令LDR。</li></ul><p><img src="/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC3%E7%AB%A0-ARM%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F3-%E7%89%B9%E6%AE%8A%E6%8C%87%E4%BB%A4/image-20230420000347052.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="FAKE"></p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-keyword">STR</span>   <span class="hljs-built_in">R0</span>，[<span class="hljs-built_in">R1</span>]，＃<span class="hljs-number">8</span> ；将<span class="hljs-built_in">R0</span>中的字数据写入以<span class="hljs-built_in">R1</span>为地址的存储器中，并将新地址<span class="hljs-built_in">R1</span>＋<span class="hljs-number">8</span>写入<span class="hljs-built_in">R1</span>。<br>    <span class="hljs-keyword">STR</span>   <span class="hljs-built_in">R0</span>，[<span class="hljs-built_in">R1</span>，＃-<span class="hljs-number">8</span>] ；将<span class="hljs-built_in">R0</span>中的字数据写入以<span class="hljs-built_in">R1</span>-<span class="hljs-number">8</span>为地址的存储器中。<br></code></pre></td></tr></table></figure><p><img src="/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC3%E7%AB%A0-ARM%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F3-%E7%89%B9%E6%AE%8A%E6%8C%87%E4%BB%A4/image-20230420000409486.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="EXP"></p><p><img src="/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC3%E7%AB%A0-ARM%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F3-%E7%89%B9%E6%AE%8A%E6%8C%87%E4%BB%A4/image-20230420000426157.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="STRB"></p><h4 id="5、STRB指令"><a href="#5、STRB指令" class="headerlink" title="5、STRB指令"></a>5、STRB指令</h4><p>STRB指令的格式为：</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml">STR</span><span class="hljs-template-variable">&#123;条件&#125;</span><span class="language-xml">B 源寄存器，<span class="hljs-tag">&lt;<span class="hljs-name">存储器地址</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>STRB指令用于从源寄存器中将一个8位的字节数据传送到存储器中。</p><p>该字节数据为源寄存器中的低8位。</p><p><img src="/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC3%E7%AB%A0-ARM%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F3-%E7%89%B9%E6%AE%8A%E6%8C%87%E4%BB%A4/image-20230420000458168.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="FAKE"></p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-keyword">STRB</span> <span class="hljs-built_in">R0</span>，[<span class="hljs-built_in">R1</span>]  ；将寄存器<span class="hljs-built_in">R0</span>中的字节数据写入以<span class="hljs-built_in">R1</span>为地址的存储器中。<br>   <span class="hljs-keyword">STRB</span> <span class="hljs-built_in">R0</span>，[<span class="hljs-built_in">R1</span>，＃<span class="hljs-number">8</span>] ；将寄存器<span class="hljs-built_in">R0</span>中的字节数据写入以<span class="hljs-built_in">R1</span>＋<span class="hljs-number">8</span>为地址的存储器中。<br><br></code></pre></td></tr></table></figure><p><img src="/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC3%E7%AB%A0-ARM%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F3-%E7%89%B9%E6%AE%8A%E6%8C%87%E4%BB%A4/image-20230420000522130.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="STRH"></p><h4 id="6、STRH指令"><a href="#6、STRH指令" class="headerlink" title="6、STRH指令"></a>6、STRH指令</h4><p>STRH指令的格式为：</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml">STR</span><span class="hljs-template-variable">&#123;条件&#125;</span><span class="language-xml">H 源寄存器，<span class="hljs-tag">&lt;<span class="hljs-name">存储器地址</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>STRH指令用于从源寄存器中将一个16位的半字数据传送到存储器中。</p><p>该半字数据为源寄存器中的低16位。</p><p><img src="/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC3%E7%AB%A0-ARM%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F3-%E7%89%B9%E6%AE%8A%E6%8C%87%E4%BB%A4/image-20230420000551405.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="FAKE"></p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-keyword">STRH</span> <span class="hljs-built_in">R0</span>，[<span class="hljs-built_in">R1</span>]  ；将寄存器<span class="hljs-built_in">R0</span>中的半字数据写入以<span class="hljs-built_in">R1</span>为地址的存储器中。<br>    <span class="hljs-keyword">STRH</span> <span class="hljs-built_in">R0</span>，[<span class="hljs-built_in">R1</span>，＃<span class="hljs-number">8</span>]  ；将寄存器<span class="hljs-built_in">R0</span>中的半字数据写入以<span class="hljs-built_in">R1</span>＋<span class="hljs-number">8</span>为地址的存储器中。<br><br></code></pre></td></tr></table></figure><h3 id="3-3-6-批量数据加载-x2F-存储指令"><a href="#3-3-6-批量数据加载-x2F-存储指令" class="headerlink" title="3.3.6 批量数据加载&#x2F;存储指令"></a>3.3.6 批量数据加载&#x2F;存储指令</h3><p> ARM微处理器所支持批量数据加载&#x2F;存储指令可以一次在一片连续的存储器单元和多个寄存器之间传送数据，批量加载指令用于将一片连续的存储器中的数据传送到多个寄存器，批量数据存储指令则完成相反的操作。常用的加载存储指令如下：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-keyword">LDM</span>     批量数据加载指令<br><span class="hljs-keyword">STM</span>     批量数据存储指令<br></code></pre></td></tr></table></figure><p>LDM（或STM）指令的格式为：</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml">LDM（或STM）</span><span class="hljs-template-variable">&#123;条件&#125;</span><span class="hljs-template-variable">&#123;类型&#125;</span><span class="language-xml">   基址寄存器</span><span class="hljs-template-variable">&#123;！&#125;</span><span class="language-xml">，寄存器列表</span><span class="hljs-template-variable">&#123;∧&#125;</span><br></code></pre></td></tr></table></figure><p><img src="/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC3%E7%AB%A0-ARM%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F3-%E7%89%B9%E6%AE%8A%E6%8C%87%E4%BB%A4/image-20230420000719024.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="ARM"></p><p><img src="/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC3%E7%AB%A0-ARM%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F3-%E7%89%B9%E6%AE%8A%E6%8C%87%E4%BB%A4/image-20230420000748003.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="LDM"></p><p><img src="/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC3%E7%AB%A0-ARM%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F3-%E7%89%B9%E6%AE%8A%E6%8C%87%E4%BB%A4/image-20230420000817032.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="image-20230420000817032">       </p><p><img src="/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC3%E7%AB%A0-ARM%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F3-%E7%89%B9%E6%AE%8A%E6%8C%87%E4%BB%A4/image-20230420001019812.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="LDM2"></p><p><img src="/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC3%E7%AB%A0-ARM%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F3-%E7%89%B9%E6%AE%8A%E6%8C%87%E4%BB%A4/image-20230420001028321.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="FAKE"></p><blockquote><p><strong>注意Rn不自更新，Rn可以出现在寄存器列表中；</strong></p><p><strong>同时寄存器列表中没有PC。</strong></p><p><strong>^表示指令中所用的寄存器为用户模式下的寄存器。</strong></p><p><strong>Rn是指令执行时当前处理器模式对应的物理寄存器。</strong></p></blockquote><p><img src="/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC3%E7%AB%A0-ARM%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F3-%E7%89%B9%E6%AE%8A%E6%8C%87%E4%BB%A4/image-20230420001116457.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="LDM3"></p><p><img src="/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC3%E7%AB%A0-ARM%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F3-%E7%89%B9%E6%AE%8A%E6%8C%87%E4%BB%A4/image-20230420001124271.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="FAKE"></p><p><strong>^</strong>表示将当前处理器模式下的<strong>SPSR值复制到CPSR</strong>中。</p><p><img src="/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC3%E7%AB%A0-ARM%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F3-%E7%89%B9%E6%AE%8A%E6%8C%87%E4%BB%A4/image-20230420001158238.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="STM1"></p><p><img src="/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC3%E7%AB%A0-ARM%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F3-%E7%89%B9%E6%AE%8A%E6%8C%87%E4%BB%A4/image-20230420001204528.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="FAKE"></p><p><strong>如果R15被作为Rn，指令将产生不可预知的结果。</strong></p><p><strong>主要用于块数据的写入、数据栈操作以及进入子程序时保存相关的寄存器的操作。</strong></p><p><img src="/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC3%E7%AB%A0-ARM%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F3-%E7%89%B9%E6%AE%8A%E6%8C%87%E4%BB%A4/image-20230420001233390.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="STM2"></p><p><img src="/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC3%E7%AB%A0-ARM%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F3-%E7%89%B9%E6%AE%8A%E6%8C%87%E4%BB%A4/image-20230420001239478.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="FAKE"></p><p>LDM（或STM）指令用于从由基址寄存器所指示的一片连续存储器到寄存器列表所指示的多个寄存器之间传送数据，该指令的常见用途是将多个寄存器的内容入栈或出栈。其中，{类型}为以下几种情况：</p><table><thead><tr><th>type</th><th></th></tr></thead><tbody><tr><td>IA</td><td><strong>每次传送后地址加</strong>1</td></tr><tr><td>IB</td><td><strong>每次传送前地址加</strong>1</td></tr><tr><td>DA</td><td><strong>每次传送后地址减</strong>1</td></tr><tr><td>DB</td><td><strong>每次传送前地址减</strong>1</td></tr><tr><td>FD</td><td><strong>满递减堆栈</strong></td></tr><tr><td>ED</td><td><strong>空递减堆栈</strong></td></tr><tr><td>FA</td><td><strong>满递增堆栈</strong></td></tr><tr><td>EA</td><td><strong>空递增堆栈</strong></td></tr></tbody></table><blockquote><p>I:increase </p><p>d:decrease</p><p>a:after</p><p>b:before</p><p>F:full</p><p>E:empty</p><p>D:Decrease</p><p>A:Arise</p></blockquote><p>{<strong>！</strong>}为可选后缀，若选用该后缀，则当数据传送完毕之后，将最后的地址写入基址寄存器，否则基址寄存器的内容不改变。</p><blockquote><p>基址寄存器不允许为R15，寄存器列表可以为R0～R15的任意组合。</p></blockquote><p>{<strong>∧</strong>}为可选后缀，<strong>当指令为LDM且寄存器列表中包含R15，选用该后缀时表示：除了正常的数据传送之外，还将SPSR复制到CPSR。同时，该后缀还表示传入或传出的是用户模式下的寄存器，而不是当前模式下的寄存器。</strong></p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-symbol">STMFD</span>  <span class="hljs-built_in">R13</span>!，&#123;<span class="hljs-built_in">R0</span>，<span class="hljs-built_in">R4</span>-<span class="hljs-built_in">R12</span>，<span class="hljs-built_in">LR</span>&#125;      ；将寄存器列表中的寄存器（<span class="hljs-built_in">R0</span>，<span class="hljs-built_in">R4</span>到<span class="hljs-built_in">R12</span>，<span class="hljs-built_in">LR</span>）存入堆栈。<br><span class="hljs-keyword">LDMFD</span>  <span class="hljs-built_in">R13</span>!，&#123;<span class="hljs-built_in">R0</span>，<span class="hljs-built_in">R4</span>-<span class="hljs-built_in">R12</span>，<span class="hljs-built_in">PC</span>&#125;      ；将堆栈内容恢复到寄存器（<span class="hljs-built_in">R0</span>，<span class="hljs-built_in">R4</span>到<span class="hljs-built_in">R12</span>，<span class="hljs-built_in">PC</span>）。<br><br></code></pre></td></tr></table></figure><h4 id="LDM-x2F-STM-操作"><a href="#LDM-x2F-STM-操作" class="headerlink" title="LDM &#x2F; STM 操作"></a><strong>LDM &#x2F; STM 操作</strong></h4><p>语法：</p><figure class="highlight bnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bnf"><span class="hljs-attribute">&lt;LDM|STM&gt;</span>&#123;<span class="hljs-attribute">&lt;cond&gt;</span>&#125;<span class="hljs-attribute">&lt;addressing_mode&gt;</span> Rb&#123;!&#125;, <span class="hljs-attribute">&lt;寄存器 list&gt;</span><br></code></pre></td></tr></table></figure><p>4 种寻址操作:</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-keyword">LDMIA</span> / <span class="hljs-keyword">STMIA</span>Increment After（先操作，后增加）<br><span class="hljs-keyword">LDMIB</span> / <span class="hljs-keyword">STMIB</span>Increment Before（先增加，后操作）<br><span class="hljs-keyword">LDMDA</span> / <span class="hljs-keyword">STMDA</span>Decrement After （先操作，后递减）<br><span class="hljs-keyword">LDMDB</span> / <span class="hljs-keyword">STMDB</span>Decrement Before （先递减，后操作）<br></code></pre></td></tr></table></figure><p><img src="/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC3%E7%AB%A0-ARM%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F3-%E7%89%B9%E6%AE%8A%E6%8C%87%E4%BB%A4/image-20230420001947862.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="ex"></p><p>ARM堆栈操作通过块传送指令来完成:</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs scss">STMFD(Push)块存储- Full Descending stack <span class="hljs-selector-attr">[STMDB]</span><br>LDMFD(Pop)块装载- Full Descending stack <span class="hljs-selector-attr">[LDMIA]</span><br></code></pre></td></tr></table></figure><p><img src="/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC3%E7%AB%A0-ARM%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F3-%E7%89%B9%E6%AE%8A%E6%8C%87%E4%BB%A4/image-20230420002032507.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="t"></p><h4 id="存储器块拷贝"><a href="#存储器块拷贝" class="headerlink" title="存储器块拷贝"></a><strong>存储器块拷贝</strong></h4><p>可选项“ <strong>!</strong> ”将导致LDM &#x2F; STM 指令去自动更新基址寄存器</p><blockquote><p>后缀为<strong>IA</strong>, <strong>IB时，加上</strong>4 乘以 用于传送的寄存器的数目的值</p><p>后缀为<strong>DA</strong>, <strong>DB时，减去</strong>4乘以用于传送的寄存器的数目的值</p></blockquote><p>; r12指向源数据起始地址</p><p>; r14指向源数据尾地址</p><p>; r13指向目的数据起始地址</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-symbol">Loop</span><span class="hljs-keyword">LDMIA</span><span class="hljs-built_in">r12</span>!, &#123;<span class="hljs-built_in">r0</span>-<span class="hljs-built_in">r11</span>&#125;<span class="hljs-comment">; 装载48 bytes</span><br><span class="hljs-keyword">STMIA</span><span class="hljs-built_in">r13</span>!, &#123;<span class="hljs-built_in">r0</span>-<span class="hljs-built_in">r11</span>&#125;<span class="hljs-comment">;和存储them</span><br><span class="hljs-keyword">CMP</span><span class="hljs-built_in">r12</span>, <span class="hljs-built_in">r14</span><span class="hljs-comment">; check for the end</span><br><span class="hljs-keyword">BNE</span>loop<span class="hljs-comment">;和loop until done</span><br></code></pre></td></tr></table></figure><p>此循环传送 48 bytes占用了31周期</p><p>时钟为33 MHz时传输速率超过50 Mbytes&#x2F;sec</p><p><img src="/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC3%E7%AB%A0-ARM%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F3-%E7%89%B9%E6%AE%8A%E6%8C%87%E4%BB%A4/image-20230420002235765.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="TU"></p><h3 id="3-3-7-数据交换指令"><a href="#3-3-7-数据交换指令" class="headerlink" title="3.3.7 数据交换指令"></a>3.3.7 数据交换指令</h3><p> ARM微处理器所支持数据交换指令能在存储器和寄存器之间交换数据。数据交换指令有如下两条：</p><ul><li>SWP   字数据交换指令</li><li>SWPB  字节数据交换指令</li></ul><p><img src="/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC3%E7%AB%A0-ARM%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F3-%E7%89%B9%E6%AE%8A%E6%8C%87%E4%BB%A4/image-20230420002346913.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="SWP"></p><h4 id="1、SWP指令"><a href="#1、SWP指令" class="headerlink" title="1、SWP指令"></a>1、SWP指令</h4><p>SWP指令的格式为：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">SWP</span>&#123;条件&#125; 目的寄存器，源寄存器<span class="hljs-number">1</span>，[源寄存器<span class="hljs-number">2</span>]<br></code></pre></td></tr></table></figure><p>方向：1.[源寄存器2] -&gt;目的寄存器</p><p>​2.源寄存器1-&gt;[源寄存器2]</p><p>SWP指令用于将源寄存器2所指向的存储器中的字数据传送到目的寄存器中，同时将源寄存器1中的字数据传送到源寄存器2所指向的存储器中。</p><p>显然，当源寄存器1和目的寄存器为同一个寄存器时，指令交换该寄存器和存储器的内容。</p><p><img src="/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC3%E7%AB%A0-ARM%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F3-%E7%89%B9%E6%AE%8A%E6%8C%87%E4%BB%A4/image-20230420002551303.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="fake"></p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-keyword">SWP</span>   <span class="hljs-built_in">R0</span>，<span class="hljs-built_in">R1</span>，[<span class="hljs-built_in">R2</span>]     ；将<span class="hljs-built_in">R2</span>所指向的存储器中的字数据传送到<span class="hljs-built_in">R0</span>，同时将<span class="hljs-built_in">R1</span>中的字数据传送到<span class="hljs-built_in">R2</span>所指向的存储单元。<br>    <span class="hljs-keyword">SWP</span>   <span class="hljs-built_in">R0</span>，<span class="hljs-built_in">R0</span>，[<span class="hljs-built_in">R1</span>]     ；该指令完成将<span class="hljs-built_in">R1</span>所指向的存储器中的字数据与<span class="hljs-built_in">R0</span>中的字数据交换。<br></code></pre></td></tr></table></figure><p>在寄存器和存储器之间，由一次存储器读和一次存储器写组成的<strong>原子操作</strong>，完成一个字节或字的交换。</p><p>语法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css">SWP&#123;&lt;cond&gt;&#125;&#123;<span class="hljs-selector-tag">B</span>&#125; Rd, Rm, <span class="hljs-selector-attr">[Rn]</span><br><br></code></pre></td></tr></table></figure><p><img src="/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC3%E7%AB%A0-ARM%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F3-%E7%89%B9%E6%AE%8A%E6%8C%87%E4%BB%A4/image-20230420003157638.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="swp"></p><p>可用作信号量</p><p>不能由armcc编译产生，必须使用汇编器。</p><p><img src="/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC3%E7%AB%A0-ARM%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F3-%E7%89%B9%E6%AE%8A%E6%8C%87%E4%BB%A4/image-20230420003210817.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="swpb"></p><h4 id="2、SWPB指令"><a href="#2、SWPB指令" class="headerlink" title="2、SWPB指令"></a>2、SWPB指令</h4><p>SWPB指令的格式为</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">SWP</span>&#123;条件&#125;B 目的寄存器，源寄存器<span class="hljs-number">1</span>，[源寄存器<span class="hljs-number">2</span>]<br><br></code></pre></td></tr></table></figure><p>SWPB指令用于将源寄存器2所指向的存储器中的字节数据传送到目的寄存器中，目的寄存器的高24清零，同时将源寄存器1中的字节数据传送到源寄存器2所指向的存储器中。</p><p>显然，当源寄存器1和目的寄存器为同一个寄存器时，指令交换该寄存器和存储器的内容。</p><p><img src="/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC3%E7%AB%A0-ARM%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F3-%E7%89%B9%E6%AE%8A%E6%8C%87%E4%BB%A4/image-20230420003235712.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="fake"></p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-keyword">SWPB</span> <span class="hljs-built_in">R0</span>，<span class="hljs-built_in">R1</span>，[<span class="hljs-built_in">R2</span>]     ；将<span class="hljs-built_in">R2</span>所指向的存储器中的字节数据传送到<span class="hljs-built_in">R0</span>，<span class="hljs-built_in">R0</span>的高<span class="hljs-number">24</span>位清零，同时将<span class="hljs-built_in">R1</span>中的低<span class="hljs-number">8</span>位数据传送到<span class="hljs-built_in">R2</span>所指向的存储单元。<br>    <span class="hljs-keyword">SWPB</span> <span class="hljs-built_in">R0</span>，<span class="hljs-built_in">R0</span>，[<span class="hljs-built_in">R1</span>]     ；该指令完成将<span class="hljs-built_in">R1</span>所指向的存储器中的字节数据与<span class="hljs-built_in">R0</span>中的低<span class="hljs-number">8</span>位数据交换。<br><br></code></pre></td></tr></table></figure><h3 id="3-3-8-移位指令（操作）"><a href="#3-3-8-移位指令（操作）" class="headerlink" title="3.3.8 移位指令（操作）"></a>3.3.8 移位指令（操作）</h3><p>ARM微处理器内嵌的桶型移位器（Barrel Shifter），支持数据的各种移位操作。</p><p><strong>移位操作在ARM指令集中不作为单独的指令使用，它只能作为指令格式中是一个字段，在汇编语言中表示为指令中的选项</strong>。</p><p>例如，数据处理指令的第二个操作数为寄存器时，就可以加入移位操作选项对它进行各种移位操作。</p><p>移位操作包括如下6种类型，ASL和LSL是等价的，可以自由互换</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>LSL</td><td>逻辑左移</td></tr><tr><td>LSR</td><td>逻辑右移</td></tr><tr><td>ASL</td><td>算术左移</td></tr><tr><td>ASR</td><td>算术右移</td></tr><tr><td>ROR</td><td>循环右移</td></tr><tr><td>RX</td><td>带扩展的循环右移</td></tr></tbody></table><p><img src="/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC3%E7%AB%A0-ARM%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F3-%E7%89%B9%E6%AE%8A%E6%8C%87%E4%BB%A4/image-20230420003419378.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="LSL1"></p><p><img src="/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC3%E7%AB%A0-ARM%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F3-%E7%89%B9%E6%AE%8A%E6%8C%87%E4%BB%A4/image-20230420003432164.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="LSL2"></p><h4 id="1、LSL（或ASL）操作"><a href="#1、LSL（或ASL）操作" class="headerlink" title="1、LSL（或ASL）操作"></a>1、LSL（或ASL）操作</h4><p>LSL（或ASL）操作的格式为</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs avrasm">通用寄存器，<span class="hljs-keyword">LSL</span>（或ASL） 操作数      <br><br></code></pre></td></tr></table></figure><p>LSL（或ASL）可完成对通用寄存器中的内容进行逻辑（或算术）的左移操作，按操作数所指定的数量向左移位，低位用零来填充。其中，操作数可以是通用寄存器，也可以是立即数（0～31）</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">    <span class="hljs-keyword">MOV</span>    <span class="hljs-built_in">R0</span>, <span class="hljs-built_in">R1</span>, <span class="hljs-keyword">LSL</span>#<span class="hljs-number">2</span>     ；将<span class="hljs-built_in">R1</span>中的内容左移两位后传送到<span class="hljs-built_in">R0</span>中。<br><br></code></pre></td></tr></table></figure><p><img src="/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC3%E7%AB%A0-ARM%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F3-%E7%89%B9%E6%AE%8A%E6%8C%87%E4%BB%A4/image-20230420003510078.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="LSR1"></p><p><img src="/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC3%E7%AB%A0-ARM%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F3-%E7%89%B9%E6%AE%8A%E6%8C%87%E4%BB%A4/image-20230420003517314.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="LSR2"></p><h4 id="2、LSR操作"><a href="#2、LSR操作" class="headerlink" title="2、LSR操作"></a>2、LSR操作</h4><p>LSR操作的格式为</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs armasm">通用寄存器，<span class="hljs-keyword">LSR</span> 操作数      <br></code></pre></td></tr></table></figure><p>nLSR可完成对通用寄存器中的内容进行右移的操作，按操作数所指定的数量向右移位，左端用零来填充。其中，操作数可以是通用寄存器，也可以是立即数（0～31）。</p><p>操作示例：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-keyword">MOV</span>  <span class="hljs-built_in">R0</span>, <span class="hljs-built_in">R1</span>, LSR<span class="hljs-number">#2</span>   ；将<span class="hljs-built_in">R1</span>中的内容右移两位后传送 到<span class="hljs-built_in">R0</span>中，左端用零来填充。<br></code></pre></td></tr></table></figure><p><img src="/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC3%E7%AB%A0-ARM%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F3-%E7%89%B9%E6%AE%8A%E6%8C%87%E4%BB%A4/image-20230420003549056.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="ASR1"></p><p><img src="/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC3%E7%AB%A0-ARM%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F3-%E7%89%B9%E6%AE%8A%E6%8C%87%E4%BB%A4/image-20230420003555426.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="ASR2"></p><h4 id="3、ASR操作"><a href="#3、ASR操作" class="headerlink" title="3、ASR操作"></a>3、ASR操作</h4><p>ASR操作的格式为：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs armasm">通用寄存器，<span class="hljs-keyword">ASR</span> 操作数   <br></code></pre></td></tr></table></figure><p>ASR可完成对通用寄存器中的内容进行右移的操作，按操作数所指定的数量向右移位，左端用第31位的值来填充。其中，操作数可以是通用寄存器，也可以是立即数（0～31）。</p><p>操作示例：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-keyword">MOV</span>  <span class="hljs-built_in">R0</span>, <span class="hljs-built_in">R1</span>, ASR<span class="hljs-number">#2</span>   ；将<span class="hljs-built_in">R1</span>中的内容右移两位后传送 到<span class="hljs-built_in">R0</span>中，左端用第<span class="hljs-number">31</span>位的值来填充。<br></code></pre></td></tr></table></figure><p><img src="/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC3%E7%AB%A0-ARM%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F3-%E7%89%B9%E6%AE%8A%E6%8C%87%E4%BB%A4/image-20230420003629090.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="ROR"></p><h4 id="4、ROR操作"><a href="#4、ROR操作" class="headerlink" title="4、ROR操作"></a>4、ROR操作</h4><p>ROR操作的格式为：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs armasm">通用寄存器，<span class="hljs-keyword">ROR</span> 操作数      <br></code></pre></td></tr></table></figure><p>ROR可完成对通用寄存器中的内容进行循环右移的操作，按操作数所指定的数量向右循环移位，左端用右端移出的位来填充。其中，操作数可以是通用寄存器，也可以是立即数（0～31）。显然，当进行32位的循环右移操作时，通用寄存器中的值不改变。</p><p>操作示例：</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">MOV</span>  <span class="hljs-built_in">R0</span>, <span class="hljs-built_in">R1</span>, <span class="hljs-keyword">ROR</span>#<span class="hljs-number">2</span>   ；将<span class="hljs-built_in">R1</span>中的内容循环右移两位 后传送到<span class="hljs-built_in">R0</span>中。<br></code></pre></td></tr></table></figure><h4 id="5、RRX操作"><a href="#5、RRX操作" class="headerlink" title="5、RRX操作"></a>5、RRX操作</h4><p>RRX操作的格式为：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs armasm">通用寄存器，<span class="hljs-keyword">RRX</span> 操作数      <br></code></pre></td></tr></table></figure><p>RRX可完成对通用寄存器中的内容进行带扩展的循环右移的操作，按操作数所指定的数量向右循环移位，左端用进位标志位C来填充。其中，操作数可以是通用寄存器，也可以是立即数（0～31）。</p><p>操作示例：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-keyword">MOV</span>  <span class="hljs-built_in">R0</span>, <span class="hljs-built_in">R1</span>, <span class="hljs-keyword">RRX</span> <span class="hljs-number">#2</span>   ；将<span class="hljs-built_in">R1</span>中的内容进行带扩 展的循环右移两位后传送到<span class="hljs-built_in">R0</span>中。<br></code></pre></td></tr></table></figure><h3 id="3-3-9-协处理器指令"><a href="#3-3-9-协处理器指令" class="headerlink" title="3.3.9 协处理器指令"></a>3.3.9 协处理器指令</h3><p>ARM微处理器可支持多达16个协处理器，用于各种协处理操作，在程序执行的过程中，每个协处理器只执行针对自身的协处理指令，忽略ARM处理器和其他协处理器的指令</p><p>这有三种协处理器指令</p><ul><li>协处理器数据处理指令<ul><li>CDP：初始化协处理器数据处理操作</li></ul></li><li>协处理器寄存器传送指令<ul><li>MRC： 从 ARM 寄存器移到协处理器寄存器</li><li>MCR：从协处理器寄存器移到ARM 寄存器</li></ul></li><li>协处理器存储器传送指令<ul><li>LDC：从存储器装载到协处理器寄存器</li><li>STC：从协处理器寄存器存储到存储器</li></ul></li></ul><p><img src="/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC3%E7%AB%A0-ARM%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F3-%E7%89%B9%E6%AE%8A%E6%8C%87%E4%BB%A4/image-20230420003829707.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="协"></p><p><img src="/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC3%E7%AB%A0-ARM%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F3-%E7%89%B9%E6%AE%8A%E6%8C%87%E4%BB%A4/image-20230420004808067.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="cdp"></p><h4 id="1、CDP指令"><a href="#1、CDP指令" class="headerlink" title="1、CDP指令"></a>1、CDP指令</h4><p>CDP指令的格式为：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">CDP</span>&#123;条件&#125; 协处理器编码，协处理器操作码<span class="hljs-number">1</span>，目的寄存器，源寄存器<span class="hljs-number">1</span>，源寄存器<span class="hljs-number">2</span>，协处理器操作码<span class="hljs-number">2</span><br><br></code></pre></td></tr></table></figure><p>CDP指令用于ARM处理器通知ARM协处理器执行特定的操作,若协处理器不能成功完成特定的操作，则产生未定义指令异常。</p><p>其中协处理器操作码1和协处理器操作码2为协处理器将要执行的操作，目的寄存器和源寄存器均为协处理器的寄存器，<strong>指令不涉及ARM处理器的寄存器和存储器。</strong></p><p><img src="/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC3%E7%AB%A0-ARM%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F3-%E7%89%B9%E6%AE%8A%E6%8C%87%E4%BB%A4/image-20230420004850790.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="FAKE"></p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-keyword">CDP</span>   <span class="hljs-built_in">P3</span>，<span class="hljs-number">2</span>，<span class="hljs-built_in">C12</span>，<span class="hljs-built_in">C10</span>，<span class="hljs-built_in">C3</span>，<span class="hljs-number">4</span>   ；该指令完成协处理器<span class="hljs-built_in">P3</span>的初始化 <br><br></code></pre></td></tr></table></figure><p><img src="/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC3%E7%AB%A0-ARM%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F3-%E7%89%B9%E6%AE%8A%E6%8C%87%E4%BB%A4/image-20230420004906259.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="LDC"></p><h4 id="2、LDC指令"><a href="#2、LDC指令" class="headerlink" title="2、LDC指令"></a>2、LDC指令</h4><p>LDC指令的格式为：</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml">LDC</span><span class="hljs-template-variable">&#123;条件&#125;</span><span class="hljs-template-variable">&#123;L&#125;</span><span class="language-xml"> 协处理器编码,目的寄存器，[源寄存器]</span><br><span class="language-xml"></span><br></code></pre></td></tr></table></figure><p>LDC指令用于将源寄存器所指向的一系列连续的存储单元中的字数据传送到协处理器的寄存器中，若协处理器不能成功完成传送操作，则产生未定义指令异常。</p><p>其中，{L}选项表示指令为长读取操作，如用于双精度数据的传输。</p><p><img src="/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC3%E7%AB%A0-ARM%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F3-%E7%89%B9%E6%AE%8A%E6%8C%87%E4%BB%A4/image-20230420004933430.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="FAKE"></p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-symbol">LDC</span>  <span class="hljs-built_in">P3</span>，<span class="hljs-built_in">C4</span>，[<span class="hljs-built_in">R0</span>]     ；将<span class="hljs-meta">ARM</span>处理器的寄存器<span class="hljs-built_in">R0</span>所   指向的存储器中的字数据传送到协处理器<span class="hljs-built_in">P3</span>的寄存器<span class="hljs-built_in">C4</span>中<br></code></pre></td></tr></table></figure><p><img src="/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC3%E7%AB%A0-ARM%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F3-%E7%89%B9%E6%AE%8A%E6%8C%87%E4%BB%A4/image-20230420004950242.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="STC"></p><h4 id="3、STC指令"><a href="#3、STC指令" class="headerlink" title="3、STC指令"></a>3、STC指令</h4><p>STC指令的格式为</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml">STC</span><span class="hljs-template-variable">&#123;条件&#125;</span><span class="hljs-template-variable">&#123;L&#125;</span><span class="language-xml"> 协处理器编码,源寄存器，[目的寄存器]</span><br><span class="language-xml"></span><br></code></pre></td></tr></table></figure><p>STC指令用于将协处理器中的寄存器中的字数据传送到目的寄存器所指向一系列连续的存储单元中，若协处理器不能成功完成传送操作，则产生未定义指令异常。</p><p>其中，{L}选项表示指令为长读取操作，如用于双精度数据的传输。</p><p><img src="/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC3%E7%AB%A0-ARM%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F3-%E7%89%B9%E6%AE%8A%E6%8C%87%E4%BB%A4/image-20230420005014584.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="FAKE"></p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-symbol">STC</span>  <span class="hljs-built_in">P3</span>，<span class="hljs-built_in">C4</span>，[<span class="hljs-built_in">R0</span>] ；将协处理器<span class="hljs-built_in">P3</span>的寄存器<span class="hljs-built_in">C4</span>中的字    数据传送到<span class="hljs-meta">ARM</span>处理器的寄存器<span class="hljs-built_in">R0</span>所指向的存储器中。<br></code></pre></td></tr></table></figure><p><img src="/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC3%E7%AB%A0-ARM%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F3-%E7%89%B9%E6%AE%8A%E6%8C%87%E4%BB%A4/image-20230420005026961.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="MCP"></p><h4 id="4、MCR指令"><a href="#4、MCR指令" class="headerlink" title="4、MCR指令"></a>4、MCR指令</h4><p>MCR指令的格式为：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">MCR</span>&#123;条件&#125; 协处理器编码，协处理器操作码<span class="hljs-number">1</span>，源寄存器，目的寄存器<span class="hljs-number">1</span>，目的寄存器<span class="hljs-number">2</span>，协处理器操作码<span class="hljs-number">2</span><br><br></code></pre></td></tr></table></figure><p>MCR指令用于将ARM处理器寄存器中的数据传送到协处理器寄存器中,若协处理器不能成功完成操作，则产生未定义指令异常。</p><p>其中协处理器操作码1和协处理器操作码2为协处理器将要执行的操作，源寄存器为ARM处理器的寄存器，目的寄存器1和目的寄存器2均为协处理器的寄存器。</p><p><img src="/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC3%E7%AB%A0-ARM%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F3-%E7%89%B9%E6%AE%8A%E6%8C%87%E4%BB%A4/image-20230420005056518.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="FAKE"></p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-symbol">MCR</span>  <span class="hljs-built_in">P3</span>，<span class="hljs-number">3</span>，<span class="hljs-built_in">R0</span>，<span class="hljs-built_in">C4</span>，<span class="hljs-built_in">C5</span>，<span class="hljs-number">6</span>  ；该指令将<span class="hljs-meta">ARM</span>处理器寄存器<span class="hljs-built_in">R0</span>中的数据传送到协处理器<span class="hljs-built_in">P3</span>的寄存器<span class="hljs-built_in">C4</span>和<span class="hljs-built_in">C5</span>中<br></code></pre></td></tr></table></figure><p><img src="/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC3%E7%AB%A0-ARM%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F3-%E7%89%B9%E6%AE%8A%E6%8C%87%E4%BB%A4/image-20230420005109717.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="MRC"></p><h4 id="5、MRC指令"><a href="#5、MRC指令" class="headerlink" title="5、MRC指令"></a>5、MRC指令</h4><p>MRC指令的格式为：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">MRC</span>&#123;条件&#125; 协处理器编码，协处理器操作码<span class="hljs-number">1</span>，目的寄存器，源寄存器<span class="hljs-number">1</span>，源寄存器<span class="hljs-number">2</span>，协处理器操作码<span class="hljs-number">2</span><br><br></code></pre></td></tr></table></figure><p>MRC指令用于将协处理器寄存器中的数据传送到ARM处理器寄存器中,若协处理器不能成功完成操作，则产生未定义指令异常。</p><p>其中协处理器操作码1和协处理器操作码2为协处理器将要执行的操作，目的寄存器为ARM处理器的寄存器，源寄存器1和源寄存器2均为协处理器的寄存器。</p><p><img src="/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC3%E7%AB%A0-ARM%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F3-%E7%89%B9%E6%AE%8A%E6%8C%87%E4%BB%A4/image-20230420005137185.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="FAKE"></p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-keyword">MRC</span>   <span class="hljs-built_in">P3</span>，<span class="hljs-number">3</span>，<span class="hljs-built_in">R0</span>，<span class="hljs-built_in">C4</span>，<span class="hljs-built_in">C5</span>，<span class="hljs-number">6</span>    ；该指令将协处理器<span class="hljs-built_in">P3</span>的寄存器中的数据传送到<span class="hljs-meta">ARM</span>处理器寄存器中<br></code></pre></td></tr></table></figure><h3 id="3-3-10-异常产生指令"><a href="#3-3-10-异常产生指令" class="headerlink" title="3.3.10 异常产生指令"></a>3.3.10 异常产生指令</h3><p><img src="/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC3%E7%AB%A0-ARM%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F3-%E7%89%B9%E6%AE%8A%E6%8C%87%E4%BB%A4/image-20230420005201932.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="SWI"></p><h4 id="1、SWI指令"><a href="#1、SWI指令" class="headerlink" title="1、SWI指令"></a>1、SWI指令</h4><p>SWI指令的格式为：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">SWI</span>&#123;条件&#125; <span class="hljs-number">24</span>位的立即数<br></code></pre></td></tr></table></figure><p>SWI指令用于产生软件中断，以便用户程序能调用操作系统的系统例程。</p><p><strong>操作系统在SWI的异常处理程序中提供相应的系统服务，指令中24位的立即数指定用户程序调用系统例程的类型，相关参数通过通用寄存器传递。</strong></p><p><strong>当指令中24位的立即数被忽略时，用户程序调用系统例程的类型由通用寄存器P0的内容决定，同时，参数通过其他通用寄存器传递。</strong> </p><p><img src="/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC3%E7%AB%A0-ARM%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F3-%E7%89%B9%E6%AE%8A%E6%8C%87%E4%BB%A4/image-20230420005246347.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="SWI"></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">SWI</span>  <span class="hljs-number">0</span>x02   ；该指令调用操作系统编号位<span class="hljs-number">02</span>的系统例程。<br><br></code></pre></td></tr></table></figure><p>软件中断 (SWI)</p><p><img src="/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC3%E7%AB%A0-ARM%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F3-%E7%89%B9%E6%AE%8A%E6%8C%87%E4%BB%A4/image-20230420005304989.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="SWI"></p><ul><li>产生一个异常陷阱，跳转到SWI 硬件向量。</li><li>SWI 处理程序可以检测SWI号，从而决定采取何种操作。</li><li>通过SWI机制，运行在用户模式下的应用程序，可请求操作系统执行一系列特权操作。</li></ul><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs applescript">SWI&#123;&lt;cond&gt;&#125; &lt;SWI <span class="hljs-built_in">number</span>&gt;   ;SWI <span class="hljs-built_in">number</span> (ignored <span class="hljs-keyword">by</span> processor)<br><br></code></pre></td></tr></table></figure><p><img src="/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC3%E7%AB%A0-ARM%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F3-%E7%89%B9%E6%AE%8A%E6%8C%87%E4%BB%A4/image-20230420005340295.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="BKPT"></p><h4 id="2、BKPT指令"><a href="#2、BKPT指令" class="headerlink" title="2、BKPT指令"></a>2、BKPT指令</h4><p>BKPT指令的格式为：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">BKPT</span>   <span class="hljs-number">16</span>位的立即数<br></code></pre></td></tr></table></figure><p>BKPT指令产生软件断点中断，可用于程序的调试(现在使用图形化界面打断点更方便)</p><p><img src="/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC3%E7%AB%A0-ARM%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F3-%E7%89%B9%E6%AE%8A%E6%8C%87%E4%BB%A4/image-20230420005407687.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="FAKE"></p><h2 id="3-4-Thumb指令及应用"><a href="#3-4-Thumb指令及应用" class="headerlink" title="3.4 Thumb指令及应用"></a>3.4 Thumb指令及应用</h2><p>为兼容数据总线宽度为16位的应用系统，ARM体系结构除了支持执行效率很高的32位ARM指令集以外，同时支持16位的Thumb指令集。<strong>Thumb指令集是ARM指令集的一个子集</strong>，允许指令编码为16位的长度。与等价的32位代码相比较，Thumb指令集在保留32代码优势的同时，大大的节省了系统的存储空间。</p><p>所有的Thumb指令都有对应的ARM指令，而且Thumb的编程模型也对应于ARM的编程模型，在应用程序的编写过程中，只要遵循一定调用的规则，<strong>Thumb子程序和ARM子程序就可以互相调用</strong>。当处理器在执行ARM程序段时，称ARM处理器处于ARM工作状态，当处理器在执行Thumb程序段时，称ARM处理器处于Thumb工作状态。</p><p>与ARM指令集相比较，<strong>Thumb指令集中的数据处理指令的操作数仍然是32位</strong>，指令地址也为32位，但Thumb指令集为实现16位的指令长度，舍弃了ARM指令集的一些特性，如大多数的Thumb指令是无条件执行的，而几乎所有的ARM指令都是有条件执行的；大多数的Thumb数据处理指令的目的寄存器与其中一个源寄存器相同。</p><p>由于Thumb指令的长度为16位，即只用ARM指令一半的位数来实现同样的功能，所以，要实现特定的程序功能，所需的Thumb指令的条数较ARM指令多。在一般的情况下，Thumb指令与ARM指令的时间效率和空间效率关系为：</p><ul><li>Thumb代码所需的存储空间约为ARM代码的60％～70％</li><li>Thumb代码使用的指令数比ARM代码多约30％～40％</li><li>若使用32位的存储器，ARM代码比Thumb代码快约40％</li><li>若使用16位的存储器，Thumb代码比ARM代码快约40％～50％</li><li>与ARM代码相比较，使用Thumb代码，存储器的功耗会降低约30％</li></ul><p>显然，ARM指令集和Thumb指令集各有其优点，若对系统的性能有较高要求，应使用32位的存储系统和ARM指令集，若对系统的成本及功耗有较高要求，则应使用16位的存储系统和Thumb指令集。当然，若两者结合使用，充分发挥其各自的优点，会取得更好的效果。</p><p><img src="/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC3%E7%AB%A0-ARM%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F3-%E7%89%B9%E6%AE%8A%E6%8C%87%E4%BB%A4/image-20230420005552160.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="1"></p><p><img src="/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC3%E7%AB%A0-ARM%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F3-%E7%89%B9%E6%AE%8A%E6%8C%87%E4%BB%A4/image-20230420005613405.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="2"></p><p><img src="/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC3%E7%AB%A0-ARM%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F3-%E7%89%B9%E6%AE%8A%E6%8C%87%E4%BB%A4/image-20230420005618741.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="3"></p>]]></content>
    
    
    <categories>
      
      <category>学习资料</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ARM体系结构与编程</tag>
      
      <tag>课件笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机组成原理-L07-ppl</title>
    <link href="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L07-ppl/"/>
    <url>/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L07-ppl/</url>
    
    <content type="html"><![CDATA[<h1 id="计算机组成与实践-流水线（pipeline）"><a href="#计算机组成与实践-流水线（pipeline）" class="headerlink" title="计算机组成与实践 -流水线（pipeline）"></a><strong>计算机组成与实践</strong> -<strong>流水线（pipeline）</strong></h1><h2 id="一-流水线概述"><a href="#一-流水线概述" class="headerlink" title="一.流水线概述"></a>一.<strong>流水线概述</strong></h2><h4 id="回顾：单时钟周期实现"><a href="#回顾：单时钟周期实现" class="headerlink" title="回顾：单时钟周期实现"></a><strong>回顾：单时钟周期实现</strong></h4><p>假设我们只关注指令运行中的：取指令、读寄存器、ALU运算、访问数据存储器、写回寄存器：</p><ul><li>访问指令和数据存储器：4ns</li><li>ALU和加法器：2ns</li><li>访问寄存器：1ns</li></ul><table><thead><tr><th><strong>指令类型</strong></th><th><strong>取指令</strong></th><th><strong>读寄存器</strong></th><th>ALU运算</th><th><strong>访问数据存储器</strong></th><th><strong>写回寄存器</strong></th><th><strong>时间</strong></th></tr></thead><tbody><tr><td>R型</td><td>4</td><td>1</td><td>2</td><td>0</td><td>1</td><td>8</td></tr><tr><td>lw</td><td>4</td><td>1</td><td>2</td><td>4</td><td>1</td><td><strong>12</strong></td></tr><tr><td>sw</td><td>4</td><td>1</td><td>2</td><td>4</td><td>0</td><td>11</td></tr><tr><td>beq</td><td>4</td><td>1</td><td>2</td><td>0</td><td>0</td><td>7</td></tr><tr><td>j</td><td>4</td><td>0</td><td>0</td><td>0</td><td>0</td><td>4</td></tr></tbody></table><h4 id="单时钟周期设计的优缺点"><a href="#单时钟周期设计的优缺点" class="headerlink" title="单时钟周期设计的优缺点"></a><strong>单时钟周期设计的优缺点</strong></h4><p>☺：实现简单，易于理解</p><p>😞：</p><ul><li>最长延迟决定时钟周期<ul><li>关键路径：取数指令</li><li>指令存储器-&gt;寄存器堆-&gt;ALU-&gt;数据存储器-&gt;寄存器堆</li></ul></li><li>违背设计原则：加速大概率事件</li></ul><table><thead><tr><th><strong>解决方法：流水线</strong></th></tr></thead><tbody><tr><td>现代处理器几乎都采用流水线实现性能的提升</td></tr><tr><td>理想情况下，流水线的加速比是流水线的级数，例如5级流水线加速比接近于5</td></tr><tr><td>加速比得益于吞吐量</td></tr></tbody></table><h4 id="流水线概述"><a href="#流水线概述" class="headerlink" title="流水线概述"></a><strong>流水线概述</strong></h4><p>洗衣房问题（采用流水线技术）：重叠进行</p><ul><li>并行性提升性能</li><li>4个任务<ul><li>加速比&#x3D;8&#x2F;3.5&#x3D;2.3</li></ul></li><li>任务足够多<ul><li>加速比&#x3D;2n&#x2F;0.5n&#x3D;4</li><li>&#x3D;stage的数量</li></ul></li></ul><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L07-ppl/image-20230411124350418.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="流水线"></p><h4 id="MIPS流水线"><a href="#MIPS流水线" class="headerlink" title="MIPS流水线"></a><strong>MIPS流水线</strong></h4><p>五个阶段，每个阶段一个步骤</p><ul><li><ol><li>**取指(IF)**：从指令存储器取指令</li></ol></li><li><ol start="2"><li>**译码(ID)**：译码并读寄存器堆</li></ol></li><li><ol start="3"><li>**执行(EX)**：执行运算或计算地址</li></ol></li><li><ol start="4"><li>**访存(MEM)**：访问（读取&#x2F;写数据）存储器</li></ol></li><li><ol start="5"><li>**写回(WB)**：将结果写回寄存器堆</li></ol></li></ul><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L07-ppl/image-20230411124441758.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="流水线"></p><blockquote><p><strong>最长的执行阶段决定时钟周期时间</strong></p></blockquote><h4 id="流水线性能"><a href="#流水线性能" class="headerlink" title="流水线性能"></a><strong>流水线性能</strong></h4><ul><li>假设每个阶段的执行时间<ul><li>读写寄存器堆：100ps</li><li>其他阶段：200ps</li></ul></li><li>比较流水线指令执行与单周期指令执行</li></ul><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L07-ppl/image-20230411125758798.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="流水线性能，上为单周期下为低周期"></p><h4 id="面向流水线的指令集设计"><a href="#面向流水线的指令集设计" class="headerlink" title="面向流水线的指令集设计"></a><strong>面向流水线的指令集设计</strong></h4><ul><li>MIPS指令集</li><li>所有指令长度相同，都是32bit<ul><li>单时钟周期内可以取得指令</li></ul></li><li>指令格式少，格式类似<ul><li>可以一步完成译码和读寄存器</li></ul></li><li>只有存&#x2F;取指令涉及到存储器访问<ul><li>可以利用ALU计算地址，并在第4级访问存储器</li></ul></li><li>所有操作数在存储器中对齐<ul><li>数据访问只需要一个时钟周期</li></ul></li></ul><h2 id="二-流水线数据通路及其控制"><a href="#二-流水线数据通路及其控制" class="headerlink" title="二.流水线数据通路及其控制"></a>二.<strong>流水线数据通路及其控制</strong></h2><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L07-ppl/image-20230411130038408.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="流水线数据通路"></p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs routeros">lw  <span class="hljs-variable">$10</span>,20(<span class="hljs-variable">$1</span>)<br>sub <span class="hljs-variable">$11</span>,<span class="hljs-variable">$2</span>,<span class="hljs-variable">$3</span><br><span class="hljs-built_in">add</span> <span class="hljs-variable">$12</span>,<span class="hljs-variable">$3</span>,<span class="hljs-variable">$4</span><br>lw  <span class="hljs-variable">$13</span>,24(<span class="hljs-variable">$1</span>)<br><span class="hljs-built_in">add</span> <span class="hljs-variable">$14</span>,<span class="hljs-variable">$5</span>,<span class="hljs-variable">$6</span><br></code></pre></td></tr></table></figure><p><strong>上升沿触发</strong></p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L07-ppl/image-20230411130642864.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="流水"></p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L07-ppl/image-20230411130714019.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="cyc2"></p><p><strong>在流水线各级间加入状态单元——流水线寄存器</strong></p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L07-ppl/image-20230411130840653.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="流水线寄存器"></p><p><strong>流水线中的指令执行（0 CC）</strong></p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L07-ppl/image-20230411131345827.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="0cc"></p><p><strong>流水线中的指令执行（1 CC）</strong></p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L07-ppl/image-20230411131432740.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="1cc"></p><p><strong>流水线中的指令执行（2 CC）</strong></p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L07-ppl/image-20230411131455478.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="2cc"></p><p><strong>流水线中的指令执行（3 CC）</strong></p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L07-ppl/image-20230411131552267.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="3CC"></p><p><strong>流水线中的指令执行（4 CC）</strong></p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L07-ppl/image-20230411131635211.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="4CC"></p><p><strong>流水线中的指令执行（5 CC）</strong></p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L07-ppl/image-20230411131725492.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="5CC"></p><p><strong>正确的流水线数据通路</strong></p><p>指令的信息随着指令执行在流水线寄存器中保存</p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L07-ppl/image-20230411131809712.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="RIGHT"></p><h4 id="流水线控制"><a href="#流水线控制" class="headerlink" title="流水线控制"></a><strong>流水线控制</strong></h4><ul><li>所有控制信号可以在译码阶段（ID）生成<ul><li>将控制信号沿着流水线状态寄存器传递</li></ul></li></ul><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L07-ppl/image-20230411132101226.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="控制信号"></p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L07-ppl/image-20230411132129492.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="complex"></p><table><thead><tr><th></th><th><strong>EX</strong></th><th></th><th></th><th></th><th><strong>MEM</strong></th><th></th><th></th><th><strong>WB</strong></th><th></th></tr></thead><tbody><tr><td></td><td>Reg  Dst</td><td>ALU  Op1</td><td>ALU  Op0</td><td>ALU  Src</td><td>Brch</td><td>Mem  Read</td><td>Mem  Write</td><td>Reg  Write</td><td>Mem  toReg</td></tr><tr><td>R</td><td>1</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td></tr><tr><td>lw</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>1</td><td>0</td><td>1</td><td>1</td></tr><tr><td>sw</td><td>X</td><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td><td>1</td><td>0</td><td>X</td></tr><tr><td>beq</td><td>X</td><td>0</td><td>1</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td><td>X</td></tr></tbody></table><h4 id="流水线操作"><a href="#流水线操作" class="headerlink" title="流水线操作"></a><strong>流水线操作</strong></h4><p>每个时钟周期，所有指令都会沿着流水线的数据通路从一个流水线寄存器传递到下一个流水线寄存器</p><ul><li>单时钟周期（Single-clock-cycle）流水线图<ul><li>显示单个时钟周期的流水线使用情况</li><li>着重显示使用的部件</li></ul></li><li>多时钟周期（multi-clock-cycle）流水线图<ul><li>随着时间的变化，展示执行的操作的图</li></ul></li></ul><h4 id="单时钟周期流水线图"><a href="#单时钟周期流水线图" class="headerlink" title="单时钟周期流水线图"></a><strong>单时钟周期流水线图</strong></h4><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L07-ppl/image-20230411132519176.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="single"></p><h4 id="多时钟周期流水线图"><a href="#多时钟周期流水线图" class="headerlink" title="多时钟周期流水线图"></a><strong>多时钟周期流水线图</strong></h4><p>展示流水线中部件的使用情况</p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L07-ppl/image-20230411132637684.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="部件"></p><h2 id="三-流水线冒险"><a href="#三-流水线冒险" class="headerlink" title="三.流水线冒险"></a>三.<strong>流水线冒险</strong></h2><p><strong>流水线冒险</strong></p><p><strong>流水线每个时钟周期都可以执行一条指令吗？</strong></p><table><thead><tr><th><strong>流水线冒险（Pipeline Hazards）</strong></th></tr></thead><tbody><tr><td>现流水线在下一个时钟周期不能执行下一条指令的情况</td></tr></tbody></table><ul><li>结构冒险（Structural Hazard ）</li><li>数据冒险（Data Hazard）</li><li>控制冒险（Control Hazard）</li></ul><p><strong>检测出冒险，解决冒险带来的问题</strong></p><h3 id="☆结构冒险"><a href="#☆结构冒险" class="headerlink" title="☆结构冒险"></a>☆<strong>结构冒险</strong></h3><p>缺乏硬件导致的冒险</p><p>1.MIPS流水线中的存储器使用冲突</p><ul><li>取指令需要访问存储器</li><li>数据传输指令lw和sw需要访问存储器</li></ul><p>2.寄存器的访问冲突</p><ul><li>同一个时钟周期内，需要读和写寄存器</li></ul><p>对指令与数据，采用分开的L1缓存</p><ul><li>Icache和Dcache</li></ul><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L07-ppl/image-20230411133330625.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="解决结构冒险1"></p><p>时钟的前半部分进行写，时钟的后半部分进行读</p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L07-ppl/image-20230411133508942.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="解决结构冒险2"></p><h3 id="☆数据冒险"><a href="#☆数据冒险" class="headerlink" title="☆数据冒险"></a>☆<strong>数据冒险</strong></h3><p>无法提供指令执行所需要的数据，即需要等待前面某些指令执行完数据的读写</p><p>1.寄存器导致的数据冒险</p><ul><li>一条指令的操作数来源于前面的某条指令</li></ul><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">add</span>$<span class="hljs-built_in">s0</span>, $<span class="hljs-built_in">t0</span>, $<span class="hljs-built_in">t1</span><br><span class="hljs-keyword">sub</span>$<span class="hljs-built_in">t2</span>, $<span class="hljs-built_in">s0</span>, $<span class="hljs-built_in">t3</span><br></code></pre></td></tr></table></figure><p>2.取数-使用型数据冒险</p><ul><li>在数据需要使用时，数据还没有从存储器读出</li></ul><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">lw</span>$<span class="hljs-built_in">s0</span>, <span class="hljs-number">20</span>($<span class="hljs-built_in">t1</span>)<br><span class="hljs-keyword">sub</span>$<span class="hljs-built_in">t2</span>, $<span class="hljs-built_in">s0</span>, $<span class="hljs-built_in">t3</span><br></code></pre></td></tr></table></figure><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L07-ppl/image-20230411133824610.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="冒险"></p><h4 id="☆旁路"><a href="#☆旁路" class="headerlink" title="☆旁路"></a>☆<strong>旁路</strong></h4><p><strong>解决数据冒险1：旁路</strong></p><table><thead><tr><th><strong>前推（Forwarding）</strong></th></tr></thead><tbody><tr><td>在EX级产生结果之后马上发送给下一条指令</td></tr></tbody></table><ul><li>旁路（bypassing）：建立额外的数据通路连接ALU的输出到输入</li><li>不需要等到结果写回到寄存器</li></ul><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L07-ppl/image-20230411134104446.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="forwarding"></p><h5 id="数据依赖"><a href="#数据依赖" class="headerlink" title="数据依赖"></a><strong>数据依赖</strong></h5><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs routeros">sub  <span class="hljs-variable">$2</span>, <span class="hljs-variable">$1</span>, <span class="hljs-variable">$3</span><br><span class="hljs-keyword">and</span>  <span class="hljs-variable">$12</span>, <span class="hljs-variable">$2</span>, <span class="hljs-variable">$5</span><br><span class="hljs-keyword">or</span>   <span class="hljs-variable">$13</span>, <span class="hljs-variable">$6</span>, <span class="hljs-variable">$2</span><br><span class="hljs-built_in">add</span>  <span class="hljs-variable">$14</span>, <span class="hljs-variable">$2</span>, <span class="hljs-variable">$2</span><br>sw   <span class="hljs-variable">$15</span>, 100(<span class="hljs-variable">$2</span>)<br></code></pre></td></tr></table></figure><p><strong>是否都会出现数据冒险？如何检测出这类数据冒险？</strong></p><p><strong>数据依赖与旁路</strong></p><h5 id=""><a href="#" class="headerlink" title=""></a><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L07-ppl/image-20230411134349134.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="旁路"></h5><h5 id="检测数据冒险"><a href="#检测数据冒险" class="headerlink" title="检测数据冒险"></a><strong>检测数据冒险</strong></h5><ul><li>使用流水线寄存器字段<ul><li>ID&#x2F;EX.RegisterRs：表示一个需要流水线寄存器ID&#x2F; EX 获得的源寄存器号</li></ul></li><li>在EX级的ALU操作的两个寄存器号为：<ul><li>ID&#x2F;EX.RegisterRs, ID&#x2F;EX.RegisterRt</li></ul></li><li>当满足下列条件时会出现数据冒险：</li></ul><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-number">1</span>a. EX<span class="hljs-regexp">/MEM.RegisterRd = ID/</span>EX.RegisterRs<br><br><span class="hljs-number">1</span>b. EX<span class="hljs-regexp">/MEM.RegisterRd = ID/</span>EX.RegisterRt<br><br><span class="hljs-number">2</span>a. MEM<span class="hljs-regexp">/WB.RegisterRd = ID/</span>EX.RegisterRs<br><br><span class="hljs-number">2</span>b. MEM<span class="hljs-regexp">/WB.RegisterRd = ID/</span>EX.RegisterRt<br></code></pre></td></tr></table></figure><ul><li>只有需要写回寄存器的指令才需要旁路<ul><li>EX&#x2F;MEM.RegWrite, MEM&#x2F;WB.RegWrite</li></ul></li><li>目的寄存器不能是$0</li></ul><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">EX</span>/MEM.RegisterRd ≠ <span class="hljs-number">0</span>,<br><span class="hljs-attribute">MEM</span>/WB.RegisterRd ≠ <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><h5 id="旁路的数据通路"><a href="#旁路的数据通路" class="headerlink" title="旁路的数据通路"></a><strong>旁路的数据通路</strong></h5><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L07-ppl/image-20230411134648154.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="旁路datapath"></p><h5 id="旁路多选器的控制信号"><a href="#旁路多选器的控制信号" class="headerlink" title="旁路多选器的控制信号"></a><strong>旁路多选器的控制信号</strong></h5><table><thead><tr><th>Mux  control</th><th>Source</th><th>Explanation</th></tr></thead><tbody><tr><td>ForwardA &#x3D; 00</td><td>ID&#x2F;EX</td><td>第一个ALU操作数来自寄存器堆</td></tr><tr><td>ForwardA  &#x3D; 10</td><td>EX&#x2F;MEM</td><td>第一个ALU操作数由上一个ALU运算结果旁路获得</td></tr><tr><td>ForwardA  &#x3D; 01</td><td>MEM&#x2F;WB</td><td>第一个ALU 操作数从数据存储器或者往前数第二条指令的ALU 结果中旁路获得</td></tr><tr><td>ForwardB  &#x3D; 00</td><td>ID&#x2F;EX</td><td>第二个ALU 操作数来自寄存器堆</td></tr><tr><td>ForwardB  &#x3D; 10</td><td>EX&#x2F;MEM</td><td>第二个ALU 拱作做由上一个ALU 运算结果旁路获得</td></tr><tr><td>ForwardB  &#x3D; 01</td><td>MEM&#x2F;WB</td><td>第二个ALU 操作般由数据存储器或者往前数第二条指令的ALU 结果旁路获得</td></tr></tbody></table><h5 id="旁路条件"><a href="#旁路条件" class="headerlink" title="旁路条件"></a><strong>旁路条件</strong></h5><p><strong>EX</strong> <strong>冒险</strong></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-keyword">if</span> (EX<span class="hljs-regexp">/MEM.RegWrite and (EX/</span>MEM.RegisterRd ≠ <span class="hljs-number">0</span>)<br><br> and (EX<span class="hljs-regexp">/MEM.RegisterRd = ID/</span>EX.RegisterRs)) ForwardA = <span class="hljs-number">10</span><br><br><span class="hljs-keyword">if</span> (EX<span class="hljs-regexp">/MEM.RegWrite and (EX/</span>MEM.RegisterRd ≠ <span class="hljs-number">0</span>)<br><br> and (EX<span class="hljs-regexp">/MEM.RegisterRd = ID/</span>EX.RegisterRt)) ForwardB = <span class="hljs-number">10</span><br></code></pre></td></tr></table></figure><p><strong>MEM</strong> <strong>冒险</strong></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-keyword">if</span> (MEM<span class="hljs-regexp">/WB.RegWrite and (MEM/</span>WB.RegisterRd ≠ <span class="hljs-number">0</span>)<br><br> and (MEM<span class="hljs-regexp">/WB.RegisterRd = ID/</span>EX.RegisterRs)) ForwardA = <span class="hljs-number">01</span><br><br><span class="hljs-keyword">if</span> (MEM<span class="hljs-regexp">/WB.RegWrite and (MEM/</span>WB.RegisterRd ≠ <span class="hljs-number">0</span>)<br><br> and (MEM<span class="hljs-regexp">/WB.RegisterRd = ID/</span>EX.RegisterRt)) ForwardB= <span class="hljs-number">01</span><br></code></pre></td></tr></table></figure><h5 id="两种冒险"><a href="#两种冒险" class="headerlink" title="两种冒险"></a><strong>两种冒险</strong></h5><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L07-ppl/image-20230411135250916.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="2"></p><h5 id="潜在数据冒险"><a href="#潜在数据冒险" class="headerlink" title="潜在数据冒险"></a><strong>潜在数据冒险</strong></h5><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">add</span> <span class="hljs-variable">$1</span>, <span class="hljs-variable">$1</span>, <span class="hljs-variable">$2</span><br><span class="hljs-built_in">add</span> <span class="hljs-variable">$1</span>, <span class="hljs-variable">$1</span>, <span class="hljs-variable">$3</span><br><span class="hljs-built_in">add</span> <span class="hljs-variable">$1</span>, <span class="hljs-variable">$1</span>, <span class="hljs-variable">$4</span><br></code></pre></td></tr></table></figure><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L07-ppl/image-20230411135445805.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="潜在数据冒险"></p><ul><li>两类数据冒险都会发生：<ul><li>MEM级的数据是最新结果，使用MEM级数据进行旁路</li></ul></li><li>更改MEM冒险的条件<ul><li>EX冒险的条件不成立时</li></ul></li></ul><h5 id="更改后的旁路条件"><a href="#更改后的旁路条件" class="headerlink" title="更改后的旁路条件"></a><strong>更改后的旁路条件</strong></h5><p><strong>MEM冒险</strong></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-keyword">if</span> (MEM/WB<span class="hljs-selector-class">.RegWrite</span><br>and (MEM/WB<span class="hljs-selector-class">.RegisterRd</span> ≠ <span class="hljs-number">0</span>)<br>and <span class="hljs-built_in">not</span>(EX/MEM<span class="hljs-selector-class">.RegWrite</span> and (EX/MEM<span class="hljs-selector-class">.RegisterRd</span> ≠ <span class="hljs-number">0</span>)<br>and (EX/MEM<span class="hljs-selector-class">.RegisterRd</span> ≠ ID/EX.RegisterRs))<br>and (MEM/WB<span class="hljs-selector-class">.RegisterRd</span> = ID/EX.RegisterRs)) ForwardA = <span class="hljs-number">01</span><br><span class="hljs-keyword">if</span> (MEM/WB<span class="hljs-selector-class">.RegWrite</span><br>and (MEM/WB<span class="hljs-selector-class">.RegisterRd</span> ≠ <span class="hljs-number">0</span>)<br>and <span class="hljs-built_in">not</span>(EX/MEM<span class="hljs-selector-class">.RegWrite</span> and (EX/MEM<span class="hljs-selector-class">.RegisterRd</span> ≠ <span class="hljs-number">0</span>)<br>and (EX/MEM<span class="hljs-selector-class">.RegisterRd</span> ≠ ID/EX.RegisterRt))<br>and (MEM/WB<span class="hljs-selector-class">.RegisterRd</span> = ID/EX.RegisterRt)) ForwardB = <span class="hljs-number">01</span><br></code></pre></td></tr></table></figure><h4 id="☆阻塞"><a href="#☆阻塞" class="headerlink" title="☆阻塞"></a>☆<strong>阻塞</strong></h4><h5 id="解决数据冒险2：阻塞"><a href="#解决数据冒险2：阻塞" class="headerlink" title="解决数据冒险2：阻塞"></a><strong>解决数据冒险2：阻塞</strong></h5><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L07-ppl/image-20230411135824830.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="阻塞"></p><ul><li>即使使用旁路也不能消除冒险</li><li>必须让流水线阻塞一个时钟周期</li></ul><p><strong>怎样阻塞流水线？</strong></p><h5 id="空指令"><a href="#空指令" class="headerlink" title="空指令"></a><strong>空指令</strong></h5><table><thead><tr><th><strong>空指令（nop）</strong></th></tr></thead><tbody><tr><td>一种不进行任何操作或不改变任何状态的指令</td></tr></tbody></table><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L07-ppl/image-20230411140049276.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="NOP"></p><p><strong>需要在译码（ID）阶段检测出！</strong></p><h5 id="取数使用型数据冒险检测"><a href="#取数使用型数据冒险检测" class="headerlink" title="取数使用型数据冒险检测"></a><strong>取数使用型数据冒险检测</strong></h5><ul><li><p>ALU操作数寄存器号可以在ID级获得：</p><ul><li>IF&#x2F;ID.RegisterRs, IF&#x2F;ID.RegisterRt</li></ul></li><li><p>取数使用型冒险发生条件：</p><ul><li>ID&#x2F;EX.MemRead</li></ul><p> and ((ID&#x2F;EX.RegisterRd &#x3D; IF&#x2F;ID.RegisterRs)<br> or (ID&#x2F;EX.RegisterRd &#x3D; IF&#x2F;ID.RegisterRt))</p></li><li><p>如果检测到冒险发生，阻塞流水线一个时钟周期</p></li></ul><h5 id="如何阻塞流水线"><a href="#如何阻塞流水线" class="headerlink" title="如何阻塞流水线"></a><strong>如何阻塞流水线</strong></h5><ul><li>将ID&#x2F;EX寄存器中的控制信号置为0（nop指令）<ul><li>EX，MEM，WB级不进行操作</li></ul></li><li>阻止PC和IF&#x2F;ID寄存器更新<ul><li>正在运行的指令重复译码</li><li>重复提取下一条指令</li><li>阻塞一个时钟周期可以让取数操作取得数据，接下来可以旁路到EX级</li></ul></li></ul><h5 id="冒险检测的数据通路"><a href="#冒险检测的数据通路" class="headerlink" title="冒险检测的数据通路"></a><strong>冒险检测的数据通路</strong></h5><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L07-ppl/image-20230411140616534.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="DATAPATH"></p><h5 id="阻塞与性能"><a href="#阻塞与性能" class="headerlink" title="阻塞与性能"></a><strong>阻塞与性能</strong></h5><ul><li>阻塞降低性能<ul><li>为了获得正确的结果，需要阻塞</li></ul></li><li>编译器可以通过调整指令执行顺序减少冒险和阻塞<ul><li>需要了解流水线结构</li></ul></li></ul><h5 id="编译器优化：指令调度避免阻塞"><a href="#编译器优化：指令调度避免阻塞" class="headerlink" title="编译器优化：指令调度避免阻塞"></a><strong>编译器优化：指令调度避免阻塞</strong></h5><p>改变指令顺序，避免产生取数-使用型数据冒险</p><p>C代码：A&#x3D;B+E；</p><p>​        C&#x3D;B+F；</p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L07-ppl/image-20230411141244615.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="优化"></p><h3 id="☆控制冒险"><a href="#☆控制冒险" class="headerlink" title="☆控制冒险"></a>☆<strong>控制冒险</strong></h3><p>分支冒险（branch hazard），指令执行不是顺序执行，即下一条指令的地址不是PC+4，而是依赖于正在执行的指令</p><ul><li>无条件分支（j、jal、jr）</li><li>条件分支（beq、bne）</li><li>异常</li></ul><p>解决方案：</p><ul><li>阻塞：影响性能</li><li>提前产生分支结果：需要额外的硬件</li><li>延迟分支决策：需要编译器的支持</li><li>分支预测（ Branch Prediction ）</li></ul><h4 id="控制冒险1：跳转"><a href="#控制冒险1：跳转" class="headerlink" title="控制冒险1：跳转"></a><strong>控制冒险1：跳转</strong></h4><ul><li>假定分支不发生</li><li>跳转指令在译码阶段（ID）才能得到跳转地址，需要清除流水线</li></ul><table><thead><tr><th><strong>清除（FLUSH）</strong></th></tr></thead><tbody><tr><td>因发生了意外而丢弃流水线中的指令</td></tr></tbody></table><p>用IF.Flush将IF&#x2F;ID流水线寄存器中的指令置为空指令</p><h4 id="支持ID级跳转的数据通路"><a href="#支持ID级跳转的数据通路" class="headerlink" title="支持ID级跳转的数据通路"></a><strong>支持ID级跳转的数据通路</strong></h4><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L07-ppl/image-20230411142031984.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="ID跳转"></p><h4 id="控制冒险2：条件分支"><a href="#控制冒险2：条件分支" class="headerlink" title="控制冒险2：条件分支"></a><strong>控制冒险2：条件分支</strong></h4><p>分支结果在MEM级获得</p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L07-ppl/image-20230411142515324.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="条件分支"></p><h4 id="解决控制冒险2：等待分支结果"><a href="#解决控制冒险2：等待分支结果" class="headerlink" title="解决控制冒险2：等待分支结果"></a><strong>解决控制冒险2：等待分支结果</strong></h4><p>分支结果在MEM级获得</p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L07-ppl/image-20230411142704449.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="分支结果"></p><h4 id="解决控制冒险2：提前计算分支结果"><a href="#解决控制冒险2：提前计算分支结果" class="headerlink" title="解决控制冒险2：提前计算分支结果"></a><strong>解决控制冒险2：提前计算分支结果</strong></h4><p>将生成分支结果的硬件放在ID级</p><ul><li>目的地址加法器</li><li>寄存器比较器</li></ul><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L07-ppl/image-20230411142806090.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="提前分支"></p><h4 id="ID级生成分支结果"><a href="#ID级生成分支结果" class="headerlink" title="ID级生成分支结果"></a><strong>ID级生成分支结果</strong></h4><p>计算分支目标地址</p><ul><li>将分支地址计算电路从EX级移到ID级</li></ul><p>判断分支条件</p><ul><li>决定是否将数据旁路到相等检测单元进行检测（beq、bnq）</li><li>可能发生数据冒险，需要阻塞流水线<ul><li>分支指令前是R型指令，计算的结果是分支指令的源操作数，发生一个阻塞</li><li>分支指令前是lw指令，载入的数据是分支指令的源操作数，发生两个阻塞</li></ul></li></ul><h4 id="ID级分支旁路问题"><a href="#ID级分支旁路问题" class="headerlink" title="ID级分支旁路问题"></a><strong>ID级分支旁路问题</strong></h4><p>分支指令beq的操作数是需要写回的数据</p><p> 需要将MEM&#x2F;WB寄存器的数据旁路到ID级的比较硬件</p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L07-ppl/image-20230411143139271.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="1"></p><p>需要将EX&#x2F;MEM寄存器的数据旁路到ID级的比较硬件</p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L07-ppl/image-20230411173544869.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="2"></p><h4 id="旁路条件-1"><a href="#旁路条件-1" class="headerlink" title="旁路条件"></a><strong>旁路条件</strong></h4><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs smali">EX 冒险<span class="hljs-built_in"></span><br><span class="hljs-built_in">if </span>(IDcontrol.Branch <span class="hljs-built_in"> and </span>(EX/MEM.RegisterRd != 0)<br>   <span class="hljs-built_in"> and </span>(EX/MEM.RegisterRd == IF/ID.RegisterRs)   ForwardC = 10<span class="hljs-built_in"></span><br><span class="hljs-built_in">if </span>(IDcontrol.Branch<span class="hljs-built_in"> and </span>(EX/MEM.RegisterRd != 0)<br>   <span class="hljs-built_in"> and </span>(EX/MEM.RegisterRd == IF/ID.RegisterRt)    ForwardD = 10<br>MEM 冒险<span class="hljs-built_in"></span><br><span class="hljs-built_in">if </span>(IDcontrol.Branch <span class="hljs-built_in"> and </span>(EX/MEM.RegisterRd != 0)<br>   <span class="hljs-built_in"> and </span>(EX/MEM.RegisterRd == IF/ID.RegisterRs)   ForwardC = 01<span class="hljs-built_in"></span><br><span class="hljs-built_in">if </span>(IDcontrol.Branch<span class="hljs-built_in"> and </span>(EX/MEM.RegisterRd != 0)<br>   <span class="hljs-built_in"> and </span>(EX/MEM.RegisterRd == IF/ID.RegisterRt)    ForwardD = 01<br></code></pre></td></tr></table></figure><h4 id="支持ID级分支的数据通路"><a href="#支持ID级分支的数据通路" class="headerlink" title="支持ID级分支的数据通路"></a><strong>支持ID级分支的数据通路</strong></h4><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L07-ppl/image-20230411173619957.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="ID分支"></p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L07-ppl/image-20230411173733329.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="放大"></p><h4 id="编译器优化：延迟分支"><a href="#编译器优化：延迟分支" class="headerlink" title="编译器优化：延迟分支"></a><strong>编译器优化：延迟分支</strong></h4><table><thead><tr><th><strong>延迟分支</strong></th></tr></thead><tbody><tr><td>MIPS编译器将一条指令I移到分支指令之后，可以延迟分支目的指令的执行，从而隐藏分支延迟</td></tr></tbody></table><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L07-ppl/image-20230411173849423.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="调度"></p><p>方案A最佳，分支发生概率大时选择方案B（循环），分支不发生概率大时选择C </p><h4 id="动态分支预测"><a href="#动态分支预测" class="headerlink" title="动态分支预测"></a><strong>动态分支预测</strong></h4><ul><li>流水线级数的增加，预测错误的代价增加</li><li>静态分支预测是粗略的预测方法</li><li>动态分支预测<ul><li>分支预测缓存（Branch prediction buffer ）或分支历史记录表（branch history table）</li><li>分支指令的地址低位索引</li><li>存储分支结果（taken&#x2F;not taken）</li></ul></li><li>执行分支<ul><li>查表，预测的结果与上次分支结果一样</li><li>按照预测结果取指令</li><li>如果出错，清洗流水线并重新提取正确的指令</li><li>将表中预测结果取反</li></ul></li></ul><h4 id="1位预测器"><a href="#1位预测器" class="headerlink" title="1位预测器"></a><strong>1位预测器</strong></h4><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L07-ppl/image-20230411174042760.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="预测器"></p><p>内层循环至少两次预测错误</p><ul><li>最后一次预测会出错：前面分支都是发生的，最后一次不发生</li><li>第一次预测会出错：上一次的预测不发生，跳出内层循环之后，再次进入内层循环也会预测不发生</li></ul><p><strong>2位预测器</strong></p><p>只有连续两次预测错误时才会改变预测结果</p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L07-ppl/image-20230411174119194.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="2bit"></p><h4 id="计算分支目标地址"><a href="#计算分支目标地址" class="headerlink" title="计算分支目标地址"></a><strong>计算分支目标地址</strong></h4><ul><li>结合分支预测器，需要计算分支目标地址<ul><li>分支发生会产生1个时钟周期的开销</li></ul></li><li>延迟分支</li><li>分支目标缓存（Branch target buffer）<ul><li>缓存分支目标地址</li><li>取指令时，由PC中的地址索引<ul><li>如果预测正确，并且分支指令发生，可以直接提取到分支目标地址</li></ul></li></ul></li></ul><h2 id="四-异常"><a href="#四-异常" class="headerlink" title="四.异常"></a>四.<strong>异常</strong></h2><table><thead><tr><th><strong>异常</strong></th></tr></thead><tbody><tr><td>指打断程序正常执行的突发事件，会改变指令执行顺序</td></tr></tbody></table><ul><li>异常（exceptions）<ul><li>产生原因可能来自处理器内部或者外部</li><li>例如，使用未定义的指令，算术溢出，系统调用</li><li>与程序执行同步，必须停止随后的指令在流水线中运行</li></ul></li><li>中断（Interrupt）<ul><li>由处理器外部引起的事件</li><li>例如I&#x2F;O设备请求</li><li>与程序执行不同步，可以等流水线中指令执行结束再处理</li></ul></li><li>处理异常和中断会牺牲系统性能</li></ul><h4 id="流水线中的异常"><a href="#流水线中的异常" class="headerlink" title="流水线中的异常"></a><strong>流水线中的异常</strong></h4><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L07-ppl/image-20230411174307635.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="流水线"></p><table><thead><tr><th></th><th><strong>发生的流水级</strong></th><th><strong>是否同步</strong></th></tr></thead><tbody><tr><td>算术溢出</td><td>EX</td><td>是</td></tr><tr><td>未定义的指令</td><td>ID</td><td>是</td></tr><tr><td>TLB或页缺失</td><td>IF，MEM</td><td>是</td></tr><tr><td>I&#x2F;O设备请求</td><td>全部</td><td>否</td></tr><tr><td>硬件故障</td><td>全部</td><td>否</td></tr></tbody></table><p><strong>多种异常可能同时发生</strong></p><h4 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a><strong>异常处理</strong></h4><ul><li>保存出错指令的地址<ul><li>异常程序计数器(Exception Program Counter，EPC)</li></ul></li><li>保存引起异常的原因<ul><li>状态寄存器（Cause寄存器）</li><li>MIPS体系结构中是32 bits</li><li>一个字段用于记录异常产生的原因，例如未定义指令&#x3D;10，算术溢出&#x3D;12</li></ul></li><li>向量中断（vectored interrupt）<ul><li>未定义指令-&gt;8000 0000（16进制），算术溢出-&gt;8000 0180（16）</li></ul></li></ul><table><thead><tr><th><strong>向量中断</strong></th></tr></thead><tbody><tr><td>由异常原因决定中断控制转移地址的中断</td></tr></tbody></table><h4 id="异常处理操作"><a href="#异常处理操作" class="headerlink" title="异常处理操作"></a><strong>异常处理操作</strong></h4><ul><li>读取异常或中断原因，找到相应的处理程序</li><li>决定需要的处理操作</li><li>如果可以处理，最后要重新启动程序<ul><li>执行相应处理操作</li><li>使用EPC返回程序继续执行</li></ul></li><li>如果不能处理<ul><li>结束程序</li><li>用EPC和cause寄存器报告错误</li></ul></li></ul><h4 id="流水线实现中的异常"><a href="#流水线实现中的异常" class="headerlink" title="流水线实现中的异常"></a><strong>流水线实现中的异常</strong></h4><ul><li>另一种形式的控制冒险</li><li>在EX级加法出现算术溢出<ul><li>add $1, $2, $1</li><li>停止运行add指令</li><li>add之前的指令可以正常运行</li><li>清空add及其之后的指令</li><li>设置EPC和cause的值</li><li>将控制权交给处理程序</li></ul></li><li>与处理分支预测错误相似</li></ul><h4 id="处理异常的数据通路与控制"><a href="#处理异常的数据通路与控制" class="headerlink" title="处理异常的数据通路与控制"></a>处理异常的数据通路与控制</h4><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L07-ppl/image-20230411174518723.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="e"></p><blockquote><p><strong>例子</strong></p><p>异常发生在add</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs routeros">40 sub <span class="hljs-variable">$11</span>, <span class="hljs-variable">$2</span>, <span class="hljs-variable">$4</span><br> 44 <span class="hljs-keyword">and</span> <span class="hljs-variable">$12</span>, <span class="hljs-variable">$2</span>, <span class="hljs-variable">$5</span><br> 48 <span class="hljs-keyword">or</span>  <span class="hljs-variable">$13</span>, <span class="hljs-variable">$2</span>, <span class="hljs-variable">$6</span><br> 4C <span class="hljs-built_in">add</span> <span class="hljs-variable">$1</span>, <span class="hljs-variable">$2</span>, <span class="hljs-variable">$1</span><br> 50 slt <span class="hljs-variable">$15</span>, <span class="hljs-variable">$6</span>, <span class="hljs-variable">$7</span><br> 54 lw  <span class="hljs-variable">$16</span>, 50(<span class="hljs-variable">$7</span>)<br></code></pre></td></tr></table></figure><p> …</p><p>异常处理程序:</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">80000180</span> sw $<span class="hljs-number">26</span>, <span class="hljs-number">1000</span>($<span class="hljs-number">0</span>)<br> <span class="hljs-attribute">80000184</span>  sw $<span class="hljs-number">27</span>, <span class="hljs-number">1004</span>($<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><p> …</p><p>给出add 指令发生溢出异常时流水线的情况</p></blockquote><h4 id="算术溢出异常例子"><a href="#算术溢出异常例子" class="headerlink" title="算术溢出异常例子"></a><strong>算术溢出异常例子</strong></h4><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L07-ppl/image-20230411174558335.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="examp"></p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L07-ppl/image-20230411174611356.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="example"></p><h4 id="多个异常"><a href="#多个异常" class="headerlink" title="多个异常"></a><strong>多个异常</strong></h4><ul><li>流水线各级都可能发生异常<ul><li>5级流水线可能同时发生异常</li></ul></li><li>处理最早最先发生异常的指令<ul><li>清洗掉接下来的所有指令</li><li>精确（precise）异常</li></ul></li><li>在更复杂的流水线中<ul><li>每个时钟周期处理多条指令</li><li>指令乱序执行</li><li>保持精确异常非常困难</li></ul></li></ul><h4 id="非精确异常"><a href="#非精确异常" class="headerlink" title="非精确异常"></a><strong>非精确异常</strong></h4><ul><li>停止流水线并保存状态<ul><li>包括异常发生的原因</li></ul></li><li>让处理程序去完成<ul><li>确定是哪条指令发生了异常</li><li>哪条指令可以完成，哪条需要清洗</li></ul></li><li>简化硬件设计，但是处理程序将变得更加复杂</li><li>对于复杂多发射乱序执行流水线不适用</li></ul><h2 id="五-小结"><a href="#五-小结" class="headerlink" title="五.小结"></a>五.<strong>小结</strong></h2><ul><li>所有现代处理器都采用流水线设计</li><li>流水线时钟频率由最慢的流水线阶段决定——流水线各阶段的划分很重要</li><li>流水线正确运行必须能够检测并解决各类冒险<ul><li>结构冒险：流水线设计阶段</li><li>数据冒险：旁路和阻塞</li><li>控制冒险：阻塞、延迟分支决策、静态分支预测和动态分支预测</li></ul></li><li>流水线复杂的异常处理</li></ul>]]></content>
    
    
    <categories>
      
      <category>学习资料</category>
      
    </categories>
    
    
    <tags>
      
      <tag>课件笔记</tag>
      
      <tag>计算机组成原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ARM体系结构与编程-第3章-ARM微处理器的指令系统2-算术指令</title>
    <link href="/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC3%E7%AB%A0-ARM%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F2-%E7%AE%97%E6%9C%AF%E6%8C%87%E4%BB%A4/"/>
    <url>/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC3%E7%AB%A0-ARM%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F2-%E7%AE%97%E6%9C%AF%E6%8C%87%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<h1 id="ARM体系结构与编程"><a href="#ARM体系结构与编程" class="headerlink" title="ARM体系结构与编程"></a><strong>ARM体系结构与编程</strong></h1><h1 id="3-3-ARM指令集"><a href="#3-3-ARM指令集" class="headerlink" title="3.3 ARM指令集"></a>3.3 ARM指令集</h1><p>ARM指令集的六大类指令进行详细的描述</p><ul><li><strong>跳转指令</strong></li><li><strong>数据处理指令</strong></li><li><strong>Load&#x2F;store指令</strong></li><li><strong>程序状态寄存器传输指令</strong></li><li><strong>协处理器指令</strong></li><li><strong>异常中断产生指令</strong></li></ul><p><img src="/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC3%E7%AB%A0-ARM%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F2-%E7%AE%97%E6%9C%AF%E6%8C%87%E4%BB%A4/image-20230411002641298.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="操作格式"></p><h4 id="ARM指令具有以下特点："><a href="#ARM指令具有以下特点：" class="headerlink" title="ARM指令具有以下特点："></a>ARM指令具有以下特点：</h4><ul><li>ARM指令集含有十分多的未定义指令；</li><li>ARM指令代码域最高4位[31:28]是条件码域；</li><li>ARM指令一般把位[27:20]作为指令码域；</li><li>位[19:0]包含立即数、寄存器和偏移量等信息；</li><li>ARM指令集为寄存器寻址安排4位代码，4位可寻址16个寄存器；</li><li>大多数情况下，目标寄存器Rd的寄存器编号存放在[15:12]位域；</li><li>位[20]是条件标志S存放位。</li></ul><h4 id="ARM指令代码一般可以分为5个域："><a href="#ARM指令代码一般可以分为5个域：" class="headerlink" title="ARM指令代码一般可以分为5个域："></a>ARM指令代码一般可以分为5个域：</h4><ul><li>条件码域[31:28] ，4位条件码共有16种组合；</li><li>指令代码域[27:20]，除指令编码外、还包含几个很重要的指令特征位和可选后缀的编码；</li><li>地址基址Rn域[19:16]，4位可编码R0-R15共16个寄存器；</li><li>目标或源寄存器Rd域[15:12]，4位可编码R0-R15共16个寄存器；</li><li>地址偏移或操作寄存器、操作数域[11:0]。</li></ul><h4 id="指令可选后缀－-S后缀"><a href="#指令可选后缀－-S后缀" class="headerlink" title="指令可选后缀－ S后缀"></a>指令可选后缀－ S后缀</h4><p>S后缀的含义：</p><ul><li>使用S后缀时，指令执行后程序状态寄存器的条件标志位将刷新；如：ADDS R3,R5,R8</li><li>不使用S后缀时，指令执行后程序状态寄存器的条件标志位将不发生变化。如：ADD R3,R5,R8</li></ul><p>S后缀的使用范围：</p><ul><li>有些指令不需要加S后缀，在执行时同样可以刷新条件标志位；如：CMP, TEQ, TST等。</li><li>有些指令不会引起条件标志位的变化，如：STR R5, [R7]</li></ul><p>S后缀的使用目的：</p><ul><li>在需要的时候，对条件进行测试。</li></ul><p>在书写时，S后缀紧跟在指令助记符后面。</p><h4 id="指令可选后缀－-！后缀"><a href="#指令可选后缀－-！后缀" class="headerlink" title="指令可选后缀－ ！后缀"></a>指令可选后缀－ ！后缀</h4><p>！后缀的含义：</p><ul><li>在指令的地址表达式中含有！后缀时，指令执行后，基址寄存器中的地址将发生变化，变化的结果如下：<ul><li>基址寄存器中的地址值（指令执行后）＝指令执行前的值＋地址偏移量</li></ul></li><li>如果指令不含！后缀，则地址值不会发生变化。</li></ul><p>！后缀的位置和范围：</p><ul><li>！后缀必须紧跟在表达地址的表达式后面，而地址表达式要有明确的地址偏移量；</li><li>！后缀不能用在R15的后面；</li><li>当使用在单个地址寄存器后面时，必须确信这个寄存器有隐性的偏移量，如：STMDB R1!, {R3,R14}</li></ul><h4 id="指令可选后缀－-B后缀-x2F-H后缀"><a href="#指令可选后缀－-B后缀-x2F-H后缀" class="headerlink" title="指令可选后缀－ B后缀&#x2F; H后缀"></a>指令可选后缀－ B后缀&#x2F; H后缀</h4><ul><li>B后缀的含义：<ul><li>指令所涉及的数据是一字节，不是一字或半字。如：LDRB R0, [R1,#4]</li></ul></li><li>B后缀的位置：<ul><li>B后缀紧跟在指令助记符后面。</li></ul></li><li>H后缀的含义：<ul><li>指令所涉及的数据是二字节，不是一字。如：LDRH R0, [R1,#4]</li></ul></li><li>H后缀的位置：<ul><li>H后缀紧跟在指令助记符后面。</li></ul></li></ul><h4 id="指令可选后缀－-T后缀"><a href="#指令可选后缀－-T后缀" class="headerlink" title="指令可选后缀－ T后缀"></a>指令可选后缀－ T后缀</h4><p>T后缀的含义：</p><ul><li>指令在特权模式下对存储器的访问，将被存储器看成是用户模式的访问。</li></ul><p>T后缀的限制：</p><ul><li>一般只用在字传送和无符号字节传送中；</li><li>在用户模式下不可选用，选用是没有意义的；</li><li>不能与事先更新寻址一起使用</li></ul><h4 id="指令可选后缀－-条件后缀"><a href="#指令可选后缀－-条件后缀" class="headerlink" title="指令可选后缀－ 条件后缀"></a>指令可选后缀－ 条件后缀</h4><ul><li>条件后缀的定义：<ul><li>如果满足后缀条件，则执行本条指令；否则不执行本条指令。</li></ul></li><li>条件后缀只是影响指令的是否执行，不影响指令的内容。</li><li>条件后缀的说明：<ul><li>条件后缀的含义为满足则执行，不满足则不执行；</li><li>被测试条件位有Z、C、N和V；</li><li>条件后缀共有15种，其编码称条件码，为4位代码；</li><li>在指令代码中，条件码排列在最高4位[31:28]；</li><li>在汇编语言中，条件码助记符紧接在指令助记符后面；</li><li>无条件后缀AL应该省略不用。</li></ul></li><li>条件后缀和S后缀的关系：<ul><li>如果既选条件后缀也选S后缀，则书写中“S”排列在后面；</li><li>条件后缀是要测试条件标志位，而S后缀是要刷新条件标志位；</li><li>条件后缀要测试的是指令执行前的标志位，而S后缀是依据指令执行的结果改变条件标志。</li></ul></li></ul><h2 id="3-3-1-跳转指令"><a href="#3-3-1-跳转指令" class="headerlink" title="3.3.1 跳转指令"></a>3.3.1 跳转指令</h2><p>跳转指令用于实现程序流程的跳转，在ARM程序中有两种方法可以实现程序流程的跳转：</p><ul><li><p><strong>使用专门的跳转指令。</strong></p></li><li><p><strong>直接向程序计数器PC写入跳转地址值。</strong></p><p>通过向程序计数器PC写入跳转地址值，可以实现在4GB的地址空间中的任意跳转，在跳转之前结合使用</p></li></ul><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-keyword">MOV</span>  <span class="hljs-built_in">LR</span>，<span class="hljs-built_in">PC</span><br></code></pre></td></tr></table></figure><p> 等类似指令，可以保存将来的返回地址值，从而实现在4GB连续的线性地址空间的子程序调用。</p><p>ARM指令集中的跳转指令可以完成从当前指令向前或向后的32MB的地址空间的跳转，包括以下4条指令：</p><ul><li><strong>B  转指令</strong></li><li><strong>BL</strong> <strong>带返回的跳转指令</strong></li><li><strong>BLX</strong> <strong>带返回和状态切换的跳转指令(ARM7不支持)</strong></li><li><strong>BX带状态切换的跳转指令</strong></li></ul><h4 id="跳转指令的编码"><a href="#跳转指令的编码" class="headerlink" title="跳转指令的编码"></a>跳转指令的编码</h4><p><img src="/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC3%E7%AB%A0-ARM%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F2-%E7%AE%97%E6%9C%AF%E6%8C%87%E4%BB%A4/image-20230411003426615.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="跳转指令"></p><p>处理器把偏移量左移两位，进行符号扩展后再与PC相加 </p><ul><li>跳转范围：± 32 Mbyte （2^25）</li><li><strong>如何执行长跳转？</strong></li></ul><p><strong>直接向程序计数器PC写入跳转地址值（长跳转）</strong></p><p><img src="/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC3%E7%AB%A0-ARM%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F2-%E7%AE%97%E6%9C%AF%E6%8C%87%E4%BB%A4/image-20230411003507327.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="B"></p><h5 id="1、-B指令"><a href="#1、-B指令" class="headerlink" title="1、 B指令"></a>1、 B指令</h5><ul><li>B指令的格式为：<ul><li><strong>B{条件}</strong> <strong>目标地址</strong></li></ul></li><li>B指令是最简单的跳转指令。一旦遇到一个 B 指令，ARM 处理器将立即跳转到给定的目标地址，从那里继续执行。</li></ul><p><strong>注意存储在跳转指令中的实际值是相对当前PC值的一个偏移量，而不是一个绝对地址，它的值由汇编器来计算</strong>（参考寻址方式中的相对寻址）。它是 24 位有符号数，有符号扩展为 32 位后左移两位，表示的有效偏移为 26 位(前后<strong>32MB</strong>的地址空间)。</p><p>指令操作的伪代码：</p><p><img src="/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC3%E7%AB%A0-ARM%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F2-%E7%AE%97%E6%9C%AF%E6%8C%87%E4%BB%A4/image-20230411003612211.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="fake"></p><p><img src="/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC3%E7%AB%A0-ARM%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F2-%E7%AE%97%E6%9C%AF%E6%8C%87%E4%BB%A4/image-20230411003622502.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="非条件分支"></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">B</span>指令的例子：<br><span class="hljs-selector-tag">B</span>  <span class="hljs-selector-tag">Label</span> ；程序无条件跳转到标号<span class="hljs-selector-tag">Label</span>处执行<br>CMP   R1，＃<span class="hljs-number">0</span> ；当CPSR寄存器中的Z条件码置位时，程序跳转到标号<span class="hljs-selector-tag">Label</span>处执行<br>BEQ   <span class="hljs-selector-tag">Label</span>       <br></code></pre></td></tr></table></figure><h5 id=""><a href="#" class="headerlink" title=""></a></h5><h5 id="2、-BL指令"><a href="#2、-BL指令" class="headerlink" title="2、 BL指令"></a>2、 BL指令</h5><p><img src="/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC3%E7%AB%A0-ARM%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F2-%E7%AE%97%E6%9C%AF%E6%8C%87%E4%BB%A4/image-20230411003737075.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="BL"></p><p>BL指令的格式为：</p><p>   <strong>BL{条件}</strong> <strong>目标地址</strong></p><p> BL 是另一个跳转指令，<strong>但跳转之前，会在寄存器R14中保存PC的当前内容</strong>，因此，可以通过将R14 的内容重新加载到PC中，来返回到跳转指令之后的那个指令处执行。</p><p>以下指令：</p><p>  BL  Label ；当程序无条件跳转到标号Label处执行时，同 时将当前的PC值保存到R14中。</p><p><img src="/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC3%E7%AB%A0-ARM%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F2-%E7%AE%97%E6%9C%AF%E6%8C%87%E4%BB%A4/image-20230411003829333.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="函数调用"></p><p>条件跳转</p><p><img src="/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC3%E7%AB%A0-ARM%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F2-%E7%AE%97%E6%9C%AF%E6%8C%87%E4%BB%A4/image-20230411003845179.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="条件分支"></p><p><img src="/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC3%E7%AB%A0-ARM%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F2-%E7%AE%97%E6%9C%AF%E6%8C%87%E4%BB%A4/image-20230411003900919.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="BLX"></p><h5 id="3、-BLX指令"><a href="#3、-BLX指令" class="headerlink" title="3、 BLX指令"></a>3、 BLX指令</h5><p>BLX指令的格式为：</p><p>  <strong>BLX</strong> <strong>目标地址</strong></p><p>BLX 目标地址指令从ARM指令集跳转到指令中所指定的目标地址，并将处理器的工作状态有ARM状态切换到Thumb状态，该指令同时将PC的当前内容保存到寄存器R14中。</p><p>因此，当子程序使用Thumb指令集，而调用者使用ARM指令集时，可以通过BLX指令实现子程序的调用和处理器工作状态的切换。同时，子程序的返回可以通过将寄存器R14值复制到PC中来完成。</p><ul><li><strong>本指令属于无条件执行的指令。</strong></li><li>从ARM到Thumb的状态切换，并可以通过BX R14返回。</li></ul><p><img src="/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC3%E7%AB%A0-ARM%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F2-%E7%AE%97%E6%9C%AF%E6%8C%87%E4%BB%A4/image-20230411003951997.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="伪代码"></p><p>指令编码中的bit[24]被作为目标地址的bit[1]</p><p><img src="/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC3%E7%AB%A0-ARM%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F2-%E7%AE%97%E6%9C%AF%E6%8C%87%E4%BB%A4/image-20230411004158021.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="blx"></p><p>BLX指令的格式为：</p><p>  <strong>BLX{条件}  &lt; Rm&gt;</strong></p><p>BLX{条件}  &lt; Rm&gt;指令跳转到指令中所指定的目标地址，目标地址处的指令既可以是ARM指令，也可以是Thumb指令。目标地址处的指令类型由寄存器&lt; Rm&gt;的bit[0]决定。</p><p><strong>从ARM到ARM或Thumb的状态切换。</strong></p><p>指令操作的伪代码：</p><p><img src="/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC3%E7%AB%A0-ARM%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F2-%E7%AE%97%E6%9C%AF%E6%8C%87%E4%BB%A4/image-20230411004241777.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="fake"></p><h5 id="4、-BX指令"><a href="#4、-BX指令" class="headerlink" title="4、 BX指令"></a>4、 BX指令</h5><p>BX指令的格式为：</p><p> BX{条件} &lt; Rm&gt; </p><p>BX指令跳转到指令中所指定的目标地址，目标地址处的指令既可以是ARM指令，也可以是Thumb指令。</p><p>目标地址处的指令类型由寄存器<Rm>的bit[0]决定。</p><p>指令操作的伪代码：</p><p><img src="/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC3%E7%AB%A0-ARM%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F2-%E7%AE%97%E6%9C%AF%E6%8C%87%E4%BB%A4/image-20230411004322326.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="fake"></p><h4 id="三种子程序的返回方法"><a href="#三种子程序的返回方法" class="headerlink" title="三种子程序的返回方法"></a>三种子程序的返回方法</h4><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-keyword">MOV</span> <span class="hljs-built_in">PC</span>, <span class="hljs-built_in">R14</span><br><br><span class="hljs-keyword">BX</span> <span class="hljs-built_in">R14</span><br><br>当子程序入口中使用了<br>STMFD <span class="hljs-built_in">R13</span>!, &#123;&lt; registers&gt;,<span class="hljs-built_in">R14</span>&#125;时，可以用指令<br><span class="hljs-keyword">LDMFD</span> <span class="hljs-built_in">R13</span>!, &#123;&lt; registers&gt;,<span class="hljs-built_in">PC</span>&#125;返回<br></code></pre></td></tr></table></figure><p><img src="/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC3%E7%AB%A0-ARM%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F2-%E7%AE%97%E6%9C%AF%E6%8C%87%E4%BB%A4/image-20230411004442442.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="数据处理指令"></p><h2 id="3-3-2-数据处理指令"><a href="#3-3-2-数据处理指令" class="headerlink" title="3.3.2 数据处理指令"></a>3.3.2 数据处理指令</h2><p>数据处理指令可分为数据传送指令、算术逻辑运算指令和比较指令等。</p><ul><li>数据传送指令用于在寄存器和第二个操作数之间进行数据的传输。</li><li>算术逻辑运算指令完成常用的算术与逻辑的运算，该类指令不但将运算结果保存在目的寄存器中，同时更新CPSR中的相应条件标志位。</li><li>比较指令不保存运算结果，只更新CPSR中相应的条件标志位。</li></ul><blockquote><p>包括：</p><p>算术指令： <strong>ADD ADC SUB SBC RSB RSC</strong></p><p>逻辑指令： <strong>AND ORR EOR BIC</strong></p><p>比较指令： <strong>CMP CMN TST TEQ</strong></p><p>数据搬移： <strong>MOV MVN</strong></p><p><strong>上述指令只能对寄存器操作，不能针对存储器。</strong></p><p>语法：</p><p> <strong>&lt; 操作&gt;{&lt; cond&gt;}{S} Rd, Rn, Operand2</strong></p><p>比较指令影响标志位 -不指定Rd</p><p>数据搬移不指定Rn</p><p><strong>第二个操作数通过桶型移位器送到ALU中。</strong></p></blockquote><p><img src="/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC3%E7%AB%A0-ARM%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F2-%E7%AE%97%E6%9C%AF%E6%8C%87%E4%BB%A4/image-20230411004737375.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="操作"></p><h4 id="桶型移位器"><a href="#桶型移位器" class="headerlink" title="桶型移位器"></a>桶型移位器</h4><p><img src="/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC3%E7%AB%A0-ARM%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F2-%E7%AE%97%E6%9C%AF%E6%8C%87%E4%BB%A4/image-20230411004756734.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="LSL:Logical Left Shift"></p><p><img src="/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC3%E7%AB%A0-ARM%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F2-%E7%AE%97%E6%9C%AF%E6%8C%87%E4%BB%A4/image-20230411004817602.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="ASR: Arithmetic Right Shift"></p><p><img src="/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC3%E7%AB%A0-ARM%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F2-%E7%AE%97%E6%9C%AF%E6%8C%87%E4%BB%A4/image-20230411004836487.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="LSR : Logical Shift Right"></p><p><img src="/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC3%E7%AB%A0-ARM%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F2-%E7%AE%97%E6%9C%AF%E6%8C%87%E4%BB%A4/image-20230411004848955.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="ROR: Rotate Right"></p><p><img src="/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC3%E7%AB%A0-ARM%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F2-%E7%AE%97%E6%9C%AF%E6%8C%87%E4%BB%A4/image-20230411004906366.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="RRX: Rotate Right Extended"></p><p>桶型移位器: 第二个操作数</p><p><img src="/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC3%E7%AB%A0-ARM%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F2-%E7%AE%97%E6%9C%AF%E6%8C%87%E4%BB%A4/image-20230411004928499.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="second op"></p><p>​寄存器, 可选择是否增加移位操作.</p><p>移位值可以是：</p><ul><li>5 bit 无符号整数</li><li>放在另一个寄存器的低字节（8bits）</li></ul><p>用于常数乘法</p><p>​     立即数</p><ul><li>8 bit ，大小范围0-255。<ul><li>右移偶数位</li></ul></li><li>允许直接加载32-bit 常数到寄存器中</li></ul><p><img src="/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC3%E7%AB%A0-ARM%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F2-%E7%AE%97%E6%9C%AF%E6%8C%87%E4%BB%A4/image-20230411005037178.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="mov"></p><h5 id="1、-MOV指令"><a href="#1、-MOV指令" class="headerlink" title="1、 MOV指令"></a>1、 MOV指令</h5><ul><li>MOV指令的格式为：<ul><li>MOV{条件}{S} 目的寄存器，源操作数</li></ul></li><li>MOV指令可完成从另一个寄存器、被移位的寄存器或将一个立即数加载到目的寄存器。</li><li>其中S选项决定指令的操作是否影响CPSR中条件标志位的值，当没有S时指令不更新CPSR中条件标志位的值。</li><li><strong>当PC作为目标寄存器且指令中S位被置位时，指令在执行跳转操作的同时，将当前处理器模式的SPSR内容复制到CPSR中。</strong></li></ul><blockquote><p><strong>MOVS PC, LR可以实现从某些异常中断中返回</strong></p></blockquote><p><img src="/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC3%E7%AB%A0-ARM%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F2-%E7%AE%97%E6%9C%AF%E6%8C%87%E4%BB%A4/image-20230411005143156.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="fake"></p><p><img src="/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC3%E7%AB%A0-ARM%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F2-%E7%AE%97%E6%9C%AF%E6%8C%87%E4%BB%A4/image-20230411005153663.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="移数"></p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs armasm">  <span class="hljs-keyword">MOV</span>   <span class="hljs-built_in">R1</span>，<span class="hljs-built_in">R0</span> ；将寄存器<span class="hljs-built_in">R0</span>的值传送到寄存器<span class="hljs-built_in">R1</span><br>  <span class="hljs-keyword">MOV</span>   <span class="hljs-built_in">PC</span>，<span class="hljs-built_in">R14</span> ；将寄存器<span class="hljs-built_in">R14</span>的值传送到<span class="hljs-built_in">PC</span>，常用于子程序返回<br>  <span class="hljs-keyword">MOV</span>   <span class="hljs-built_in">R1</span>，<span class="hljs-built_in">R0</span>，LSL＃<span class="hljs-number">3</span> ；将寄存器<span class="hljs-built_in">R0</span>的值左移<span class="hljs-number">3</span>位后传送到<span class="hljs-built_in">R1</span><br><span class="hljs-keyword">MOV</span>   <span class="hljs-built_in">R1</span>，＃<span class="hljs-number">123</span> ；将立即数<span class="hljs-number">123</span>传送到<span class="hljs-built_in">R1</span><br></code></pre></td></tr></table></figure><p><img src="/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC3%E7%AB%A0-ARM%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F2-%E7%AE%97%E6%9C%AF%E6%8C%87%E4%BB%A4/image-20230411005226378.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="MVN"></p><h5 id="2、-MVN指令"><a href="#2、-MVN指令" class="headerlink" title="2、 MVN指令"></a>2、 MVN指令</h5><ul><li>MVN指令的格式为：<ul><li>MVN{条件}{S} 目的寄存器，源操作数</li></ul></li><li>MVN指令可完成从另一个寄存器、被移位的寄存器、或将一个立即数加载到目的寄存器。</li><li>与MOV指令不同之处是在传送之前<strong>按位被取反</strong>了，即把一个被取反的值传送到目的寄存器中。</li><li>其中S决定指令的操作是否影响CPSR中条件标志位的值，当没有S时指令不更新CPSR中条件标志位的值。</li></ul><p><img src="/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC3%E7%AB%A0-ARM%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F2-%E7%AE%97%E6%9C%AF%E6%8C%87%E4%BB%A4/image-20230411005302299.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="fake"></p><p><img src="/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC3%E7%AB%A0-ARM%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F2-%E7%AE%97%E6%9C%AF%E6%8C%87%E4%BB%A4/image-20230411005309607.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="取法移数用处"></p><blockquote><p> MVN  R0，＃0 ；将立即数0取反传送到寄存器R0中，完成后 <strong>R0&#x3D;-1</strong></p></blockquote><p><img src="/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC3%E7%AB%A0-ARM%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F2-%E7%AE%97%E6%9C%AF%E6%8C%87%E4%BB%A4/image-20230411005351596.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="CMP"></p><h5 id="3、-CMP指令"><a href="#3、-CMP指令" class="headerlink" title="3、 CMP指令"></a>3、 CMP指令</h5><ul><li>CMP指令的格式为：<ul><li>CMP{条件} 操作数1，操作数2</li></ul></li><li>CMP指令用于把一个寄存器的内容和另一个寄存器的内容或立即数进行比较，同时更新CPSR中条件标志位的值。</li><li>该指令进行一次<strong>减法</strong>运算，但不存储结果，只更改条件标志位。标志位表示的是操作数1与操作数2的关系(大、小、相等)，例如，当操作数1大于操作操作数2，则此后的有GT 后缀的指令将可以执行。</li></ul><p><img src="/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC3%E7%AB%A0-ARM%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F2-%E7%AE%97%E6%9C%AF%E6%8C%87%E4%BB%A4/image-20230411005441417.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="fake"></p><p><img src="/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC3%E7%AB%A0-ARM%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F2-%E7%AE%97%E6%9C%AF%E6%8C%87%E4%BB%A4/image-20230411005449867.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="比较"></p><blockquote><p>CMP  R1，R0 ；将寄存器R1的值与寄存器R0的值相减，并根据 结果设置CPSR的标志位</p><p>  CMP  R1，＃100 ；将寄存器R1的值与立即数100相减，并根据 结果设置CPSR的标志位</p></blockquote><p><img src="/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC3%E7%AB%A0-ARM%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F2-%E7%AE%97%E6%9C%AF%E6%8C%87%E4%BB%A4/image-20230411005511003.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="CMN"></p><h5 id="4、-CMN指令"><a href="#4、-CMN指令" class="headerlink" title="4、 CMN指令"></a>4、 CMN指令</h5><ul><li>CMN指令的格式为：<ul><li>CMN{条件} 操作数1，操作数2</li></ul></li><li>CMN指令用于把一个寄存器的内容和另一个寄存器的内容或立即数取反后进行比较，同时更新CPSR中条件标志位的值。</li><li>该指令实际完成操作数1和操作数2<strong>相加</strong>，并根据结果更改条件标志位。</li></ul><blockquote><p><strong>CMP指令与SUBS指令的区别在于CMP指令不保存操作结果</strong></p></blockquote><p><img src="/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC3%E7%AB%A0-ARM%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F2-%E7%AE%97%E6%9C%AF%E6%8C%87%E4%BB%A4/image-20230411005544464.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="fake"></p><blockquote><p>   CMN  R1，R0 ；将寄存器R1的值与寄存器R0的值相 加，并根据结果设置CPSR的标志位</p><p>  CMN  R1，＃100 ；将寄存器R1的值与立即数100相 加，并根据结果设置CPSR的标志位</p></blockquote><p><img src="/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC3%E7%AB%A0-ARM%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F2-%E7%AE%97%E6%9C%AF%E6%8C%87%E4%BB%A4/image-20230411005608076.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="TST"></p><h5 id="5、-TST指令"><a href="#5、-TST指令" class="headerlink" title="5、 TST指令"></a>5、 TST指令</h5><p>TST指令的格式为：</p><p> TST{条件} 操作数1，操作数2</p><p>TST指令用于把一个寄存器的内容和另一个寄存器的内容或立即数进行<strong>按位与运算</strong>，并根据运算结果更新CPSR中条件标志位的值。</p><p>操作数1是要测试的数据，而操作数2是一个位掩码，该指令一般用来检测是否设置了特定的位。</p><blockquote><p><strong>TST指令用于测试寄存器中某些位是1还是0</strong></p></blockquote><p><img src="/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC3%E7%AB%A0-ARM%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F2-%E7%AE%97%E6%9C%AF%E6%8C%87%E4%BB%A4/image-20230411005725294.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="fake"></p><blockquote><p> TST  R1，＃％1 ；用于测试在寄存器R1中是否设置了最低 位（％表示二进制数）</p><p>  TST  R1，＃0xfe ；将寄存器R1的值与立即数0xfe按位 与，并根据结果设置CPSR的标志位</p></blockquote><p><img src="/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC3%E7%AB%A0-ARM%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F2-%E7%AE%97%E6%9C%AF%E6%8C%87%E4%BB%A4/image-20230411005739652.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="TEQ"></p><h5 id="6、-TEQ指令"><a href="#6、-TEQ指令" class="headerlink" title="6、 TEQ指令"></a>6、 TEQ指令</h5><ul><li>TEQ指令的格式为：<ul><li>TEQ{条件} 操作数1，操作数2</li></ul></li><li>TEQ指令用于把一个寄存器的内容和另一个寄存器的内容或立即数进行<strong>按位异或运算</strong>，并根据运算结果更新CPSR中条件标志位的值。</li></ul><blockquote><p><strong>TEQ指令通常用于比较操作数1和操作数2是否相等</strong></p></blockquote><p><img src="/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC3%E7%AB%A0-ARM%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F2-%E7%AE%97%E6%9C%AF%E6%8C%87%E4%BB%A4/image-20230411005821582.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="fake"></p><p><img src="/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC3%E7%AB%A0-ARM%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F2-%E7%AE%97%E6%9C%AF%E6%8C%87%E4%BB%A4/image-20230411005836658.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="equal"></p><blockquote><p> TEQ  R1，R2 ；将寄存器R1的值与寄存器R2的值按位异或， 并根据结果设置CPSR的标志位</p></blockquote><p><img src="/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC3%E7%AB%A0-ARM%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F2-%E7%AE%97%E6%9C%AF%E6%8C%87%E4%BB%A4/image-20230411005905038.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="ADD"></p><h5 id="7、-ADD指令"><a href="#7、-ADD指令" class="headerlink" title="7、 ADD指令"></a>7、 ADD指令</h5><ul><li>ADD指令的格式为：<ul><li>ADD{条件}{S} 目的寄存器，操作数1，操作数2</li></ul></li><li>ADD指令用于把两个操作数相加，并将结果存放到目的寄存器中。</li><li>操作数1应是一个寄存器，操作数2可以是一个寄存器，被移位的寄存器，或一个立即数。</li></ul><p><img src="/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC3%E7%AB%A0-ARM%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F2-%E7%AE%97%E6%9C%AF%E6%8C%87%E4%BB%A4/image-20230411005941935.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="fake"></p><p><img src="/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC3%E7%AB%A0-ARM%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F2-%E7%AE%97%E6%9C%AF%E6%8C%87%E4%BB%A4/image-20230411005951786.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="add"></p><blockquote><p>ADD  R0，R1，R2 ； R0 &#x3D; R1 + R2</p><p>  ADD  R0，R1，#256 ； R0 &#x3D; R1 + 256</p><p>  ADDS  R0，R2，R3，LSL#1 ； R0 &#x3D; R2 + (R3 &lt;&lt; 1)</p></blockquote><p><img src="/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC3%E7%AB%A0-ARM%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F2-%E7%AE%97%E6%9C%AF%E6%8C%87%E4%BB%A4/image-20230411010008380.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="ADC"></p><h5 id="8、-ADC指令"><a href="#8、-ADC指令" class="headerlink" title="8、 ADC指令"></a>8、 ADC指令</h5><ul><li>ADC指令的格式为：<ul><li>ADC{条件}{S} 目的寄存器，操作数1，操作数2</li></ul></li><li>ADC指令用于把两个操作数相加，再加上CPSR中的C条件标志位的值，并将结果存放到目的寄存器中。</li><li><strong>它使用一个进位标志位，这样就可以做比32位大的数的加法，注意不要忘记设置S后缀来更改进位标志</strong>。</li><li>操作数1应是一个寄存器，操作数2可以是一个寄存器，被移位的寄存器，或一个立即数。</li></ul><blockquote><p><strong>ADC指令和ADD指令联合使用可以实现64位、128位的加法操作</strong></p></blockquote><p><img src="/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC3%E7%AB%A0-ARM%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F2-%E7%AE%97%E6%9C%AF%E6%8C%87%E4%BB%A4/image-20230411010133769.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="FAKE"></p><p>以下指令序列完成两个128位数的加法，第一个数由高到低存放在寄存器R7～R4，第二个数由高到低存放在寄存器R11～R8，运算结果由高到低存放在寄存器R3～R0：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs armasm">   <span class="hljs-keyword">ADDS</span>   <span class="hljs-built_in">R0</span>，<span class="hljs-built_in">R4</span>，<span class="hljs-built_in">R8</span>     ； 加低端的字<br>   <span class="hljs-keyword">ADCS</span>   <span class="hljs-built_in">R1</span>，<span class="hljs-built_in">R5</span>，<span class="hljs-built_in">R9</span>     ； 加第二个字，带进位<br>   <span class="hljs-keyword">ADCS</span>   <span class="hljs-built_in">R2</span>，<span class="hljs-built_in">R6</span>，<span class="hljs-built_in">R10</span>   ； 加第三个字，带进位<br>   <span class="hljs-keyword">ADC</span>     <span class="hljs-built_in">R3</span>，<span class="hljs-built_in">R7</span>，<span class="hljs-built_in">R11</span>    ； 加第四个字，带进位<br></code></pre></td></tr></table></figure><p><img src="/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC3%E7%AB%A0-ARM%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F2-%E7%AE%97%E6%9C%AF%E6%8C%87%E4%BB%A4/image-20230411010202001.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="SUB"></p><h5 id="9、-SUB指令"><a href="#9、-SUB指令" class="headerlink" title="9、 SUB指令"></a>9、 SUB指令</h5><ul><li>SUB指令的格式为：<ul><li>SUB{条件}{S} 目的寄存器，操作数1，操作数2</li></ul></li><li>SUB指令用于把操作数1减去操作数2，并将结果存放到目的寄存器中。</li><li>操作数1应是一个寄存器，操作数2可以是一个寄存器，被移位的寄存器，或一个立即数。</li><li>该指令可用于有符号数或无符号数的减法运算。</li></ul><p><img src="/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC3%E7%AB%A0-ARM%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F2-%E7%AE%97%E6%9C%AF%E6%8C%87%E4%BB%A4/image-20230411010238432.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="FAKE"></p><p><img src="/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC3%E7%AB%A0-ARM%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F2-%E7%AE%97%E6%9C%AF%E6%8C%87%E4%BB%A4/image-20230411010245469.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="SUB"></p><blockquote><p>  SUB   R0，R1，R2  ； R0 &#x3D; R1 - R2</p><p>  SUB   R0，R1，#256  ； R0 &#x3D; R1 - 256</p><p>  SUBS  R0，R2，R3，LSL#1 ； R0 &#x3D; R2 - (R3 &lt;&lt; 1)</p></blockquote><p><img src="/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC3%E7%AB%A0-ARM%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F2-%E7%AE%97%E6%9C%AF%E6%8C%87%E4%BB%A4/image-20230411010307495.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="SBC"></p><h5 id="10、SBC指令"><a href="#10、SBC指令" class="headerlink" title="10、SBC指令"></a>10、SBC指令</h5><ul><li>SBC指令的格式为：<ul><li>SBC {条件 }{ S} 目的寄存器，操作数1，操作数2</li></ul></li><li>SBC指令用于把操作数1减去操作数2，再减去CPSR中的<strong>C条件标志位的反码</strong>，并将结果存放到目的寄存器中。</li><li>操作数1应是一个寄存器，操作数2可以是一个寄存器，被移位的寄存器，或一个立即数。</li><li>该指令使用进位标志来表示借位，这样就可以做大于32位的减法，注意不要忘记设置S后缀来更改进位标志。</li><li>该指令可用于有符号数或无符号数的减法运算</li></ul><blockquote><p><strong>SBC指令和SUB指令联合使用可以实现64位、128位的减法操作</strong></p></blockquote><p><img src="/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC3%E7%AB%A0-ARM%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F2-%E7%AE%97%E6%9C%AF%E6%8C%87%E4%BB%A4/image-20230422224125976.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="fake"></p><blockquote><p>  SBC R0，R1，R2 ；R0 &#x3D; R1 - R2 - ！C，并根据结 果设置CPSR的进位标志位</p></blockquote><p><img src="/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC3%E7%AB%A0-ARM%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F2-%E7%AE%97%E6%9C%AF%E6%8C%87%E4%BB%A4/image-20230411010559319.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="rsb"></p><h5 id="11、RSB指令"><a href="#11、RSB指令" class="headerlink" title="11、RSB指令"></a>11、RSB指令</h5><ul><li>RSB指令的格式为：<ul><li>RSB{条件}{S} 目的寄存器，操作数1，操作数2</li></ul></li><li>RSB指令称为逆向减法指令，用于把操作数2减去操作数1，并将结果存放到目的寄存器中。</li><li>操作数1应是一个寄存器，操作数2可以是一个寄存器，被移位的寄存器，或一个立即数。</li><li>该指令可用于有符号数或无符号数的减法运算。</li></ul><p><img src="/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC3%E7%AB%A0-ARM%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F2-%E7%AE%97%E6%9C%AF%E6%8C%87%E4%BB%A4/image-20230411010642832.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="FAKE"></p><p><img src="/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC3%E7%AB%A0-ARM%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F2-%E7%AE%97%E6%9C%AF%E6%8C%87%E4%BB%A4/image-20230411010650719.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="RSB"></p><blockquote><p> RSB   R0，R1，R2 ； R0 &#x3D; R2 – R1</p><p>  RSB   R0，R1，#256 ； R0 &#x3D; 256 – R1</p><p>  RSBS  R0，R2，R3，LSL#1 ； R0 &#x3D; (R3 &lt;&lt; 1) - R2</p></blockquote><p><img src="/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC3%E7%AB%A0-ARM%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F2-%E7%AE%97%E6%9C%AF%E6%8C%87%E4%BB%A4/image-20230411010711989.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="RSC"></p><h5 id="12、RSC指令"><a href="#12、RSC指令" class="headerlink" title="12、RSC指令"></a>12、RSC指令</h5><ul><li>RSC指令的格式为：<ul><li>RSC{条件}{S} 目的寄存器，操作数1，操作数2</li></ul></li><li>RSC指令用于把操作数2减去操作数1，再减去CPSR中的<strong>C</strong>条件标志位的反码，并将结果存放到目的寄存器中。</li><li>操作数1应是一个寄存器，操作数2可以是一个寄存器，被移位的寄存器，或一个立即数。</li><li><strong>该指令使用进位标志来表示借位，这样就可以做大于32位的减法，注意不要忘记设置S后缀来更改进位标志。</strong></li><li>该指令可用于有符号数或无符号数的减法运算。</li></ul><blockquote><p><strong>RSC指令和RSB指令联合使用可以实现64位、128位的减法操作</strong></p></blockquote><p><img src="/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC3%E7%AB%A0-ARM%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F2-%E7%AE%97%E6%9C%AF%E6%8C%87%E4%BB%A4/image-20230411010853265.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="FAKE"></p><blockquote><p> RSC  R0，R1，R2  ； R0 &#x3D; R2 – R1 - ！C</p></blockquote><p><img src="/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC3%E7%AB%A0-ARM%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F2-%E7%AE%97%E6%9C%AF%E6%8C%87%E4%BB%A4/image-20230411011249351.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="and"></p><h5 id="13、AND指令"><a href="#13、AND指令" class="headerlink" title="13、AND指令"></a>13、AND指令</h5><ul><li>AND指令的格式为：</li><li>AND{条件}{S} 目的寄存器，操作数1，操作数2</li><li>AND指令用于在两个操作数上进行<strong>逻辑与运算</strong>，并把结果放置到目的寄存器中。</li><li>操作数1应是一个寄存器，操作数2可以是一个寄存器，被移位的寄存器，或一个立即数。</li><li><strong>该指令常用于屏蔽操作数1的某些位。</strong></li></ul><blockquote><p><strong>设置一个掩码值，AND指令可以提取寄存器中某些位的值</strong></p></blockquote><p><img src="/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC3%E7%AB%A0-ARM%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F2-%E7%AE%97%E6%9C%AF%E6%8C%87%E4%BB%A4/image-20230411011325772.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="FAKE"></p><blockquote><p> AND  R0，R0，＃3  ； 该指令保持R0的0、1位，其余位 清零。</p></blockquote><p><img src="/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC3%E7%AB%A0-ARM%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F2-%E7%AE%97%E6%9C%AF%E6%8C%87%E4%BB%A4/image-20230411011522647.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="ORR"></p><h5 id="14、ORR指令"><a href="#14、ORR指令" class="headerlink" title="14、ORR指令"></a>14、ORR指令</h5><ul><li>ORR指令的格式为：<ul><li>ORR{条件}{S} 目的寄存器，操作数1，操作数2</li></ul></li><li>ORR指令用于在两个操作数上进行<strong>逻辑或运算</strong>，并把结果放置到目的寄存器中。</li><li>操作数1应是一个寄存器，操作数2可以是一个寄存器，被移位的寄存器，或一个立即数。</li><li><strong>该指令常用于设置操作数1的某些位。</strong></li></ul><blockquote><p><strong>设置一个掩码值，ORR指令可以设置寄存器中某些位的值为1</strong></p></blockquote><p><img src="/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC3%E7%AB%A0-ARM%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F2-%E7%AE%97%E6%9C%AF%E6%8C%87%E4%BB%A4/image-20230411011605321.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="FAKE"></p><p><img src="/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC3%E7%AB%A0-ARM%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F2-%E7%AE%97%E6%9C%AF%E6%8C%87%E4%BB%A4/image-20230411011612621.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="ORR"></p><blockquote><p>  ORR  R0，R0，＃3 ； 该指令设置R0的0、1位，其余位保持 不变。</p></blockquote><p><img src="/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC3%E7%AB%A0-ARM%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F2-%E7%AE%97%E6%9C%AF%E6%8C%87%E4%BB%A4/image-20230411011654792.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="EOR"></p><h5 id="15、EOR指令"><a href="#15、EOR指令" class="headerlink" title="15、EOR指令"></a>15、EOR指令</h5><ul><li>EOR指令的格式为：<ul><li>EOR{条件}{S} 目的寄存器，操作数1，操作数2</li></ul></li><li>EOR指令用于在两个操作数上进行<strong>逻辑异或运算</strong>，并把结果放置到目的寄存器中。</li><li>操作数1应是一个寄存器，操作数2可以是一个寄存器，被移位的寄存器，或一个立即数。</li><li><strong>该指令常用于反转操作数1的某些位。</strong></li></ul><blockquote><p><strong>设置一个掩码值，EOR指令可以将寄存器中某些位的值取反</strong></p></blockquote><p><img src="/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC3%E7%AB%A0-ARM%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F2-%E7%AE%97%E6%9C%AF%E6%8C%87%E4%BB%A4/image-20230411011741649.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="FAKE"></p><blockquote><p>  EOR  R0，R0，＃3  ； 该指令反转R0的0、1位，其余位保 持不变。</p></blockquote><p><img src="/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC3%E7%AB%A0-ARM%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F2-%E7%AE%97%E6%9C%AF%E6%8C%87%E4%BB%A4/image-20230411011753844.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="BIC"></p><h5 id="16、BIC指令"><a href="#16、BIC指令" class="headerlink" title="16、BIC指令"></a>16、BIC指令</h5><ul><li>BIC指令的格式为：<ul><li>BIC{条件}{S} 目的寄存器，操作数1，操作数2</li></ul></li><li>BIC指令用于清除操作数1的某些位，并把结果放置到目的寄存器中。</li><li>操作数1应是一个寄存器，操作数2可以是一个寄存器，被移位的寄存器，或一个立即数。</li><li>操作数2为32位的掩码，<strong>如果在掩码中设置了某一位，则清除这一位</strong>，<strong>未设置的掩码位保持不变</strong>。</li></ul><blockquote><p><strong>设置一个掩码值，BIC指令可以将寄存器中某些位的值设置成0</strong></p></blockquote><p><img src="/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC3%E7%AB%A0-ARM%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F2-%E7%AE%97%E6%9C%AF%E6%8C%87%E4%BB%A4/image-20230411011831841.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="FAKE"></p><p><img src="/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC3%E7%AB%A0-ARM%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F2-%E7%AE%97%E6%9C%AF%E6%8C%87%E4%BB%A4/image-20230411011837808.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="BIC"></p><blockquote><p>  BIC  R0，R0，＃％1011 ； 该指令清除 R0 中的位 0、1、和  3，其余的位保持不变。</p></blockquote><h2 id="3-3-3-乘法指令与乘加指令"><a href="#3-3-3-乘法指令与乘加指令" class="headerlink" title="3.3.3 乘法指令与乘加指令"></a>3.3.3 乘法指令与乘加指令</h2><p>ARM微处理器支持的乘法指令与乘加指令共有6条，可分为运算结果为32位和运算结果为64位两类，与前面的数据处理指令不同:</p><ul><li><strong>指令中的所有操作数、目的寄存器必须为通用寄存器，不能对操作数使用立即数或被移位的寄存器</strong></li><li><strong>同时，目的寄存器和操作数1必须是不同的寄存器</strong></li></ul><p>乘法指令与乘加指令共有以下6条：</p><blockquote><p>MUL   32位乘法指令</p><p>MLA   32位乘加指令</p><p>SMULL  64位有符号数乘法指令</p><p>SMLAL  64位有符号数乘加指令</p><p>UMULL  64位无符号数乘法指令</p><p>UMLAL  64位无符号数乘加指令</p></blockquote><p><img src="/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC3%E7%AB%A0-ARM%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F2-%E7%AE%97%E6%9C%AF%E6%8C%87%E4%BB%A4/image-20230411012015228.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="MUL"></p><h4 id="1、-MUL指令"><a href="#1、-MUL指令" class="headerlink" title="1、 MUL指令"></a>1、 MUL指令</h4><ul><li>MUL指令的格式为：<ul><li>MUL{条件}{S} 目的寄存器，操作数1，操作数2</li></ul></li><li>MUL指令完成将操作数1与操作数2的乘法运算，并把结果放置到目的寄存器中，同时可以根据运算结果设置CPSR中相应的条件标志位。</li><li>其中，操作数1和操作数2均为32位的有符号数或无符号数。</li></ul><blockquote><p><strong>结果仅保存了64位的低32位</strong></p></blockquote><p><img src="/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC3%E7%AB%A0-ARM%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F2-%E7%AE%97%E6%9C%AF%E6%8C%87%E4%BB%A4/image-20230411012055345.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="FAKE"></p><p><img src="/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC3%E7%AB%A0-ARM%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F2-%E7%AE%97%E6%9C%AF%E6%8C%87%E4%BB%A4/image-20230411012101399.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="非法"></p><p><img src="/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC3%E7%AB%A0-ARM%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F2-%E7%AE%97%E6%9C%AF%E6%8C%87%E4%BB%A4/image-20230411012120443.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="mul"></p><h4 id="2、-MLA指令"><a href="#2、-MLA指令" class="headerlink" title="2、 MLA指令"></a>2、 MLA指令</h4><ul><li><p>MLA指令的格式为：</p></li><li><p>MLA{条件}{S}  目的寄存器， 操作数1，操作数2，操作数3</p></li></ul><p>  <img src="/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC3%E7%AB%A0-ARM%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F2-%E7%AE%97%E6%9C%AF%E6%8C%87%E4%BB%A4/image-20230411012226956.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="MLA"></p><ul><li><p>MLA指令完成将操作数1与操作数2的乘法运算，再将乘积加上操作数3，并把结果放置到目的寄存器中，同时可以根据运算结果设置CPSR中相应的条件标志位。</p><ul><li>其中，操作数1和操作数2均为32位的有符号数或无符号数</li></ul></li></ul><p><img src="/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC3%E7%AB%A0-ARM%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F2-%E7%AE%97%E6%9C%AF%E6%8C%87%E4%BB%A4/image-20230411012247213.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="FAKE"></p><p><img src="/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC3%E7%AB%A0-ARM%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F2-%E7%AE%97%E6%9C%AF%E6%8C%87%E4%BB%A4/image-20230411012253209.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="MLA"></p><blockquote><p> MLA   R0，R1，R2，R3 ；R0 &#x3D; R1 × R2 + R3</p><p>  MLAS R0，R1，R2，R3  ；R0 &#x3D; R1 × R2 + R3，同时设 置CPSR中的相关条件标志位</p></blockquote><p><img src="/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC3%E7%AB%A0-ARM%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F2-%E7%AE%97%E6%9C%AF%E6%8C%87%E4%BB%A4/image-20230411012307519.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="SMULL"></p><h4 id="3、-SMULL指令"><a href="#3、-SMULL指令" class="headerlink" title="3、 SMULL指令"></a>3、 SMULL指令</h4><ul><li>SMULL指令的格式为：<ul><li>SMULL{条件}{S}  目的寄存器Low，目的寄存器低High，操作数1，操作数2</li></ul></li><li>SMULL指令完成将操作数1与操作数2的乘法运算，并把结果的低32位放置到目的寄存器Low中，结果的高32位放置到目的寄存器High中，同时可以根据运算结果设置CPSR中相应的条件标志位。</li><li>其中，操作数1和操作数2均为32位的有符号数。</li></ul><p><img src="/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC3%E7%AB%A0-ARM%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F2-%E7%AE%97%E6%9C%AF%E6%8C%87%E4%BB%A4/image-20230411012534715.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="FAKE"></p><blockquote><pre><code class="hljs">            SMULL R0，R1，R2，R3       ；R0 = （R2 × R3）的低32位             ；R1 = （R2 × R3）的高32位           </code></pre></blockquote><p><img src="/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC3%E7%AB%A0-ARM%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F2-%E7%AE%97%E6%9C%AF%E6%8C%87%E4%BB%A4/image-20230411012553857.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="SMLAL"></p><h4 id="4、-SMLAL指令"><a href="#4、-SMLAL指令" class="headerlink" title="4、 SMLAL指令"></a>4、 SMLAL指令</h4><ul><li>SMLAL指令的格式为：<ul><li>SMLAL{条件}{S}  目的寄存器Low，目的寄存器低High，操作数1，操作数2</li></ul></li><li>SMLAL指令完成将操作数1与操作数2的乘法运算，并把结果的低32位同目的寄存器Low中的值相加后又放置到目的寄存器Low中，结果的高32位同目的寄存器High中的值相加后又放置到目的寄存器High中，同时可以根据运算结果设置CPSR中相应的条件标志位。<ul><li>其中，操作数1和操作数2均为32位的有符号数。</li></ul></li><li>对于目的寄存器Low，在指令执行前存放64位加数的低32位，指令执行后存放结果的低32位。</li><li>对于目的寄存器High，在指令执行前存放64位加数的高32位，指令执行后存放结果的高32位。</li></ul><p><img src="/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC3%E7%AB%A0-ARM%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F2-%E7%AE%97%E6%9C%AF%E6%8C%87%E4%BB%A4/image-20230411012629334.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="FAKE"></p><blockquote><pre><code class="hljs">         SMLAL R0，R1，R2，R3         ；R0 = （R2 × R3）的低32位 ＋ R0         ；R1 = （R2 × R3）的高32位 ＋ R1 ＋ C</code></pre></blockquote><p><img src="/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC3%E7%AB%A0-ARM%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F2-%E7%AE%97%E6%9C%AF%E6%8C%87%E4%BB%A4/image-20230411012644562.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="UMULL"></p><h4 id="5、-UMULL指令"><a href="#5、-UMULL指令" class="headerlink" title="5、 UMULL指令"></a>5、 UMULL指令</h4><ul><li>UMULL指令的格式为：<ul><li>UMULL{条件}{S}  目的寄存器Low，目的寄存器低High，操作数1，操作数2</li></ul></li><li>UMULL指令完成将操作数1与操作数2的乘法运算，并把结果的低32位放置到目的寄存器Low中，结果的高32位放置到目的寄存器High中，同时可以根据运算结果设置CPSR中相应的条件标志位。<ul><li>其中，操作数1和操作数2均为32位的无符号数。</li></ul></li></ul><p><img src="/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC3%E7%AB%A0-ARM%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F2-%E7%AE%97%E6%9C%AF%E6%8C%87%E4%BB%A4/image-20230411012719703.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="FAKE"></p><blockquote><pre><code class="hljs">UMULL R0，R1，R2，R3 </code></pre><p>；R0 &#x3D; （R2 × R3）的低32位<br>     ；R1 &#x3D; （R2 × R3）的高32位               </p></blockquote><p><img src="/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC3%E7%AB%A0-ARM%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F2-%E7%AE%97%E6%9C%AF%E6%8C%87%E4%BB%A4/image-20230411012735492.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="UMLAL"></p><h4 id="6、-UMLAL指令"><a href="#6、-UMLAL指令" class="headerlink" title="6、 UMLAL指令"></a>6、 UMLAL指令</h4><ul><li>UMLAL指令的格式为：<ul><li>UMLAL{条件}{S}  目的寄存器Low，目的寄存器低 High，操作数1，操作数2</li></ul></li><li>UMLAL指令完成将操作数1与操作数2的乘法运算，并把结果的低32位同目的寄存器Low中的值相加后又放置到目的寄存器Low中，结果的高32位同目的寄存器High中的值相加后又放置到目的寄存器High中，同时可以根据运算结果设置CPSR中相应的条件标志位。<ul><li>其中，操作数1和操作数2均为32位的无符号数。</li></ul></li><li>对于目的寄存器Low，在指令执行前存放64位加数的低32位，指令执行后存放结果的低32位。</li><li>对于目的寄存器High，在指令执行前存放64位加数的高32位，指令执行后存放结果的高32位。</li></ul><p><img src="/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC3%E7%AB%A0-ARM%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F2-%E7%AE%97%E6%9C%AF%E6%8C%87%E4%BB%A4/image-20230411012822316.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="FAKE"></p><blockquote><p> ​UMLAL R0，R1，R2，R3    </p><p>​  ；R0 &#x3D; （R2 × R3）的低32位 ＋ R0</p><p>​              ；R1 &#x3D; （R2 × R3）的高32位 ＋ R1 ＋C</p></blockquote><h2 id="课后练习"><a href="#课后练习" class="headerlink" title="课后练习"></a>课后练习</h2><p>用一条指令实现下列表达式：</p><ul><li>R2&#x3D;R1+R0</li><li>R2&#x3D;R1-64</li><li>R2&#x3D;32-R1</li><li>R5&#x3D;R5*R4 (32位乘法)</li><li>R5&#x3D;R4*R3+R2 (32位乘法)</li><li>R4&#x3D;R3+R2*16</li><li>R4&#x3D;5*R3</li><li>R4&#x3D;7*R3</li><li>分别将寄存器R2的bit8、bit7置位和清零。</li></ul>]]></content>
    
    
    <categories>
      
      <category>学习资料</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ARM体系结构与编程</tag>
      
      <tag>课件笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机组成原理-L06-Control_Unit</title>
    <link href="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L06-Control-Unit/"/>
    <url>/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L06-Control-Unit/</url>
    
    <content type="html"><![CDATA[<h1 id="计算机组成与实践-控制单元（Control-Unit）"><a href="#计算机组成与实践-控制单元（Control-Unit）" class="headerlink" title="计算机组成与实践 -控制单元（Control Unit）"></a><strong>计算机组成与实践</strong> -<strong>控制单元（</strong>Control Unit）</h1><h2 id="一-控制概述"><a href="#一-控制概述" class="headerlink" title="一.控制概述"></a>一.控制概述</h2><h4 id="数据通路中的控制"><a href="#数据通路中的控制" class="headerlink" title="数据通路中的控制"></a><strong>数据通路中的控制</strong></h4><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L06-Control-Unit/image-20230407005441946.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="数据通路"></p><p>ALU需要实现正确的运算</p><p>多个单元的信号来源有多种选择（寄存器、ALU、加法器、多选器、符号扩展、存储器等）</p><p>状态单元的写入需要写控制信号与时钟共同决定（寄存器、数据存储器）</p><h4 id="ALU控制单元"><a href="#ALU控制单元" class="headerlink" title="ALU控制单元"></a><strong>ALU控制单元</strong></h4><p>让各个单元实现正确的功能（运算、读、写）</p><p>控制数据流的来源（多选器）</p><p>上述控制信息来自于<strong>指令</strong></p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L06-Control-Unit/image-20230407005544125.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="R型"></p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L06-Control-Unit/image-20230407005558374.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="I型"></p><p>总结：</p><ul><li><strong>op</strong>字段在31~ 26位</li><li>源操作数寄存器<strong>rs</strong>和<strong>rt</strong>字段分别在25 - 21位和20 - 16位</li><li>lw和sw指令中的基址寄存器是<strong>rs</strong>（25~21位）</li><li>保存写回数据的寄存器有两个：<ul><li>lw指令：rt（20~16位）</li><li>R型指令：rd（15~11位）</li></ul></li><li>立即数字段（15~0位）</li></ul><h4 id="加入ALU控制单元"><a href="#加入ALU控制单元" class="headerlink" title="加入ALU控制单元"></a><strong>加入ALU控制单元</strong></h4><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L06-Control-Unit/image-20230407005633561.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="aluop"></p><p>主控制器产生ALUOp信号（2 bits）</p><p>ALU控制单元产生ALUcontrol信号（4 bits）</p><h2 id="二-ALU控制设计"><a href="#二-ALU控制设计" class="headerlink" title="二.ALU控制设计"></a>二.<strong>ALU控制设计</strong></h2><h4 id="ALU控制信号"><a href="#ALU控制信号" class="headerlink" title="ALU控制信号"></a><strong>ALU控制信号</strong></h4><p>由ALU控制单元生成的4位控制信号及其定义的操作</p><table><thead><tr><th align="center">ALU  control输入</th><th align="left"><strong>操作</strong></th></tr></thead><tbody><tr><td align="center">0000</td><td align="left">与</td></tr><tr><td align="center">0001</td><td align="left">或</td></tr><tr><td align="center">0010</td><td align="left">加</td></tr><tr><td align="center">0110</td><td align="left">减</td></tr><tr><td align="center">0111</td><td align="left">小于则置位</td></tr><tr><td align="center">1100</td><td align="left">或非</td></tr></tbody></table><h4 id="生成ALU控制信号"><a href="#生成ALU控制信号" class="headerlink" title="生成ALU控制信号"></a><strong>生成ALU控制信号</strong></h4><ul><li>由2 bits ALUOp和6 bits funct功能字段生成ALU控制信号</li><li>采用多级译码的方法<ul><li>主控制单元生成ALUOp信号（不使用11）</li><li>ALU控制单元生成ALUcontrol信号</li></ul></li></ul><table><thead><tr><th><strong>指令操作码</strong></th><th><strong>ALUOp</strong></th><th><strong>指令操作</strong></th><th>funct字段</th><th>ALU操作</th><th><strong>ALUcontrol</strong></th></tr></thead><tbody><tr><td>lw</td><td>00</td><td>lw</td><td>XXXXXX</td><td>add</td><td>0010</td></tr><tr><td>sw</td><td>00</td><td>sw</td><td>XXXXXX</td><td>add</td><td>0010</td></tr><tr><td>beq</td><td>01</td><td>beq</td><td>XXXXXX</td><td>subtract</td><td>0110</td></tr><tr><td>R类型</td><td>10</td><td>add</td><td>100000</td><td>add</td><td>0010</td></tr><tr><td>R类型</td><td>10</td><td>sub</td><td>100010</td><td>subtract</td><td>0110</td></tr><tr><td>R类型</td><td>10</td><td>and</td><td>100100</td><td>and</td><td>0000</td></tr><tr><td>R类型</td><td>10</td><td>or</td><td>100101</td><td>or</td><td>0001</td></tr><tr><td>R类型</td><td>10</td><td>slt</td><td>101010</td><td>slt</td><td>0111</td></tr></tbody></table><h4 id="ALU控制单元真值表"><a href="#ALU控制单元真值表" class="headerlink" title="ALU控制单元真值表"></a><strong>ALU控制单元真值表</strong></h4><table><thead><tr><th><strong>ALUOp</strong></th><th></th><th><strong>Funt字段</strong></th><th></th><th></th><th></th><th></th><th></th><th><strong>操作</strong></th></tr></thead><tbody><tr><td>ALUOp1</td><td>ALUOp0</td><td>F5</td><td>F4</td><td>F3</td><td>F2</td><td>F1</td><td>F0</td><td></td></tr><tr><td>0</td><td>0</td><td>X</td><td>X</td><td>X</td><td>X</td><td>X</td><td>X</td><td>0010</td></tr><tr><td>X</td><td>1</td><td>X</td><td>X</td><td>X</td><td>X</td><td>X</td><td>X</td><td>0110</td></tr><tr><td>1</td><td>X</td><td>X</td><td>X</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0010</td></tr><tr><td>1</td><td>X</td><td>X</td><td>X</td><td>0</td><td>0</td><td>1</td><td>0</td><td>0110</td></tr><tr><td>1</td><td>X</td><td>X</td><td>X</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0000</td></tr><tr><td>1</td><td>X</td><td>X</td><td>X</td><td>0</td><td>1</td><td>0</td><td>1</td><td>0001</td></tr><tr><td>1</td><td>X</td><td>X</td><td>X</td><td>1</td><td>0</td><td>1</td><td>0</td><td>0111</td></tr></tbody></table><p>X:表示与结果无关</p><h4 id="ALU控制逻辑实现"><a href="#ALU控制逻辑实现" class="headerlink" title="ALU控制逻辑实现"></a><strong>ALU控制逻辑实现</strong></h4><p>根据真值表实现的ALU控制单元逻辑</p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L06-Control-Unit/image-20230407010159515.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="真值表操作码"></p><h2 id="三-主控制单元的设计"><a href="#三-主控制单元的设计" class="headerlink" title="三.主控制单元的设计"></a>三.<strong>主控制单元的设计</strong></h2><p><strong>主控制信号</strong></p><p>控制信号源于指令</p><p>9位控制信号：7个1位控制信号和2位ALUOp信号</p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L06-Control-Unit/image-20230407010253871.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="9个信号"></p><h4 id="带主控制单元的数据通路"><a href="#带主控制单元的数据通路" class="headerlink" title="带主控制单元的数据通路"></a><strong>带主控制单元的数据通路</strong></h4><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L06-Control-Unit/image-20230407010317085.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="在寄存器前有一个控制单元发送这9信号"></p><h4 id="控制信号：执行R型指令"><a href="#控制信号：执行R型指令" class="headerlink" title="控制信号：执行R型指令"></a><strong>控制信号：执行R型指令</strong></h4><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L06-Control-Unit/image-20230407010448308.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="R-type"></p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L06-Control-Unit/image-20230407010659278.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="截图算了，做表格不方便看"></p><h4 id="控制信号：执行lw指令"><a href="#控制信号：执行lw指令" class="headerlink" title="控制信号：执行lw指令"></a><strong>控制信号：执行lw指令</strong></h4><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L06-Control-Unit/image-20230407010746946.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="load写回寄存器"></p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L06-Control-Unit/image-20230407010921530.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="注意比较不同"></p><h4 id="控制信号：执行sw指令"><a href="#控制信号：执行sw指令" class="headerlink" title="控制信号：执行sw指令"></a><strong>控制信号：执行sw指令</strong></h4><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L06-Control-Unit/image-20230407010907940.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="store"></p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L06-Control-Unit/image-20230407010936992.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="写入内存"></p><h4 id="控制信号：执行beq指令"><a href="#控制信号：执行beq指令" class="headerlink" title="控制信号：执行beq指令"></a><strong>控制信号：执行beq指令</strong></h4><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L06-Control-Unit/image-20230407011017842.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="相等则分支"></p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L06-Control-Unit/image-20230407011133607.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="branch项用于分支"></p><h4 id="主控制单元真值表"><a href="#主控制单元真值表" class="headerlink" title="主控制单元真值表"></a><strong>主控制单元真值表</strong></h4><table><thead><tr><th><strong>输入或输出</strong></th><th><strong>信号名</strong></th><th><strong>R型</strong></th><th><strong>lw</strong></th><th><strong>sw</strong></th><th><strong>beq</strong></th></tr></thead><tbody><tr><td><strong>输入</strong></td><td>Op5</td><td>0</td><td>1</td><td>1</td><td>0</td></tr><tr><td></td><td>Op4</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td></td><td>Op3</td><td>0</td><td>0</td><td>1</td><td>0</td></tr><tr><td></td><td>Op2</td><td>0</td><td>0</td><td>0</td><td>1</td></tr><tr><td></td><td>Op1</td><td>0</td><td>1</td><td>1</td><td>0</td></tr><tr><td></td><td>Op0</td><td>0</td><td>1</td><td>1</td><td>0</td></tr><tr><td><strong>输出</strong></td><td>RegDst</td><td>1</td><td>0</td><td>X</td><td>X</td></tr><tr><td></td><td>ALUSrc</td><td>0</td><td>1</td><td>1</td><td>0</td></tr><tr><td></td><td>MemtoReg</td><td>0</td><td>1</td><td>X</td><td>X</td></tr><tr><td></td><td>RegWrite</td><td>1</td><td>1</td><td>0</td><td>0</td></tr><tr><td></td><td>MemRead</td><td>0</td><td>1</td><td>0</td><td>0</td></tr><tr><td></td><td>MemWrite</td><td>0</td><td>0</td><td>1</td><td>0</td></tr><tr><td></td><td>Branch</td><td>0</td><td>0</td><td>0</td><td>1</td></tr><tr><td></td><td>ALUOp1</td><td>1</td><td>0</td><td>0</td><td>0</td></tr><tr><td></td><td>ALUOp0</td><td>0</td><td>0</td><td>0</td><td>1</td></tr></tbody></table><h4 id="主控制单元逻辑实现"><a href="#主控制单元逻辑实现" class="headerlink" title="主控制单元逻辑实现"></a><strong>主控制单元逻辑实现</strong></h4><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L06-Control-Unit/image-20230407011526078.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="梦回数电的图形"></p><h2 id="四-跳转的实现"><a href="#四-跳转的实现" class="headerlink" title="四.跳转的实现"></a>四.<strong>跳转的实现</strong></h2><blockquote><p><strong>回顾：跳转实现</strong></p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L06-Control-Unit/image-20230407011616025.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="j-type"></p><p>26 bits常数符号扩展成28 bits</p><p>用28 bits将PC+4的低28位替换</p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L06-Control-Unit/image-20230407011642921.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="偏移量换算地址"></p></blockquote><h4 id="课堂练习：带跳转的实现"><a href="#课堂练习：带跳转的实现" class="headerlink" title="课堂练习：带跳转的实现"></a><strong>课堂练习：带跳转的实现</strong></h4><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L06-Control-Unit/image-20230407011722940.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="练习，画出类似的表格"></p><h2 id="五-单时钟周期实现"><a href="#五-单时钟周期实现" class="headerlink" title="五.单时钟周期实现"></a>五.<strong>单时钟周期实现</strong></h2><ul><li>单时钟周期实现简单，适合小指令集</li><li>对于不同指令，不能使用不同时钟周期</li><li>最长延迟决定时钟周期</li><li>那种类型的指令执行最慢？</li></ul><h4 id="最慢的指令决定时钟周期"><a href="#最慢的指令决定时钟周期" class="headerlink" title="最慢的指令决定时钟周期"></a><strong>最慢的指令决定时钟周期</strong></h4><p>假设我们只关注指令运行中的：取指令、读寄存器、ALU运算、访问数据存储器、写回寄存器：</p><p>访问指令和数据存储器：4ns</p><p>ALU和加法器：2ns</p><p>访问寄存器：1ns</p><table><thead><tr><th>指令类型</th><th>取指令</th><th>读寄存器</th><th>ALU运算</th><th>访问数据存储器</th><th>写回寄存器</th><th>时间</th></tr></thead><tbody><tr><td>R型</td><td>4</td><td>1</td><td>2</td><td>0</td><td>1</td><td>8</td></tr><tr><td>lw</td><td>4</td><td>1</td><td>2</td><td>4</td><td>1</td><td><strong>12</strong></td></tr><tr><td>sw</td><td>4</td><td>1</td><td>2</td><td>4</td><td>0</td><td>11</td></tr><tr><td>beq</td><td>4</td><td>1</td><td>2</td><td>0</td><td>0</td><td>7</td></tr><tr><td>j</td><td>4</td><td>0</td><td>0</td><td>0</td><td>0</td><td>4</td></tr></tbody></table><h2 id="六-小结"><a href="#六-小结" class="headerlink" title="六.小结"></a>六.<strong>小结</strong></h2><ol><li>状态单元的写入需要写控制信号与时钟共同决定</li><li>ALU控制器采用多级译码的方法</li><li>主控制单元与数据通路共同实现指令的正确执行</li><li>单时钟周期实现效率低</li></ol>]]></content>
    
    
    <categories>
      
      <category>学习资料</category>
      
    </categories>
    
    
    <tags>
      
      <tag>课件笔记</tag>
      
      <tag>计算机组成原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>显卡突发错误-代码12的破除</title>
    <link href="/%E6%98%BE%E5%8D%A1%E7%AA%81%E5%8F%91%E9%94%99%E8%AF%AF-%E4%BB%A3%E7%A0%8112%E7%9A%84%E7%A0%B4%E9%99%A4/"/>
    <url>/%E6%98%BE%E5%8D%A1%E7%AA%81%E5%8F%91%E9%94%99%E8%AF%AF-%E4%BB%A3%E7%A0%8112%E7%9A%84%E7%A0%B4%E9%99%A4/</url>
    
    <content type="html"><![CDATA[<h2 id="一-前情提要"><a href="#一-前情提要" class="headerlink" title="一.前情提要"></a>一.前情提要</h2><p>今天我把之前买的p106-100又改了一下，用手锯锯掉原有的铝块部分，并且配上pdd 9.9包邮的太阳花580散热风扇，热管敲进去，凑出一张itx短卡来。（不过温控还有问题）</p><p><img src="/%E6%98%BE%E5%8D%A1%E7%AA%81%E5%8F%91%E9%94%99%E8%AF%AF-%E4%BB%A3%E7%A0%8112%E7%9A%84%E7%A0%B4%E9%99%A4/image-20230406235500626.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="有点越肩"></p><p><img src="/%E6%98%BE%E5%8D%A1%E7%AA%81%E5%8F%91%E9%94%99%E8%AF%AF-%E4%BB%A3%E7%A0%8112%E7%9A%84%E7%A0%B4%E9%99%A4/image-20230406235713836.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="标准双槽itx"></p><p>然后，下午另一张p106-90索泰短卡也到了，于是我搭上亮机卡r5 240分别上电脑装驱动测试了一遍。</p><p>本来我测好了就结束了，但是当我把3070插回电脑时意外就发生了。</p><h2 id="二-错误捏"><a href="#二-错误捏" class="headerlink" title="二.错误捏"></a>二.错误捏</h2><p>因为当时太急，忘了截图喵。简单描述一下：</p><p>dp线插显卡上开机，主板debug灯不报错，但是屏幕无输出。</p><p>在第二pcie*16插槽插上亮机卡，这下正常进系统了，点开gpuz一看，妈呀，显存信息什么的都没有了，大概就是这张图里bios信息无，uefi没打勾，显存类型无，显存大小0Mb,带宽什么的通通没有</p><p><img src="/%E6%98%BE%E5%8D%A1%E7%AA%81%E5%8F%91%E9%94%99%E8%AF%AF-%E4%BB%A3%E7%A0%8112%E7%9A%84%E7%A0%B4%E9%99%A4/image-20230407001908348.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="正常的情况"></p><p>下面两排打勾的也没有。</p><p>我打了下驱动，发现是可以打上的，安装驱动没有报错，但是当我按照提示重新开机时发现情况还是这样（不过驱动版本是正常的）。</p><p>我的第一反应是这卡是不是炸了，但一想，我啥也没做啊，只是取下来放一边再安装回去罢了。</p><p>又猜测是不是bios无了，这卡是双bios，换到silent bios结果还是一样。。。用nvflash工具也提示找不到显卡。。。</p><p>最后看设备管理器的错误提示，显示内容为–显卡：该设备找不到足够资源可以使用（代码12）</p><p><img src="/%E6%98%BE%E5%8D%A1%E7%AA%81%E5%8F%91%E9%94%99%E8%AF%AF-%E4%BB%A3%E7%A0%8112%E7%9A%84%E7%A0%B4%E9%99%A4/image-20230407002719295.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="正常的情况"></p><p>一般维修视频的报错都是代码43，可能是显存或者核心坏了，本来我都有点想托人去送保了，但看到这代码12或许有点搞头，便接着折腾了。</p><p>网上基本没什么资料，通通试了一遍，最后选择了一个看起来不知道原理的方法，在主板bios内，更改csm为uefi，就直接点亮了，驱动也不用再装，就是上次显卡读不出来时打上的（伏笔是吧），不用再把卡送去保修浪费时间了。。。</p><h2 id="三-结论"><a href="#三-结论" class="headerlink" title="三.结论"></a>三.结论</h2><p>1.家中常备亮机卡（新的亮机卡—一张Nv公版泰坦皮770正在路上）</p><p>2.老老实实开uefi，csm不知道为何出现这种兼容性问题</p><p>3.我换显卡的过程中，这套平台内存兼容性太差了（微星老主板+国产长鑫颗粒，经常卡cpu灯，而且我还是四条内存槽插满的，想要四条插上同时点亮还挺麻烦），解决方案，等14代或者8000系锐龙出了换一套全新板U上双条16g d5。</p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>矿卡</tag>
      
      <tag>P106</tag>
      
      <tag>魔改</tag>
      
      <tag>error</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机组成原理-L05-datapath</title>
    <link href="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L05-datapath/"/>
    <url>/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L05-datapath/</url>
    
    <content type="html"><![CDATA[<h1 id="计算机组成与实践-数据通路（Datapath）"><a href="#计算机组成与实践-数据通路（Datapath）" class="headerlink" title="计算机组成与实践 -数据通路（Datapath）"></a><strong>计算机组成与实践</strong> -<strong>数据通路（Datapath）</strong></h1><h2 id="一-指令执行概述"><a href="#一-指令执行概述" class="headerlink" title="一.指令执行概述"></a>一.<strong>指令执行概述</strong></h2><h3 id="处理器：指令执行"><a href="#处理器：指令执行" class="headerlink" title="处理器：指令执行"></a><strong>处理器：指令执行</strong></h3><p>MIPS的核心指令：</p><ul><li>数据传输指令：lw、sw</li><li>算术与逻辑运算指令： add、addu、addi、addiu、sub、subu、and、andi、or、ori、xor、xori、nor、slt、slti、sltu、sltiu</li><li>决策指令：beq、j</li></ul><p>指令执行：</p><ul><li>PC -&gt;取指令（更新PC）</li><li>指令译码，读取寄存器</li><li>执行指令</li></ul><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L05-datapath/image-20230405102613034.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="转换"></p><h3 id="指令实现的抽象图"><a href="#指令实现的抽象图" class="headerlink" title="指令实现的抽象图"></a><strong>指令实现的抽象图</strong></h3><p>核心指令子集实现的抽象视图，描述了主要功能单元及其连接</p><ul><li>单时钟周期实现</li><li>哈佛模型：指令存储和数据存储分开</li></ul><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L05-datapath/image-20230405102646260.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="指令实现"></p><h3 id="逻辑设计的一般方法"><a href="#逻辑设计的一般方法" class="headerlink" title="逻辑设计的一般方法"></a><strong>逻辑设计的一般方法</strong></h3><ul><li>二进制表示信息<ul><li>低电压&#x3D;0；高电压&#x3D;1</li><li>1bit一条线路</li><li>多个bit的数据编码为多条线路</li></ul></li><li>组合单元（Combinational Element）<ul><li>处理数据值的单元</li><li>输出只与输入相关，输入相同则输出也相同</li></ul></li><li>状态单元（State Element 或者 Sequential Element）<ul><li>存储信息</li><li>时钟信号</li></ul></li></ul><h3 id="组合单元"><a href="#组合单元" class="headerlink" title="组合单元"></a><strong>组合单元</strong></h3><p>AND-gate</p><p>Y &#x3D; A &amp; B</p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L05-datapath/image-20230405102928688.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="and"></p><p>Adder</p><p>Y &#x3D; A + B</p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L05-datapath/image-20230405102953250.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="adder"></p><p>Multiplexer</p><p>Y &#x3D; S ? I1 : I0</p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L05-datapath/image-20230405103012267.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="mult"></p><p>Arithmetic&#x2F;Logic Unit</p><p>Y &#x3D; F(A, B)</p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L05-datapath/image-20230405103035989.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="arith"></p><h3 id="时序单元（-Sequential-Element-）"><a href="#时序单元（-Sequential-Element-）" class="headerlink" title="时序单元（ Sequential Element ）"></a><strong>时序单元（</strong> <strong>Sequential Element</strong> <strong>）</strong></h3><ul><li>寄存器：能够存储数据的电路<ul><li>时钟信号决定何时更新存储的值</li><li>边缘触发：只允许在时钟跳变的边沿时改变存储的值</li></ul></li></ul><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L05-datapath/image-20230405103146841.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="寄存器时序"></p><ul><li>带写信号的寄存器<ul><li>当写信号有效时，才会在时钟边沿时更新存储的值</li><li>当存储的值稍后使用时</li></ul></li></ul><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L05-datapath/image-20230405103230598.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="write的寄存器"></p><h3 id="时钟方法（Clocking-Methodology）"><a href="#时钟方法（Clocking-Methodology）" class="headerlink" title="时钟方法（Clocking Methodology）"></a><strong>时钟方法（Clocking Methodology）</strong></h3><p>组合单元在时钟周期内对数据进行处理</p><ul><li>时钟边沿之间进行</li><li>输入来自状态单元，输出给状态单元</li><li>最长的延迟决定时钟周期时间</li></ul><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L05-datapath/image-20230405103326447.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="时钟循环"></p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L05-datapath/image-20230405103342806.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="简化版"></p><h2 id="二-取指令实现"><a href="#二-取指令实现" class="headerlink" title="二.取指令实现"></a>二.<strong>取指令实现</strong></h2><h3 id="建立取指令数据通路"><a href="#建立取指令数据通路" class="headerlink" title="建立取指令数据通路"></a>建立取指令数据通路</h3><p>数据通路（Datapath）</p><ul><li>处理或保存处理器中数据的单元<ul><li>数据通路部件：寄存器、ALU、多选器、存储器等</li></ul></li><li>取指令的数据通路:PC寄存器、指令存储器（instruction memory）、加法器</li></ul><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L05-datapath/image-20230405103449988.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="取指令"></p><blockquote><p>读PC值，获得指令的地址</p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L05-datapath/image-20230405103548919.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="读pc"></p><p>读指令存储器，获得指令</p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L05-datapath/image-20230405103619250.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="读指令存储器"></p><p>更新PC&#x3D;PC+4，与读指令同时完成</p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L05-datapath/image-20230405103659010.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="读指令的同时更新PC"></p></blockquote><h2 id="三-R型指令实现"><a href="#三-R型指令实现" class="headerlink" title="三.R型指令实现"></a>三.<strong>R型指令实现</strong></h2><p>R型指令：add、sub、slt、and、or</p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L05-datapath/image-20230405110907904.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="R"></p><ul><li>对寄存器rs和rt中的值进行运算（op和funct）</li><li>将结果写回到寄存器rd</li><li>使用写控制信号RegWrite</li></ul><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L05-datapath/image-20230405110938969.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="Rxin"></p><h4 id="R型指令：读寄存器"><a href="#R型指令：读寄存器" class="headerlink" title="R型指令：读寄存器"></a><strong>R型指令：读寄存器</strong></h4><p>根据rs和rt指令域获得寄存器地址（编号）</p><p>对所有类型的指令，寄存器的读端口处于激活状态</p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L05-datapath/image-20230405112049981.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="读寄存器"></p><h4 id="R型指令：ALU运算"><a href="#R型指令：ALU运算" class="headerlink" title="R型指令：ALU运算"></a><strong>R型指令：ALU运算</strong></h4><p>ALU根据控制信号（ALU operation）进行运算</p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L05-datapath/image-20230405112227712.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="alu"></p><h4 id="R型指令：写回"><a href="#R型指令：写回" class="headerlink" title="R型指令：写回"></a><strong>R型指令：写回</strong></h4><p>将ALU result写回寄存器</p><p>rd是目标寄存器地址（编号）</p><p>写控制信号RegWrite有效</p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L05-datapath/image-20230405112426529.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="写回"></p><blockquote><p><strong>思考slt指令</strong></p><p>要把0（或1）写回到$t0，0（或1）从哪里获得？</p><p>  <strong>slt</strong> $t0, $s0, $s1 #如果$s0&lt;$s1,则$t0&#x3D;1；           #否则$t0&#x3D;0</p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L05-datapath/image-20230405112509327.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="slt"></p></blockquote><h2 id="四-数据传输指令实现"><a href="#四-数据传输指令实现" class="headerlink" title="四.数据传输指令实现"></a><strong>四.数据传输指令实现</strong></h2><p>数据传输指令：lw和sw</p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L05-datapath/image-20230405112727073.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="I"></p><ul><li>通过基址寄存器（rs）的值加指令中16 bits的常数，计算存储器地址<ul><li>基址寄存器的值通过读寄存器获得</li><li>16 bits的常数经符号扩展单元，有符号扩展成32 bits的常数</li></ul></li><li><strong>lw</strong>指令：获得存储器地址后访问数据存储器，将值写回到目标寄存器（rt）</li><li><strong>sw</strong>指令：读取寄存器rt中的值，根据获得的存储器地址将该值存入数据存储器</li></ul><p>使用写控制信号MemWrite和读控制信号MemRead控制数据存储器的写入和读出</p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L05-datapath/image-20230405112818108.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="总"></p><h4 id="读寄存器和符号扩展"><a href="#读寄存器和符号扩展" class="headerlink" title="读寄存器和符号扩展"></a><strong>读寄存器和符号扩展</strong></h4><p>根据rs和rt指令域获得寄存器地址（编号），读寄存器rs和rt</p><p>16 bits符号扩展成32 bits</p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L05-datapath/image-20230405112905116.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="读寄存器"></p><h4 id="ALU计算地址"><a href="#ALU计算地址" class="headerlink" title="ALU计算地址"></a><strong>ALU计算地址</strong></h4><p>ALU计算存储器地址：基地址（rs的值）加32 bits立即数</p><p>寄存器rt中的值传输到数据存储器</p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L05-datapath/image-20230405112955664.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="alu"></p><h4 id="sw-访问数据存储器"><a href="#sw-访问数据存储器" class="headerlink" title="sw:访问数据存储器"></a><strong>sw:访问数据存储器</strong></h4><p>根据获得的存储器地址，将数据（rt）写入存储器</p><p>写控制信号MemWrite有效</p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L05-datapath/image-20230405113037530.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="访问数据"></p><h4 id="lw：访问数据存储器"><a href="#lw：访问数据存储器" class="headerlink" title="lw：访问数据存储器"></a><strong>lw：访问数据存储器</strong></h4><p>根据获得的存储器地址，从数据存储器读出数据</p><p>读控制信号MemRead有效</p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L05-datapath/image-20230405113114179.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="lw"></p><h4 id="lw-写回"><a href="#lw-写回" class="headerlink" title="lw:写回"></a><strong>lw:写回</strong></h4><p>rt是目标寄存器地址（编号）</p><p>写控制信号RegWrite有效</p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L05-datapath/image-20230405113207512.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="lw写回"></p><h2 id="五-分支指令实现"><a href="#五-分支指令实现" class="headerlink" title="五.分支指令实现"></a>五.<strong>分支指令实现</strong></h2><h3 id="条件分支指令实现"><a href="#条件分支指令实现" class="headerlink" title="条件分支指令实现"></a><strong>条件分支指令实现</strong></h3><p>条件分支指令：beq</p><ul><li><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L05-datapath/image-20230405113256834.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="I">****</li><li>根据rs和rt指令域获得寄存器地址（编号），读寄存器</li><li>ALU对两个值进行减法，结果为0则zero信号有效</li><li>16 bits的常数经符号扩展单元，有符号扩展成32 bits，然后左移2位转化成字地址（32 bits常数）</li><li>计算分支的目标地址：PC的值32 bits常数</li></ul><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L05-datapath/image-20230405113639194.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="条件分支"></p><h4 id="读寄存器和符号扩展-1"><a href="#读寄存器和符号扩展-1" class="headerlink" title="读寄存器和符号扩展"></a><strong>读寄存器和符号扩展</strong></h4><p>根据rs和rt指令域获得寄存器地址（编号），读寄存器rs和rt</p><p>16 bits符号扩展成32 bits</p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L05-datapath/image-20230405113708410.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="读寄存器"></p><h4 id="逻辑左移-amp"><a href="#逻辑左移-amp" class="headerlink" title="逻辑左移&amp;"></a><strong>逻辑左移&amp;</strong></h4><p>符号扩展后的32 bits常数左移2位转化成字地址</p><p>ALU执行减法：寄存器rs的值减寄存器rt的值</p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L05-datapath/image-20230405113737350.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="左移"></p><h4 id="分支判断-amp-目标地址计算"><a href="#分支判断-amp-目标地址计算" class="headerlink" title="分支判断&amp;目标地址计算"></a><strong>分支判断&amp;目标地址计算</strong></h4><p>ALU减法结果为0，则<strong>Zero</strong>信号有效，传输给分支控制单元（控制是否更新PC为分支目标地址）</p><p>加法器：PC+4加32 bits常数</p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L05-datapath/image-20230405113803225.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="分支判断计算"></p><h4 id="无条件分支实现"><a href="#无条件分支实现" class="headerlink" title="无条件分支实现"></a><strong>无条件分支实现</strong></h4><p>无条件分支指令：j</p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L05-datapath/image-20230405113845355.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="J"></p><p>26 bits常数符号扩展成28 bits</p><p>用28 bits将PC+4的低28位替换</p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L05-datapath/image-20230405113905077.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="🤣"></p><h2 id="六-完整数据通路实现"><a href="#六-完整数据通路实现" class="headerlink" title="六.完整数据通路实现"></a>六.<strong>完整数据通路实现</strong></h2><h4 id="创建完整的数据通路"><a href="#创建完整的数据通路" class="headerlink" title="创建完整的数据通路"></a><strong>创建完整的数据通路</strong></h4><ul><li>一个时钟周期执行一条指令<ul><li>时钟周期由最长执行线路决定</li></ul></li><li>将R型指令（算术逻辑指令）、存取指令和分支指令的数据通路中相同的部件重合</li><li>使用多选器实现多个数据源的选择</li><li>加入取指令的数据通路</li></ul><h4 id="加入多选器"><a href="#加入多选器" class="headerlink" title="加入多选器"></a><strong>加入多选器</strong></h4><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L05-datapath/image-20230405114002399.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="多选器"></p><p>ALU第二个操作数：寄存器或立即数</p><p>写回到寄存器的数据：ALU计算结果或数据存储器</p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L05-datapath/image-20230405114041191.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="操作"></p><h4 id="完整的数据通路实现"><a href="#完整的数据通路实现" class="headerlink" title="完整的数据通路实现"></a><strong>完整的数据通路实现</strong></h4><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L05-datapath/image-20230405114052009.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="image-20230405114052009"></p><h2 id="七-小结"><a href="#七-小结" class="headerlink" title="七.小结"></a><strong>七.小结</strong></h2><p>按照指令执行建立数据通路</p><p>独立的指令存储器和数据存储器</p><p>采用<strong>多选器</strong>实现多个数据源的选择</p>]]></content>
    
    
    <categories>
      
      <category>学习资料</category>
      
    </categories>
    
    
    <tags>
      
      <tag>课件笔记</tag>
      
      <tag>计算机组成原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ARM体系结构与编程-第3章-ARM微处理器的指令系统1-寻址方式</title>
    <link href="/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC3%E7%AB%A0-ARM%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F1-%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F/"/>
    <url>/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC3%E7%AB%A0-ARM%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F1-%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="ARM体系结构与编程"><a href="#ARM体系结构与编程" class="headerlink" title="ARM体系结构与编程"></a><strong>ARM体系结构与编程</strong></h1><p>本章的主要内容有：</p><ul><li>ARM指令集、Thumb指令集概述</li><li>ARM指令的寻址方式</li><li>ARM指令集的分类与具体应用</li><li>Thumb指令集简介及应用场合</li></ul><h2 id="3-1-ARM微处理器的指令集概述"><a href="#3-1-ARM微处理器的指令集概述" class="headerlink" title="3.1 ARM微处理器的指令集概述"></a>3.1 ARM微处理器的指令集概述</h2><h3 id="3-1-1-ARM微处理器的指令的分类与格式"><a href="#3-1-1-ARM微处理器的指令的分类与格式" class="headerlink" title="3.1.1 ARM微处理器的指令的分类与格式"></a>3.1.1 ARM微处理器的指令的分类与格式</h3><p>ARM微处理器的指令集是加载&#x2F;存储型的，也即指令集仅能处理寄存器中的数据，而且处理结果都要放回寄存器中，而对系统存储器的访问则需要通过专门的加载&#x2F;存储指令来完成。</p><p>ARM微处理器的指令集可以分为：</p><ul><li>跳转指令</li><li>数据处理指令</li><li>加载&#x2F;存储指令</li><li>程序状态寄存器（PSR）处理指令</li><li>协处理器指令</li><li>异常产生指令</li></ul><p>六大类，具体的指令及功能如下表所示（表中指令为基本ARM指令，不包括派生的ARM指令）。</p><p><strong>ARM指令及功能描述</strong> </p><table><thead><tr><th>助记符</th><th>指令功能描述</th></tr></thead><tbody><tr><td>ADC</td><td>带进位加法指令</td></tr><tr><td>ADD</td><td>加法指令</td></tr><tr><td>AND</td><td>逻辑与指</td></tr><tr><td>B</td><td>跳转指令</td></tr><tr><td>BIC</td><td>位清零指令</td></tr><tr><td>BL</td><td>带返回的跳转指</td></tr><tr><td>BLX</td><td>带返回和状态切换的跳转指令</td></tr><tr><td>BX</td><td>带状态切换的跳转指令</td></tr><tr><td>CDP</td><td>协处理器数据操作指令</td></tr></tbody></table><table><thead><tr><th>助记符</th><th>指令功能描述</th></tr></thead><tbody><tr><td>CMN</td><td>比较反值指令</td></tr><tr><td>CMP</td><td>比较指令</td></tr><tr><td>EOR</td><td>异或指令</td></tr><tr><td>LDC</td><td>存储器到协处理器的数据传输指令</td></tr><tr><td>LDM</td><td>加载多个寄存器指令</td></tr><tr><td>LDR</td><td>存储器到寄存器的数据传输指令</td></tr><tr><td>MCR</td><td>从ARM寄存器到协处理器寄存器的数据传输指令</td></tr><tr><td>MOV</td><td>数据传送指令</td></tr></tbody></table><table><thead><tr><th>助记符</th><th>指令功能描述</th></tr></thead><tbody><tr><td>MRC</td><td>从协处理器寄存器到ARM寄存器的数据传输指令</td></tr><tr><td>MRS</td><td>传送CPSR或SPSR的内容到通用寄存器指令</td></tr><tr><td>MSR</td><td>传送通用寄存器到CPSR或SPSR的指</td></tr><tr><td>MUL</td><td>32位乘法指</td></tr><tr><td>MLA</td><td>32位乘加指令</td></tr><tr><td>MVN</td><td>数据取反传送指令</td></tr><tr><td>ORR</td><td>逻辑或指令</td></tr><tr><td>RSB</td><td>逆向减法指令</td></tr><tr><td>RSC</td><td>带借位的逆向减法指令</td></tr></tbody></table><table><thead><tr><th>助记符</th><th>指令功能描述</th></tr></thead><tbody><tr><td>SBC</td><td>带借位减法指令</td></tr><tr><td>STC</td><td>协处理器寄存器写入存储器指</td></tr><tr><td>STM</td><td>批量内存字写入指令</td></tr><tr><td>STR</td><td>寄存器到存储器的数据传输指</td></tr><tr><td>SUB</td><td>减法指令</td></tr><tr><td>SWI</td><td>软件中断指令</td></tr><tr><td>SWP</td><td>交换指令</td></tr><tr><td>TEQ</td><td>相等测试指</td></tr><tr><td>TST</td><td>位测试指</td></tr></tbody></table><h4 id="ARM指令编码格式"><a href="#ARM指令编码格式" class="headerlink" title="ARM指令编码格式"></a>ARM指令编码格式</h4><p><img src="/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC3%E7%AB%A0-ARM%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F1-%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F/image-20230331125031434.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="arm"></p><p><strong>说明</strong></p><ul><li>Cond<ul><li>指令执行的条件编码</li></ul></li><li>Opcode<ul><li>指令操作符编码</li></ul></li><li>S<ul><li>决定指令的操作是否影响CPSR的值</li></ul></li><li>Rd<ul><li>操作目标寄存器编码</li></ul></li><li>Rn<ul><li>包含第一操作数的寄存器编码</li></ul></li><li><strong>Shifter_operand</strong><ul><li>表示第二操作数</li></ul></li></ul><h3 id="3-1-2-指令的条件域"><a href="#3-1-2-指令的条件域" class="headerlink" title="3.1.2 指令的条件域"></a>3.1.2 指令的条件域</h3><ul><li>当处理器工作在ARM状态时，几乎所有的指令均根据CPSR中条件码的状态和指令的条件域有条件的执行。当指令的执行条件满足时，指令被执行，否则指令被忽略。</li><li>每一条ARM指令包含4位的条件码，位于指令的最高4位[31:28]。条件码共有16种，每种条件码可用两个字符表示，这两个字符可以添加在指令助记符的后面和指令同时使用。<ul><li>例如，跳转指令B可以加上后缀EQ变为BEQ表示“相等则跳转”，即当CPSR中的Z标志置位时发生跳转。</li></ul></li><li>n在16种条件标志码中，只有15种可以使用，如表3-2所示，第16种（1111）为系统保留，暂时不能使用。</li></ul><h4 id="指令的条件码"><a href="#指令的条件码" class="headerlink" title="指令的条件码"></a><strong>指令的条件码</strong></h4><table><thead><tr><th>条件码</th><th>助记符后缀</th><th>标 志</th><th>含 义</th></tr></thead><tbody><tr><td>0000</td><td>EQ</td><td>Z置位</td><td>相等</td></tr><tr><td>0001</td><td>NE</td><td>Z清零</td><td>不相等</td></tr><tr><td>0010</td><td>CS</td><td>C置位</td><td>无符号数大于或等于</td></tr><tr><td>0011</td><td>CC</td><td>C清零</td><td>无符号数小于</td></tr><tr><td>0100</td><td>MI</td><td>N置位</td><td>负数</td></tr><tr><td>0101</td><td>PL</td><td>N清零</td><td>正数或零</td></tr><tr><td>0110</td><td>VS</td><td>V置位</td><td>溢出</td></tr><tr><td>0111</td><td>VC</td><td>V清零</td><td>未溢出</td></tr></tbody></table><table><thead><tr><th>条件码</th><th>助记符后缀</th><th>标 志</th><th>含 义</th></tr></thead><tbody><tr><td>1000</td><td>HI</td><td>C置位Z清零</td><td>无符号数大于</td></tr><tr><td>1001</td><td>LS</td><td>C清零Z置位</td><td>无符号数小于或等于</td></tr><tr><td>1010</td><td>GE</td><td>N等于V</td><td>带符号数大于或等于</td></tr><tr><td>1011</td><td>LT</td><td>N不等于V</td><td>带符号数小于</td></tr><tr><td>1100</td><td>GT</td><td>Z清零且（N等于V）</td><td>带符号数大于</td></tr><tr><td>1101</td><td>LE</td><td>Z置位或（N不等于V）</td><td>带符号数小于或等于</td></tr><tr><td>1110</td><td>AL</td><td>忽略</td><td>无条件执行</td></tr><tr><td>1111</td><td>NV</td><td></td><td>该指令从不执行</td></tr></tbody></table><p><img src="/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC3%E7%AB%A0-ARM%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F1-%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F/image-20230331125331854.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="explain"></p><h4 id="条件执行及标志位"><a href="#条件执行及标志位" class="headerlink" title="条件执行及标志位"></a>条件执行及标志位</h4><p>ARM指令可以通过添加适当的条件码后缀来达到条件执行的目的。</p><p>这样可以提高代码密度，减少分支跳转指令数目，提高性能。</p><p><img src="/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC3%E7%AB%A0-ARM%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F1-%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F/image-20230331125501422.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="汇编"></p><p>默认情况下，数据处理指令不影响条件码标志位，但可以选择通过添加“S”来影响标志位。 CMP不需要增加 “S”就可改变相应的标志位。</p><p><img src="/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC3%E7%AB%A0-ARM%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F1-%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F/image-20230331125531379.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="图"></p><h2 id="3-2-ARM指令的寻址方式"><a href="#3-2-ARM指令的寻址方式" class="headerlink" title="3.2 ARM指令的寻址方式"></a>3.2 ARM指令的寻址方式</h2><p>所谓<strong>寻址方式</strong>就是处理器根据指令中给出的地址信息来寻找物理地址的方式。目前ARM指令系统支持如下几种常见的寻址方式。</p><h3 id="3-2-1-立即寻址"><a href="#3-2-1-立即寻址" class="headerlink" title="3.2.1 立即寻址"></a>3.2.1 立即寻址</h3><p>立即寻址也叫立即数寻址，这是一种特殊的寻址方式，操作数本身就在指令中给出，只要取出指令也就取到了操作数。这个操作数被称为立即数，对应的寻址方式也就叫做立即寻址。例如以下指令：</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">ADD</span> <span class="hljs-built_in">R0</span>，<span class="hljs-built_in">R0</span>，＃<span class="hljs-number">1</span>          ；<span class="hljs-built_in">R0</span>←<span class="hljs-built_in">R0</span>＋<span class="hljs-number">1</span><br><span class="hljs-keyword">ADD</span> <span class="hljs-built_in">R0</span>，<span class="hljs-built_in">R0</span>，＃<span class="hljs-number">0x3f</span>       ；<span class="hljs-built_in">R0</span>←<span class="hljs-built_in">R0</span>＋<span class="hljs-number">0x3f</span><br></code></pre></td></tr></table></figure><p>在以上两条指令中，第二个源操作数即为立即数，要求以“＃”为前缀，对于以十六进制表示的立即数，还要求在“＃”后加上“0x”或“&amp;” ，另外％表示二进制数。</p><h4 id="立即数-1"><a href="#立即数-1" class="headerlink" title="立即数 (1)"></a>立即数 (1)</h4><p>没有任何一条ARM 指令可包括一个32 bit的立即数</p><p>所有的ARM指令都是32 bits固定长度</p><p>数据处理指令格式中，第二个操作数有12位</p><p><img src="/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC3%E7%AB%A0-ARM%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F1-%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F/image-20230331125714613.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="移位"></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Immed_8</span>=<span class="hljs-number">0</span>x3F,rotate_imm=<span class="hljs-number">0</span>xE<br><span class="hljs-attribute">or</span><br><span class="hljs-attribute">Immed_8</span>=<span class="hljs-number">0</span>xFC,rotate_imm=<span class="hljs-number">0</span>xF<br></code></pre></td></tr></table></figure><p>4 bit 移位值 (0-15)乘于2，得到一个范围在0-30，步长为 2的移位值。</p><p>记住一条准则： “<strong>最后8位一定要移动偶数位</strong>”.</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs avrasm">Quick Quiz:<br><span class="hljs-number">0x3F0</span>   <span class="hljs-meta">#???</span><br><span class="hljs-number">0xe3a004ff</span><br><span class="hljs-keyword">MOV</span> <span class="hljs-built_in">r0</span>, <span class="hljs-meta">#???</span><br></code></pre></td></tr></table></figure><h4 id="立即数-2"><a href="#立即数-2" class="headerlink" title="立即数 (2)"></a>立即数 (2)</h4><p>Examples:</p><p><img src="/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC3%E7%AB%A0-ARM%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F1-%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F/image-20230331125915297.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="立即数"></p><p>下列命令中，汇编器把立即数转换为移位操作：</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-keyword">MOV</span> <span class="hljs-built_in">r0</span>,<span class="hljs-meta">#4096 ; uses 0x40 ROR 26</span><br><span class="hljs-keyword">ADD</span> <span class="hljs-built_in">r1</span>,<span class="hljs-built_in">r2</span>,<span class="hljs-meta">#0xFF0000 ; uses 0xFF ROR 16</span><br></code></pre></td></tr></table></figure><p>也可使用 MVN来进行位反转:</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">MOV</span> <span class="hljs-built_in">r0</span>, #<span class="hljs-number">0xFFFFFFFF</span> <span class="hljs-comment">; assembles to MVN r0,#0</span><br></code></pre></td></tr></table></figure><p>使用无法用上述方法生成的数据，将产生错误。</p><h3 id="3-2-2-寄存器寻址"><a href="#3-2-2-寄存器寻址" class="headerlink" title="3.2.2 寄存器寻址"></a>3.2.2 寄存器寻址</h3><p>寄存器寻址就是利用寄存器中的数值作为操作数，这种寻址方式是各类微处理器经常采用的一种方式，也是一种执行效率较高的寻址方式。如下指令：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-keyword">ADD</span> <span class="hljs-built_in">R0</span>，<span class="hljs-built_in">R1</span>，<span class="hljs-built_in">R2</span>   ；<span class="hljs-built_in">R0</span>←<span class="hljs-built_in">R1</span>＋<span class="hljs-built_in">R2</span><br></code></pre></td></tr></table></figure><p>  该指令的执行效果是将寄存器R1和R2的内容相加，其结果存放在寄存器R0中。</p><h3 id="3-2-3-寄存器间接寻址"><a href="#3-2-3-寄存器间接寻址" class="headerlink" title="3.2.3 寄存器间接寻址"></a>3.2.3 寄存器间接寻址</h3><p>  寄存器间接寻址就是以寄存器中的值作为操作数的地址，而操作数本身存放在存储器中。例如以下指令：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-keyword">LDR</span>  <span class="hljs-built_in">R0</span>，[<span class="hljs-built_in">R1</span>]                 ；<span class="hljs-built_in">R0</span>←[<span class="hljs-built_in">R1</span>]<br><span class="hljs-keyword">STR</span>  <span class="hljs-built_in">R0</span>，[<span class="hljs-built_in">R1</span>]                 ；[<span class="hljs-built_in">R1</span>]←<span class="hljs-built_in">R0</span><br></code></pre></td></tr></table></figure><ul><li>第一条指令将以R1的值为地址的存储器中的数据传送到R0中。</li><li>第二条指令将R0的值传送到以R1的值为地址的存储器中</li></ul><h3 id="3-2-4-基址变址寻址"><a href="#3-2-4-基址变址寻址" class="headerlink" title="3.2.4 基址变址寻址"></a>3.2.4 基址变址寻址</h3><p>  基址变址寻址就是将寄存器（该寄存器一般称作<strong>基址寄存器</strong>）的内容与指令中给出的地址偏移量相加，从而得到一个操作数的有效地址。变址寻址方式常用于访问某基地址附近的地址单元。</p><p> 地址偏移量通常有以下三种表示方式</p><ul><li>常量</li><li>寄存器</li><li>比例（scaled）</li></ul><p>偏移寻址（offset addressing）</p><ul><li>LDR R0, [R1]</li><li>LDR R0, [R1, #4]</li><li>LDR R0, [R1, R2]</li><li>LDR R0, [R1, R2, LSL #2]</li></ul><p><img src="/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC3%E7%AB%A0-ARM%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F1-%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F/image-20230331132342992.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="示意图"></p><h4 id="地址的偏移（offset）"><a href="#地址的偏移（offset）" class="headerlink" title="地址的偏移（offset）"></a>地址的偏移（offset）</h4><p>使用一个绝对值不大于4095的数值，可使用带符号数，即在-4095~+4095之间； 如：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-keyword">LDR</span> <span class="hljs-built_in">R2</span>, [Rn, #-<span class="hljs-number">0x8</span>]<br></code></pre></td></tr></table></figure><p>使用对寄存器移位的方法计算偏移量；如：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-keyword">LDR</span> <span class="hljs-built_in">R2</span>, [Rn, <span class="hljs-built_in">R3</span>,<span class="hljs-keyword">LSL</span> <span class="hljs-number">#2</span>]<br></code></pre></td></tr></table></figure><p>使用寄存器偏移的方法计算偏移量；如：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-keyword">LDR</span> <span class="hljs-built_in">R2</span>, [Rn, -<span class="hljs-built_in">R3</span>]<br></code></pre></td></tr></table></figure><p>使用语句标号。如：</p><figure class="highlight tp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs tp">LDR <span class="hljs-keyword">R</span><span class="hljs-number">2</span>, <span class="hljs-literal">START</span>;<span class="hljs-keyword">R</span><span class="hljs-number">2</span>&lt;-[<span class="hljs-literal">START</span>]<br></code></pre></td></tr></table></figure><p>在这种寻址方式中，程序计算器PC是隐含的基址寄存器，偏移量是语句标号所在的地址和PC（当前正在执行的指令）之间的差值。</p><h4 id="事先更新寻址（pre-index-addressing）"><a href="#事先更新寻址（pre-index-addressing）" class="headerlink" title="事先更新寻址（pre-index addressing）"></a>事先更新寻址（pre-index addressing）</h4><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-keyword">LDR</span> <span class="hljs-built_in">R0</span>, [<span class="hljs-built_in">R1</span>, <span class="hljs-number">#4</span>]!<br><span class="hljs-keyword">LDR</span> <span class="hljs-built_in">R0</span>, [<span class="hljs-built_in">R1</span>, <span class="hljs-built_in">R2</span>]!<br><span class="hljs-keyword">LDR</span> <span class="hljs-built_in">R0</span>, [<span class="hljs-built_in">R1</span>, <span class="hljs-built_in">R2</span>, <span class="hljs-keyword">LSL</span> <span class="hljs-number">#2</span>]!<br></code></pre></td></tr></table></figure><p><img src="/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC3%E7%AB%A0-ARM%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F1-%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F/image-20230331132450905.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="示意图"></p><h4 id="事后更新寻址（Post-index-addressing）"><a href="#事后更新寻址（Post-index-addressing）" class="headerlink" title="事后更新寻址（Post-index addressing）"></a>事后更新寻址（Post-index addressing）</h4><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-keyword">LDR</span> <span class="hljs-built_in">R0</span>, [<span class="hljs-built_in">R1</span>], <span class="hljs-number">#4</span><br><span class="hljs-keyword">LDR</span> <span class="hljs-built_in">R0</span>, [<span class="hljs-built_in">R1</span>], <span class="hljs-built_in">R2</span><br><span class="hljs-keyword">LDR</span> <span class="hljs-built_in">R0</span>, [<span class="hljs-built_in">R1</span>], <span class="hljs-built_in">R2</span>, <span class="hljs-keyword">LSL</span> <span class="hljs-number">#2</span><br></code></pre></td></tr></table></figure><p><img src="/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC3%E7%AB%A0-ARM%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F1-%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F/image-20230331132516712.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="事后"></p><blockquote><p>Pre or Post Indexed 寻址?</p><p> Pre-indexed: <strong>STR r0,[r1,#12]!</strong></p><p><img src="/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC3%E7%AB%A0-ARM%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F1-%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F/image-20230331132544198.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="pre"></p><p> Post-indexed: <strong>STR r0,[r1],#12</strong></p><p><img src="/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC3%E7%AB%A0-ARM%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F1-%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F/image-20230331132611007.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="post"></p></blockquote><h4 id="数据移动寻址方式（data-movement-addressing-modes）"><a href="#数据移动寻址方式（data-movement-addressing-modes）" class="headerlink" title="数据移动寻址方式（data movement addressing modes）"></a>数据移动寻址方式（data movement addressing modes）</h4><p><img src="/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC3%E7%AB%A0-ARM%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F1-%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F/image-20230331133652648.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="data movement"></p><h4 id="内存寻址方式（memory-addressing-modes）"><a href="#内存寻址方式（memory-addressing-modes）" class="headerlink" title="内存寻址方式（memory addressing modes）"></a>内存寻址方式（memory addressing modes）</h4><p><img src="/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC3%E7%AB%A0-ARM%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F1-%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F/image-20230331133740763.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="内存寻址"></p><h3 id="3-2-5-多寄存器寻址"><a href="#3-2-5-多寄存器寻址" class="headerlink" title="3.2.5 多寄存器寻址"></a>3.2.5 多寄存器寻址</h3><p>采用多寄存器寻址方式，一条指令可以完成多个寄存器值的传送。这种寻址方式可以用一条指令完成传送最多16个通用寄存器的值。以下指令：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-keyword">LDMIA</span> <span class="hljs-built_in">R13</span>，&#123;<span class="hljs-built_in">R1</span>，<span class="hljs-built_in">R2</span>，<span class="hljs-built_in">R3</span>，<span class="hljs-built_in">R4</span>&#125;  <br>或写成：<span class="hljs-keyword">LDMIA</span> <span class="hljs-built_in">R13</span>，&#123;<span class="hljs-built_in">R1</span>-<span class="hljs-built_in">R4</span>&#125;  ；<span class="hljs-built_in">R1</span>←[<span class="hljs-built_in">R13</span>]<br>                                ；<span class="hljs-built_in">R2</span>←[<span class="hljs-built_in">R13</span>＋<span class="hljs-number">4</span>]<br>                                     ；<span class="hljs-built_in">R3</span>←[<span class="hljs-built_in">R13</span>＋<span class="hljs-number">8</span>]<br>                                    ；<span class="hljs-built_in">R4</span>←[<span class="hljs-built_in">R13</span>＋<span class="hljs-number">12</span>]<br></code></pre></td></tr></table></figure><p>该指令的后缀<strong>IA</strong>表示在每次执行完加载&#x2F;存储操作后，Rn按字长度增加，因此，指令可将连续存储单元的值传送到R1～R4。</p><p>指令中寄存器和内存单元的对应关系：<strong>编号低的寄存器对应于内存中低地址单元，编号高的寄存器对应于内存中高地址单元。</strong></p><h3 id="3-2-6-堆栈寻址"><a href="#3-2-6-堆栈寻址" class="headerlink" title="3.2.6 堆栈寻址"></a>3.2.6 堆栈寻址</h3><ul><li>堆栈是一种数据结构，按先进后出（First In Last Out，FILO）的方式工作，使用一个称作堆栈指针的专用寄存器指示当前的操作位置，堆栈指针总是指向栈顶。</li><li>当堆栈指针指向最后压入堆栈的数据时，称为<strong>满堆栈</strong>（Full Stack），而当堆栈指针指向下一个将要放入数据的空位置时，称为<strong>空堆栈</strong>（Empty Stack）</li></ul><p>同时，根据堆栈的生成方式，又可以分为<strong>递增堆栈</strong>（Ascending Stack）和<strong>递减堆栈</strong>（Decending Stack），当堆栈由低地址向高地址生成时，称为递增堆栈，当堆栈由高地址向低地址生成时，称为递减堆栈。这样就有四种类型的堆栈工作方式，ARM微处理器支持这四种类型的堆栈工作方式，即：</p><ul><li>满递增堆栈 (<strong>FA</strong>)：堆栈指针指向最后压入的数据，且由低地址向高地址生成。</li><li>满递减堆栈(<strong>FD</strong>) ：堆栈指针指向最后压入的数据，且由高地址向低地址生成。</li><li>空递增堆栈(<strong>EA</strong>) ：堆栈指针指向下一个将要放入数据的空位置，且由低地址向高地址生成。</li><li>空递减堆栈(<strong>ED</strong>) ：堆栈指针指向下一个将要放入数据的空位置，且由高地址向低地址生成</li></ul><p><img src="/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC3%E7%AB%A0-ARM%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F1-%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F/image-20230422215603754.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="A/D只是栈的方向不同，和放数据关系不大"></p><blockquote><p>此处我个人易混，放一个别人的<a href="https://www.cnblogs.com/fanzhidongyzby/p/5250116.html">链接</a></p></blockquote><h3 id="3-2-7-块拷贝寻址"><a href="#3-2-7-块拷贝寻址" class="headerlink" title="3.2.7 块拷贝寻址"></a>3.2.7 块拷贝寻址</h3><ul><li>多寄存器传送指令用于将一块数据从存储器的某一位置拷贝到另一位置。 如：STMIA R0!,{R1-R7} ; 将R1～R7的数据保存到存储器中。</li><li>IA (increment after)  事后递增方式</li><li>IB (increment before)  事先递增方式</li><li>DA (decrement after)  事后递减方式</li><li>DB (decrement before)  事先递减方式</li></ul><p>批量load&#x2F;store指令可以实现在一组寄存器和一块连续的内存单元之间传输数据。例如：</p><p>LDMIA R13,{R5-R8} ;将内存单元（R13）到（R13+12）4个数据读取到R5-R8的4个寄存器中。</p><h3 id="3-2-8-相对寻址"><a href="#3-2-8-相对寻址" class="headerlink" title="3.2.8 相对寻址"></a>3.2.8 相对寻址</h3><p>与基址变址寻址方式相类似，相对寻址是基址寻址的一种变通。</p><p>相对寻址以程序计数器PC的当前值为基地址，指令中的地址标号作为偏移量，将两者相加之后得到操作数的有效地址。以下程序段完成子程序的调用和返回，跳转指令BL采用了相对寻址方式：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-keyword">BL</span>  NEXT      ；跳转到子程序NEXT处执行<br>……                         <br><span class="hljs-symbol">NEXT</span>；跳转地址：<span class="hljs-built_in">PC</span>+NEXT<br>……                             <br><span class="hljs-keyword">MOV</span>  <span class="hljs-built_in">PC</span>，<span class="hljs-built_in">LR</span>        ；从子程序返回<br></code></pre></td></tr></table></figure><h2 id="课后练习"><a href="#课后练习" class="headerlink" title="课后练习"></a>课后练习</h2><p>下面哪些立即数是数据处理指令中有效的数据? 并分别写出指令编码中的立即数和循环移位的位数。</p><p> <strong>a) 0x0000ef00    b) 0x00011113</strong>    </p><p> <strong>c) 0xf0000009   d) 0x08000012</strong>   </p><p> <strong>e) 0x00001280    f) 0xffffffff</strong></p><p> <strong>g) 0x00ab0000    h) 0x0001ffff</strong>    </p><p> <strong>i) 0xf000001a   j) 0x08000012</strong>   </p><p> <strong>k) 0x00001f80    l) 0xf0f0f0f0</strong></p><p> STMFD sp!, {R0-R5,LR}是一条批量存储指令，画出该指令执行前后内存中数据存放及栈指针变化情况，并简述该指令的操作过程。</p>]]></content>
    
    
    <categories>
      
      <category>学习资料</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ARM体系结构与编程</tag>
      
      <tag>课件笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机组成原理-L04-performance</title>
    <link href="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L04-performance/"/>
    <url>/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L04-performance/</url>
    
    <content type="html"><![CDATA[<h1 id="计算机组成与实践-计算机的性能（Performance）"><a href="#计算机组成与实践-计算机的性能（Performance）" class="headerlink" title="计算机组成与实践 -计算机的性能（Performance）"></a><strong>计算机组成与实践</strong> -<strong>计算机的性能（Performance）</strong></h1><h2 id="一-性能的定义"><a href="#一-性能的定义" class="headerlink" title="一.性能的定义"></a>一.<strong>性能的定义</strong></h2><h3 id="性能"><a href="#性能" class="headerlink" title="性能"></a><strong>性能</strong></h3><ul><li>购买计算机<ul><li>最好的性能？</li><li>最小开销？</li></ul></li><li>设计计算机<ul><li>最大程度提升性能？</li><li>降低计算机开销？</li><li>均衡性能与开销？</li></ul></li></ul><h3 id="计算机性能对比"><a href="#计算机性能对比" class="headerlink" title="计算机性能对比"></a><strong>计算机性能对比</strong></h3><blockquote><p>处理器：第10代 i7-10700K，  (8-核,16MB 缓存, 基本频率3.80 GHz，最高睿频 5.1GHz）</p><p>存储器：256GB 固态硬盘 + 1TB </p><p>内存： 16GB，可扩展到64GB </p><p>显卡： NVIDIA® GeForce® GTX 6GB</p><p>价格：15999</p></blockquote><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L04-performance/image-20230330223406122.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="几年前的外星人Alienware Aurora R11(ALWS-R6726KB)，显卡是GTX1660ti"></p><blockquote><p>处理器：支持双Xeon处理器，Xeon 3204，  (6核, 8.25MB 缓存, 1.9GHz）</p><p>存储器：256GB 固态硬盘 + 1TB </p><p>内存： 16GB，可支持高达768GB </p><p>显卡： NVIDIA® Quadro® P1000 4G</p><p>价格：15999</p></blockquote><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L04-performance/image-20230330223445232.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="服务器加专业图形显卡"></p><blockquote><p>处理器：5000系锐龙，Ryzen 5 5600，  (6核,32MB 缓存, 基础频率3.5GHz，最大加速时钟4.4GHz）</p><p>存储器：1T 固态硬盘 + 4TB </p><p>内存： 32GB，可支持高达128GB </p><p>显卡： NVIDIA®  GeForce® RTX 3070 8GB</p><p>价格：&lt;6000</p></blockquote><h3 id="响应时间和吞吐率"><a href="#响应时间和吞吐率" class="headerlink" title="响应时间和吞吐率"></a><strong>响应时间和吞吐率</strong></h3><table><thead><tr><th align="left">响应时间（Response Time）</th></tr></thead><tbody><tr><td align="left">完成一项任务所需要花费的时间，也称为<strong>执行时间</strong>，包括硬盘访问、内存访问、I&#x2F;O活动、操作系统开销和CPU执行时间等</td></tr><tr><td align="left">对用户重要</td></tr></tbody></table><table><thead><tr><th>吞吐率（Throughput）</th></tr></thead><tbody><tr><td>在一定的时间内完成任务的总量</td></tr><tr><td>带宽(Bandwidth)，在单位时间内完成任务的总量</td></tr><tr><td>对云服务提供商重要</td></tr></tbody></table><p>针对不同的用户和应用，性能的度量也不同</p><h3 id="性能的定义"><a href="#性能的定义" class="headerlink" title="性能的定义"></a><strong>性能的定义</strong></h3><ul><li>性能&#x3D;1&#x2F;执行时间</li><li>“X性能是Y性能的n倍”</li></ul><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L04-performance/image-20230330232529657.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="公式"></p><blockquote><p>例1：计算机A运行一个程序需要10秒，计算机B运行同样的程序需要15秒，那么A的性能是B的多少倍？</p><p>Ans:执行时间B&#x2F;执行时间A&#x3D;15s&#x2F;10s&#x3D;1.5</p><p>​       A的性能是B的1.5倍</p></blockquote><p><strong>降低执行时间通常会提升吞吐量</strong></p><h2 id="二-CPU性能及其因素"><a href="#二-CPU性能及其因素" class="headerlink" title="二.CPU性能及其因素"></a>二.CPU性能及其因素</h2><h3 id="性能的度量"><a href="#性能的度量" class="headerlink" title="性能的度量"></a><strong>性能的度量</strong></h3><p>CPU时间(CPU Execution Time)</p><ul><li>在CPU上花费的时间，不包括等待I&#x2F;O或运行其他程序的时间</li><li>可分为用户CPU时间(User CPU Time)和系统CPU时间(System CPU Time)</li></ul><p>响应时间→系统性能(System Performance)</p><p>用户CPU时间→CPU性能(CPU Performance)</p><table><thead><tr><th><strong>计算机设计者</strong></th></tr></thead><tbody><tr><td>考虑如何度量计算机硬件完成基本功能的速度</td></tr><tr><td>时钟</td></tr></tbody></table><h3 id="时钟"><a href="#时钟" class="headerlink" title="时钟"></a><strong>时钟</strong></h3><p>计算机中以时钟来触发硬件执行各种事件</p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L04-performance/image-20230330232736302.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="时钟图"></p><ul><li>时钟周期（Clock Cycle）：时钟间隔的时间<ul><li>例如，250ps&#x3D;0.25ns&#x3D;250×10^–12s</li></ul></li><li>时钟频率（Clock Rate）：时钟周期的倒数<ul><li>例如，4.0GHz &#x3D; 4000MHz &#x3D; 4.0×10^9Hz</li></ul></li></ul><h4 id="CPU时间"><a href="#CPU时间" class="headerlink" title="CPU时间"></a><strong>CPU时间</strong></h4><blockquote><p>CPU时间&#x3D;CPU时钟周期数×时钟周期时间&#x3D;CPU时钟周期数&#x2F;时钟频率</p></blockquote><table><thead><tr><th><strong>提高性能的方式</strong></th></tr></thead><tbody><tr><td>减少一个程序的CPU时钟周期数</td></tr><tr><td>提高时钟频率</td></tr><tr><td>硬件设计者需要权衡时钟周期数和时钟频率</td></tr></tbody></table><blockquote><p><strong>例2</strong></p><p>计算机A的时钟频率为2GHz，某程序在A上运行的CPU时间是10s，如果目标时钟在计算机B上运行的CPU时间为6s，那么B的时钟频率应该为多少才能使该程序在B上运行的时钟周期数是A上的1.2倍？</p><p>时钟周期数A&#x3D;CPU时间A×时钟频率A</p><p>​          &#x3D;10s×2 GHz&#x3D;20×10^9</p><p>时钟频率B&#x3D;时钟周期数B&#x2F;CPU时间B</p><p>​        &#x3D;（1.2×时钟周期数A）&#x2F; 6s</p><p>​        &#x3D;（1.2×20×10^9）&#x2F; 6s&#x3D;4 GHz</p></blockquote><h4 id="指令的性能"><a href="#指令的性能" class="headerlink" title="指令的性能"></a><strong>指令的性能</strong></h4><p>通过程序的指令数和指令的平均时钟周期数获得</p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L04-performance/image-20230330233007410.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="!"></p><ul><li>程序的指令数量</li><li>指令的平均时钟周期数（Clock cycles per instruction, CPI）：<ul><li>如果不同指令有不同的CPI，采用加权平均CPI</li><li>比较相同ISA下的，不同实现方式的性能</li></ul></li></ul><h4 id="CPI的计算"><a href="#CPI的计算" class="headerlink" title="CPI的计算"></a><strong>CPI的计算</strong></h4><p>如果执行不同类型的指令需要不同的时钟周期数</p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L04-performance/image-20230330233154761.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="时钟周期"></p><p>加权平均CPI</p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L04-performance/image-20230330233209102.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="CPI"></p><h4 id="经典的CPU性能公式"><a href="#经典的CPU性能公式" class="headerlink" title="经典的CPU性能公式"></a><strong>经典的CPU性能公式</strong></h4><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L04-performance/image-20230330233230656.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="classic"></p><table><thead><tr><th><strong>影响性能的三个关键因素</strong></th></tr></thead><tbody><tr><td>减少时钟周期时间或增加时钟频率（Intel Core i7的Turbo  mode睿频，暂时将时钟频率提高10%）</td></tr><tr><td>减少指令数</td></tr><tr><td>减少CPI</td></tr></tbody></table><blockquote><p>例3</p><p>计算机A：时钟周期时间&#x3D;250ps，CPI&#x3D;2.0</p><p>计算机B：时钟周期时间&#x3D;500ps，CPI&#x3D;1.2</p><p>相同ISA，相同程序，哪台计算机执行的速度快？快多少？</p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L04-performance/image-20230330233343912.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="ans"></p></blockquote><h4 id="理解程序性能"><a href="#理解程序性能" class="headerlink" title="理解程序性能"></a><strong>理解程序性能</strong></h4><table><thead><tr><th><strong>硬件或软件指标</strong></th><th><strong>指令数</strong></th><th><strong>CPI</strong></th><th><strong>时钟周期时间</strong></th></tr></thead><tbody><tr><td>算法</td><td><strong>√</strong></td><td><strong>√</strong></td><td></td></tr><tr><td>编程语言</td><td><strong>√</strong></td><td><strong>√</strong></td><td></td></tr><tr><td>编译程序</td><td><strong>√</strong></td><td><strong>√</strong></td><td></td></tr><tr><td>ISA</td><td><strong>√</strong></td><td><strong>√</strong></td><td><strong>√</strong></td></tr></tbody></table><h4 id="基准测试程序"><a href="#基准测试程序" class="headerlink" title="基准测试程序"></a><strong>基准测试程序</strong></h4><table><thead><tr><th>基准测试程序(benchmark)</th></tr></thead><tbody><tr><td>一组专门用于测量性能的程序</td></tr><tr><td>这些测试程序形成负载，用户期望预测实际负载的性能</td></tr></tbody></table><p>SPEC (system performance evaluation cooperative)是为现代计算机系统建立的基准测试程序集</p><p>目前最新的是SPEC CPU2006 ，包括12 个整数基准程序集(ClNT 2006)和17 个浮点基准程序集(CFP 2006)</p><p><a href="http://www.spec.org/">www.spec.org</a></p><blockquote><p>个人超频跑分可以试试cpu-z，3dmark</p></blockquote><p><strong>CINT2006 for Intel Core i7 920</strong></p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L04-performance/image-20230330233530357.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="i7 920"></p><p>将被测计算机的执行时间标准化，即将被测计算机的执行时间除以一个参考处理器的执行时间，结果称为SPEC ratio</p><p>几何平均数（GM）</p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L04-performance/image-20230330233546302.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="GM"></p><h1 id="三-小结"><a href="#三-小结" class="headerlink" title="三.小结"></a>三.小结</h1><ul><li><strong>执行时间</strong>是唯一有效且不可推翻的性能度量方法</li><li>可靠的测量性能的方法</li></ul><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L04-performance/image-20230330233619552.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="公式"></p>]]></content>
    
    
    <categories>
      
      <category>学习资料</category>
      
    </categories>
    
    
    <tags>
      
      <tag>课件笔记</tag>
      
      <tag>计算机组成原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ARM体系结构与编程-第2章-ARM微处理器的编程模型</title>
    <link href="/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC2%E7%AB%A0-ARM%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%9E%8B/"/>
    <url>/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC2%E7%AB%A0-ARM%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="本章的主要内容"><a href="#本章的主要内容" class="headerlink" title="本章的主要内容"></a>本章的主要内容</h1><ul><li>ARM微处理器的工作状态</li><li>ARM体系结构的存储器格式</li><li>ARM微处理器的指令长度及数据类型</li><li>ARM微处理器的工作模式</li><li>ARM体系结构的寄存器组织</li><li>ARM微处理器的异常状态</li></ul><p><img src="/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC2%E7%AB%A0-ARM%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%9E%8B/image-20230328120234122.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="model"></p><p><img src="/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC2%E7%AB%A0-ARM%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%9E%8B/image-20230328120244418.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="armcoding"></p><blockquote><p>在开始本章之前，首先对字（Word）、半字（Half-Word）、字节（Byte）的概念作一个说明：</p><p>**字(Word) **：在ARM体系结构中，字的长度为32位，而在8位&#x2F;16位处理器体系结构中，字的长度一般为16位。</p><p><strong>半字（Half-Word）</strong>：在ARM体系结构中，半字的长度为16位，与8位&#x2F;16位处理器体系结构中字的长度一致。</p><p><strong>字节（Byte）</strong>：在ARM体系结构和8位&#x2F;16位处理器体系结构中，字节的长度均为8位。</p><p><img src="/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC2%E7%AB%A0-ARM%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%9E%8B/image-20230328120400293.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="概述"></p></blockquote><h1 id="2-1-ARM微处理器的工作状态"><a href="#2-1-ARM微处理器的工作状态" class="headerlink" title="2.1 ARM微处理器的工作状态"></a>2.1 ARM微处理器的工作状态</h1><ul><li>从编程的角度看，ARM微处理器的工作状态一般有两种，并可在两种状态之间切换：<ul><li>第一种为<strong>ARM状态</strong>，此时处理器执行32位的字对齐的ARM指令；</li><li>第二种为<strong>Thumb状态</strong>，此时处理器执行16位的半字对齐的Thumb指令。</li></ul></li><li>当ARM微处理器执行32位的ARM指令集时，工作在ARM状态；</li><li>当ARM微处理器执行16位的Thumb指令集时，工作在Thumb状态。</li><li>在程序的执行过程中，微处理器可以随时在两种工作状态之间切换，并且，<strong>处理器工作状态的转变并不影响处理器的工作模式和相应寄存器中的内容。</strong></li></ul><h4 id="状态切换方法："><a href="#状态切换方法：" class="headerlink" title="状态切换方法："></a>状态切换方法：</h4><ul><li>ARM指令集和Thumb指令集均有切换处理器状态的指令，并可在两种工作状态之间切换，但ARM微处理器在开始执行代码时，应该处于ARM状态。</li><li>进入Thumb状态：当操作数寄存器的状态位（位0）为1时，可以采用执行BX指令的方法，使微处理器从ARM状态切换到Thumb状态。<ul><li>此外，当处理器处于Thumb状态时发生异常（如IRQ、FIQ、Undef、Abort、SWI等），则异常处理返回时，自动切换到Thumb状态。</li></ul></li><li>进入ARM状态：当操作数寄存器的状态位为0时，执行BX指令时可以使微处理器从Thumb状态切换到ARM状态。<ul><li>此外，在处理器进行异常处理时，把PC指针放入异常模式链接寄存器中，并从异常向量地址开始执行程序，也可以使处理器切换到ARM状态。</li></ul></li></ul><p><img src="/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC2%E7%AB%A0-ARM%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%9E%8B/image-20230328120611456.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="bx指令"></p><h1 id="2-2-ARM体系结构的存储器格式"><a href="#2-2-ARM体系结构的存储器格式" class="headerlink" title="2.2 ARM体系结构的存储器格式"></a>2.2 ARM体系结构的存储器格式</h1><ul><li><p>ARM体系结构将存储器看作是从零地址开始的字节的线性组合。从零字节到三字节放置第一个存储的字数据，从第四个字节到第七个字节放置第二个存储的字数据，依次排列。作为32位的微处理器，<strong>ARM体系结构所支持的最大寻址空间为4GB（2^32字节)</strong>.</p></li><li><p>ARM体系结构可以用两种方法存储字数据，称之为<strong>大端格式</strong>和<strong>小端格式</strong>，具体说明如下：</p></li><li><p>大端格式:</p><p>在这种格式中，字数据的高字节存储在低地址中，而字数据的低字节则存放在高地址中，如图所示：</p></li></ul><p><img src="/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC2%E7%AB%A0-ARM%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%9E%8B/image-20230328120733613.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="bigend"></p><ul><li>小端格式</li></ul><p> 与大端存储格式相反，在小端存储格式中，低地址中存放的是字数据的低字节，高地址存放的是字数据的高字节。如图所示：</p><p><img src="/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC2%E7%AB%A0-ARM%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%9E%8B/image-20230328120749619.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="smallend"></p><h1 id="2-3-指令长度及数据类型"><a href="#2-3-指令长度及数据类型" class="headerlink" title="2.3 指令长度及数据类型"></a>2.3 指令长度及数据类型</h1><p>ARM微处理器的指令长度可以是32位（在ARM状态下），也可以为16位（在Thumb状态下）。</p><ul><li>ARM微处理器中支持三种数据类型：<ul><li>字节（8位）</li><li>半字（16位）</li><li>字（32位） </li><li><img src="/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC2%E7%AB%A0-ARM%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%9E%8B/image-20230328121040800.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="word"></li><li>其中，字需要4字节对齐（地址的低两位为0）、半字需要2字节对齐（地址的最低位为0）。</li></ul></li></ul><h1 id="2-4-处理器模式"><a href="#2-4-处理器模式" class="headerlink" title="2.4 处理器模式"></a>2.4 处理器模式</h1><ul><li><p>ARM微处理器支持7种运行模式，分别为：</p><ul><li>用户模式（usr）：ARM处理器正常的程序执行状态</li><li>快速中断模式（fiq）：用于高速数据传输或通道处理</li><li>外部中断模式（irq）：用于通用的中断处理</li><li>管理模式（svc）：操作系统使用的保护模式（复位或软中断）</li><li>数据访问终止模式(abt)：当数据或指令预取终止时进入该模式，可用于虚拟存储及存储保护。</li><li>系统模式（sys）：运行具有特权的操作系统任务。</li><li>未定义指令中止模式（und）：当未定义的指令执行时进入该模式，可用于支持硬件协处理器的软件仿真。</li></ul></li><li><p>ARM微处理器的运行模式可以通过软件改变，也可以通过外部中断或异常处理改变。</p></li><li><p>大多数的应用程序运行在用户模式下，当处理器运行在用户模式下时，某些被保护的系统资源是不能被访问的。</p></li><li><p>除用户模式以外，其余的所有6种模式称之为非用户模式，或<strong>特权模式</strong>（Privileged Modes）；其中除去用户模式和系统模式以外的5种又称为<strong>异常模式</strong>（Exception Modes），常用于处理中断或异常，以及需要访问受保护的系统资源等情况。</p></li></ul><h1 id="2-5-寄存器组织"><a href="#2-5-寄存器组织" class="headerlink" title="2.5 寄存器组织"></a>2.5 寄存器组织</h1><p>ARM微处理器共有37个32位寄存器，其中31个为通用寄存器，6个为状态寄存器。但是这些寄存器不能被同时访问，具体哪些寄存器是可编程访问的，取决微处理器的工作状态及具体的运行模式。</p><p>但在任何时候，通用寄存器R0～R14、程序计数器PC、一个或两个状态寄存器都是可访问的。</p><h2 id="2-5-1-ARM状态下的寄存器组织"><a href="#2-5-1-ARM状态下的寄存器组织" class="headerlink" title="2.5.1 ARM状态下的寄存器组织"></a>2.5.1 ARM状态下的寄存器组织</h2><p>通用寄存器：</p><p> 通用寄存器包括R0～R15，可以分为三类：</p><ul><li>未分组寄存器R0～R7</li><li>分组寄存器R8～R14(备份寄存器)</li><li>程序计数器PC(R15)</li></ul><h5 id="未分组寄存器R0～R7："><a href="#未分组寄存器R0～R7：" class="headerlink" title="未分组寄存器R0～R7："></a>未分组寄存器R0～R7：</h5><p> <strong>在所有的运行模式下，未分组寄存器都指向同一个物理寄存器</strong>，他们未被系统用作特殊的用途，因此，在中断或异常处理进行运行模式转换时，由于不同的处理器运行模式均使用相同的物理寄存器，可能会造成寄存器中数据的破坏，这一点在进行程序设计时应引起注意。</p><h5 id="分组寄存器R8～R14："><a href="#分组寄存器R8～R14：" class="headerlink" title="分组寄存器R8～R14："></a>分组寄存器R8～R14：</h5><p> <strong>对于分组寄存器，每一次所访问的物理寄存器与处理器当前的运行模式有关</strong>。</p><p><strong>对于</strong>R8～R12<strong>来说，每个寄存器对应两个不同的物理寄存器</strong>，当使用fiq模式时，访问寄存器R8_fiq～R12_fiq；当使用除fiq模式以外的其他模式时，访问寄存器R8_usr～R12_usr</p><p><img src="/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC2%E7%AB%A0-ARM%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%9E%8B/image-20230328121353354.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="arm寄存器"></p><ul><li><p>ARM 有37个32-Bits长的寄存器.</p><ul><li>1 个用作PC</li><li>1个用作CPSR</li><li>5个用作SPSR</li><li>30 个通用寄存器</li></ul></li><li><p>当前处理器的模式决定着哪组寄存器可操作. 任何模式都可以存取： </p><ul><li>相应的r0-r12子集</li><li>相应的 r13 (sp) and r14 (lr)</li><li>相应的 r15 (pc)</li><li>相应的CPSR</li></ul></li><li><p>特权模式 (除system模式) 还可以存取；</p><ul><li>相应的 SPSR</li></ul></li><li><p>对于R13、R14来说，每个寄存器对应6个不同的物理寄存器，其中的一个是用户模式与系统模式共用，另外5个物理寄存器对应于其他5种不同的运行模式。</p></li><li><p>采用以下的记号来区分不同的物理寄存器：</p><ul><li><strong>R13_<mode></strong></li><li><strong>R14_<mode></strong></li><li><strong>其中，</strong>mode为以下几种模式之一：<strong>usr</strong>、<strong>fiq</strong>、<strong>irq</strong>、<strong>svc</strong>、<strong>abt</strong>、<strong>und</strong>。</li></ul></li><li><p>寄存器R13在ARM指令中常用作<strong>堆栈指针</strong>，但这只是一种习惯用法，用户也可使用其他的寄存器作为堆栈指针。</p><ul><li>而在Thumb指令集中，某些指令强制性的要求使用R13作为堆栈指针。</li><li>由于处理器的每种运行模式均有自己独立的物理寄存器R13，在用户应用程序的初始化部分，一般都要初始化每种模式下的R13，使其指向该运行模式的栈空间，这样，当程序的运行进入异常模式时，可以将需要保护的寄存器放入R13所指向的堆栈，而当程序从异常模式返回时，则从对应的堆栈中恢复，采用这种方式可以保证异常发生后程序的正常执行。</li></ul></li><li><p>R14也称作<strong>子程序连接寄存器</strong>（Subroutine Link Register）或<strong>连接寄存器</strong>LR。当执行BL子程序调用指令时，R14中得到R15（程序计数器PC）的备份。其他情况下，R14用作通用寄存器。</p></li><li><p>与之类似，当发生中断或异常时，对应的分组寄存器R14_svc、R14_irq、R14_fiq、R14_abt和R14_und用来保存R15的返回值。</p></li><li><p>寄存器R14常用在如下的情况：</p></li><li><p>在每一种运行模式下，都可用R14保存子程序的返回地址。当用BL或BLX指令调用子程序时，将PC的当前值拷贝给R14，执行完子程序后，又将R14的值拷贝回PC，即可完成子程序的调用返回。以上的描述可用指令完成：</p></li></ul><p>  1、执行以下任意一条指令可以返回：</p><p>  ​    MOV    PC，LR  ；PC      LR</p><pre><code class="hljs"> 或 BX    LR</code></pre><p>   2、在子程序入口处使用以下指令将R14存入堆栈：</p><p>  ​    STMFD  SP！,{<Regs>,LR}</p><pre><code class="hljs"> 对应的，使用以下指令可以完成子程序返回：</code></pre><p>  ​    LDMFD  SP！,{<Regs>,PC}</p><ul><li><p>R14也可作为通用寄存器。</p></li><li><p><strong>程序计数器PC(R15)</strong></p><ul><li>寄存器R15用作<strong>程序计数器（PC）</strong>。在ARM状态下，位[1:0]为0，位[31:2]用于保存PC；在Thumb状态下，位[0]为0，位[31:1]用于保存PC；</li><li>R15虽然也可用作通用寄存器，但一般不这么使用，因为对R15的使用有一些特殊的限制，当违反了这些限制时，程序的执行结果是未知的。</li><li>由于ARM体系结构采用了多级流水线技术，对于ARM指令集而言，PC总是指向当前指令的下两条指令的地址，即PC的值为当前指令的地址值加8个字节。（？P.14）</li></ul></li><li><p>当处理器执行在ARM状态:</p><ul><li>所有指令 32 bits 宽</li><li>所有指令必须 word 对齐</li><li>pc值由bits [31:2]决定, bits [1:0] 未定义 (所以指令不能halfword &#x2F; byte对齐).</li></ul></li><li><p>当处理器执行在Thumb状态:</p><ul><li>所有指令 16 bits 宽</li><li>所有指令必须 halfword 对齐</li><li>pc值由bits [31:1]决定, bits [0] 未定义 (所以指令不能 byte对齐).</li></ul></li><li><p><strong>当前程序状态寄存器：</strong></p><ul><li>寄存器的名字为<strong>CPSR</strong>(Current Program Status Register，当前程序状态寄存器)，CPSR可在任何运行模式下被访问，它包括条件标志位、中断禁止位、当前处理器模式标志位，以及其他一些相关的控制和状态位。</li><li>每一种运行模式下又都有一个专用的物理状态寄存器，称为<strong>SPSR</strong>（Saved Program Status Register，备份的程序状态寄存器），当异常发生时，SPSR用于保存CPSR的当前值，从异常退出时则可由SPSR来恢复CPSR。</li><li>由于用户模式和系统模式不属于异常模式，他们没有SPSR，当在这两种模式下访问SPSR，结果是未知的。</li></ul></li></ul><h2 id="2-5-2-Thumb状态下的寄存器组织"><a href="#2-5-2-Thumb状态下的寄存器组织" class="headerlink" title="2.5.2 Thumb状态下的寄存器组织"></a>2.5.2 Thumb状态下的寄存器组织</h2><ul><li><strong>Thumb</strong>状态下的寄存器集是<strong>ARM</strong>状态下寄存器集的一个<strong>子集</strong>，程序可以直接访问8个通用寄存器（R0～R7）、程序计数器（PC）、堆栈指针（SP）、连接寄存器（LR）和CPSR。</li><li>同时，<strong>在每一种特权模式下都有一组SP、LR和SPSR</strong>。下图表明Thumb状态下的寄存器组织。</li></ul><p><img src="/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC2%E7%AB%A0-ARM%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%9E%8B/image-20230328122628038.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="Thumb状态下的寄存器组织 "></p><p>Thumb状态下的寄存器组织与ARM状态下的寄存器组织的关系：</p><ul><li>Thumb状态下和ARM状态下的R0～R7是相同的。</li><li>Thumb状态下和ARM状态下的CPSR和所有的SPSR是相同的。</li><li>Thumb状态下的SP对应于ARM状态下的R13。</li><li>Thumb状态下的LR对应于ARM状态下的R14。</li><li>Thumb状态下的程序计数器对应于ARM状态下R15。</li></ul><p><img src="/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC2%E7%AB%A0-ARM%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%9E%8B/image-20230328122648027.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="Thumb状态下的寄存器组织与ARM状态下的寄存器组织的对应关系 "></p><ul><li>访问Thumb状态下的高位寄存器（Hi-registers）：</li><li>在Thumb状态下，高位寄存器R8～R15并不是标准寄存器集的一部分，但可使用汇编语言程序有限制的访问这些寄存器，将其用作快速的暂存器。<ul><li>使用带特殊变量的MOV指令，数据可以在低位寄存器和高位寄存器之间进行传送；</li><li>高位寄存器的值可以使用CMP和ADD指令进行比较或加上低位寄存器中的值。</li></ul></li></ul><h2 id="2-5-3-程序状态寄存器"><a href="#2-5-3-程序状态寄存器" class="headerlink" title="2.5.3 程序状态寄存器"></a>2.5.3 程序状态寄存器</h2><p>ARM体系结构包含一个当前程序状态寄存器（CPSR）和五个备份的程序状态寄存器（SPSRs）。备份的程序状态寄存器用来进行异常处理，其功能包括：</p><ul><li><strong>保存ALU中的当前操作信息</strong></li><li><strong>控制允许和禁止中断</strong></li><li><strong>设置处理器的运行模式</strong></li></ul><p><img src="/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC2%E7%AB%A0-ARM%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%9E%8B/image-20230328122738479.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="程序状态寄存器的每一位的安排"></p><p><img src="/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC2%E7%AB%A0-ARM%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%9E%8B/image-20230328122754612.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="程序状态寄存器CPSR"></p><blockquote><p> 条件位：</p><ul><li><strong>N</strong> &#x3D; 1-结果为负，0-结果为正或0</li><li><strong>Z</strong> &#x3D; 1-结果为0，0-结果不为0</li><li><strong>C</strong> &#x3D;1-进位，0-借位</li><li><strong>V</strong> &#x3D;1-结果溢出，0结果没溢出</li></ul><p><strong>Q</strong> 位：</p><ul><li>仅ARM 5TE&#x2F;J架构支持</li><li>指示增强型DSP指令是否溢出</li></ul><p><strong>J</strong> 位</p><ul><li>仅ARM 5TE&#x2F;J架构支持</li><li>J &#x3D; 1: 处理器处于Jazelle状态</li></ul><p><strong>中断禁止位：</strong></p><ul><li><strong>I</strong> &#x3D; 1: 禁止 IRQ.</li><li><strong>F</strong> &#x3D; 1: 禁止 FIQ.</li></ul><p><strong>T</strong> Bit</p><ul><li>仅ARM xT架构支持</li><li>T &#x3D; 0: 处理器处于 ARM 状态</li><li>T &#x3D; 1: 处理器处于 Thumb 状态</li></ul><p>Mode位(处理器模式位):</p><ul><li>0b10000 User</li><li>0b10001 FIQ</li><li>0b10010 IRQ</li><li>0b10011 Supervisor</li><li>0b10111 Abort</li><li>0b11011 Undefined</li><li>0b11111 System</li></ul></blockquote><h4 id="条件码标志（Condition-Code-Flags）"><a href="#条件码标志（Condition-Code-Flags）" class="headerlink" title="条件码标志（Condition Code Flags）"></a>条件码标志（Condition Code Flags）</h4><ul><li>N、Z、C、V均为条件码标志位。它们的内容可被算术或逻辑运算的结果所改变，并且可以决定某条指令是否被执行。</li><li>在ARM状态下，绝大多数的指令都是有条件执行的。</li><li>在Thumb状态下，仅有分支指令是有条件执行的。</li></ul><p>条件码标志各位的具体含义如下表所示：</p><table><thead><tr><th>标志位</th><th>含    义</th></tr></thead><tbody><tr><td>N</td><td>当用两个补码表示的带符号数进行运算时，N&#x3D;1  表示运算的结果为负数；N&#x3D;0  表示运算的结果为正数或零；</td></tr><tr><td>Z</td><td>Z&#x3D;1  表示运算的结果为零；Z&#x3D;0表示运算的结果为非零；</td></tr><tr><td>C</td><td>可以有4种方法设置C的值：  ─  加法运算（包括比较指令CMN）：当运算结果产生了进位时（无符号数溢出），C&#x3D;1，否则C&#x3D;0。  ─  减法运算（包括比较指令CMP）：当运算时产生了借位（无符号数溢出），C&#x3D;0，否则C&#x3D;1。  ─  对于包含移位操作的非加&#x2F;减运算指令，C为移出值的最后一位。  ─  对于其他的非加&#x2F;减运算指令，C的值通常不改变。</td></tr><tr><td>V</td><td>可以有2种方法设置V的值：  ─  对于加&#x2F;减法运算指令，当操作数和运算结果为二进制的补码表示的带符号数时，V&#x3D;1表示符号位溢出。  ─  对于其他的非加&#x2F;减运算指令，V的值通常不改变。</td></tr><tr><td>Q</td><td>在ARM  v5及以上版本的E系列处理器中，用Q标志位指示增强的DSP运算指令是否发生了溢出。在其他版本的处理器中，Q标志位无定义。</td></tr></tbody></table><h5 id="控制位"><a href="#控制位" class="headerlink" title="控制位"></a>控制位</h5><p>PSR的低8位（包括I、F、T和M[4：0]）称为控制位，当发生异常时这些位可以被改变。如果处理器运行特权模式，这些位也可以由程序修改。</p><ul><li>中断禁止位I、F：</li><li>I&#x3D;1  禁止IRQ中断;</li><li>F&#x3D;1  禁止FIQ中断。</li><li>T标志位：该位反映处理器的运行状态。<ul><li>对于ARM体系结构v5及以上的版本的T系列处理器，当该位为1时，程序运行于Thumb状态，否则运行于ARM状态。</li><li>对于ARM体系结构v5及以上的版本的非T系列处理器，当该位为1时，执行下一条指令以引起为定义的指令异常；当该位为0时，表示运行于ARM状态。</li></ul></li><li>运行模式位M[4：0]：M0、M1、M2、M3、M4是模式位。这些位决定了处理器的运行模式。</li></ul><h6 id="运行模式位M-4：0-的具体含义"><a href="#运行模式位M-4：0-的具体含义" class="headerlink" title="运行模式位M[4：0]的具体含义"></a>运行模式位M[4：0]的具体含义</h6><table><thead><tr><th>M[4：0]</th><th>处理器模式</th><th>可访问的寄存器</th></tr></thead><tbody><tr><td>0b10000</td><td>用户模式</td><td>PC，CPSR,R0-R14</td></tr><tr><td>0b10001</td><td>FIQ模式</td><td>PC，CPSR,  SPSR_fiq，R14_fiq-R8_fiq,  R7～R0</td></tr><tr><td>0b10010</td><td>IRQ模式</td><td>PC，CPSR,  SPSR_irq，R14_irq,R13_irq,R12～R0</td></tr><tr><td>0b10011</td><td>管理模式</td><td>PC，CPSR,  SPSR_svc，R14_svc,R13_svc,,R12～R0,</td></tr><tr><td>0b10111</td><td>中止模式</td><td>PC，CPSR,  SPSR_abt，R14_abt,R13_abt,  R12～R0,</td></tr><tr><td>0b11011</td><td>未定义模式</td><td>PC，CPSR,  SPSR_und，R14_und,R13_und,  R12～R0,</td></tr><tr><td>0b11111</td><td>系统模式</td><td>PC，CPSR,  R14～R0  （ARM  v4及以上版本）</td></tr></tbody></table><p>由表可知，并不是所有的运行模式位的组合都是有效地，其他的组合结果会导致处理器进入一个不可恢复的状态。</p><h5 id="保留位"><a href="#保留位" class="headerlink" title="保留位"></a>保留位</h5><p>PSR中的其余位为保留位，当改变PSR中的条件码标志位或者控制位时，保留位不要被改变，在程序中也不要使用保留位来存储数据。保留位将用于ARM版本的扩展</p><h1 id="2-6-异常（Exceptions）"><a href="#2-6-异常（Exceptions）" class="headerlink" title="2.6  异常（Exceptions）"></a>2.6  异常（Exceptions）</h1><ul><li>当正常的程序执行流程发生暂时的停止时，称之为<strong>异常</strong>，处理器将进入异常模式，例如处理一个外部的中断请求。</li><li>在处理异常之前，当前处理器的状态必须保留，这样当异常处理完成之后，当前程序可以继续执行。处理器允许多个异常同时发生，它们将会按固定的优先级进行处理。</li><li>如果同时发生两个或更多异常，将按照固定的顺序来处理异常。</li><li>ARM体系结构中的异常，与8位&#x2F;16位体系结构的中断有很大的相似之处，但<strong>异常</strong>与<strong>中断</strong>（interrupt）的概念并不完全等同。</li></ul><h2 id="2-6-1-ARM体系结构所支持的异常类型"><a href="#2-6-1-ARM体系结构所支持的异常类型" class="headerlink" title="2.6.1 ARM体系结构所支持的异常类型"></a>2.6.1 ARM体系结构所支持的异常类型</h2><table><thead><tr><th>异常类型</th><th>具体含义</th></tr></thead><tbody><tr><td>复位</td><td>当处理器的复位电平有效时，产生复位异常，程序跳转到复位异常处理程序处执行。</td></tr><tr><td>未定义指令</td><td>当ARM处理器或协处理器遇到不能处理的指令时，产生未定义指令异常。可使用该异常机制进行软件仿真。</td></tr><tr><td>软件中断</td><td>该异常由执行SWI指令产生，可用于用户模式下的程序调用特权操作指令。可使用该异常机制实现系统功能调用。</td></tr><tr><td>指令预取中止</td><td>若处理器预取指令的地址不存在，或该地址不允许当前指令访问，存储器会向处理器发出中止信号，但当预取的指令被执行时，才会产生指令预取中止异常。</td></tr><tr><td>数据中止</td><td>若处理器数据访问指令的地址不存在，或该地址不允许当前指令访问时，产生数据中止异常。</td></tr><tr><td>IRQ（外部中断请求）</td><td>当处理器的外部中断请求引脚有效，且CPSR中的I位为0时，产生IRQ异常。系统的外设可通过该异常请求中断服务。</td></tr><tr><td>FIQ（快速中断请求）</td><td>当处理器的快速中断请求引脚有效，且CPSR中的F位为0时，产生FIQ异常。</td></tr></tbody></table><h2 id="2-6-2-对异常的响应"><a href="#2-6-2-对异常的响应" class="headerlink" title="2.6.2 对异常的响应"></a>2.6.2 对异常的响应</h2><p>当一个异常出现以后，ARM微处理器会执行以下几步操作：</p><ul><li><strong>1、将下一条指令的地址存入相应连接寄存器LR，以便程序在处理异常返回时能从正确的位置重新开始执行。</strong>若异常是从ARM状态进入，LR寄存器中保存的是下一条指令的地址（当前PC＋4或PC＋8，与异常的类型有关）；若异常是从Thumb状态进入，则在LR寄存器中保存当前PC的偏移量，这样，异常处理程序就不需要确定异常是从何种状态进入的。例如：在软件中断异常SWI，指令 MOV PC，R14_svc总是返回到下一条指令，不管SWI是在ARM状态执行，还是在Thumb状态执行。</li><li><strong>2、将CPSR复制到相应的SPSR中。</strong></li><li><strong>3、根据异常类型，强制设置CPSR的运行模式位。</strong></li><li><strong>4、强制PC从相关的异常向量地址取下一条指令执行，从而跳转到相应的异常处理程序处。</strong></li></ul><p>还可以设置中断禁止位，以禁止中断发生。</p><p><strong>如果异常发生时，处理器处于Thumb状态，则当异常向量地址加载入PC时，处理器自动切换到ARM状态</strong></p><p>ARM微处理器对异常的响应过程用伪码可以描述为：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">R14_</span>&lt;Exception_Mode&gt; = Return Link<br><span class="hljs-attribute">SPSR_</span>&lt;Exception_Mode&gt; = CPSR<br><span class="hljs-attribute">CPSR</span>[<span class="hljs-number">4</span>:<span class="hljs-number">0</span>] = Exception Mode Number<br><span class="hljs-attribute">CPSR</span>[<span class="hljs-number">5</span>] = <span class="hljs-number">0</span>   ；当运行于ARM工作状态时<br><span class="hljs-attribute">If</span> &lt;Exception_Mode&gt; == Reset or FIQ then<br><span class="hljs-attribute">CPSR</span>[<span class="hljs-number">6</span>] = <span class="hljs-number">1</span>  ；当响应FIQ异常时，禁止新的FIQ异常   <br><span class="hljs-attribute">CPSR</span>[<span class="hljs-number">7</span>] = <span class="hljs-number">1</span>  ；禁止新的IRQ异常<br><span class="hljs-attribute">PC</span> = Exception Vector Address <br></code></pre></td></tr></table></figure><p><img src="/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC2%E7%AB%A0-ARM%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%9E%8B/image-20230328123542643.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="进入异常"></p><h2 id="2-6-3-从异常返回"><a href="#2-6-3-从异常返回" class="headerlink" title="2.6.3 从异常返回"></a>2.6.3 从异常返回</h2><p>异常处理完毕之后，ARM微处理器会执行以下几步操作从异常返回： </p><ul><li><strong>1、将SPSR复制回CPSR中。</strong></li><li><strong>2、若在进入异常处理时设置了中断禁止位，要在此清除。</strong></li><li><strong>3、将连接寄存器LR的值减去相应的偏移量后送到PC中。</strong></li></ul><p>可以认为应用程序总是从复位异常处理程序开始执行的，因此复位异常处理程序不需要返回。</p><p><img src="/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC2%E7%AB%A0-ARM%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%9E%8B/image-20230328123640788.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="异常返回"></p><h2 id="2-6-4-各类异常的具体描述"><a href="#2-6-4-各类异常的具体描述" class="headerlink" title="2.6.4 各类异常的具体描述"></a>2.6.4 各类异常的具体描述</h2><h4 id="FIQ（Fast-Interrupt-Request）"><a href="#FIQ（Fast-Interrupt-Request）" class="headerlink" title="FIQ（Fast Interrupt Request）"></a>FIQ（Fast Interrupt Request）</h4><ul><li>FIQ异常是为了支持数据传输或者通道处理而设计的。在ARM状态下，系统有足够的私有寄存器，从而可以避免对寄存器保存的需求，并减小了系统上下文切换的开销。</li><li>若将CPSR的F位置为1，则会禁止FIQ中断，若将CPSR的F位清零，处理器会在指令执行时检查FIQ输入。注意只有在特权模式下才能改变F位的状态。</li><li>可由外部通过对处理器上的nFIQ引脚输入低电平产生FIQ。不管是在ARM状态还是在Thumb状态下进入FIQ模式，FIQ处理程序均会执行以下指令从FIQ模式返回：</li></ul><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-keyword">SUBS</span>  <span class="hljs-built_in">PC</span>,R14_fiq ,<span class="hljs-number">#4</span><br></code></pre></td></tr></table></figure><pre><code class="hljs">     该指令将寄存器R14_fiq的值减去4后，复制到程序计数器PC中，从而实现从异常处理程序中的返回，同时将SPSR_mode寄存器的内容复制到当前程序状态寄存器CPSR中。</code></pre><h4 id="IRQ（Interrupt-Request）"><a href="#IRQ（Interrupt-Request）" class="headerlink" title="IRQ（Interrupt Request）"></a>IRQ（Interrupt Request）</h4><ul><li>IRQ异常属于正常的中断请求，可通过对处理器的nIRQ引脚输入低电平产生，IRQ的优先级低于FIQ，当程序执行进入FIQ异常时，IRQ可能被屏蔽。</li><li>若将CPSR的I位置为1，则会禁止IRQ中断，若将CPSR的I位清零，处理器会在指令执行完之前检查IRQ的输入。注意只有在特权模式下才能改变I位的状态。</li><li>不管是在ARM状态还是在Thumb状态下进入IRQ模式，IRQ处理程序均会执行以下指令从IRQ模式返回：</li></ul><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-keyword">SUBS</span> <span class="hljs-built_in">PC</span> , R14_irq , <span class="hljs-number">#4</span><br></code></pre></td></tr></table></figure><pre><code class="hljs">     该指令将寄存器R14_irq的值减去4后，复制到程序计数器PC中，从而实现从异常处理程序中的返回，同时将SPSR_mode寄存器的内容复制到当前程序状态寄存器CPSR中</code></pre><h4 id="ABORT（中止）"><a href="#ABORT（中止）" class="headerlink" title="ABORT（中止）"></a>ABORT（中止）</h4><ul><li>产生中止异常意味着对存储器的访问失败。ARM微处理器在存储器访问周期内检查是否发生中止异常。</li><li>中止异常包括两种类型：<ul><li><strong>指令预取中止：发生在指令预取时。</strong></li><li><strong>数据中止：发生在数据访问时。</strong></li></ul></li><li>当指令预取访问存储器失败时，存储器系统向ARM处理器发出存储器中止（Abort）信号，预取的指令被记为无效，但只有当处理器试图执行无效指令时，指令预取中止异常才会发生，如果指令未被执行，例如在指令流水线中发生了跳转，则预取指令中止不会发生。</li><li>若数据中止发生，系统的响应与指令的类型有关。</li><li>当确定了中止的原因后，Abort处理程序均会执行以下指令从中止模式返回，无论是在ARM状态还是Thumb状态：</li></ul><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-keyword">SUBS</span> <span class="hljs-built_in">PC</span>, R14_abt, <span class="hljs-number">#4</span>   ；指令预取中止<br><br><span class="hljs-keyword">SUBS</span> <span class="hljs-built_in">PC</span>, R14_abt, <span class="hljs-number">#8</span>   ；数据中止<br></code></pre></td></tr></table></figure><p>​以上指令恢复PC（从R14_abt）和CPSR（从SPSR_abt）的值，并重新执行中止的指令。</p><h4 id="Software-Interruupt-软件中断"><a href="#Software-Interruupt-软件中断" class="headerlink" title="Software Interruupt(软件中断)"></a>Software Interruupt(软件中断)</h4><p>软件中断指令（SWI）用于进入管理模式，常用于请求执行特定的管理功能。软件中断处理程序执行以下指令从SWI模式返回，无论是在ARM状态还是Thumb状态：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-keyword">MOV</span> <span class="hljs-built_in">PC</span> , R14_svc<br></code></pre></td></tr></table></figure><p> 以上指令恢复PC（从R14_svc）和CPSR（从SPSR_svc）的值，并返回到SWI的下一条指令。</p><h4 id="Undefined-Instruction-未定义指令"><a href="#Undefined-Instruction-未定义指令" class="headerlink" title="Undefined Instruction(未定义指令)"></a>Undefined Instruction(未定义指令)</h4><ul><li>当ARM处理器遇到不能处理的指令时，会产生未定义指令异常。采用这种机制，可以通过软件仿真扩展ARM或Thumb指令集。</li><li>在仿真未定义指令后，处理器执行以下程序返回，无论是在ARM状态还是Thumb状态：</li></ul><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-keyword">MOVS</span> <span class="hljs-built_in">PC</span>, R14_und<br></code></pre></td></tr></table></figure><p>​ 以上指令恢复PC（从R14_und）和CPSR（从SPSR_und）的值，并返回到未定义指令后的下一条指令。</p><h2 id="2-6-5-异常进入-x2F-退出小节"><a href="#2-6-5-异常进入-x2F-退出小节" class="headerlink" title="2.6.5 异常进入&#x2F;退出小节"></a>2.6.5 异常进入&#x2F;退出小节</h2><table><thead><tr><th></th><th>返回指令</th><th>以前的状态</th><th>备注</th><th></th></tr></thead><tbody><tr><td>ARM   R14_x</td><td>Thumb  R14_x</td><td></td><td></td><td></td></tr><tr><td><strong>BL</strong></td><td><strong>MOV  PC，R14</strong></td><td><strong>PC＋4</strong></td><td><strong>PC＋2</strong></td><td>1</td></tr><tr><td><strong>SWI</strong></td><td><strong>MOVS  PC，R14_svc</strong></td><td><strong>PC4</strong></td><td><strong>PC＋2</strong></td><td>1</td></tr><tr><td><strong>UDEF</strong></td><td><strong>MOVS  PC，R14_und</strong></td><td><strong>PC＋4</strong></td><td><strong>PC＋2</strong></td><td>1</td></tr><tr><td><strong>FIQ</strong></td><td><strong>SUBS  PC，R14_fiq，＃4</strong></td><td><strong>PC＋4</strong></td><td><strong>PC＋4</strong></td><td>2</td></tr><tr><td><strong>IRQ</strong></td><td><strong>SUBS  PC，R14_irq，＃4</strong></td><td><strong>PC＋4</strong></td><td><strong>PC＋4</strong></td><td>2</td></tr><tr><td><strong>PABT</strong></td><td><strong>SUBS  PC，R14_abt，＃4</strong></td><td><strong>PC＋4</strong></td><td><strong>PC＋4</strong></td><td>1</td></tr><tr><td><strong>DABT</strong></td><td><strong>SUBS  PC，R14_abt，＃8</strong></td><td><strong>PC＋8</strong></td><td><strong>PC＋8</strong></td><td>3</td></tr><tr><td><strong>RESET</strong></td><td><strong>NA</strong></td><td><strong>－</strong></td><td><strong>－</strong></td><td>4</td></tr></tbody></table><p>备注：</p><ul><li>1–在此PC应是具有预取中止的BL&#x2F;SWI&#x2F;未定义指令所取的地址。</li><li>2–在此PC是从FIQ或IRQ取得不能执行的指令的地址。</li><li>3–在此PC是产生数据中止的加载或存储指令的地址。</li><li>4–系统复位时，保存在R14_svc中的值是不可预知的。</li></ul><h2 id="2-6-6-异常向量（Exception-Vectors）"><a href="#2-6-6-异常向量（Exception-Vectors）" class="headerlink" title="2.6.6 异常向量（Exception Vectors）"></a>2.6.6 异常向量（Exception Vectors）</h2><table><thead><tr><th>地 址</th><th>异 常</th><th>进入模式</th></tr></thead><tbody><tr><td>0x0000,0000</td><td>复位</td><td>管理模式</td></tr><tr><td>0x0000,0004</td><td>未定义</td><td>指令未定义模式</td></tr><tr><td>0x0000,0008</td><td>软件中断</td><td>管理模式</td></tr><tr><td>0x0000,000C</td><td>中止（预取指令）</td><td>中止模式</td></tr><tr><td>0x0000,0010</td><td>中止（数据）</td><td>中止模式</td></tr><tr><td>0x0000,0014</td><td>保留</td><td>保留</td></tr><tr><td>0x0000,0018</td><td>IRQ</td><td>IRQ</td></tr><tr><td>0x0000,001C</td><td>FIQ</td><td>FIQ</td></tr></tbody></table><h2 id="2-6-7-异常优先级（Exception-Priorities）"><a href="#2-6-7-异常优先级（Exception-Priorities）" class="headerlink" title="2.6.7 异常优先级（Exception Priorities）"></a>2.6.7 异常优先级（Exception Priorities）</h2><p>当多个异常同时发生时，系统根据固定的优先级决定异常的处理次序。异常优先级由高到低的排列次序如下表所示。</p><table><thead><tr><th>优先级</th><th>异 常</th></tr></thead><tbody><tr><td>1（最高）</td><td>复位</td></tr><tr><td>2</td><td>数据中止</td></tr><tr><td>3</td><td>FIQ</td></tr><tr><td>4</td><td>IRQ</td></tr><tr><td>5</td><td>预取指令中止</td></tr><tr><td>6（最低）</td><td>未定义指令、SWI</td></tr></tbody></table><h2 id="2-6-8-应用程序中的异常处理"><a href="#2-6-8-应用程序中的异常处理" class="headerlink" title="2.6.8 应用程序中的异常处理"></a>2.6.8 应用程序中的异常处理</h2><p>当系统运行时，异常可能会随时发生，为保证在ARM处理器发生异常时不至于处于未知状态，在应用程序的设计中，首先要进行异常处理，采用的方式是在异常向量表中的特定位置放置一条跳转指令，跳转到异常处理程序。当ARM处理器发生异常时，程序计数器PC会被强制设置为对应的异常向量，从而跳转到异常处理程序，当异常处理完成以后，返回到主程序继续执行。</p><h1 id="2-7-本章小节"><a href="#2-7-本章小节" class="headerlink" title="2.7 本章小节"></a>2.7 本章小节</h1><p>本章对ARM微处理器的体系结构、寄存器的组织、处理器的工作状态、运行模式以及处理器异常等内容进行了描述，这些内容也是ARM体系结构的基本内容，是系统软、硬件设计的基础。</p><ul><li>掌握各种运行模式下寄存器的组织使用</li><li>掌握异常响应和异常返回的代码设置</li></ul><h1 id="复习与作业"><a href="#复习与作业" class="headerlink" title="复习与作业"></a>复习与作业</h1><p>复习：</p><ul><li>1、ARM处理器有几个寄存器？分别说明其用途。</li><li>2、CPSR状态寄存器中各位表示的含义是什么？</li><li>3、ARM中断向量表位于存储器的什么位置？</li></ul><p>作业：</p><ul><li>4、思考为什么处理器采用中断运行机制？并且设置中断向量表？（自查资料）</li><li>要求与第一次作业同</li></ul>]]></content>
    
    
    <categories>
      
      <category>学习资料</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ARM体系结构与编程</tag>
      
      <tag>课件笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ARM体系结构与编程-第1章-ARM体系结构概述</title>
    <link href="/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC1%E7%AB%A0-ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0/"/>
    <url>/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC1%E7%AB%A0-ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="1-1-ARM-微处理器简介"><a href="#1-1-ARM-微处理器简介" class="headerlink" title="1.1 ARM 微处理器简介"></a>1.1 ARM 微处理器简介</h1><ul><li>成立于1990年11月<ul><li>前身为 Acorn计算机公司</li><li>ARM (Advance RISC Machine)</li></ul></li><li>主要设计ARM系列RISC处理器内核</li><li>授权ARM内核给生产和销售半导体的合作伙伴<ul><li>ARM 公司不生产芯片</li><li>IP(Intelligence Property)</li></ul></li><li>另外也提供基于ARM架构的开发设计技术<ul><li>软件工具，评估板，调试工具，应用软件</li><li>总线架构，外围设备单元，等等</li></ul></li></ul><p><img src="/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC1%E7%AB%A0-ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0/image-20230326092448629.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="合作伙伴"></p><h1 id="1-2-ARM微处理器的应用领域及特点-P-1"><a href="#1-2-ARM微处理器的应用领域及特点-P-1" class="headerlink" title="1.2 ARM微处理器的应用领域及特点 (P.1)"></a>1.2 ARM微处理器的应用领域及特点 (P.1)</h1><h2 id="1-2-1-ARM微处理器的应用领域"><a href="#1-2-1-ARM微处理器的应用领域" class="headerlink" title="1.2.1 ARM微处理器的应用领域"></a>1.2.1 ARM微处理器的应用领域</h2><ul><li>工业控制领域 ：高端微控制器 </li><li>无线通讯领域 ：无线通讯设备 </li><li>网络应用 ：宽带技术、语音及视频处理 </li><li>消费类电子产品 ：数字音频播放器、数字机顶盒和游戏机 </li><li>成像和安全产品 ：数码相机、打印机及32位SIM智能卡</li></ul><p><img src="/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC1%E7%AB%A0-ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0/image-20230326092647606.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="啊"></p><p><strong>ARM嵌入式处理器的片上系统</strong></p><ul><li>基于ARM嵌入式处理器的片上系统解决方案可应用于企业应用、汽车系统，家庭网络和无线技术等市场领域。</li><li>ARM CortexTM系列提供了一个标准的体系结构来满足以上各种技术的不同性能要求，基于ARM架构有3个分工明确的系列：<ul><li>A系列面向复杂的尖端应用程序，用于运行开放式的复杂操作系统;</li><li>R系列针对实时系统;</li><li>M系列专为低成本控制和微控制器应用开发。</li></ul></li><li>Cortex-M3是基于ARM架构的处理器，是专门为了在微控制器等对功耗和成本敏感的应用领域实现高系统性能而设计的，它简化了可编程的复杂性，使ARM架构成为各种应用方案的良好选择。</li></ul><h2 id="1-2-2-ARM微处理器的特点"><a href="#1-2-2-ARM微处理器的特点" class="headerlink" title="1.2.2 ARM微处理器的特点"></a>1.2.2 ARM微处理器的特点</h2><p>采用RISC架构的ARM微处理器具有如下特点：</p><ul><li>体积小、低功耗、低成本、高性能；</li><li>支持Thumb（16位）&#x2F;ARM（32位）双指令集，能很好的兼容8位&#x2F;16位器件；</li><li>大量使用寄存器，指令执行速度更快；</li><li>大多数数据操作都在寄存器中完成；</li><li>寻址方式灵活简单，执行效率高；</li><li>指令长度固定。</li></ul><p>ARM体系的特别技术<strong>（与IA-64比较）</strong>：</p><ul><li>在同一条数据处理指令中包含算术逻辑处理单元处理和移位处理。</li><li>使用地址自动增加（减少）来优化程序中循环处理</li><li>load&#x2F;store指令可以批量传输数据，从而提高数据传输的效率。</li><li>所有指令都可以条件执行。</li></ul><h1 id="1-3-ARM微处理器系列-P-7"><a href="#1-3-ARM微处理器系列-P-7" class="headerlink" title="1.3 ARM微处理器系列(P.7)"></a>1.3 ARM微处理器系列(P.7)</h1><ul><li>ARM7系列</li><li>ARM9系列</li><li>ARM9E系列</li><li>ARM10E系列</li><li>ARM11系列</li><li>SecurCore系列</li><li>Intel的StrongARM</li><li>Intel的Xscale</li><li>CortexTM-M3</li></ul><p>其中，ARM7、ARM9、ARM9E和ARM10为4个通用处理器系列，每一个系列提供一套相对独特的性能来满足不同应用领域的需求。SecurCore系列专门为安全要求较高的应用而设计</p><p><img src="/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC1%E7%AB%A0-ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0/image-20230326093222674.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="ARM处理器的技术支持"></p><h2 id="1-3-1-ARM7微处理器系列-P-7"><a href="#1-3-1-ARM7微处理器系列-P-7" class="headerlink" title="1.3.1 ARM7微处理器系列(P.7)"></a>1.3.1 ARM7微处理器系列(P.7)</h2><p>ARM7系列微处理器为低功耗的32位RISC处理器(三级流水：IF,ID,EX)，最适合用于对价位和功耗要求较高的消费类应用。</p><blockquote><p>ARM7TDMI 是基于 ARM7 内核</p><p>3 级流水线—0.9MIPS&#x2F;MHz</p><p>冯.诺依曼架构:只有数据存储器接口，同时用来取指令和数据访问。</p><p>CPI(Clock-Cycle Per Instruction) 约为1.9 </p><p>ARM7没有MMU,ARM720T是MMU的 </p><p><strong>T</strong> - Thumb 架构扩展, 提供两个独立的指令集：</p><ul><li>ARM 指令，均为 32位</li><li>Thumb指令，均为 16位</li><li>两种运行状态，用来选择哪个指令集被执行</li></ul><p><strong>D</strong> - 内核具有Debug扩展结构</p><p><strong>M</strong> - 增强乘法器 (32x32) 支持64位结果.</p><p><strong>I</strong>  - Embedded ICE-RT逻辑—提供片上断点和调试点支持</p></blockquote><h3 id="ARM-MMU工作原理"><a href="#ARM-MMU工作原理" class="headerlink" title="ARM MMU工作原理"></a>ARM MMU工作原理</h3><p>MMU: Memory Management Unit</p><p>CPU管理虚拟存储器、物理存储器，也负责虚拟地址映射为物理地址。</p><p>虚拟地址空间划分成称为页（page）的单位</p><p>而相应的物理地址空间也被进行划分，单位是页框(frame)</p><p>页和页框的大小必须相同</p><p><img src="/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC1%E7%AB%A0-ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0/image-20230326093343960.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="映射"></p><p><img src="/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC1%E7%AB%A0-ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0/image-20230326093401060.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="va"></p><p><strong>ARM7系列微处理器的主要应用领域为：</strong></p><p>工业控制、Internet设备、网络和调制解调器设备、移动电话等多种多媒体和嵌入式应用。</p><p>数字蜂窝电话和硬盘驱动器。</p><p>ARM7系列微处理器包括如下几种类型的核：</p><ul><li>ARM7TDMI</li><li>ARM7TDMI-S</li><li>ARM720T</li><li>ARM7EJ</li></ul><p> 其中，ARM7TMDI是目前使用最广泛的32位嵌入式RISC处理器，属低端ARM处理器核。</p><p><img src="/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC1%E7%AB%A0-ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0/image-20230326093447141.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="内核信号1"></p><p><img src="/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC1%E7%AB%A0-ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0/image-20230326093520157.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="框图"></p><p><img src="/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC1%E7%AB%A0-ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0/image-20230326093649523.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="内核"></p><h3 id="指令流水线"><a href="#指令流水线" class="headerlink" title="指令流水线"></a>指令流水线</h3><p>为增加处理器指令流的速度，ARM7 系列使用3级流水线.</p><p>允许多个操作同时处理，比逐条指令执行要快。</p><p><img src="/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC1%E7%AB%A0-ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0/image-20230326093728732.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="流水"></p><p> <strong>PC</strong>指向正被取指的指令，而非正在执行的指令</p><p><strong>最佳(理想)流水线</strong></p><p><img src="/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC1%E7%AB%A0-ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0/image-20230326093816011.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="最佳"></p><p>o该例中用6个时钟周期执行了6条指令</p><p>o所有的操作都在寄存器中（单周期执行）</p><p>o指令周期数 (CPI) &#x3D; 1</p><p><strong>LDR 流水线举例</strong></p><p><img src="/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC1%E7%AB%A0-ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0/image-20230326093901441.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="image-20230326093901441"></p><p>o该例中，用6周期执行了4条指令</p><p>o指令周期数 (CPI) &#x3D; 1.5 </p><p><strong>分支流水线举例</strong></p><p><img src="/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC1%E7%AB%A0-ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0/image-20230326094107849.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="分支"></p><p>o流水线被阻断（ARM没有延时槽）</p><p>o注意:内核运行在ARM状态</p><p><strong>中断流水线举例</strong></p><p><img src="/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC1%E7%AB%A0-ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0/image-20230326094142481.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="中断"></p><p> IRQ 中断的反应时间最小&#x3D;7周期</p><h2 id="1-3-2-ARM9微处理器系列-P-8"><a href="#1-3-2-ARM9微处理器系列-P-8" class="headerlink" title="1.3.2 ARM9微处理器系列(P.8)"></a>1.3.2 ARM9微处理器系列(P.8)</h2><p>ARM9系列微处理器在<strong>高性能和低功耗特性</strong>方面提供最佳的性能。具有以下特点：</p><ul><li>5级整数流水线，指令执行效率更高。</li><li>提供1.1MIPS&#x2F;MHz的<strong>哈佛结构：</strong>独立的指令和数据存储器接口，可同时取指和读写数据。</li><li>实现了一个周期完成loads指令和stores指令<ul><li>引入了独立的存储器和写回流水线，分别用来访问存储器和将结果写回寄存器。</li></ul></li><li>支持32位ARM指令集和16位Thumb指令集。</li><li>支持32位的高速AMBA总线接口。</li><li>全性能的MMU，支持Windows CE、Linux、Palm OS等多种主流嵌入式操作系统。</li><li>MPU支持实时操作系统。</li><li>支持数据Cache和指令Cache，具有更高的指令和数据处理能力。</li><li>增强型乘法器设计</li></ul><p> ARM9系列微处理器主要应用于无线设备、仪器仪表、安全系统、机顶盒、高端打印机、数字照相机和数字摄像机等。</p><p> ARM9系列微处理器包含ARM920T、ARM922T和ARM940T三种类型，以适用于不同的应用场合。</p><blockquote><p> ARM9E系列微处理器为可综合处理器，使用单一的处理器内核提供了微控制器、DSP、Java应用系统的解决方案，极大的减少了芯片的面积和系统的复杂程度。ARM9E系列微处理器提供了增强的DSP处理能力，很适合于那些需要同时使用DSP和微控制器的应用</p><p>oARM9E系列微处理器的主要特点如下：</p><ul><li>支持DSP指令集，适合于需要高速数字信号处理的场合。</li><li><strong>5</strong>级整数流水线，指令执行效率更高。</li><li>支持32位ARM指令集和16位Thumb指令集。</li><li>支持32位的高速AMBA总线接口。</li><li>支持VFP9浮点处理协处理器。</li><li>全性能的MMU，支持Windows CE、Linux、Palm OS等多种主流嵌入式操作系统。</li><li>MPU支持实时操作系统。</li><li>支持数据Cache和指令Cache，具有更高的指令和数据处理能力。</li><li>主频最高可达300MIPS。</li></ul></blockquote><p><strong>ARM9主要应用</strong></p><ul><li>无线网络设备：手机上网、电子邮件及其他定位服务等功能；</li><li>PDA功能：含有用户操作系统(Windows CE、Symbian OS、Linux等）及其他功能；</li><li>高性能功能：音频播放器、视频电话、手机游戏等。</li><li>o在2.5G和3G的应用中ARM9已经全面替代了ARM7。</li><li>ARM9典型处理器：S3C2440</li></ul><h3 id="ARM9TDMI"><a href="#ARM9TDMI" class="headerlink" title="ARM9TDMI"></a><strong>ARM9TDMI</strong></h3><ul><li><strong>Harvard</strong>架构</li><li>增加了可用的存储器宽度<ul><li>指令存储器接口</li><li>数据存储器接口</li></ul></li><li>可以实现对指令和数据存储器的同时访问</li><li><strong>5</strong> <strong>级流水线</strong></li><li><strong>实现了以下改进：</strong><ul><li>改进 CPI 到 ~1.5</li><li>提高了最大时钟频率</li></ul></li></ul><p><strong>ARM9TDMI流水线的变化</strong></p><p><img src="/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC1%E7%AB%A0-ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0/image-20230326094754540.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="ARM7TDMI"></p><p><img src="/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC1%E7%AB%A0-ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0/image-20230326094809784.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="ARM9TDMI"></p><p><strong>ARM9TDMI数据通道 (1)</strong></p><p><img src="/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC1%E7%AB%A0-ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0/image-20230326094841870.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="数据"></p><p>MU逻辑单元包含有：多路复用器,乘法器和桶形移位器</p><p><img src="/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC1%E7%AB%A0-ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0/image-20230326094857604.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="2"></p><h4 id="LDR互锁"><a href="#LDR互锁" class="headerlink" title="LDR互锁"></a><strong>LDR互锁</strong></h4><p><img src="/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC1%E7%AB%A0-ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0/image-20230326095407582.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="互锁"></p><p>本例中，用了7个时钟周期执行6条指令， CPI &#x3D; 1.2 。</p><p>LDR指令之后立即跟一条数据操作指令，由于使用了相同的寄存器，将会导致互锁 。</p><h4 id="互锁-interlocks-技术"><a href="#互锁-interlocks-技术" class="headerlink" title="互锁(interlocks)技术"></a>互锁(interlocks)技术</h4><ul><li>当指令需要的数据因为以前的指令没有执行完而没有准备好就会产生管道自锁互锁。</li><li>当管道互锁发生时，硬件会停止这个指令的执行，直到数据准备好为止。</li><li>编译器以及汇编程序员可以通过重新设计代码的顺序或者其他方法来减少管道互锁的数量</li></ul><p><img src="/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC1%E7%AB%A0-ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0/image-20230326095538626.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="最佳(理想)流水线"></p><p>本例中，用了6个时钟周期执行6条指令， CPI &#x3D; 1。</p><p>LDR指令没有引起流水线互锁</p><p><img src="/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC1%E7%AB%A0-ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0/image-20230326095611282.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="LDM互锁 (1)"></p><p>本例中，用了8个时钟周期执行5条指令， CPI &#x3D; 1.6</p><p>在LDM期间，有并行的存储器访问和回写周期</p><p><img src="/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC1%E7%AB%A0-ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0/image-20230326095638325.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="image-20230326095638325"></p><p>本例中，用了9个时钟周期执行5条指令， CPI &#x3D; 1.8 </p><p>此处SUB 使用了 R3，增加了一个额外的互锁周期来完成该寄存器数据的获取</p><p>这种情况对任何LDM 指令，像带IA, DB, FD,等，都会发生 。</p><h2 id="1-3-4-ARM10E微处理器系列（P-9）"><a href="#1-3-4-ARM10E微处理器系列（P-9）" class="headerlink" title="1.3.4 ARM10E微处理器系列（P.9）"></a>1.3.4 ARM10E微处理器系列（P.9）</h2><p>ARM10E系列微处理器具有高性能、低功耗的特点，由于采用了新的体系结构，与同等的ARM9器件相比较，在同样的时钟频率下，性能提高了近50％，同时，ARM10E系列微处理器采用了两种先进的节能方式，使其功耗极低。</p><p>ARM10E系列微处理器的主要特点如下：</p><ul><li><p>支持DSP指令集，适合于需要高速数字信号处理的场合。</p></li><li><p><strong>6</strong>级整数流水线，指令执行效率更高。</p></li><li><p>支持32位ARM指令集和16位Thumb指令集。</p></li><li><p>支持32位的高速AMBA总线接口。</p></li><li><p>支持VFP10浮点处理协处理器。</p></li><li><p>全性能的MMU，支持Windows CE、Linux、Palm OS等多种主流嵌入式操作系统。</p></li><li><p>支持数据Cache和指令Cache，具有更高的指令和数据处理能力</p></li><li><p>主频最高可达400MIPS。</p></li><li><p>内嵌并行读&#x2F;写操作部件，支持64位的load&#x2F;store体系。</p><p> ARM10E系列微处理器主要应用于下一代无线设备、数字消费品、成像设备、工业控制、通信和信息系统等领域。</p><p>ARM10E系列微处理器包含ARM1020E、ARM1022E和ARM1026EJ-S三种类型，以适用于不同的应用场合。</p></li></ul><h3 id="ARM10E-系列"><a href="#ARM10E-系列" class="headerlink" title="ARM10E 系列"></a>ARM10E 系列</h3><p><strong>ARM1020E</strong></p><ul><li>v5TE架构</li><li>CPI » 1.3</li><li>6 级流水线</li><li>静态分支预测</li><li>32kB 指令cache和32kB数据cache<ul><li>支持“Hit under miss”</li><li>非阻塞的执行单元</li></ul></li><li>每周期64 位的 LDM &#x2F; STM操作</li><li>Embedded ICE逻辑 - RT-II</li><li>支持新的 VFPv1 结构</li></ul><p><strong>ARM1022E</strong></p><p>同上，除了cache大小为16kB</p><p>对SUDL(single user design license )有效</p><h4 id="ARM10-与ARM9的流水线对比"><a href="#ARM10-与ARM9的流水线对比" class="headerlink" title="ARM10 与ARM9的流水线对比"></a>ARM10 与ARM9的流水线对比</h4><p><img src="/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC1%E7%AB%A0-ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0/image-20230326095925802.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="9"></p><p><img src="/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC1%E7%AB%A0-ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0/image-20230326095937631.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="10"></p><h4 id="ARM10-整数单元数据通道"><a href="#ARM10-整数单元数据通道" class="headerlink" title="ARM10 整数单元数据通道"></a>ARM10 整数单元数据通道</h4><p><img src="/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC1%E7%AB%A0-ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0/image-20230326095958062.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="10"></p><h3 id="顺序代码的执行"><a href="#顺序代码的执行" class="headerlink" title="顺序代码的执行"></a>顺序代码的执行</h3><p> 开始于64位的对齐地址</p><p><img src="/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC1%E7%AB%A0-ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0/image-20230326100052287.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="image-20230326100052287"></p><h2 id="1-3-5-SecurCore微处理器系列-P-10"><a href="#1-3-5-SecurCore微处理器系列-P-10" class="headerlink" title="1.3.5 SecurCore微处理器系列(P.10)"></a>1.3.5 SecurCore微处理器系列(P.10)</h2><p> SecurCore系列微处理器专为安全需要而设计，提供了完善的32位RISC技术的安全解决方案，因此，SecurCore系列微处理器除了具有ARM体系结构的低功耗、高性能的特点外，还具有其独特的优势，即提供了对安全解决方案的支持。</p><p>SecurCore系列微处理器除了具有ARM体系结构各种主要特点外，还在系统安全方面具有如下的特点：</p><ul><li><p>带有灵活的保护单元，以确保操作系统和应用数据的安全。</p></li><li><p>采用软内核技术，防止外部对其进行扫描探测。</p></li><li><p>可集成用户自己的安全特性和其他协处理器。</p><p>SecurCore系列微处理器主要应用于一些对安全性要求较高的应用产品及应用系统，如电子商务、电子政务、电子银行业务、网络和认证系统等领域。</p><p>SecurCore系列微处理器包含SecurCore SC100、SecurCore SC110、SecurCore SC200和SecurCore SC210四种类型，以适用于不同的应用场合。</p></li></ul><h2 id="1-3-6-StrongARM微处理器系列"><a href="#1-3-6-StrongARM微处理器系列" class="headerlink" title="1.3.6 StrongARM微处理器系列"></a>1.3.6 StrongARM微处理器系列</h2><p>Intel StrongARM SA-1100处理器是采用ARM体系结构高度集成的32位RISC微处理器。它融合了Intel公司的设计和处理技术以及ARM体系结构的电源效率，采用在软件上兼容ARMv4体系结构、同时采用具有Intel技术优点的体系结构。</p><p> Intel StrongARM处理器是便携式通讯产品和消费类电子产品的理想选择，已成功应用于多家公司的掌上电脑系列产品。</p><h2 id="1-3-7-Xscale处理器"><a href="#1-3-7-Xscale处理器" class="headerlink" title="1.3.7 Xscale处理器"></a>1.3.7 Xscale处理器</h2><p> Xscale 处理器是基于ARMv5TE体系结构的解决方案，是一款全性能、高性价比、低功耗的处理器。它支持16位的Thumb指令和DSP指令集，已使用在数字移动电话、个人数字助理和网络产品等场合。</p><p> Xscale 处理器是Intel目前主要推广的一款ARM微处理器。</p><h2 id="1-3-8-CortexTM-处理器"><a href="#1-3-8-CortexTM-处理器" class="headerlink" title="1.3.8 CortexTM-?处理器"></a>1.3.8 CortexTM-?处理器</h2><p>ARM公司在经典处理器ARM11以后的产品改用Cortex命名，Cortex系列属于ARMV7架构，这是ARM公司最新的指令集架构。</p><p>ARM V7架构定义了三大分工明确的系列：</p><ul><li>“A”系列面向尖端的基于虚拟内存的操作系统和用户应用；</li><li>“R”系列针对实时系统；</li><li>“M”系列对微控制器。</li></ul><p>CortexTM-M3处理器采用了纯Thumb2指令的执行方式，使得这个具有32位高性能的ARM内核能够实现8位和16位处理器级数的代码存储密度。</p><p>CortexTM-R4处理器是首款基于ARM v7架构的高级嵌入式处理器，其目标主要为产量巨大的高级嵌入式应用方案，如硬盘，喷墨式打印机，以及汽车安全系统等等。</p><p>CortexTM-R4F处理器在CortexTM-R4处理器的基础上加入了代码错误校正（ECC）技术、浮点运算单元（FPU）以及DMA综合配置的能力。</p><p>CortexTM-A8是ARM公司所开发的基于ARMv7架构的首款应用级处理器，同时也是ARM所开发的同类处理器中性能最好、能效最高的处理器。</p><p><strong>Cortex-A8的系统框图</strong></p><p>Cortex-A8第一款基于ARMv7构架的应用处理器。专门提供了新的函数库（Artisan Advantage-CE）</p><p><img src="/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC1%E7%AB%A0-ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0/image-20230326101916664.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="结构"></p><p><strong>Cortex-R4的系统框图</strong></p><p>Cortex-R4是ARM开发的超标量结构的ARM内核，主要面向实时控制领域，如汽车刹车控制等</p><p><img src="/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC1%E7%AB%A0-ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0/image-20230326101942611.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="r4"></p><p><strong>Cortex-M3的系统框图</strong></p><p>Cortex-M系列主要面向单片机领域，可以说是51单品机的完美替代品。</p><p><img src="/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC1%E7%AB%A0-ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0/image-20230326102013105.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="m"></p><h1 id="1-4-ARM微处理器结构"><a href="#1-4-ARM微处理器结构" class="headerlink" title="1.4 ARM微处理器结构"></a>1.4 ARM微处理器结构</h1><h2 id="1-4-1-RISC体系结构"><a href="#1-4-1-RISC体系结构" class="headerlink" title="1.4.1 RISC体系结构"></a>1.4.1 RISC体系结构</h2><p>传统的<strong>CISC</strong>（<strong>Complex Instruction Set Computer</strong>，复杂指令集计算机）结构有其固有的缺点，即随着计算机技术的发展而不断引入新的复杂的指令集，为支持这些新增的指令，计算机的体系结构会越来越复杂，然而，在CISC指令集的各种指令中，其使用频率却相差悬殊，大约有20％的指令会被反复使用，占整个程序代码的80％。而余下的80％的指令却不经常使用，在程序设计中只占20％，显然，这种结构是不太合理的。</p><p>基于以上的不合理性，1979年美国加州大学伯克利分校提出了<strong>RISC</strong>（<strong>Reduced Instruction Set Computer</strong>，精简指令集计算机）的概念，RISC并非只是简单地去减少指令，而是把着眼点放在了如何使计算机的结构更加简单合理地提高运算速度上。RISC结构优先选取使用频度最高的简单指令，避免复杂指令；将指令长度固定，指令格式和寻址方式种类减少；以控制逻辑为主，不用或少用微码控制等措施来达到上述目的。</p><p>到目前为止，RISC体系结构也还没有严格的定义，一般认为，RISC体系结构应具有如下特点：</p><ul><li><strong>采用固定长度的指令格式，指令归整、简单、基本寻址方式有2-3种。</strong></li><li><strong>使用单周期指令，便于流水线操作执行。</strong></li><li><strong>大量使用寄存器，数据处理指令只对寄存器进行操作，只有加载&#x2F;存储指令可以访问存储器，提高指令的执行效率。</strong></li></ul><p>除此以外，ARM体系结构还采用了一些特别的技术，在保证高性能的前提下尽量缩小芯片的面积，并降低功耗：</p><ul><li><strong>所有的指令都可根据前面的执行结果决定是否被执行，从而提高指令的执行效率。（条件执行）</strong></li><li><strong>可用加载&#x2F;存储指令批量传输数据，以提高数据的传输效率。</strong></li><li><strong>可在一条数据处理指令中同时完成逻辑处理和移位处理。</strong></li><li><strong>在循环处理中使用地址的自动增减来提高运行效率。</strong></li></ul><p>当然，和CISC架构相比较，尽管RISC架构有上述的优点，但决不能认为RISC架构就可以取代CISC架构，事实上，RISC和CISC各有优势，而且界限并不那么明显。现代的CPU往往采用CISC的外围，内部加入了RISC的特性，如<strong>超长指令集</strong>CPU就是融合了RISC和CISC的优势，成为未来的CPU发展方向之一。</p><h4 id="ARM协处理器"><a href="#ARM协处理器" class="headerlink" title="ARM协处理器"></a>ARM协处理器</h4><p><img src="/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC1%E7%AB%A0-ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0/image-20230326102143336.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="协"></p><ul><li>多达16个可定义协处理器,用唯一的ID来标示 </li><li>扩充ARM指令集</li><li>通常用作ARM “internal functions” (例如：cp15通常 用作 ARM cache 控制器)</li><li>通常系统设计的时候最好用<strong>内存映射外设</strong><ul><li>容易实现</li></ul></li></ul><h2 id="1-4-2-数据和指令类型"><a href="#1-4-2-数据和指令类型" class="headerlink" title="1.4.2 数据和指令类型"></a>1.4.2 数据和指令类型</h2><p>ARM 采用的是32位架构.</p><p>ARM 约定:</p><ul><li><strong>Byte</strong> <strong>：</strong>   <strong>8 bits (1 byte)</strong></li><li><strong>Halfword</strong> <strong>：</strong> <strong>16 bits (2 bytes)</strong></li><li><strong>Word :   32 bits (4 bytes)</strong></li></ul><p>大部分ARM core 提供：</p><ul><li>ARM 指令集（32-bit） </li><li>Thumb 指令集(T变种)（16-bit ）</li></ul><h4 id="字节顺序"><a href="#字节顺序" class="headerlink" title="字节顺序"></a>字节顺序</h4><p><img src="/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC1%E7%AB%A0-ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0/image-20230326102251549.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="endian"></p><h2 id="1-4-3-ARM体系结构的异常中断"><a href="#1-4-3-ARM体系结构的异常中断" class="headerlink" title="1.4.3 ARM体系结构的异常中断"></a><strong>1.4.3 ARM</strong>体系结构的异常中断</h2><p>ARM 有7个基本工作模式:</p><ul><li><strong>User</strong>:非特权模式，大部分任务执行在这种模式<ul><li>正常程序执行的模式</li></ul></li><li><strong>FIQ</strong>:当一个高优先级(fast)中断产生时将会进入这种模式<ul><li>高速数据传输和通道处理</li></ul></li><li><strong>IRQ</strong>:当一个低优先级(normal)中断产生时将会进入这种模式<ul><li>通常的中断处理</li></ul></li><li><strong>Supervisor</strong>:当复位或软中断指令执行时将会进入这种模式<ul><li>供操作系统使用的一种保护模式</li></ul></li><li><strong>Abort</strong>: 当存取异常时将会进入这种模式<ul><li>虚拟存储及存储保护(指令预取和存取操作)</li></ul></li><li><strong>Undef</strong>: 当执行未定义指令时会进入这种模式<ul><li>软件仿真硬件协处理器</li></ul></li><li><strong>System</strong>: 使用和User模式相同寄存器集的特权模式<ul><li>特权级的操作系统任务</li></ul></li></ul><h4 id="系统模式"><a href="#系统模式" class="headerlink" title="系统模式"></a>系统模式</h4><p>解决异常可重入问题的，就是如果异常处理函数中有函数调用的话要进入系统模式执行，因为使用的是用户模式的lr，这样就避免如果来了相同的异常造成lr_mode被复写，陷入死循环的问题</p><h2 id="1-4-4-ARM微处理器的寄存器结构-P-11"><a href="#1-4-4-ARM微处理器的寄存器结构-P-11" class="headerlink" title="1.4.4 ARM微处理器的寄存器结构(P.11)"></a>1.4.4 ARM微处理器的寄存器结构(P.11)</h2><p>ARM处理器共有37个寄存器，被分为若干个组（bank），这些寄存器包括：</p><ul><li>31个通用寄存器，包括程序计数器（PC指针），均为32位的寄存器。</li><li>6个状态寄存器，用以标识CPU的工作状态及程序的运行状态，均为32位，目前只使用了其中的一部分。</li></ul><p>同时，ARM处理器又有7种不同的处理器模式，在每一种处理器模式下均有一组相应的寄存器与之对应。即在任意一种处理器模式下，可访问的寄存器包括15个通用寄存器（R0～R14）、一至二个状态寄存器和程序计数器。在所有的寄存器中，有些是在7种处理器模式下共用的同一个物理寄存器，而有些寄存器则是在不同的处理器模式下有不同的物理寄存器。</p><p>关于ARM处理器的寄存器结构，在后面的相关章节将会详细描述</p><h4 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h4><p>当异常产生时, ARM core:</p><ul><li><strong>拷贝</strong> <strong>CPSR</strong> <strong>到</strong> <strong>SPSR_<mode></strong></li><li><strong>设置适当的</strong> <strong>CPSR</strong> <strong>位：</strong> </li><li><strong>改变处理器状态进入</strong> <strong>ARM</strong> <strong>态</strong></li><li><strong>改变处理器模式进入相应的异常模式</strong></li><li><strong>设置中断禁止位禁止相应中断</strong> (若需要）</li><li><strong>保存返回地址到</strong> <strong>LR_<mode></strong></li><li><strong>设置</strong> <strong>PC</strong> <strong>为相应的异常向量</strong></li></ul><p>返回时, 异常处理需要:</p><ul><li><strong>从</strong> SPSR_<mode>恢复CPSR</li><li>从LR_<mode>恢复PC</li></ul><blockquote><p>Note:这些操作只能在 ARM 态执行</p></blockquote><p><img src="/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC1%E7%AB%A0-ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0/image-20230326102650087.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="table"></p><h2 id="1-4-5-ARM微处理器的指令结构"><a href="#1-4-5-ARM微处理器的指令结构" class="headerlink" title="1.4.5 ARM微处理器的指令结构"></a>1.4.5 ARM微处理器的指令结构</h2><p>ARM微处理器的在较新的体系结构中支持两种指令集：</p><ul><li>ARM指令集</li><li>Thumb指令集</li><li>其中，ARM指令为32位的长度，Thumb指令为16位长度。Thumb指令集为ARM指令集的功能子集，但与等价的ARM代码相比较，可节省30％～40％以上的存储空间，同时具备32位代码的所有优点。</li></ul><p>关于ARM处理器的指令结构，在后面的相关章节将会详细描述。</p><h4 id="ARM指令集"><a href="#ARM指令集" class="headerlink" title="ARM指令集"></a>ARM指令集</h4><ul><li>所有ARM指令均为32-bits长</li><li>大部分为单周期指令</li><li>所有指令都可以条件执行</li><li>采用 Load&#x2F;Store 架构</li></ul><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-meta">#数据处理指令：</span><br> <span class="hljs-keyword">SUB</span>    <span class="hljs-built_in">r0</span>,<span class="hljs-built_in">r1</span>,<span class="hljs-meta">#5;r1-5-&gt;r0  </span><br> <span class="hljs-keyword">ADD</span>    <span class="hljs-built_in">r2</span>,<span class="hljs-built_in">r3</span>,<span class="hljs-built_in">r3</span>,<span class="hljs-keyword">LSL</span> <span class="hljs-meta">#2;R3x4+r3-&gt;r2</span><br> ANDS   <span class="hljs-built_in">r4</span>,<span class="hljs-built_in">r4</span>,<span class="hljs-meta">#0x20;r4+0x20-&gt;r4,更新条件码标志位</span><br> ADDEQ  <span class="hljs-built_in">r5</span>,<span class="hljs-built_in">r5</span>,<span class="hljs-built_in">r6</span><span class="hljs-comment">;r5+r6-&gt;r5(条件-相等)</span><br><span class="hljs-meta">#存储器存取指令：</span><br> LDR    <span class="hljs-built_in">r0</span>,[<span class="hljs-built_in">r1</span>],<span class="hljs-meta">#4;r1+4-&gt;r0</span><br> STRNEB <span class="hljs-built_in">r2</span>,[<span class="hljs-built_in">r3</span>,<span class="hljs-built_in">r4</span>]<span class="hljs-comment">;NE符合-将r2低8位数写到[r3+r4]内存单元</span><br> LDRSH  <span class="hljs-built_in">r5</span>,[<span class="hljs-built_in">r6</span>,<span class="hljs-meta">#8]! ;[r6+8]-&gt;r5(半字节),r5中高16位设置成字节的符位</span><br> STMFD  sp!,&#123;<span class="hljs-built_in">r0</span>,<span class="hljs-built_in">r2</span>-<span class="hljs-built_in">r7</span>,<span class="hljs-built_in">r10</span>&#125;<span class="hljs-comment">;压栈 </span><br></code></pre></td></tr></table></figure><p>ARM 跳转分支指令</p><ul><li>B <label><ul><li>PC ±32 Mbyte .</li></ul></li><li>BL &lt;子程序&gt;<ul><li>保存返回地址到 LR</li><li>返回时从 LR 恢复 PC</li><li>对于 non-leaf 函数, LR 必须压栈保存</li></ul></li></ul><p><img src="/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC1%E7%AB%A0-ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0/image-20230326103002764.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="b"></p><h4 id="Thumb指令集"><a href="#Thumb指令集" class="headerlink" title="Thumb指令集"></a>Thumb指令集</h4><p>•Thumb 是一个 16-bits 指令集</p><p>​–优化代码密度 (~65% of ARM )</p><p>​–提高窄内存操作性能</p><p>​–是ARM指令集的一个功能子集</p><p>•ARM &#x2F; Thumb 转换使用 <strong>BX</strong> 指令</p><p><img src="/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC1%E7%AB%A0-ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0/image-20230326103049145.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="thumb"></p><h4 id="ARM-x2F-Thumb-性能分析"><a href="#ARM-x2F-Thumb-性能分析" class="headerlink" title="ARM &#x2F; Thumb 性能分析"></a>ARM &#x2F; Thumb 性能分析</h4><p><img src="/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC1%E7%AB%A0-ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0/image-20230326103109460.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="性能"></p><h4 id="Jazelle"><a href="#Jazelle" class="headerlink" title="Jazelle"></a>Jazelle</h4><ul><li>Jazelle 使得 ARM cores 执行 8-bit 的Java 字节码<ul><li>95% 的字节码执行使用 hardware (typical)<ul><li>Normal JVM: 1.0 Caffeinemarks&#x2F;MHz</li><li>ARM9EJ: 5.5 Caffeinemarks&#x2F;MHz</li></ul></li><li>更高的性能</li><li>增加的门电路&lt;12K （ARM9EJ-S 同 ARM9E-S比较）</li></ul></li><li>ARM JTEK (Java Technology Enabling Kit) 提供支持代码</li></ul><h1 id="1-5-ARM微处理器的应用选型"><a href="#1-5-ARM微处理器的应用选型" class="headerlink" title="1.5 ARM微处理器的应用选型"></a>1.5 ARM微处理器的应用选型</h1><ul><li><p>ARM微处理器内核的选择</p><ul><li>从前面所介绍的内容可知，ARM微处理器包含一系列的内核结构，以适应不同的应用领域，用户如果希望使用WinCE或标准Linux等操作系统以减少软件开发时间，就需要选择ARM720T以上带有MMU（Memory Management Unit）功能的ARM芯片，ARM720T、ARM920T、ARM922T、ARM946T、Strong-ARM都带有MMU功能。而ARM7TDMI则没有MMU，不支持Windows CE和标准Linux，但目前有uCLinux等不需要MMU支持的操作系统可运行于ARM7TDMI硬件平台之上。事实上，uCLinux已经成功移植到多种不带MMU的微处理器平台上，并在稳定性和其他方面都有上佳表现。</li></ul></li><li><p>系统的工作频率</p><ul><li>系统的工作频率在很大程度上决定了ARM微处理器的处理能力。ARM7系列微处理器的典型处理速度为0.9MIPS&#x2F;MHz，常见的ARM7芯片系统主时钟为20MHz-133MHz，ARM9系列微处理器的典型处理速度为1.1MIPS&#x2F;MHz，常见的ARM9的系统主时钟频率为100MHz-233MHz，ARM10最高可以达到700MHz。不同芯片对时钟的处理不同，有的芯片只需要一个主时钟频率，有的芯片内部时钟控制器可以分别为ARM核和USB、UART、DSP、音频等功能部件提供不同频率的时钟</li></ul></li><li><p>芯片内存储器的容量</p><ul><li>大多数的ARM微处理器片内存储器的容量都不太大，需要用户在设计系统时外扩存储器，但也有部分芯片具有相对较大的片内存储空间，如ATMEL的AT91F40162就具有高达2MB的片内程序存储空间，用户在设计时可考虑选用这种类型，以简化系统的设计。</li></ul></li><li><p>片内外围电路的选择</p><ul><li>除ARM微处理器核以外，几乎所有的ARM芯片均根据各自不同的应用领域，扩展了相关功能模块，并集成在芯片之中，称之为片内外围电路，如USB接口、IIS接口、LCD控制器、键盘接口、RTC、ADC和DAC、DSP协处理器等，设计者应分析系统的需求，尽可能采用片内外围电路完成所需的功能，这样既可简化系统的设计，同时提高系统的可靠性。</li></ul></li></ul><h1 id="1-6-基于ARM系统设计示例"><a href="#1-6-基于ARM系统设计示例" class="headerlink" title="1.6 基于ARM系统设计示例"></a>1.6 基于ARM系统设计示例</h1><p><img src="/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC1%E7%AB%A0-ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0/image-20230326103342846.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="arm"></p><p><img src="/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC1%E7%AB%A0-ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0/image-20230326103351253.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="AMBA总线"></p><p>•AMBA</p><p>–Advanced Microcontroller Bus Architecture</p><p>•ADK</p><p>Complete AMBA Design Kit</p><p>•ACT</p><p>–AMBA Compliance Testbench</p><p>•PrimeCell</p><p>–ARM’s AMBA compliant peripherals</p><blockquote><p><strong>ARM Developer Suite 1.2</strong></p><p>ADS1.2是为嵌入式ARM开发而设计的一整套软件开发工具</p><p>从最初的软件原型到最终优化的ROM代码。</p><p>ADS1.2发布于2001的12月份</p><p>支持的主机系统</p><ul><li>IBM compatible PCs with Windows 95, 98, 2000, ME or NT4</li><li>Sun workstations with Solaris 2.6, 2.7 or 2.8</li><li>HP workstations with HPUX 10.20, 11</li><li>Red Hat Linux 6.2 &amp; 7.1</li></ul><p>使用FLEXLM管理器,管理它的LICENSE</p><p>45天的评估版软件</p><p>第三方工具支持:</p><p><strong><a href="http://www.arm.com/DevSupp/">http://www.arm.com/DevSupp/</a></strong></p></blockquote><p><strong>使用 Multi-ICE 调试</strong></p><p><img src="/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC1%E7%AB%A0-ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0/image-20230326103452042.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="交叉编译"></p><ul><li>被调试的系统可以是最终系统!</li><li>也可以使用第三方开发调试工具。</li></ul><p><img src="/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC1%E7%AB%A0-ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0/image-20230326103524702.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="ARM 实时跟踪"></p><ul><li><strong>Embedded Trace</strong> <strong>Macrocell</strong> <strong>(ETM)</strong><ul><li>实时指令 (PC) 跟踪</li><li>实时数据访问跟踪</li><li>包含 ICE功能（trigger &amp; filter logic）</li></ul></li><li><strong>MultiTrace</strong> <strong>Trace Port Analyzer (TPA)</strong><ul><li>更深层次的追踪</li></ul></li><li><strong>Trace Debug Tools</strong><ul><li>通过 JTAG&#x2F;Multi-ICE配置 ETM 跟踪</li><li>从ETM&#x2F;MultiTrace接收跟踪信息</li><li>使用源代码镜像文件得到 ETM跟踪的数据</li></ul></li></ul><h1 id="1-7-本章小节"><a href="#1-7-本章小节" class="headerlink" title="1.7 本章小节"></a>1.7 本章小节</h1><p>本章对ARM微处理器、ARM技术的基本概念做了一些简单的介绍，通过对本章的学习，能对ARM微处理器、ARM技术有一个总体上的认识</p>]]></content>
    
    
    <categories>
      
      <category>学习资料</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ARM体系结构与编程</tag>
      
      <tag>课件笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GPT-3代码辅助工具尝鲜-cursor</title>
    <link href="/GPT-3%E4%BB%A3%E7%A0%81%E8%BE%85%E5%8A%A9%E5%B7%A5%E5%85%B7%E5%B0%9D%E9%B2%9C-cursor/"/>
    <url>/GPT-3%E4%BB%A3%E7%A0%81%E8%BE%85%E5%8A%A9%E5%B7%A5%E5%85%B7%E5%B0%9D%E9%B2%9C-cursor/</url>
    
    <content type="html"><![CDATA[<h1 id="一-大概的背景"><a href="#一-大概的背景" class="headerlink" title="一.大概的背景"></a>一.大概的背景</h1><p>舍友推荐了一个新的GPT代码辅助IDE</p><p><img src="/GPT-3%E4%BB%A3%E7%A0%81%E8%BE%85%E5%8A%A9%E5%B7%A5%E5%85%B7%E5%B0%9D%E9%B2%9C-cursor/image-20230321231411897.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="官网"></p><p>网址<a href="https://www.cursor.so/">https://www.cursor.so/</a></p><p>ctrl +l 可以询问代码相关问题</p><p>ctrl +k 可以叫他帮忙写代码</p><p>目前应该对英语支持较好，使用模型为GPT-3(问他不认识3090ti，回答的最新ubuntu为21.04)</p><p><img src="/GPT-3%E4%BB%A3%E7%A0%81%E8%BE%85%E5%8A%A9%E5%B7%A5%E5%85%B7%E5%B0%9D%E9%B2%9C-cursor/image-20230321231918714.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="嗯对"></p><p><img src="/GPT-3%E4%BB%A3%E7%A0%81%E8%BE%85%E5%8A%A9%E5%B7%A5%E5%85%B7%E5%B0%9D%E9%B2%9C-cursor/image-20230321231949430.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="不认识"></p><p>免费，不需要梯子，这点好评。</p><h1 id="二-使用测试"><a href="#二-使用测试" class="headerlink" title="二.使用测试"></a>二.使用测试</h1><p>试着让他帮我写个可以画图的java代码</p><p><img src="/GPT-3%E4%BB%A3%E7%A0%81%E8%BE%85%E5%8A%A9%E5%B7%A5%E5%85%B7%E5%B0%9D%E9%B2%9C-cursor/image-20230321232153616.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="生成代码测试"></p><p>能跑，但不太对劲</p><p><img src="/GPT-3%E4%BB%A3%E7%A0%81%E8%BE%85%E5%8A%A9%E5%B7%A5%E5%85%B7%E5%B0%9D%E9%B2%9C-cursor/image-20230321232300485.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="运行效果有点偏差"></p><p>我舍友测过叫他写二叉树是可以的，如果输出不完可以输入continue继续写</p><p>代码解释</p><p><img src="/GPT-3%E4%BB%A3%E7%A0%81%E8%BE%85%E5%8A%A9%E5%B7%A5%E5%85%B7%E5%B0%9D%E9%B2%9C-cursor/image-20230321233320365.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="随便找的代码"></p><h1 id="三-评价"><a href="#三-评价" class="headerlink" title="三.评价"></a>三.评价</h1><p>虽然仍有缺陷，但功能研究够强大了，目前免费，如果以后转收费了，可能会更强，趁着还没火，多玩几下还是爽的。</p>]]></content>
    
    
    <categories>
      
      <category>杂谈</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Cursor</tag>
      
      <tag>GPT</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机组成原理-L03-ALU</title>
    <link href="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L03-ALU/"/>
    <url>/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L03-ALU/</url>
    
    <content type="html"><![CDATA[<h1 id="计算机组成与实践-算术和逻辑单元（ALU）"><a href="#计算机组成与实践-算术和逻辑单元（ALU）" class="headerlink" title="计算机组成与实践 -算术和逻辑单元（ALU）"></a><strong>计算机组成与实践</strong> -算术和逻辑单元（ALU）</h1><h2 id="一-概述"><a href="#一-概述" class="headerlink" title="一.概述"></a>一.概述</h2><p>MIPS指令集：add、sub、and、or……</p><p>ALU的实现</p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L03-ALU/image-20230321230943274.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="alu"></p><h4 id="设计MIPS的ALU"><a href="#设计MIPS的ALU" class="headerlink" title="设计MIPS的ALU"></a><strong>设计MIPS的ALU</strong></h4><p>必须支持MIPS指令集中的算术与逻辑操作</p><ul><li>加减指令：add、addi、addiu、sub、subu等</li><li>乘除指令：mult、multu、div、divu、sqrt</li><li>逻辑运算指令：and、andi、nor、or、ori、xor</li><li>分支指令：beq、bne、slt、slti、sltiu、sltu</li></ul><p>以及一些指令所需的特殊处理：</p><ul><li>符号扩展：addi、addiu、slti、sltiu</li><li>零扩展：andi、ori、xori</li><li>溢出检测：add、addi、sub</li></ul><h4 id="MIPS算术与逻辑指令"><a href="#MIPS算术与逻辑指令" class="headerlink" title="MIPS算术与逻辑指令"></a><strong>MIPS算术与逻辑指令</strong></h4><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L03-ALU/image-20230321233509253.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="R型"></p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L03-ALU/image-20230321233601720.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="I型"></p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L03-ALU/image-20230321233634589.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="非立即数"></p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L03-ALU/image-20230321233651180.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="立即数指令"></p><h2 id="二-加法"><a href="#二-加法" class="headerlink" title="二.加法"></a>二.加法</h2><h4 id="加法"><a href="#加法" class="headerlink" title="加法"></a>加法</h4><p>7+6</p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L03-ALU/image-20230321233728883.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="进位示意图"></p><p>Ø如果结果超过32位将产生溢出</p><ul><li><p>正数和负数相加-&gt;不产生溢出</p></li><li><p>两个正数相加</p><ul><li>如果结果的符号位为1，则产生了溢出</li></ul></li><li><p>两个负数相加</p><ul><li>如果结果的符号位为0，则产生了溢出</li></ul></li></ul><h4 id="1位全加器"><a href="#1位全加器" class="headerlink" title="1位全加器"></a><strong>1位全加器</strong></h4><p>Ø输入端：两个加数、进位输入</p><p>Ø输出端：和、进位输出</p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L03-ALU/image-20230321235423357.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="example"></p><blockquote><p>S &#x3D; A xor B xor Cin</p><p>Cout &#x3D; (A and B) or (A and Cin) or (B andCin)</p></blockquote><p><strong>如何用1位全加器构建32-bit全加器？</strong></p><p>：串联32个1位全加器</p><h4 id="32-bit全加器"><a href="#32-bit全加器" class="headerlink" title="32-bit全加器"></a><strong>32-bit全加器</strong></h4><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L03-ALU/image-20230321235601014.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="串行"></p><ul><li>将低位的Cout连接到相邻高位的Cin就可以构建32-bit全加器</li><li>串行加法器或行波进位加法器（Ripple Carry Adder, RCA）<ul><li>​🙂:逻辑简单，低开销</li><li>​☹：速度慢</li></ul></li><li>n-bit串行加法器的性能<ul><li>​     <em>n</em> × <em>CP</em></li></ul></li></ul><h4 id="快速加法：超前进位"><a href="#快速加法：超前进位" class="headerlink" title="快速加法：超前进位"></a><strong>快速加法：超前进位</strong></h4><p>关键是提高高阶进位的速度</p><p>Cout &#x3D; (A and B) or (A and Cin) or (B andCin)</p><p>Cout &#x3D; AB+ACin+BCin&#x3D; AB+(A+B)Cin</p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L03-ALU/image-20230321235737597.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="代入"></p><ul><li>进位生成因子（gi）： aibi</li><li>进位传递因子（ pi ）： (ai+bi)</li></ul><p>ci+1 &#x3D; aibi+ (ai+bi) ci&#x3D;gi+ pi ci</p><h5 id="超前进位"><a href="#超前进位" class="headerlink" title="超前进位"></a><strong>超前进位</strong></h5><p><strong>超前进位加法器（carry-lookahead adder）</strong></p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L03-ALU/image-20230321235903316.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="公式图片"></p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L03-ALU/image-20230321235938705.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="例"></p><p>如果之前的加法器生成了一个进位，并且所有的中间传递因子传输了这个进位，那么ci+1 &#x3D;1</p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L03-ALU/image-20230321235957583.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="计算式"></p><h5 id="4位并行加法器"><a href="#4位并行加法器" class="headerlink" title="4位并行加法器"></a>4位并行加法器</h5><p>根据超前进位设计并行加法器</p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L03-ALU/image-20230322000102881.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="加法器构造"></p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L03-ALU/image-20230322000128162.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="单个结点构造"></p><h4 id="多位并行进位加法器"><a href="#多位并行进位加法器" class="headerlink" title="多位并行进位加法器"></a><strong>多位并行进位加法器</strong></h4><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L03-ALU/image-20230322000214927.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="多位"></p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L03-ALU/image-20230322000241085.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="这里是大P"></p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L03-ALU/image-20230322000312927.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="这里是大G,最后的G0是错误的，应该为G3"></p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L03-ALU/image-20230322000342462.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="计算大C"></p><p><strong>Quiz1-进位传输函数和进位产生函数</strong></p><ul><li>确定两个16 位数的gi、pi、Pi以及Gi值：</li></ul><p>​a: 0001 1010 0011 0011–2</p><p>​b: 1110 0101 1110 1011–2</p><ul><li>CarryOut15(C4)的值是多少</li></ul><blockquote><p>第一题gi，和pi可以直接对应下来计算得出</p><p>a: 0001 1010 0011 0011</p><p>b: 1110 0101 1110 1011</p><hr><p>g: 0000 0000 0010 0011</p><p>p:1111 1111 1111 1011</p><table><thead><tr><th></th><th>3</th><th>2</th><th>1</th><th>0</th></tr></thead><tbody><tr><td>Pi</td><td>1</td><td>1</td><td>1</td><td>0</td></tr><tr><td>Gi</td><td>0</td><td>0</td><td>1</td><td>0</td></tr></tbody></table><p>第二题，带入</p><p>C4&#x3D;0+0+1+0&#x3D;1</p></blockquote><p><strong>Quiz2-加法器的性能比较</strong></p><p>行波进位加法器和超前进位加法器速度的比较.</p><p>假设通过每个与门&#x2F;或门需要的时间是相同的。比较16 位加法器路径上门延迟的数量，一个用行波进位，另一个用的是两级的超前进位。（1位全加器的每个进位输出信号需要2个门延迟）</p><blockquote><p>行波进位加法器指的将16个1位加法器串联，每个全加器，执行加法的同时执行</p><p>S &#x3D; A xor B xor Cin</p><p>Cout &#x3D; (A and B) or (A and Cin) or (B andCin) 对于这个进位信号，有两种不同的门运算（与和或），门延迟为2，由于串行每一位加法器都需要等待后一个的进位信号，因此从最低进位道最高进位，总门延迟为16*2&#x3D;32个门延迟</p><p>超前进位加法器最高位输出是上一题的C4,由于两级超前进位，每一级内的操作都是并行的，第一步计算小p,小g，都只有一个与或门运算，因此门延迟为1.第二级计算大P,门延迟1，计算大G门延迟2，因此第二级总的门延迟为2(P&#x2F;G的运算也是并行的).最后计算C4时的门延迟为2。整体最坏的门延迟是5（假设每个逻辑运算都是一个门延迟）.</p></blockquote><h3 id="减法"><a href="#减法" class="headerlink" title="减法"></a><strong>减法</strong></h3><p>看作加法的第二个操作数为负数</p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L03-ALU/image-20230322003030271.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="计算时不考虑符号"></p><h4 id="减法器设计"><a href="#减法器设计" class="headerlink" title="减法器设计"></a><strong>减法器设计</strong></h4><p>设计思想：X – Y &#x3D; X + (-Y)</p><ul><li>​每个bit位取反</li></ul><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L03-ALU/image-20230322003151001.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="结构"></p><ul><li>​最低位加1</li></ul><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L03-ALU/image-20230322003225365.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="流程"></p><blockquote><p>感觉是取模得到最高位（符号位）然后再按不同的方法处理</p></blockquote><h4 id="溢出检测"><a href="#溢出检测" class="headerlink" title="溢出检测"></a><strong>溢出检测</strong></h4><p>如果结果超过32位将产生溢出</p><ul><li>两个正数或两个负数相减，不产生溢出</li><li>当正数加正数：结果符号位为1则溢出</li><li>当负数加负数：结果符号位为0则溢出</li></ul><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L03-ALU/image-20230322003620484.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="二进制算式"></p><ul><li>最高有效位的进位输入与进位输出异或</li></ul><blockquote><p>V&#x3D;Cin ⊕ Cout </p></blockquote><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L03-ALU/image-20230322003701153.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="溢出检测"></p><ul><li>无符号整数的溢出可以忽略</li><li>溢出时产生异常<ul><li>加法add、立即数加法addi 和减法sub</li></ul></li><li>溢出时不产生异常<ul><li>无符号加法addu、立即数无符号加法addiu 和无符号减法subu</li></ul></li><li>C语言忽略溢出，C编译器采用无符号算术指令</li></ul><h3 id="ALU需要支持的其他操作"><a href="#ALU需要支持的其他操作" class="headerlink" title="ALU需要支持的其他操作"></a><strong>ALU需要支持的其他操作</strong></h3><ul><li>逻辑操作（and, or, xor, nor）<ul><li>按位操作，不涉及进位</li><li>每个功能需要一个逻辑门，多选器选择输出结果</li></ul></li><li>小于则置位指令（slt）<ul><li>使用减法判断a-b是否小于0</li></ul></li><li>条件分支指令的相等测试（bne，beq）<ul><li>使用减法判断a-b是否等于0</li></ul></li><li>立即数指令<ul><li>ALU外设置符号扩展</li></ul></li></ul><h4 id="支持逻辑操作的ALU单元设计"><a href="#支持逻辑操作的ALU单元设计" class="headerlink" title="支持逻辑操作的ALU单元设计"></a><strong>支持逻辑操作的ALU单元设计</strong></h4><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L03-ALU/image-20230322003835696.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="逻辑操作"></p><h4 id="实现slt"><a href="#实现slt" class="headerlink" title="实现slt"></a><strong>实现slt</strong></h4><ul><li>首先进行减法<ul><li>如果减法结果为负数（最高有效位结果为1），将result置为1</li><li>如果减法结果为正数（最高有效位结果为0），将result置为0</li></ul></li><li>将最高有效位（set）连接到最低位的less输入</li></ul><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L03-ALU/image-20230322003935750.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="slt"></p><h4 id="一个简单完整的ALU"><a href="#一个简单完整的ALU" class="headerlink" title="一个简单完整的ALU"></a><strong>一个简单完整的ALU</strong></h4><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L03-ALU/image-20230322004847719.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="alu"></p><h2 id="三-乘法和除法"><a href="#三-乘法和除法" class="headerlink" title="三.乘法和除法"></a>三.乘法和除法</h2><h3 id="乘法"><a href="#乘法" class="headerlink" title="乘法"></a><strong>乘法</strong></h3><p>通过移位与加法实现</p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L03-ALU/image-20230322005058639.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="乘法"></p><p>积的位数是被乘数与乘数的位数之和</p><h4 id="乘法的硬件实现-第一版"><a href="#乘法的硬件实现-第一版" class="headerlink" title="乘法的硬件实现(第一版)"></a><strong>乘法的硬件实现(第一版)</strong></h4><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L03-ALU/image-20230322005140361.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="流程"></p><p>硬件：</p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L03-ALU/image-20230322005222739.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="流程"></p><h4 id="改进后的乘法器"><a href="#改进后的乘法器" class="headerlink" title="改进后的乘法器"></a><strong>改进后的乘法器</strong></h4><p>同时进行加法和移位</p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L03-ALU/image-20230322005319369.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="乘法器"></p><p>每一步只需要一个时钟周期</p><p>​乘法运算频率较低时</p><h5 id="例子-1"><a href="#例子-1" class="headerlink" title="例子-1"></a>例子-1</h5><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L03-ALU/image-20230322005441498.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="机器码"></p><h5 id="更快速的乘法"><a href="#更快速的乘法" class="headerlink" title="更快速的乘法"></a><strong>更快速的乘法</strong></h5><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L03-ALU/image-20230322005521728.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="快速乘法"></p><h5 id="更快速的乘法器设计"><a href="#更快速的乘法器设计" class="headerlink" title="更快速的乘法器设计"></a><strong>更快速的乘法器设计</strong></h5><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L03-ALU/image-20230322005624475.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="快速"></p><h5 id="n×n乘法阵列"><a href="#n×n乘法阵列" class="headerlink" title="n×n乘法阵列"></a><strong>n×n乘法阵列</strong></h5><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L03-ALU/image-20230322005714826.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="matrix"></p><h4 id="MIPS中的乘法指令"><a href="#MIPS中的乘法指令" class="headerlink" title="MIPS中的乘法指令"></a><strong>MIPS中的乘法指令</strong></h4><p>乘法mult和无符号乘法multu</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-keyword">mult</span> $<span class="hljs-built_in">s0</span>, $<span class="hljs-built_in">s1</span>    # hi<span class="hljs-title">||</span>lo = $<span class="hljs-built_in">s0</span> * $<span class="hljs-built_in">s1</span><br></code></pre></td></tr></table></figure><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L03-ALU/image-20230322005801126.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="代码"></p><p>一对容纳64位乘积的寄存器：$hi和$lo</p><ul><li>高32-bit放入寄存器hi，低32-bit放入寄存器lo</li><li>用于存储乘法与除法的结果</li><li>不可直接寻址访问</li><li>通过mflo（move from lo）和mfhi（move from hi）两个指令将积送入指定的寄存器</li></ul><p>编译器会用移位指令替代乘数为2的幂次的乘法操作</p><h3 id="除法"><a href="#除法" class="headerlink" title="除法"></a><strong>除法</strong></h3><ul><li>除数不能为0</li><li>长除法</li><li>如果除数&lt;&#x3D;被除数<ul><li>该位商为1，被除数减去除数</li></ul></li><li>其他<ul><li>该位商为0，取被除数下一位</li></ul></li><li>可恢复的除法<ul><li>被除数减去除数，直到余数小于0，再将被除数加回来</li></ul></li><li>有符号除法<ul><li>采用绝对值进行除法</li><li>源操作数的符号相反时商为负，同时使非零余数的符号和被除数的相同</li></ul></li></ul><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L03-ALU/image-20230322010005895.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="除法例"></p><h4 id="除法的硬件"><a href="#除法的硬件" class="headerlink" title="除法的硬件"></a><strong>除法的硬件</strong></h4><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L03-ALU/image-20230322010105309.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="硬件"></p><h4 id="改进后的除法器"><a href="#改进后的除法器" class="headerlink" title="改进后的除法器"></a><strong>改进后的除法器</strong></h4><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L03-ALU/image-20230322010150571.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="除法器"></p><p>​将加法器和寄存器的位长减半</p><p>​将加法器和寄存器的位长减半</p><p>​有些部件可以共用</p><h4 id="MIPS中的除法"><a href="#MIPS中的除法" class="headerlink" title="MIPS中的除法"></a><strong>MIPS中的除法</strong></h4><p>除法div和无符号除divu</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-built_in">div</span> <span class="hljs-symbol">$</span>s0, <span class="hljs-symbol">$</span>s1    # <span class="hljs-symbol">$</span>lo = <span class="hljs-symbol">$</span>s0/<span class="hljs-symbol">$</span>s1<br>                # <span class="hljs-symbol">$</span>hi = <span class="hljs-symbol">$</span>s0 <span class="hljs-built_in">mod</span> <span class="hljs-symbol">$</span>s1<br><br></code></pre></td></tr></table></figure><ul><li>R型指令格式</li><li>乘法和除法共用硬件</li><li>商存放在$lo，余数存放在$hi</li><li>采用mflo和mfhi指令将运算结果放入其他寄存器</li></ul><h2 id="四-移位"><a href="#四-移位" class="headerlink" title="四.移位"></a>四.移位</h2><h4 id="移位操作"><a href="#移位操作" class="headerlink" title="移位操作"></a><strong>移位操作</strong></h4><p>将所有位向左或者向右移动</p><figure class="highlight cos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cos">sll <span class="hljs-built_in">$t</span>2, <span class="hljs-built_in">$s</span>0, <span class="hljs-number">8</span>  # <span class="hljs-built_in">$t</span>2=<span class="hljs-built_in">$s</span>0 &lt;&lt; <span class="hljs-number">8</span> bits<br>srl <span class="hljs-built_in">$t</span>2, <span class="hljs-built_in">$s</span>0, <span class="hljs-number">8</span>  # <span class="hljs-built_in">$t</span>2=<span class="hljs-built_in">$s</span>0 &gt;&gt; <span class="hljs-number">8</span> bits<br>sra <span class="hljs-built_in">$t</span>2, <span class="hljs-built_in">$s</span>0, <span class="hljs-number">8</span>  # <span class="hljs-built_in">$t</span>2=<span class="hljs-built_in">$s</span>0 &gt;&gt; <span class="hljs-number">8</span> bits<br></code></pre></td></tr></table></figure><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L03-ALU/image-20230323154734600.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="R"></p><ul><li>5bit移位域足够表示移动31位</li><li>逻辑移位以0填充，算术移位以符号位填充</li><li>移位与ALU分开实现</li><li>空指令（nop）当作特殊的左移指令</li></ul><h4 id="移位单元"><a href="#移位单元" class="headerlink" title="移位单元"></a><strong>移位单元</strong></h4><p>控制：</p><ul><li>移动距离（Sh4Sh3Sh2Sh1Sh0）</li><li>移动方向（left，right）</li><li>移动类型（逻辑logical，算术arithmetic）</li></ul><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L03-ALU/image-20230323154930369.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="unit"></p><h4 id="移位实现"><a href="#移位实现" class="headerlink" title="移位实现"></a>移位实现</h4><table><thead><tr><th>Sh0</th><th>!Sh0</th><th><strong>r</strong></th><th><strong>l</strong></th><th>Doi</th></tr></thead><tbody><tr><td>1</td><td>0</td><td>1</td><td>0</td><td>Dii+1</td></tr><tr><td>1</td><td>0</td><td>0</td><td>1</td><td><strong>Dii-1</strong></td></tr><tr><td>0</td><td>1</td><td>0</td><td>0</td><td>Dii</td></tr></tbody></table><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L03-ALU/image-20230323155042299.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="ph"></p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L03-ALU/image-20230323155203019.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="ex"></p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L03-ALU/image-20230323155251585.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="next"></p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L03-ALU/image-20230323155333437.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="then"></p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L03-ALU/image-20230323155402308.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="移位"></p><h2 id="五-浮点数"><a href="#五-浮点数" class="headerlink" title="五.浮点数"></a>五.浮点数</h2><p>计算机中以浮点数表示实数</p><h3 id="科学计数法"><a href="#科学计数法" class="headerlink" title="科学计数法"></a><strong>科学计数法</strong></h3><p>–2.34 × 10^56</p><p>+0.002× 10^–4</p><p>+987.0210 × 10^9</p><table><thead><tr><th><strong>规格化(Normalized)数</strong></th></tr></thead><tbody><tr><td>一个采用科学记数法表示的数，若没有前导零且小数点左边只有一位整数</td></tr></tbody></table><h3 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h3><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L03-ALU/image-20230323155745521.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="结构"></p><table><thead><tr><th>浮点数(floating point)</th></tr></thead><tbody><tr><td>二进制小数点不固定的表达数的计数法</td></tr></tbody></table><ul><li>简化了浮点数的数据交换</li><li>简化了浮点数的算术算法</li><li>提高了用一个字存储的数的精度</li></ul><h4 id="IEEE754浮点数格式"><a href="#IEEE754浮点数格式" class="headerlink" title="IEEE754浮点数格式"></a><strong>IEEE754浮点数格式</strong></h4><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L03-ALU/image-20230323165504602.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="format"></p><ul><li><strong>S</strong>：符号位（0 Þ非负，1 Þ负）</li><li>规格化计数：1.0&lt;&#x3D;|有效位|&lt;&#x3D;2.0<ul><li>二进制数的前导位为1，不需要表示</li><li>有效位由1.与后面的<strong>尾数</strong>部分构成</li></ul></li><li><strong>指数</strong>：实际的指数+偏阶<ul><li>指数为无符号数，为了表示2^-126到2^-127采用了偏阶</li><li>单精度偏阶为127，双精度偏阶为1023</li></ul></li><li>指数代表数值范围，尾数代表数的精度，指数域和尾数域大小需要折中</li></ul><h4 id="单精度浮点数的取值范围"><a href="#单精度浮点数的取值范围" class="headerlink" title="单精度浮点数的取值范围"></a><strong>单精度浮点数的取值范围</strong></h4><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L03-ALU/image-20230323165833524.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="单精度"></p><ul><li>指数00000000和11111111是保留值(1~254)</li><li>最小的值<ul><li>指数为00000001 -&gt; 实际指数&#x3D; 1 – 127 &#x3D; –126</li><li>尾数：000…0 -&gt; 有效位 &#x3D; 1.0</li><li>±1.0 × 2^–126 ≈ ±1.2 × 10^–38</li></ul></li><li>最大的值<ul><li>指数：11111110 -&gt;实际指数&#x3D; 254 – 127 &#x3D; +127</li><li>尾数：111…1-&gt;有效位 ≈ 2.0</li><li>±2.0 × 2^+127 ≈ ±3.4 × 10^+38</li></ul></li></ul><h4 id="双精度浮点数的取值范围"><a href="#双精度浮点数的取值范围" class="headerlink" title="双精度浮点数的取值范围"></a><strong>双精度浮点数的取值范围</strong></h4><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L03-ALU/image-20230323165847894.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="双精度"></p><ul><li>指数000…0到111…1是保留值(1~2046)</li><li>最小的值<ul><li>指数为00000000001 -&gt; 实际指数&#x3D; 1 – 1023 &#x3D; –1022</li><li>尾数：000…0 -&gt; 有效位 &#x3D; 1.0</li><li>±1.0 × 2^–1022 ≈ ±2.2 × 10^–308</li></ul></li><li>最大的值<ul><li>指数：11111111110 -&gt; 实际指数&#x3D; 2046-1023&#x3D; +1023</li><li>尾数：111…1-&gt; 有效位 ≈ 2.0</li><li>±2.0 × 2+1023 ≈ ±1.8 × 10^+308</li></ul></li></ul><h4 id="溢出"><a href="#溢出" class="headerlink" title="溢出"></a><strong>溢出</strong></h4><p>浮点数表示法可以表示很大的数值范围，但与无穷还是不同</p><p>溢出（上溢）：正的指数太大而超过指数域的表示范围</p><p>下溢：负的指数太小而超过指数域的表示范围</p><p>浮点数&#x3D;&gt;异常</p><h4 id="浮点数的精确度"><a href="#浮点数的精确度" class="headerlink" title="浮点数的精确度"></a><strong>浮点数的精确度</strong></h4><ul><li>相对精确度</li><li>所有尾数位是有效位</li><li>单精度：约2–23<ul><li>23 × log102 ≈ 23 × 0.3 ≈ 6 位十进制的精度</li></ul></li><li>双精度：约2–52<ul><li>52 × log102 ≈ 52 × 0.3 ≈ 16 位十进制的精度</li></ul></li></ul><h5 id="浮点数例子1"><a href="#浮点数例子1" class="headerlink" title="浮点数例子1"></a><strong>浮点数例子1</strong></h5><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L03-ALU/image-20230323170347882.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="图"></p><h5 id="浮点数例子2"><a href="#浮点数例子2" class="headerlink" title="浮点数例子2"></a>浮点数例子2</h5><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L03-ALU/image-20230323170418417.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="2"></p><h4 id="特殊数"><a href="#特殊数" class="headerlink" title="特殊数"></a><strong>特殊数</strong></h4><table><thead><tr><th><strong>单精度</strong></th><th></th><th>双精度</th><th></th><th>表示对象</th></tr></thead><tbody><tr><td>指数</td><td>尾数</td><td>指数</td><td>尾数</td><td></td></tr><tr><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>0</td><td>非0</td><td>0</td><td>非0</td><td>±非规格化数</td></tr><tr><td>1~254</td><td>任何值</td><td>1~2046</td><td>任何值</td><td>±浮点数</td></tr><tr><td>255</td><td>0</td><td>2047</td><td>0</td><td>±无穷</td></tr><tr><td>255</td><td>非0</td><td>255</td><td>非0</td><td>NaN（非数）</td></tr></tbody></table><ul><li>±无穷<ul><li>避免溢出检测的需要</li></ul></li><li>非数（Not-a-Number，NaN）<ul><li>表示非法数或者无效操作结果</li><li>e.g., 0.0 &#x2F; 0.0</li></ul></li></ul><h4 id="浮点数加法"><a href="#浮点数加法" class="headerlink" title="浮点数加法"></a><strong>浮点数加法</strong></h4><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L03-ALU/image-20230323171026141.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="410"></p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L03-ALU/image-20230323171042330.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="42"></p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L03-ALU/image-20230323170735971.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="流程图"></p><h4 id="FP加法器"><a href="#FP加法器" class="headerlink" title="FP加法器"></a><strong>FP加法器</strong></h4><ul><li>比整数加法器复杂</li><li>如果采用单周期时间完成，时钟周期很长<ul><li>比整数操作时间长很多</li><li>较慢的时钟周期将会影响所有指令</li></ul></li><li>FP加法器花费几个时钟周期<ul><li>可以并行执行</li></ul></li></ul><h4 id="浮点加的基本结构"><a href="#浮点加的基本结构" class="headerlink" title="浮点加的基本结构"></a><strong>浮点加的基本结构</strong></h4><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L03-ALU/image-20230323170837125.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="浮点加法"></p><h4 id="浮点数乘法"><a href="#浮点数乘法" class="headerlink" title="浮点数乘法"></a><strong>浮点数乘法</strong></h4><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L03-ALU/image-20230323170950881.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="4位10"></p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L03-ALU/image-20230323171006092.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="4位2"></p><h4 id="FP运算的硬件"><a href="#FP运算的硬件" class="headerlink" title="FP运算的硬件"></a>FP运算的硬件</h4><ul><li>FP乘法器与FP加法器相似<ul><li>对有效数采用乘法，而不是加法</li></ul></li><li>FP运算硬件通常可以实现<ul><li>加法，减法，乘法，除法，倒数，平方根</li></ul></li><li>FP操作花费几个时钟周期<ul><li>并行执行</li></ul></li></ul><h4 id="MIPS中的浮点指令"><a href="#MIPS中的浮点指令" class="headerlink" title="MIPS中的浮点指令"></a><strong>MIPS中的浮点指令</strong></h4><ul><li>浮点寄存器<ul><li>MIPS 设计增加了单独的浮点寄存器——称为$f0，$f1，$f2 ，…，$f31</li><li>双精度寄存器是一组单精度寄存器的偶数－奇数对，并使用偶数寄存器编号作为其名称</li></ul></li><li>针对浮点寄存器的存和取指令： lwcl 和swcl</li><li>单精度指令<ul><li>add.s, sub.s, mul.s, div.s, c.x.s(例如c.eq.s)</li></ul></li><li>双精度指令<ul><li>add.d, sub.d, mul.d, div.d, c.x.d(例如c.eq.d)</li></ul></li><li>浮点比较为真跳转bclt 和浮点比较为假跳转bclf</li></ul><h4 id="浮点数例子-°F转°C"><a href="#浮点数例子-°F转°C" class="headerlink" title="浮点数例子:°F转°C"></a>浮点数例子:°F转°C</h4><p>C 代码:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">float</span> f2c (<span class="hljs-built_in">float</span> fahr) &#123;<br>   <span class="hljs-built_in">return</span> ((<span class="hljs-number">5.0</span>/<span class="hljs-number">9.0</span>)*(fahr - <span class="hljs-number">32.0</span>));<br>   &#125;<br>  //fahr存放在<span class="hljs-variable">$f12</span>, 结果存放在<span class="hljs-variable">$f0</span><br></code></pre></td></tr></table></figure><p>MIPS汇编代码：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">f2c</span>:<br>      <span class="hljs-attribute">lwcl</span>    $f16, const5($gp)    # $f16=<span class="hljs-number">5</span>.<span class="hljs-number">0</span> (<span class="hljs-number">5</span>.<span class="hljs-number">0</span>在存储器中)<br>      <span class="hljs-attribute">lwcl</span>    $f18, const9($gp)    # $f18=<span class="hljs-number">9</span>.<span class="hljs-number">0</span> (<span class="hljs-number">9</span>.<span class="hljs-number">0</span>在存储器中) <br>      <span class="hljs-attribute">div</span>.s   $<span class="hljs-number">16</span>, $<span class="hljs-number">16</span>, $<span class="hljs-number">18</span>          # $f16=<span class="hljs-number">5</span>.<span class="hljs-number">0</span> / <span class="hljs-number">9</span>.<span class="hljs-number">0</span><br>      <span class="hljs-attribute">lwcl</span>    $f18, const32($gp)  # $f18=<span class="hljs-number">32</span>.<span class="hljs-number">0</span> (<span class="hljs-number">32</span>.<span class="hljs-number">0</span>在存储器中) <br>      <span class="hljs-attribute">sub</span>.s  $f18, $f12, $f18      # $f18=fahr-<span class="hljs-number">32</span>.<span class="hljs-number">0</span> <br>      <span class="hljs-attribute">mul</span>.s  $f0, $f16, $f18        # $f0=(<span class="hljs-number">5</span>.<span class="hljs-number">0</span>/<span class="hljs-number">9</span>.<span class="hljs-number">0</span>)*(fahr-<span class="hljs-number">32</span>.<span class="hljs-number">0</span>)<br>      <span class="hljs-attribute">jr</span>  $ra                                 #return<br></code></pre></td></tr></table></figure><h4 id="浮点数例子：矩阵乘法"><a href="#浮点数例子：矩阵乘法" class="headerlink" title="浮点数例子：矩阵乘法"></a><strong>浮点数例子：矩阵乘法</strong></h4><p>C &#x3D; C + A × B</p><p>都是32 × 32 的二维矩阵, 每个元素都是双精度</p><p>C 代码:</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs inform7">void mm (double c<span class="hljs-comment">[]</span><span class="hljs-comment">[]</span>,<br>    double a<span class="hljs-comment">[]</span><span class="hljs-comment">[]</span>, double b<span class="hljs-comment">[]</span><span class="hljs-comment">[]</span>) &#123;<br> int i, j, k;<br> for (i = 0; i! = 32; i = i + 1)<br>  for (j = 0; j! = 32; j = j + 1)<br>   for (k = 0; k! = 32; k = k + 1)<br>    c<span class="hljs-comment">[i]</span><span class="hljs-comment">[j]</span> = c<span class="hljs-comment">[i]</span><span class="hljs-comment">[j]</span><br>         \+ a<span class="hljs-comment">[i]</span><span class="hljs-comment">[k]</span> * b<span class="hljs-comment">[k]</span><span class="hljs-comment">[j]</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>a,b,c的基地址是参数，存在$a0,$a1,$a2中，i, j, k 分别存在$s0,$s1,$s2中。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs stylus">mm：<br>      <span class="hljs-selector-tag">li</span><span class="hljs-variable">$t1</span>, <span class="hljs-number">32</span><br>      <span class="hljs-selector-tag">li</span><span class="hljs-variable">$s0</span>, <span class="hljs-number">0</span><br>   L1:    <span class="hljs-selector-tag">li</span>    <span class="hljs-variable">$s1</span>, <span class="hljs-number">0</span><br>   L2:    <span class="hljs-selector-tag">li</span>    <span class="hljs-variable">$s2</span>, <span class="hljs-number">0</span><br>     sll   <span class="hljs-variable">$t2</span>, <span class="hljs-variable">$s0</span>, <span class="hljs-number">5</span><br>     addu    <span class="hljs-variable">$t2</span>, <span class="hljs-variable">$t2</span>, <span class="hljs-variable">$s1</span><br>     sll    <span class="hljs-variable">$t2</span>, <span class="hljs-variable">$t2</span>, <span class="hljs-number">3</span><br>     addu    <span class="hljs-variable">$t2</span>, <span class="hljs-variable">$a0</span>, <span class="hljs-variable">$t2</span><br>     l<span class="hljs-selector-class">.d</span>    <span class="hljs-variable">$f4</span>, <span class="hljs-number">0</span>(<span class="hljs-variable">$t2</span>)<br>  L3:    sll    <span class="hljs-variable">$t0</span>, <span class="hljs-variable">$s2</span>, <span class="hljs-number">5</span><br>    addu    <span class="hljs-variable">$t0</span>, <span class="hljs-variable">$t0</span>, <span class="hljs-variable">$s1</span><br>    sll    <span class="hljs-variable">$t0</span>, <span class="hljs-variable">$t0</span>, <span class="hljs-number">3</span><br>    addu    <span class="hljs-variable">$t0</span>, <span class="hljs-variable">$a2</span>, <span class="hljs-variable">$t0</span><br>    l<span class="hljs-selector-class">.d</span>    <span class="hljs-variable">$f16</span>, <span class="hljs-number">0</span>(<span class="hljs-variable">$t0</span>)<br>    sll    <span class="hljs-variable">$t0</span>, <span class="hljs-variable">$s0</span>, <span class="hljs-number">5</span><br>addu    <span class="hljs-variable">$t0</span>, <span class="hljs-variable">$t0</span>, <span class="hljs-variable">$s2</span><br>sll    <span class="hljs-variable">$t0</span>, <span class="hljs-variable">$t0</span>, <span class="hljs-number">3</span><br>addu    <span class="hljs-variable">$t0</span>, <span class="hljs-variable">$a1</span>, <span class="hljs-variable">$t0</span><br>l<span class="hljs-selector-class">.d</span>    <span class="hljs-variable">$f18</span>, <span class="hljs-number">0</span>(<span class="hljs-variable">$t0</span>)<br>mul<span class="hljs-selector-class">.d</span>    <span class="hljs-variable">$f16</span>, <span class="hljs-variable">$f18</span>, <span class="hljs-variable">$f16</span><br>add<span class="hljs-selector-class">.d</span>    <span class="hljs-variable">$f4</span>, <span class="hljs-variable">$f4</span>, <span class="hljs-variable">$f16</span><br>addiu    <span class="hljs-variable">$s2</span>, <span class="hljs-variable">$s2</span>, <span class="hljs-number">1</span><br>bne    <span class="hljs-variable">$s2</span>, <span class="hljs-variable">$t1</span>, L3<br>s<span class="hljs-selector-class">.d</span>    <span class="hljs-variable">$f4</span>, <span class="hljs-number">0</span>(<span class="hljs-variable">$t2</span>)<br>addiu    <span class="hljs-variable">$s1</span>, <span class="hljs-variable">$s1</span>, <span class="hljs-number">1</span><br>bne    <span class="hljs-variable">$s1</span>, <span class="hljs-variable">$t1</span>, L2<br>addiu    <span class="hljs-variable">$s0</span>, <span class="hljs-variable">$s0</span>, <span class="hljs-number">1</span><br>bne    <span class="hljs-variable">$s0</span>, <span class="hljs-variable">$t1</span>, L1<br><br><br></code></pre></td></tr></table></figure><h4 id="算术精确性"><a href="#算术精确性" class="headerlink" title="算术精确性"></a><strong>算术精确性</strong></h4><ul><li>IEEE 756提供几种舍入模式<ul><li>中间结果总是多保留两位，称为保护位（guard）和舍入位（round）</li><li>四种舍入模式： 总是向上舍入（向＋∞ ），总是向下舍入（向－ ∞ ） ， 截断舍入，向最靠近的偶数舍入。</li></ul></li><li>例子：2.56 × 10^0 与 2.34 × 10^2相加<ul><li>首先右移较小的数以对齐指数，有了保护位和舍入位，可以表示两个最低位:0.0256+2.3400&#x3D;2.3656 (×10^2)，</li><li>舍入后变为2.37 ×10^2</li><li>如果没有保护位和舍入位：0.02+2.34&#x3D;2.36 (×10^2)</li></ul></li></ul><h2 id="六-小结"><a href="#六-小结" class="headerlink" title="六.小结"></a>六.小结</h2><ul><li>位模式没有内在的含义<ul><li>对位模式的操作决定其含义</li></ul></li><li>计算机中的数字<ul><li>有限的数值范围与精度</li><li>程序设计中需要考虑到</li></ul></li><li>体系结构支持的算术运算<ul><li>有符号与无符号整数运算</li><li>以浮点数近似表示的实数的运算</li></ul></li><li>有限的取值范围与精度<ul><li>运算可能出现上溢或者下溢</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>学习资料</category>
      
    </categories>
    
    
    <tags>
      
      <tag>课件笔记</tag>
      
      <tag>计算机组成原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>试着白嫖微软U盘</title>
    <link href="/%E8%AF%95%E7%9D%80%E7%99%BD%E5%AB%96%E5%BE%AE%E8%BD%AFU%E7%9B%98/"/>
    <url>/%E8%AF%95%E7%9D%80%E7%99%BD%E5%AB%96%E5%BE%AE%E8%BD%AFU%E7%9B%98/</url>
    
    <content type="html"><![CDATA[<h1 id="一-起因"><a href="#一-起因" class="headerlink" title="一.起因"></a>一.起因</h1><p>今天逛贴吧，突然刷到说微软会给win11 canary通道的测试者开放申请渠道，发u盘用于后续的系统安装，还说高于build25000的会员就会自动转canary。</p><p><img src="/%E8%AF%95%E7%9D%80%E7%99%BD%E5%AB%96%E5%BE%AE%E8%BD%AFU%E7%9B%98/image-20230319185305754.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="大概的消息"></p><p>我马上打开设置看，我不就是吗？</p><p><img src="/%E8%AF%95%E7%9D%80%E7%99%BD%E5%AB%96%E5%BE%AE%E8%BD%AFU%E7%9B%98/image-20230319185540315.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="！"></p><p>于是立刻翻看邮件，居然在几天前就给我发了消息了</p><p><img src="/%E8%AF%95%E7%9D%80%E7%99%BD%E5%AB%96%E5%BE%AE%E8%BD%AFU%E7%9B%98/image-20230319185731991.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="3月14日啊，我居然没有去看这封写了什么"></p><p><img src="/%E8%AF%95%E7%9D%80%E7%99%BD%E5%AB%96%E5%BE%AE%E8%BD%AFU%E7%9B%98/image-20230319185905269.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="这个码我已经用了，哈哈"></p><p>点击链接会跳到一个登记表页面，中国大陆是可以传的，填写之后又发送了一个确认邮件</p><p><img src="/%E8%AF%95%E7%9D%80%E7%99%BD%E5%AB%96%E5%BE%AE%E8%BD%AFU%E7%9B%98/image-20230319190053600.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="码只能用一次，这里就看不到表格了"></p><blockquote><p>*Due to mailing regulations, we are unable to deliver the USB to the following countries: Afghanistan, Cuba, Russia, Timor-Leste, Belarus, Laos, Samoa, Turkmenistan, Bhutan, Libya, Solomon Islands, Yemen, Brunei, Mongolia, South Sudan, Chad, Papua New Guinea, and Syria。</p><p>中国大陆是可以送达的</p></blockquote><p><img src="/%E8%AF%95%E7%9D%80%E7%99%BD%E5%AB%96%E5%BE%AE%E8%BD%AFU%E7%9B%98/image-20230319190224133.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="回执，应该是美国运过来"></p><h1 id="二-收到了"><a href="#二-收到了" class="headerlink" title="二.收到了"></a>二.收到了</h1><p>。。。。。。<img src="/%E8%AF%95%E7%9D%80%E7%99%BD%E5%AB%96%E5%BE%AE%E8%BD%AFU%E7%9B%98/image-20230524161839397.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="收到了"></p><p>微软有东西它是真送啊，我今天下午一回来就看到了，听舍友说是宿管阿姨送上来的。</p><p>过程耗时两个月，从美国发的快递，U盘还以为是8G，实际上是64g的，而且是Made in China</p><p><img src="/%E8%AF%95%E7%9D%80%E7%99%BD%E5%AB%96%E5%BE%AE%E8%BD%AFU%E7%9B%98/image-20230524162120377.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="made in china"></p><p><img src="/%E8%AF%95%E7%9D%80%E7%99%BD%E5%AB%96%E5%BE%AE%E8%BD%AFU%E7%9B%98/image-20230524162138429.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="windows insider program"></p><p><img src="/%E8%AF%95%E7%9D%80%E7%99%BD%E5%AB%96%E5%BE%AE%E8%BD%AFU%E7%9B%98/image-20230524162528710.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="速度不快"></p><p>速度不快，测速也只有20m，还是当作收藏吧</p>]]></content>
    
    
    <categories>
      
      <category>杂谈</category>
      
    </categories>
    
    
    <tags>
      
      <tag>白嫖</tag>
      
      <tag>U盘</tag>
      
      <tag>微软</tag>
      
      <tag>windows</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>嵌入式程序设计ch5-嵌入式输入/输出设备接口</title>
    <link href="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1ch5-%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%BE%93%E5%85%A5-%E8%BE%93%E5%87%BA%E8%AE%BE%E5%A4%87%E6%8E%A5%E5%8F%A3/"/>
    <url>/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1ch5-%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%BE%93%E5%85%A5-%E8%BE%93%E5%87%BA%E8%AE%BE%E5%A4%87%E6%8E%A5%E5%8F%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="嵌入式系统设计-嵌入式输入-x2F-输出设备接口"><a href="#嵌入式系统设计-嵌入式输入-x2F-输出设备接口" class="headerlink" title="嵌入式系统设计-嵌入式输入&#x2F;输出设备接口"></a>嵌入式系统设计-嵌入式输入&#x2F;输出设备接口</h1><h2 id="一-I-x2F-O接口"><a href="#一-I-x2F-O接口" class="headerlink" title="一.I&#x2F;O接口"></a>一.I&#x2F;O接口</h2><h3 id="硬件结构"><a href="#硬件结构" class="headerlink" title="硬件结构"></a>硬件结构</h3><p>接口结构：连接外设与CPU的中间接口电路</p><ul><li><p>满足外设具备多样性、复杂性、异构性的要求</p></li><li><p>中间接口电路即输入&#x2F;输出接口电路，简称I&#x2F;O接口</p></li><li><p>I&#x2F;O接口在嵌入式系统中具有重要的位置</p></li></ul><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1ch5-%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%BE%93%E5%85%A5-%E8%BE%93%E5%87%BA%E8%AE%BE%E5%A4%87%E6%8E%A5%E5%8F%A3/image-20230319001217846.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="示意"></p><h3 id="I-x2F-O接口组成"><a href="#I-x2F-O接口组成" class="headerlink" title="I&#x2F;O接口组成"></a>I&#x2F;O接口组成</h3><p>I&#x2F;O接口组成</p><ul><li><p>数据缓存</p></li><li><p>信号电平转换</p></li><li><p>数据格式转换</p></li><li><p>外设选择</p></li><li><p>中断管理</p></li><li><p>CPU命令接收和执行</p></li></ul><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1ch5-%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%BE%93%E5%85%A5-%E8%BE%93%E5%87%BA%E8%AE%BE%E5%A4%87%E6%8E%A5%E5%8F%A3/image-20230319002907631.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="组成图"></p><p>I&#x2F;0接口的三个基本功能模块：数据缓存、逻辑控制和外设连接</p><h3 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h3><p>数据缓存功能模块：负责I&#x2F;O交互过程的控制、记录和数据的存储</p><ul><li>数据寄存器：存放交互过程中需传输的数据</li><li>控制寄存器：存放外设、I&#x2F;O接口的控制命令</li><li>状态寄存器：记录外设、I&#x2F;O接口的状态信息</li></ul><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1ch5-%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%BE%93%E5%85%A5-%E8%BE%93%E5%87%BA%E8%AE%BE%E5%A4%87%E6%8E%A5%E5%8F%A3/image-20230319002955582.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="寄存器"></p><h3 id="控制与外设"><a href="#控制与外设" class="headerlink" title="控制与外设"></a>控制与外设</h3><p>逻辑控制功能模块</p><ul><li>接收CPU传输过来的地址，根据地址进行外设选择</li></ul><p>外设连接功能模块</p><ul><li>I&#x2F;O接口与外设的交互接口</li></ul><h3 id="I-x2F-O设备的分类"><a href="#I-x2F-O设备的分类" class="headerlink" title="I&#x2F;O设备的分类"></a>I&#x2F;O设备的分类</h3><p>计算机所管理的I&#x2F;O设备按输入输出对象的不同可以分为以下3类：</p><ul><li><strong>用户可读写</strong>设备，用于用户与计算机通信。如：显示器、键盘、鼠标、打印机等</li><li><strong>机器可读写</strong>设备，用于电子装置与计算机通信。如：硬盘、U盘、控制器</li><li><strong>通信</strong>设备，用于与远程设备通信。如：Modem、ISDN终端</li></ul><h2 id="二-数据传输"><a href="#二-数据传输" class="headerlink" title="二.数据传输"></a>二.数据传输</h2><h3 id="I-x2F-O接口的数据传输"><a href="#I-x2F-O接口的数据传输" class="headerlink" title="I&#x2F;O接口的数据传输"></a>I&#x2F;O接口的数据传输</h3><p>🔷程序查询方式，也称忙等I&#x2F;O</p><p>CPU负责查询外设的状态寄存器，判断外设的数据是否就绪。若就绪，直接传输数据；否则，CPU等待数据就绪或继续查询其他外设</p><p>🔷中断方式</p><p>当外设数据就绪时，外设向CPU发出中断服务请求信号，CPU响应外设的中断服务请求，并处理中断请求</p><p>🔷直接访存方式，DMA</p><p>数据传输无需CPU的参与，在外设与内存之间建立直接的数据传输通道</p><h3 id="I-x2F-O编程"><a href="#I-x2F-O编程" class="headerlink" title="I&#x2F;O编程"></a>I&#x2F;O编程</h3><p>两种方法支持I&#x2F;O编程</p><p>特殊的I&#x2F;O指令</p><ul><li>Intel x86 提供 in, out 指令</li></ul><p>内存映射I&#x2F;O</p><ul><li>大多数CPUs 应用内存映射I&#x2F;O</li><li>支持I&#x2F;O 指令的CPU并不排除内存映射I&#x2F;O</li></ul><h4 id="内存映射IO"><a href="#内存映射IO" class="headerlink" title="内存映射IO"></a>内存映射IO</h4><p>为每一个I&#x2F;O设备的寄存器提供地址</p><p>程序使用普通的CPU读写指令来与设备通信</p><p>为设备定义地址:</p><p>​DEV1 EQU 0x1000</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-symbol">Read</span>/write 编码:<br><br><span class="hljs-keyword">LDR</span> <span class="hljs-built_in">r1</span>,=<span class="hljs-symbol">#DEV1</span> <br><br><span class="hljs-keyword">LDR</span> <span class="hljs-built_in">r0</span>,[<span class="hljs-built_in">r1</span>] ；read<br><br><span class="hljs-keyword">LDR</span> <span class="hljs-built_in">r0</span>,=<span class="hljs-number">#8</span> <br><br><span class="hljs-keyword">STR</span> <span class="hljs-built_in">r0</span>,[<span class="hljs-built_in">r1</span>] ；write<br></code></pre></td></tr></table></figure><h5 id="内存映射IO-高级语言（PEEK和POKE函数）"><a href="#内存映射IO-高级语言（PEEK和POKE函数）" class="headerlink" title="内存映射IO-高级语言（PEEK和POKE函数）"></a>内存映射IO-高级语言（PEEK和POKE函数）</h5><ul><li>读操作</li></ul><p>int peek(char *location) {</p><p>return *location; }</p><ul><li>写操作</li></ul><p>void poke (char *location, char newval) {</p><p>(*location) &#x3D; newval; }</p><h4 id="程序查询方式，忙等I-x2F-O方式"><a href="#程序查询方式，忙等I-x2F-O方式" class="headerlink" title="程序查询方式，忙等I&#x2F;O方式"></a>程序查询方式，忙等I&#x2F;O方式</h4><p>轮询（polling）:通过CPU反复读I&#x2F;O设备状态寄存器来询问设备是否空闲</p><ul><li>设备比CPU慢，需要多个周期完成一项工作</li><li>必须等待前一个操作完成后再进行下一个操作</li><li>比如CPU向设备写数据，即输出<ul><li>通过读设备状态寄存器来询问设备是否空闲</li><li>若空闲，则写数据到数据寄存器</li><li>若忙，则等待。</li></ul></li></ul><h5 id="忙等IO方式-输出设备编程"><a href="#忙等IO方式-输出设备编程" class="headerlink" title="忙等IO方式-输出设备编程"></a>忙等IO方式-输出设备编程</h5><p>将一个字符串写到输出设备</p><figure class="highlight hsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs hsp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> OUT_CHAR <span class="hljs-number">0</span>x1000 <span class="hljs-comment">/* data register*/</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> OUT_STATUS <span class="hljs-number">0</span>x1001 <span class="hljs-comment">/* status register*/</span></span><br><br>Char *mystring=“Hello,world.”<span class="hljs-comment">;</span><br><br>Char *current_char<span class="hljs-comment">;</span><br><br>current_char = mystring<span class="hljs-comment">;</span><br><br><span class="hljs-keyword">while</span> (*current_char != ‘\<span class="hljs-number">0</span>’) &#123;<br><br><span class="hljs-keyword">poke</span>(OUT_CHAR,*current_char)<span class="hljs-comment">;</span><br><br><span class="hljs-keyword">poke</span>(OUT_STATUS,<span class="hljs-number">1</span>)<span class="hljs-comment">;</span><br><br><span class="hljs-keyword">while</span> (<span class="hljs-keyword">peek</span>(OUT_STATUS) != <span class="hljs-number">0</span>)<span class="hljs-comment">;</span><br><br>current_char++<span class="hljs-comment">;</span><br><br>&#125;<br></code></pre></td></tr></table></figure><h5 id="忙等IO方式-输入-x2F-输出同步方式编程"><a href="#忙等IO方式-输入-x2F-输出同步方式编程" class="headerlink" title="忙等IO方式-输入&#x2F;输出同步方式编程"></a>忙等IO方式-输入&#x2F;输出同步方式编程</h5><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1ch5-%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%BE%93%E5%85%A5-%E8%BE%93%E5%87%BA%E8%AE%BE%E5%A4%87%E6%8E%A5%E5%8F%A3/image-20230319004521702.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="忙等I/O"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> in_CHAR 0x1000 </span><br><span class="hljs-comment">/* input data register */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> in_STATUS 0x1001 </span><br><span class="hljs-comment">/* input status register */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> OUT_CHAR 0x1100</span><br><span class="hljs-comment">/* output data register */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> OUT_STATUS 0x1101</span><br><span class="hljs-comment">/* output status register </span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p><strong>输入设备</strong>：</p><ul><li>当有新字符能够被CPU读取， in_STATUS&#x3D;1</li><li>当字符被CPU读取或无字符可读，in_STATUS&#x3D;&#x3D;0</li></ul><p><strong>输出设备</strong>：</p><ul><li><p>当CPU写入字符，有新字符能够被写入到输出设备</p><p>​out_STATUS&#x3D;1</p></li><li><p>当字符被输出设备读取或设备无字符可读</p><p>​in_STATUS&#x3D;&#x3D;0</p></li></ul><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs gcode"><span class="hljs-keyword">while</span> <span class="hljs-comment">(TRUE)</span> &#123;<br><span class="hljs-comment">/* read */</span><br><span class="hljs-keyword">while</span> <span class="hljs-comment">(peek(IN_STATUS)</span> == <span class="hljs-number">0</span>);<br>achar = <span class="hljs-comment">(char)</span>peek<span class="hljs-comment">(IN_DATA)</span>;<br>poke<span class="hljs-comment">(IN_STATUS,0)</span>;<br><span class="hljs-comment">/* write */</span><br>poke<span class="hljs-comment">(OUT_DATA,achar)</span>;<br>poke<span class="hljs-comment">(OUT_STATUS,1)</span>;<br><span class="hljs-keyword">while</span> <span class="hljs-comment">(peek(OUT_STATUS)</span> != <span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="I-x2F-O中断"><a href="#I-x2F-O中断" class="headerlink" title="I&#x2F;O中断"></a>I&#x2F;O中断</h4><p>▪忙等I&#x2F;O效率非常低</p><ul><li>I&#x2F;O设备的速度远远小于CPU的速度</li><li>除了测试，CPU不能做其它任何事情</li></ul><p>▪CPU的很多操作是可以与I&#x2F;O并行执行</p><ul><li>计算操作</li><li>控制其它I&#x2F;O设备</li></ul><p>▪中断机制：</p><ul><li>可以改变CPU的控制流顺序</li><li>强制CPU执行一段特定代码——中断处理子例程（设备驱动程序）</li></ul><blockquote><p>▪ 由I&#x2F;O设备逻辑决定什么时候中断，发中断请求</p><p>▪ CPU响应中断——可能无法立即响应</p><p>​一旦响应，将程序计数器（PC）指向中断处理子例程</p><p>▪ 前台程序：无中断情况下CPU运行的程序</p><p>▪ 后台程序：中断处理子程序</p></blockquote><h4 id="中断机制"><a href="#中断机制" class="headerlink" title="中断机制"></a>中断机制</h4><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1ch5-%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%BE%93%E5%85%A5-%E8%BE%93%E5%87%BA%E8%AE%BE%E5%A4%87%E6%8E%A5%E5%8F%A3/image-20230319005040231.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="图"></p><p>◼ CPU 和设备通过CPU总线连接</p><p>◼ CPU 和设备通过握手协议进行通信</p><ul><li>设备发出中断请求</li><li>CPU准备处理I&#x2F;O设备请求时，CPU发出中断响应</li></ul><h4 id="中断行为"><a href="#中断行为" class="headerlink" title="中断行为"></a>中断行为</h4><p>基于调用中断服务子例程的形式</p><ul><li>(保护现场)中断强制下一条指令调用中断服务子例程</li><li>执行中断子例程</li><li>（恢复现场）返回前台程序</li></ul><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1ch5-%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%BE%93%E5%85%A5-%E8%BE%93%E5%87%BA%E8%AE%BE%E5%A4%87%E6%8E%A5%E5%8F%A3/image-20230319005232629.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="中断行为"></p><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1ch5-%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%BE%93%E5%85%A5-%E8%BE%93%E5%87%BA%E8%AE%BE%E5%A4%87%E6%8E%A5%E5%8F%A3/image-20230319092359626.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="应用基本中断讲字符从输入设备复制到输出设备"></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">//中断子例程（输入/输出都会引发中断）</span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">input_handler</span>() <span class="hljs-comment">/*输入中断子例程*/</span></span><br><br>&#123;achar = peek(IN_DATA);<br><br>gotchar = TRUE;<br><br>poke(IN_STATUS,<span class="hljs-number">0</span>);&#125;<br><br><span class="hljs-comment">/*当字符输出完成时会发出中断信号*/</span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">output_handler</span>() <span class="hljs-comment">/*输出中断子例程*/</span></span><br><br>&#123; &#125;<br>main() &#123;<br><span class="hljs-keyword">while</span> (TRUE) &#123;<br><span class="hljs-keyword">if</span> (gotchar) &#123;<br>poke(OUT_DATA,achar);<br>poke(OUT_STATUS,<span class="hljs-number">1</span>);<br>gotchar = FALSE;<br>&#125; <br>&#125;<br>&#125;<br><span class="hljs-comment">//特点：读一个字符，然后写一个字符；</span><br></code></pre></td></tr></table></figure><h5 id="例：具有缓冲区的中断IO"><a href="#例：具有缓冲区的中断IO" class="headerlink" title="例：具有缓冲区的中断IO"></a>例：具有缓冲区的中断IO</h5><p>为了使读和写完全独立，使用缓冲区机制</p><ul><li>允许输入输出设备以不同的速率运行</li><li>前台的工作完全独立于输入输出设备</li><li>通过输入中断、输出中断完成与I&#x2F;O的通信</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">//缓冲区的设计</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BUF_SIZE 8</span><br><span class="hljs-built_in">char</span> io_buf[BUF_SIZE];<br><span class="hljs-built_in">int</span> buf_head=<span class="hljs-number">0</span>,buf_tail=<span class="hljs-number">0</span>;<br><span class="hljs-built_in">int</span> error=<span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">empty_buffer</span>()</span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">full_buffer</span>()</span>;<br><span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">nchars</span>()</span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add_char</span>(<span class="hljs-params"><span class="hljs-built_in">char</span> achar</span>)</span>;<br><span class="hljs-function"><span class="hljs-built_in">char</span> <span class="hljs-title">remove_char</span>()</span>;<br></code></pre></td></tr></table></figure><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">//基于缓冲区的输入的中断子例程</span><br>void input<span class="hljs-constructor">_handler()</span> &#123;<br><span class="hljs-built_in">char</span> achar;<br><span class="hljs-keyword">if</span> (full<span class="hljs-constructor">_buffer()</span>) error = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">else</span> &#123; achar = peek(IN_DATA); <br>add<span class="hljs-constructor">_char(<span class="hljs-params">achar</span>)</span>; &#125;<br>poke(IN_STATUS,<span class="hljs-number">0</span>);<br><span class="hljs-keyword">if</span> (nchars<span class="hljs-literal">()</span><span class="hljs-operator"> == </span><span class="hljs-number">1</span>) <br>&#123; poke(OUT_DATA,remove<span class="hljs-constructor">_char()</span>); <br>poke(OUT_STATUS,<span class="hljs-number">1</span>); &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-comment">//基于缓冲区的输出的中断子例程</span><br>void <span class="hljs-built_in">output_handler</span>() &#123;<br>if (!empty_buffer())&#123;<br><span class="hljs-built_in">poke</span>(OUT_DATA, remove_char());<br><span class="hljs-built_in">poke</span>(OUT_STATUS,<span class="hljs-number">1</span>);<br>&#125; <br>&#125;<br><span class="hljs-comment">/*若io_buf有字符，则输出可以自行引发一个输出中断；</span><br><span class="hljs-comment">▪ 若无，需要外部在新字符到达时启动输出处理子程序。</span><br><span class="hljs-comment">▪ 输入处理子程序启动此种情况</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h5 id="调试中断代码"><a href="#调试中断代码" class="headerlink" title="调试中断代码"></a>调试中断代码</h5><p>若忘记改变(或恢复)寄存器的内容</p><p>▪前台程序会展示一些非常奇怪的错误</p><p>▪错误很难重现—它依赖与中断</p><p>例：（handler（）中一个错误应发j的改变）</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs inform7">for(i=0;i&lt;M;i++)&#123;<br>y<span class="hljs-comment">[i]</span>=b<span class="hljs-comment">[i]</span>;<br>for(j=0;j&lt;N;j++)<br>y<span class="hljs-comment">[i]</span>=y<span class="hljs-comment">[i]</span>+A<span class="hljs-comment">[i,j]</span>*x<span class="hljs-comment">[j]</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="如何发现中断"><a href="#如何发现中断" class="headerlink" title="如何发现中断"></a>如何发现中断</h4><ul><li>在开始执行每条指令之前检查中断请求信号是否有中断请求</li><li>一旦出现中断，PC将指向中断服务子例程</li><li>注意：要保护和恢复现场</li></ul><h4 id="中断优先级和中断向量"><a href="#中断优先级和中断向量" class="headerlink" title="中断优先级和中断向量"></a>中断优先级和中断向量</h4><ul><li>两种机制允许中断处理更多的设备<ul><li><strong>优先级（Priorities）</strong>：确定哪种中断首先获得CPU</li><li><strong>向量（Vectors）</strong>： 允许中断设备灵活定义其中断服务子例程</li></ul></li><li>大多数CPU这两种方式都支持</li></ul><h4 id="具有优先级的中断"><a href="#具有优先级的中断" class="headerlink" title="具有优先级的中断"></a>具有优先级的中断</h4><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1ch5-%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%BE%93%E5%85%A5-%E8%BE%93%E5%87%BA%E8%AE%BE%E5%A4%87%E6%8E%A5%E5%8F%A3/image-20230319093510034.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="如"></p><p>使用轮询让几个设备共享一个中断</p><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1ch5-%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%BE%93%E5%85%A5-%E8%BE%93%E5%87%BA%E8%AE%BE%E5%A4%87%E6%8E%A5%E5%8F%A3/image-20230319093620555.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="轮询访问"></p><p>例： 优先级 I&#x2F;O（A的优先级最高，C的优先级最低）</p><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1ch5-%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%BE%93%E5%85%A5-%E8%BE%93%E5%87%BA%E8%AE%BE%E5%A4%87%E6%8E%A5%E5%8F%A3/image-20230319093726394.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="按优先级询问"></p><blockquote><p>优先级排序：</p><ul><li><p>Masking(屏蔽): 发生中断的优先级比正在中断的优先级低，CPU将不响应该优先级低的中断。</p></li><li><p>Nonmaskable interrupt (NMI,不可屏蔽中断): 最高优先级，永不屏蔽</p></li><li><p>电源故障</p><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1ch5-%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%BE%93%E5%85%A5-%E8%BE%93%E5%87%BA%E8%AE%BE%E5%A4%87%E6%8E%A5%E5%8F%A3/image-20230319093901787.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="ARM Cortex-M4"></p></li></ul></blockquote><h4 id="中断向量"><a href="#中断向量" class="headerlink" title="中断向量"></a>中断向量</h4><p>▪不同的设备有不同的中断服务子例程</p><p>▪中断向量表</p><p>​-设备存贮其向量号</p><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1ch5-%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%BE%93%E5%85%A5-%E8%BE%93%E5%87%BA%E8%AE%BE%E5%A4%87%E6%8E%A5%E5%8F%A3/image-20230319094202102.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="中断表"></p><h4 id="一般的中断机制"><a href="#一般的中断机制" class="headerlink" title="一般的中断机制"></a>一般的中断机制</h4><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1ch5-%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%BE%93%E5%85%A5-%E8%BE%93%E5%87%BA%E8%AE%BE%E5%A4%87%E6%8E%A5%E5%8F%A3/image-20230319094252857.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="流程图"></p><h4 id="中断开销"><a href="#中断开销" class="headerlink" title="中断开销"></a>中断开销</h4><ul><li>中断服务子例程执行的时间</li><li>中断机制的开销</li><li>寄存器存储&#x2F;恢复</li><li>流水相关补偿</li><li>Cache相关补偿</li></ul><h4 id="IO接口传输对比"><a href="#IO接口传输对比" class="headerlink" title="IO接口传输对比"></a>IO接口传输对比</h4><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1ch5-%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%BE%93%E5%85%A5-%E8%BE%93%E5%87%BA%E8%AE%BE%E5%A4%87%E6%8E%A5%E5%8F%A3/image-20230319094448468.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="IO接口传输对比"></p><h2 id="三-通信接口"><a href="#三-通信接口" class="headerlink" title="三.通信接口"></a>三.通信接口</h2><p>用于实现外设与处理器之间的交互</p><ul><li>UART、SPI和I2C等 </li><li>与 GPIO 的区别主要体现在通信时序、速度等方面</li></ul><h3 id="通信接口的分类"><a href="#通信接口的分类" class="headerlink" title="通信接口的分类"></a>通信接口的分类</h3><h5 id="并行-x2F-串行通信"><a href="#并行-x2F-串行通信" class="headerlink" title="并行&#x2F;串行通信"></a>并行&#x2F;串行通信</h5><ul><li>并行通信：外设和微处理器之间存在多根数据传输线，数据的多个比特位可同时传输，例IEEE1284，主要用于点阵式打印机和绘图仪</li><li>串行通信：外设和微处理器之间仅存在一根数据传输线，数据必须按照顺序一位一位传输，例如USB</li></ul><h5 id="同步-x2F-异步通信"><a href="#同步-x2F-异步通信" class="headerlink" title="同步&#x2F;异步通信"></a>同步&#x2F;异步通信</h5><ul><li>同步通信：外设和微处理器之间有同步时钟，两者之间的数据传输受同步时钟的控制</li><li>采用阻塞模式，发送方发出数据后需接收到接收方响应后才发送下一个数据</li><li>例如IEEE1588标准，SPI，I2C </li><li>异步通信：外设和微处理之间没有同步时钟，借助缓存进行数据传输<ul><li>异步通信过程中，通信双方必须约定通信协议和传输速率</li><li>采用非阻塞模式，即发送方发出数据后，无需等待接收方相应便可直接发送下一个数据</li><li>例如UART</li></ul></li></ul><h5 id="单工-x2F-半双工-x2F-全双工通信（按照传输方向）"><a href="#单工-x2F-半双工-x2F-全双工通信（按照传输方向）" class="headerlink" title="单工&#x2F;半双工&#x2F;全双工通信（按照传输方向）"></a>单工&#x2F;半双工&#x2F;全双工通信（按照传输方向）</h5><ul><li>单工制式：数据只能从发送方往接收方传输</li><li>半双工制式：数据能在发送接收方之间双向传输，但在任何时刻数据只能一个方向传输，例如I2C </li><li>全双工制式：接收和发送数据占用不同的线路，因此数据可同时在两个方向上传输，例如UART</li></ul><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1ch5-%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%BE%93%E5%85%A5-%E8%BE%93%E5%87%BA%E8%AE%BE%E5%A4%87%E6%8E%A5%E5%8F%A3/image-20230319095521043.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="UART,SPI，I2C比较"></p><h3 id="串行通信"><a href="#串行通信" class="headerlink" title="串行通信"></a>串行通信</h3><p>▪ 使用方便、成本低廉、编程简单</p><p>▪ 各微处理器提供的常见串行通信接口：通用异步收发器（UART） </p><p>▪ STM32系列微处理器提供：通用UART和USART（同步&#x2F;异步收发器接口）</p><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1ch5-%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%BE%93%E5%85%A5-%E8%BE%93%E5%87%BA%E8%AE%BE%E5%A4%87%E6%8E%A5%E5%8F%A3/image-20230319100138868.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="rs232很像vga啊，但百度告诉我不是，凹凸都不同"></p><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1ch5-%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%BE%93%E5%85%A5-%E8%BE%93%E5%87%BA%E8%AE%BE%E5%A4%87%E6%8E%A5%E5%8F%A3/image-20230319100217991.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="串行通信过程"></p><h4 id="USART优点"><a href="#USART优点" class="headerlink" title="USART优点"></a>USART优点</h4><p>◼支持全双工、异步通信</p><p>◼采用分数波特率发生器，可配置，最高可支持10.5Mb&#x2F;s波特</p><p>率</p><p>◼可编程配置的数据字长度（8 位或 9 位）</p><p>◼可配置的停止位（1 位或 2 位）</p><p>◼USART 实现同步数据通信时，发送端提供时钟</p><p>◼支持奇偶校验</p><p>◼发送奇偶校验位，接收数据奇偶校验</p><p>◼支持 4 种错误检测：溢出错误、噪声错误、帧错误和校验错误</p><p>◼……</p><blockquote><p>USART通信接口通过3个引脚与外设之间进行通信</p><ul><li>RX：接收数据输入</li><li>TX：发送数据输出</li></ul><p>▪ SW_RX：在单线和智能卡模式下，接收数据</p><p>▪USART与外设通信至少需要RX和TX两个引脚</p><p>▪USART的部分引脚仅用于同步模式，如SCLK、IrDA模式、硬件流量控制模式</p></blockquote><h4 id="USART结构"><a href="#USART结构" class="headerlink" title="USART结构"></a>USART结构</h4><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1ch5-%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%BE%93%E5%85%A5-%E8%BE%93%E5%87%BA%E8%AE%BE%E5%A4%87%E6%8E%A5%E5%8F%A3/image-20230319100734422.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="结构图"></p><h5 id="分数波特率计算"><a href="#分数波特率计算" class="headerlink" title="分数波特率计算"></a>分数波特率计算</h5><p>波特率寄存器(USART_BRR)A</p><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1ch5-%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%BE%93%E5%85%A5-%E8%BE%93%E5%87%BA%E8%AE%BE%E5%A4%87%E6%8E%A5%E5%8F%A3/image-20230319100846788.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="寄存器示意图"></p><p>▪位 31:16 保留</p><p>▪位 15:4 DIV_Mantissa[11:0]：USARTDIV 的整数部分</p><p>▪位 3:0 DIV_Fraction[3:0]：USARTDIV 的小数部分</p><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1ch5-%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%BE%93%E5%85%A5-%E8%BE%93%E5%87%BA%E8%AE%BE%E5%A4%87%E6%8E%A5%E5%8F%A3/image-20230319100914335.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="公式"></p><blockquote><p>▪ fck是给外设的时钟</p><p>▪设置波特率位115200，fck &#x3D; 36MHz，则USARTDIV &#x3D; 19.5</p><p>▪整数部分为19 &lt;&lt; 4 &#x3D; 304</p><p>▪小数部分为0.5*16 &#x3D; 8</p><p>▪ USART_BRR寄存器的值位304+8&#x3D;312&#x3D;0x138</p></blockquote><h4 id="USART的数据发送过程"><a href="#USART的数据发送过程" class="headerlink" title="USART的数据发送过程"></a>USART的数据发送过程</h4><p>（1）写USART_CR1寄存器的UE位为1来使能USART</p><p>（2）写USART_CR1寄存器的M位来定义数据帧长度为8位或9位 </p><p>（3）写USART_CR2寄存器的STOP来配置停止位</p><p>（4）如果采用多缓冲区通信的话，写USART_CR3寄存器的DMAT位来使能DMA传输，此时需按多缓冲区通信中的描述配置DMA寄存器</p><p>（5）写USART_BRR寄存器来配置波特率</p><p>（6）初次传输时需设置USART_CR1寄存器中的TE位来发送一个空闲帧</p><p>（7）把需传输的数据写到USART_DR寄存器，帧已发送（停止位后）且TXE 位置 1，可在单缓冲区通信时将重复进行此动作来进行数据传输</p><p>（8）在写入最后一个数据到USART_DR寄存器后，等待USART_SR寄存器的<strong>TC</strong>信号变为1，此时表明最后一个数据帧传输结束</p><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1ch5-%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%BE%93%E5%85%A5-%E8%BE%93%E5%87%BA%E8%AE%BE%E5%A4%87%E6%8E%A5%E5%8F%A3/image-20230319102809756.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="时序图"></p><h4 id="USART的数据接收过程"><a href="#USART的数据接收过程" class="headerlink" title="USART的数据接收过程"></a>USART的数据接收过程</h4><p>（1）写USART_CR1寄存器的UE位为1来使能USART</p><p>（2）写USART_CR1寄存器的M位来定义数据帧长度为8位或9位 </p><p>（3）写USART_CR2寄存器来的STOP配置停止位</p><p>（4）如果采用多缓冲区通信的话，写USART_CR3寄存器的DMAT位来使能DMA传输，此时需按多缓冲区通信中的描述配置DMA寄存器</p><p>（5）写USART_BRR寄存器来配置波特率</p><p>（6）写USART_CR1寄存器中的RE位使能数据接收。当接收到一个数据帧时，USART_SR寄存器中的RXNE位被设置，此时表明移位寄存器中的数据传输到了RDR，数据帧可以被录取</p><h3 id="SPI"><a href="#SPI" class="headerlink" title="SPI"></a>SPI</h3><p>串行外设接口（Serial Peripheral Interface，SPI） </p><p>▪ 同步串行通信接口，主要用于微处理器与外设之间的串行通信</p><p>▪ 高速、全双工、同步，占用4个引脚 -&gt; 节约芯片引脚</p><p>（1）MISO引脚：主设备数据输入，从设备数据输出</p><p>（2）MOSI引脚：主设备数据输出，从设备数据输入</p><p>（3）SCLK引脚：时钟信号，由主设备产生</p><p>（4）CS引脚：从设备片选信号，由主设备控制</p><p>▪ SPI是一种不对等的通信接口，通信的发起、结束均由主机控制，SPI通信双方时钟产生和片选控制的一方即为主机</p><h4 id="spi的硬件连线图"><a href="#spi的硬件连线图" class="headerlink" title="spi的硬件连线图"></a>spi的硬件连线图</h4><p>一个SPI总线可连接多个主机和多个从机，但是在同一个时刻只允许由一个主机来操作总线</p><p>在每次传输的过程中，主机总是向从机发送一个字节的数据，从机也是向主机发送一个字节的数据</p><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1ch5-%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%BE%93%E5%85%A5-%E8%BE%93%E5%87%BA%E8%AE%BE%E5%A4%87%E6%8E%A5%E5%8F%A3/image-20230319104112006.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="图"></p><h4 id="spi工作方式"><a href="#spi工作方式" class="headerlink" title="spi工作方式"></a>spi工作方式</h4><p>SPI接口可根据外设通信的需求，对串行同步时钟的极性（CPOL）和相位（CPHA）进行配置</p><ul><li>CPOL对SPI接口的通信影响不大，CPOL&#x3D;0，串行同步时钟的空闲状态为低电平；CPOL&#x3D;1，串行同步时钟的空闲状态为高电平</li><li>CPHA决定了SPI接口上数据的采样位置，CPHA&#x3D;0，在串行同步时钟的第一个跳变沿数据将被采样；CPHA&#x3D;1，在串行同步时钟的第二个跳变沿数据才被采样；</li></ul><p>SPI接口可根据外设通信的需求，对串行同步时钟的极性（CPOL）和相位（CPHA）进行配置</p><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1ch5-%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%BE%93%E5%85%A5-%E8%BE%93%E5%87%BA%E8%AE%BE%E5%A4%87%E6%8E%A5%E5%8F%A3/image-20230319104300040.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="image-20230319104300040"></p><h4 id="SPI内部结构"><a href="#SPI内部结构" class="headerlink" title="SPI内部结构"></a>SPI内部结构</h4><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1ch5-%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%BE%93%E5%85%A5-%E8%BE%93%E5%87%BA%E8%AE%BE%E5%A4%87%E6%8E%A5%E5%8F%A3/image-20230319111143172.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="图"></p><h4 id="SPI寄存器"><a href="#SPI寄存器" class="headerlink" title="SPI寄存器"></a>SPI寄存器</h4><p>SPI寄存器：通过SPI_CR1寄存器的配置来设置SPI的</p><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1ch5-%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%BE%93%E5%85%A5-%E8%BE%93%E5%87%BA%E8%AE%BE%E5%A4%87%E6%8E%A5%E5%8F%A3/image-20230319111228570.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="图"></p><h4 id="工作模式-主机模式和从机模式"><a href="#工作模式-主机模式和从机模式" class="headerlink" title="工作模式-主机模式和从机模式"></a><strong>工作模式</strong>-主机模式和从机模式</h4><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1ch5-%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%BE%93%E5%85%A5-%E8%BE%93%E5%87%BA%E8%AE%BE%E5%A4%87%E6%8E%A5%E5%8F%A3/image-20230319111314475.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="image-20230319111314475"></p><blockquote><p>在主机模式下</p><ul><li>主机使用一个IO引脚选择从机</li><li>传输的起始由主机发送数据来启动</li><li>时钟（SCK）信号由主机产生</li><li>通过MOSI引脚发送数据</li><li>通过MISO引脚接收数据</li></ul></blockquote><blockquote><p> 在从机模式下</p><ul><li>数据传输在SSEL被主机拉低后开始</li><li>接收主机输出的时钟信号</li><li>通过MOSI引脚接收数据</li><li>通过MOSI引脚发送数据</li></ul></blockquote><h5 id="SPI的从模式配置"><a href="#SPI的从模式配置" class="headerlink" title="SPI的从模式配置"></a>SPI的从模式配置</h5><p><strong>配置SPI为从模式的过程（SCK引脚用于接收主机的串行时钟）</strong></p><p>（1）设置DEF位来定义数据帧格式（8位或16位）</p><p>（2）设置CPOL位和CPHA位来定义数据传输和串行时钟之间的相位关系，保持主机和从机CPOL位和CPHA位的一致</p><p>（3）保持主机和从机帧格式的一致</p><p>（4）在通信的过程中，必须保证CS片选信号处于低电平</p><p>（5）清除MSTR位，设置SPE位使相应引脚处于SPI工作模式</p><p><strong>从模式下的数据传输</strong></p><ul><li>数据发送过程：在写操作过程中，数据字被并行写入发送缓冲器；当从设备收到时钟信号并且在MOSI引脚上出现第一个数据位时，发送过程开始，剩下的数据位被写入移位寄存器；当发送缓冲器中的数据字写入移位寄存器时，SPI_SP寄存器的TXE位被置位，如果设置了SPI_CR2寄存器中的TXEIE位，将触发中断</li><li>数据接收过程：当数据接收完成时，移位寄存器中的数据传输到接收缓冲器中，SPI_SR寄存器中的RXNE标志位被置位，如果设置了SPI_CR2寄存器中的RXNEIE位，将触发中断</li><li>在最后一个采样时钟边沿后，RXNE位被置位，移位寄存器中的数据字被写入接收缓冲器。当读SPI_DR寄存器时，SPI设备返回接收缓冲器接收到的数据字</li></ul><h5 id="SPI的主模式配置"><a href="#SPI的主模式配置" class="headerlink" title="SPI的主模式配置"></a>SPI的主模式配置</h5><p><strong>配置SPI为主模式的过程（SCK引脚用于产生时钟信号）</strong></p><p>（1）通过SPI_CR1寄存器的BR[2:0]位定义串行时钟波特率</p><p>（2）设置CPOL位和CPHA位来定义数据传输和串行时钟之间的相位关系</p><p>（3）设置DEF位来定义数据帧格式（8位或16位）</p><p>（4）设置SPI_CR1寄存器的LSBFIRST位来定义帧格式</p><p>（5）在通信的过程中，必须保证CS片选信号处于高电平</p><p><strong>主模式下的数据传输</strong></p><ul><li>数据发送过程：当写入数据到发送缓冲器时，发送过程开始；当发送第一个数据位时，数据被并行写入移位寄存器，然后串行地移出到MOSI引脚；数据字的高位在前还是低位在前传输，取决于SPI_SP寄存器的LSBFIRST位的配置；当数据字从发送缓冲器写入移位寄存器时，SPI_SP寄存器的TXE位被置位，如果设置了SPI_CR2寄存器中的TXEIE位，将触发中断</li><li>数据接收过程：当数据传输完成时，移位寄存器中的数据字被写入接收缓冲器，并且SRXNE标志位被置位，如果设置了SPI_CR2寄存器中的RXNEIE位，将触发中断；在最后采样时钟边沿，RXNE位被置位，移位寄存器接收到的数据字被写入缓冲器。读SPI_DR寄存器时，SPI设备返回接收缓冲器接收到的数据字，RXNE位被清除</li><li>一旦数据传输开始，如果下一个将要发送的数据字被写入了发送缓冲器，就可以维持持续的数据字传输。在写发送缓冲器之前，需确认TXE标志位是否被置位</li></ul><h3 id="I2C"><a href="#I2C" class="headerlink" title="I2C"></a>I2C</h3><ul><li><p>串行通信总线（Inter-Integrated Circuit，I2C）概述</p></li><li><p>双向数据传输，传输速度0～100Kbps，高速模式达0～400Kbps</p></li><li><p>简单灵活可扩展，总线中的所有设备仅有唯一地址，通过软件寻址</p><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1ch5-%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%BE%93%E5%85%A5-%E8%BE%93%E5%87%BA%E8%AE%BE%E5%A4%87%E6%8E%A5%E5%8F%A3/image-20230319111818511.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="典型结构"></p></li></ul><blockquote><p>➢ 总线上可同时连接多个能控制总线的设备</p><p>➢ 只能有一个控制设备获得总线控制权而成为主机</p><p>➢ 总线系统能同步所有控制设备所产生的时钟信号</p></blockquote><h4 id="I2C数据传输"><a href="#I2C数据传输" class="headerlink" title="I2C数据传输"></a>I2C数据传输</h4><ul><li>I2C总线上每传输一个数据位必须产生一个时钟脉冲，通信双方之间每次发送一个字节的数据</li><li>SDA线上的数据必须在时钟线SCL的高电平期间保持稳定，SDA线的电平状态只有在SCL线的时钟信号为低电平时才能发送改变</li><li>I2C总线上的4种信号<ul><li>起始信号：SCL为高电平，SDA由高跳变低，开始数据传输</li><li>停止信号：SCL为高电平，SDA由低跳变高，终止数据传输</li><li>应答信号：接收器向发送器发出特定的低电平脉冲信号，表示已经接收到数据</li><li>非应答信号：主机向从机发送一个高电平有效脉冲信号，表示接收完最后一个数据字节，使从机释放数据线</li></ul></li></ul><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1ch5-%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%BE%93%E5%85%A5-%E8%BE%93%E5%87%BA%E8%AE%BE%E5%A4%87%E6%8E%A5%E5%8F%A3/image-20230319112012915.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="传输过程"></p><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1ch5-%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%BE%93%E5%85%A5-%E8%BE%93%E5%87%BA%E8%AE%BE%E5%A4%87%E6%8E%A5%E5%8F%A3/image-20230319112121853.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="主-&gt;从机通信"></p><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1ch5-%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%BE%93%E5%85%A5-%E8%BE%93%E5%87%BA%E8%AE%BE%E5%A4%87%E6%8E%A5%E5%8F%A3/image-20230319112254392.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="主&lt;-从机通信"></p><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1ch5-%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%BE%93%E5%85%A5-%E8%BE%93%E5%87%BA%E8%AE%BE%E5%A4%87%E6%8E%A5%E5%8F%A3/image-20230319112324895.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="主&lt;-&gt;从机通信"></p><h2 id="四-人机交互-LCD"><a href="#四-人机交互-LCD" class="headerlink" title="四.人机交互-LCD"></a>四.人机交互-LCD</h2><p><strong>液晶显示器</strong>（Liquid Crystal Display，LCD）是一种被动的显示器材，本身不能发光，需借助于周围环境的光</p><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1ch5-%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%BE%93%E5%85%A5-%E8%BE%93%E5%87%BA%E8%AE%BE%E5%A4%87%E6%8E%A5%E5%8F%A3/image-20230319112518769.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="原理"></p><h4 id="LCD的基本原理"><a href="#LCD的基本原理" class="headerlink" title="LCD的基本原理"></a>LCD的基本原理</h4><ul><li>LCD将液晶置于两个导电玻璃之间，通过两个电极间电场的驱动引起液晶分子有规则地旋转形成扭曲角，发生扭曲向列效应，从而控制投射光的强度</li><li>完全投射即白色，完全阻挡即黑色，不同投射程度呈现不同的灰阶</li><li>LCD分类：根据工作原理，将LCD划分为扭曲向列型液晶TN-LCD、超扭曲向列型液晶STN-LCD和薄膜晶体管液晶TFT-LCD</li></ul><h4 id="LCD显示的控制方法"><a href="#LCD显示的控制方法" class="headerlink" title="LCD显示的控制方法"></a>LCD显示的控制方法</h4><h5 id="LCD的两种驱动方式"><a href="#LCD的两种驱动方式" class="headerlink" title="LCD的两种驱动方式"></a>LCD的两种驱动方式</h5><ul><li>扫描驱动的LCD驱动器：将显示缓存中的图像数据通过动态扫描的方式传输到LCD显示屏</li><li>总线驱动的液晶模块（LCD Module，LCM）：将液晶显示屏、连接件、驱动和控制集成电路、PCB线路板、背光源等装配在一起的显示控制器</li></ul><p>TFT-LCD的LCM内置有与液晶像素点对应的显示数据RAM区，若要改变一个像素点的颜色，只需对该点所对应的16位显存进行操作即可</p><h5 id="TFT-LCD模块的两种操作：对控制寄存器的读-x2F-写操作、对显存的读-x2F-写操"><a href="#TFT-LCD模块的两种操作：对控制寄存器的读-x2F-写操作、对显存的读-x2F-写操" class="headerlink" title="TFT-LCD模块的两种操作：对控制寄存器的读&#x2F;写操作、对显存的读&#x2F;写操"></a>TFT-LCD模块的两种操作：对控制寄存器的读&#x2F;写操作、对显存的读&#x2F;写操</h5><p>两种操作均通过对ILI9341的寄存器的操作来完成</p><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1ch5-%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%BE%93%E5%85%A5-%E8%BE%93%E5%87%BA%E8%AE%BE%E5%A4%87%E6%8E%A5%E5%8F%A3/image-20230319112624350.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="时序读写"></p><p> TFT-LCD的使用：当对TFT-LCD显示面板上的某一点（X，Y）</p><p>进行操作时，需要先通过地址定位到该点所对应的RAM显存地址，然后通过光标的上下左右移动的控制来连续写入或读取显存数据</p><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1ch5-%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%BE%93%E5%85%A5-%E8%BE%93%E5%87%BA%E8%AE%BE%E5%A4%87%E6%8E%A5%E5%8F%A3/image-20230319112725054.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="流程"></p><h2 id="六-ADC-x2F-DAC"><a href="#六-ADC-x2F-DAC" class="headerlink" title="六.ADC&#x2F;DAC"></a>六.ADC&#x2F;DAC</h2><ul><li>模数转换器（Analog-to-Digital Converter，ADC）负责将物理环境中的模拟信号（连续物理量）转换为计算机可处理的数字信号（离散数字量）</li><li>数模转换器（Digital-to-Analog Converter，DAC）负责将数字信号还原为模拟信号</li></ul><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1ch5-%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%BE%93%E5%85%A5-%E8%BE%93%E5%87%BA%E8%AE%BE%E5%A4%87%E6%8E%A5%E5%8F%A3/image-20230319112820409.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="效果图"></p><h4 id="ADC接口的内部结构"><a href="#ADC接口的内部结构" class="headerlink" title="ADC接口的内部结构"></a>ADC接口的内部结构</h4><ul><li>ADC一般经过取样、保持、量化和编码4个过程，并且4个往往同时实现</li><li>ADC转换分为两个通道组：规则通道组和注入通道组</li><li>规则通道组相当于正常运行的程序，而注入通道组相当于中断。在正常执行程序的时候，中断可以打断其执行</li></ul><h4 id="Cortex-M4处理器的ADC结构"><a href="#Cortex-M4处理器的ADC结构" class="headerlink" title="Cortex-M4处理器的ADC结构"></a>Cortex-M4处理器的ADC结构</h4><ul><li>12位逐次逼近模数转换器，支持19路信号输入，分别是16路外部信号（ADCx_IN0~ADCx_IN15）、2路内部信号（温度传感器和VREFINT）和VBAT电源信号</li><li>Cortex-M4处理器中一个规则通道组最多支持16路转换输入，一个注入通道组最多支持4路转换输入</li></ul><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1ch5-%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%BE%93%E5%85%A5-%E8%BE%93%E5%87%BA%E8%AE%BE%E5%A4%87%E6%8E%A5%E5%8F%A3/image-20230319113011405.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="配图"></p><h4 id="CORTEX-M4处理器的ADC特点"><a href="#CORTEX-M4处理器的ADC特点" class="headerlink" title="CORTEX-M4处理器的ADC特点"></a>CORTEX-M4处理器的ADC特点</h4><ul><li>多种分辨率</li><li>中断的产生</li><li>单转换模式&#x2F;连续转换模式</li><li>扫描模式的自动切换</li><li>间隔采样模式</li></ul><h4 id="ADC的引脚描述"><a href="#ADC的引脚描述" class="headerlink" title="ADC的引脚描述"></a>ADC的引脚描述</h4><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1ch5-%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%BE%93%E5%85%A5-%E8%BE%93%E5%87%BA%E8%AE%BE%E5%A4%87%E6%8E%A5%E5%8F%A3/image-20230319142311892.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="table"></p><h3 id="ADC功能"><a href="#ADC功能" class="headerlink" title="ADC功能"></a>ADC功能</h3><ul><li>启动与时钟</li><li>时序</li><li>单次转换模式</li><li>连续转换模式</li><li>扫描模式</li><li>注入通道管理</li><li>间断模式</li><li>快速转换模式</li><li>校准</li><li>数据对齐</li></ul><h4 id="启动与时钟"><a href="#启动与时钟" class="headerlink" title="启动与时钟"></a>启动与时钟</h4><p>ADC_CR2寄存器中的ADON位决定ADC接口的供电与掉电；SWSTART或JSWSTART位置1可启动ADC转 换</p><p>ADC的两种时钟方案</p><ul><li>ADCCLK时钟用于模拟电路，可供所有ADC连接公用。RCC控制器位ADC时钟提供一个专用的可编程预分频器，ADCCLK时钟可通过APB2分频来得到</li><li>用于数字接口的时钟，等同于APB2时钟。可通过RCC APB2外设时钟使能寄存器分别为每个ADC使能&#x2F;禁止数字接口时钟</li></ul><h4 id="时序"><a href="#时序" class="headerlink" title="时序"></a>时序</h4><p>ADC在开始精确转换之前需要一段稳定时间tSTAB。ADC开始转换并经过15个时钟周期后，EOC标志置1，转换结果将存放在16位ADC数据寄存器中</p><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1ch5-%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%BE%93%E5%85%A5-%E8%BE%93%E5%87%BA%E8%AE%BE%E5%A4%87%E6%8E%A5%E5%8F%A3/image-20230319142557032.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="时序图"></p><h4 id="单次转换模式"><a href="#单次转换模式" class="headerlink" title="单次转换模式"></a>单次转换模式</h4><p>ADC仅执行一次转换，完成后ADC停止</p><h5 id="单次转换模式的启动方式"><a href="#单次转换模式的启动方式" class="headerlink" title="单次转换模式的启动方式"></a>单次转换模式的启动方式</h5><p>（1）将ADC_CR2寄存器中的SWSTART位置1（适用于规则通道）</p><p>（2）将JSWSTART位置1（适用于注入通道）</p><p>（3）外部触发（同时适用于规则&#x2F;注入通道）</p><p>完成所选通道的信号转换之后</p><ul><li>如果规则通道完成转换：转换数据存储在16位ADC_DR寄存器中；EOC转换结束标志位置1；EOCIE位置1时产生中断</li><li>如果注入通道完成转换：转换数据存储在16位ADC_JDR1寄存器中；JEOC转换结束标志位置1；JEOCIE位置1时产生中断</li></ul><h4 id="连续转换模式"><a href="#连续转换模式" class="headerlink" title="连续转换模式"></a>连续转换模式</h4><p>ADC一次转换结束后立即启动下一次的转换</p><ul><li>该模式通过外部触发或ADC_CR2寄存器中的ADON位启动</li><li>每次规则通道完成转换：转换数据存储在16位ADC_DR寄存器中；EOC转换结束标志位置1；EOCIE位置1时产生中断</li></ul><p>注：注入通道一般不能采用连续转换模式，唯一的例外情况是注入通道配置为在规则通道之后自动转换时</p><h4 id="扫描模式-x2F-注入通道管理-x2F-间断模式"><a href="#扫描模式-x2F-注入通道管理-x2F-间断模式" class="headerlink" title="扫描模式&#x2F;注入通道管理&#x2F;间断模式"></a>扫描模式&#x2F;注入通道管理&#x2F;间断模式</h4><p><strong>扫描模式</strong>：用来扫描一组模拟通道，通过设置ADC_CR1寄存器的SCAN位来选择</p><p><strong>注入通道管理</strong></p><ul><li>触发注入：清除ADC_CR1寄存器中的JAUTO位，并设置SCAN 位 </li><li>自动注入：如果设置了JAUTO位，在规则组通道转换完成之后，注入组通道将自动启动转换</li></ul><p><strong>间断模式</strong></p><ul><li>规则组：间断模式通过设置ADC_CR1寄存器的DISCEN位激活</li><li>注入组：间断模式通过设置ADC_CR1寄存器的JDISCEN位激活</li></ul><h4 id="快速转换模式"><a href="#快速转换模式" class="headerlink" title="快速转换模式"></a>快速转换模式</h4><p>▪降低ADC分辨率（转换精确度）可以提高转换速度</p><p>▪RES位用于选择数据寄存器中可用的位数</p><p>▪各种分辨率对应的最小转换时间计算方法</p><ul><li>12位：3+12&#x3D;15 ADCCLK周期</li><li>10位：3+10&#x3D;13 ADCCLK周期</li><li>8 位：3+8&#x3D;11 ADCCLK周期</li><li>6 位：3+6&#x3D;9 ADCCLK周期</li></ul><p>▪总转换时间的计算公式</p><p>​Tconv&#x3D;采样时间+12个时钟周期</p><h4 id="校准"><a href="#校准" class="headerlink" title="校准"></a>校准</h4><ul><li>由于ADC接口中会因内部电容器组的变化而造成转换精确度误差，ADC内置自动校准模式</li><li>通过设置ADC_CR2寄存器中的CAL位启动校准，校准结束CAL位将被硬件复位，随后ADC可开始正常转换</li><li>校准结束后，校准码存储在ADC_DR<strong>寄存器中</strong></li></ul><h4 id="数据对齐"><a href="#数据对齐" class="headerlink" title="数据对齐"></a>数据对齐</h4><p>ADC_CR2寄存器中的ALIGN位用于选择转换得到数据的存储对齐方式，数据可以左对齐或右对齐</p><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1ch5-%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%BE%93%E5%85%A5-%E8%BE%93%E5%87%BA%E8%AE%BE%E5%A4%87%E6%8E%A5%E5%8F%A3/image-20230319143112279.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="转换结果数据的左对齐存储"></p><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1ch5-%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%BE%93%E5%85%A5-%E8%BE%93%E5%87%BA%E8%AE%BE%E5%A4%87%E6%8E%A5%E5%8F%A3/image-20230319143131037.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="转换结果数据的右对齐存储"></p><h3 id="DAC转换-DAC接口的内部结构"><a href="#DAC转换-DAC接口的内部结构" class="headerlink" title="DAC转换-DAC接口的内部结构"></a>DAC转换-DAC接口的内部结构</h3><p>DAC模块是12位离散数字输入、连续电压输出的数模转换器</p><p>▪ DAC可以按8位或12位模式进行配置，并且可与DMA控制器配合使用</p><p>​ 在12位模式下，数据可以采用左对齐或右对齐方式进行存储</p><p>▪ DAC有两个输出通道，每个通道各有一个转换器</p><p>​在DAC双通道模式下，每个通道可以单独进行转换</p><p>​ 当两个通道组合在一起同步执行更新操作时，也可同时进行转换</p><p>▪ DAC可通过一个输入参考电压引脚VREF+（与ADC共享）来提高分辨率</p><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1ch5-%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%BE%93%E5%85%A5-%E8%BE%93%E5%87%BA%E8%AE%BE%E5%A4%87%E6%8E%A5%E5%8F%A3/image-20230319143349187.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="附图"></p><h4 id="CORTEX-M4处理器的DAC特点"><a href="#CORTEX-M4处理器的DAC特点" class="headerlink" title="CORTEX-M4处理器的DAC特点"></a>CORTEX-M4处理器的DAC特点</h4><ul><li>包含2个DAC转换器，每个转换器对应一个输出通道</li><li>支持8位或12位的单调输出</li><li>12位模式下支持数据的左对齐或者右对齐存储</li><li>具备同步更新功能</li><li>可生成噪声波形</li><li>可生成三角波形</li></ul><h4 id="DAC的引脚描述"><a href="#DAC的引脚描述" class="headerlink" title="DAC的引脚描述"></a>DAC的引脚描述</h4><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1ch5-%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%BE%93%E5%85%A5-%E8%BE%93%E5%87%BA%E8%AE%BE%E5%A4%87%E6%8E%A5%E5%8F%A3/image-20230319143512659.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="DAC引脚"></p><h4 id="DAC功能"><a href="#DAC功能" class="headerlink" title="DAC功能"></a>DAC功能</h4><ul><li>DAC通道使能</li><li>DAC输出缓存使能</li><li>DAC输出电压</li><li>DAC数据格式</li><li>DAC转换</li></ul><h4 id="DAC通道使能"><a href="#DAC通道使能" class="headerlink" title="DAC通道使能"></a>DAC通道使能</h4><ul><li><p>将DAC_CR寄存器的ENx位置1即可打开DAC通道x的供电，经过一段启动时间tWAKEUP之后，DAC通道x即被使能</p></li><li><p>ENx位置位只使能DAC通道x的模拟部分，即便该位被置0，DAC通道x的数字部分仍然继续工作</p></li><li><p>DAC输出缓存使能</p><p>​DAC接口中集成了2个输出缓存，可以用来减少输出阻抗，无需外部运放即可直接驱动外部负载。每个DAC通道输出缓存可以通过设置DAC_CR寄存器中的BOFFx位来使能或者关闭</p></li></ul><h4 id="DAC输出电压"><a href="#DAC输出电压" class="headerlink" title="DAC输出电压"></a>DAC输出电压</h4><p>▪ 数字输入经过DAC被线性转换为模拟电压输出，其范围0到VREF+</p><p>▪ 任一DAC通道引脚上的输出电压均满足关系式</p><p>​DAC输出&#x3D;VREF×（DOR&#x2F;4095） </p><p>▪ DAC数据格式</p><ul><li>根据不同的配置模式，数据以不同的方式写入指定的寄存器</li><li>对于DAC单通道x，存在三种可能的写入方式</li></ul><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1ch5-%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%BE%93%E5%85%A5-%E8%BE%93%E5%87%BA%E8%AE%BE%E5%A4%87%E6%8E%A5%E5%8F%A3/image-20230319144145533.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="对齐例子"></p><p>对于DAC双通道，存在三种可能的写入方式</p><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1ch5-%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%BE%93%E5%85%A5-%E8%BE%93%E5%87%BA%E8%AE%BE%E5%A4%87%E6%8E%A5%E5%8F%A3/image-20230319144815401.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="双通道"></p><h4 id="DAC转换"><a href="#DAC转换" class="headerlink" title="DAC转换"></a>DAC转换</h4><ul><li>DAC_DORx寄存器无法直接写入数据，任何输出到DAC通道x的数据都必须先写入DAC_DHRx寄存器才能传到通道x <ul><li>如果未选中硬件触发，存入寄存器DAC_DHRx中的数据会在一个APB1时钟周期后自动传输至寄存器DAC_DORx</li><li>如果选中硬件触发，数据传输在触发发生之后3个APB1时钟周期后完成</li></ul></li></ul><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1ch5-%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%BE%93%E5%85%A5-%E8%BE%93%E5%87%BA%E8%AE%BE%E5%A4%87%E6%8E%A5%E5%8F%A3/image-20230319144939823.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="DAC触发关闭时的转换时序图"></p><p>当数据从DAC_DHRx寄存器写入DAC_DORx寄存器，在经过时延tSETTLING之后，DAC的输出即有效，该时延的长短依赖于电源电压和模拟输出负载的大小</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>I&#x2F;O接口的结构、编程方法</li><li>通信接口</li><li>人机交互</li><li>ADC&#x2F;DAC转换</li></ul>]]></content>
    
    
    <categories>
      
      <category>学习资料</category>
      
    </categories>
    
    
    <tags>
      
      <tag>课件笔记</tag>
      
      <tag>嵌入式程序设计</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>3dmark超频记录之3070</title>
    <link href="/3dmark%E8%B6%85%E9%A2%91%E8%AE%B0%E5%BD%95%E4%B9%8B3070/"/>
    <url>/3dmark%E8%B6%85%E9%A2%91%E8%AE%B0%E5%BD%95%E4%B9%8B3070/</url>
    
    <content type="html"><![CDATA[<h1 id="一-起因"><a href="#一-起因" class="headerlink" title="一.起因"></a>一.起因</h1><p>之前就有打算换回n卡，于是挑了半天选了张3070，前不久才把6700xt公版在海鲜市场卖掉，换回n卡似乎还多花了600多钱。。。不过n卡要玩ai之类的更方便，而且也保值一些，换的是碍国嘉旗舰&#x2F;（次旗舰），亏了就亏了吧。</p><blockquote><p>二手我倒是无所谓，新卡还是不推荐鸡架，毕竟有前科，有那钱不如买七彩虹火神或者猛禽。。。</p></blockquote><p><img src="/3dmark%E8%B6%85%E9%A2%91%E8%AE%B0%E5%BD%95%E4%B9%8B3070/image-20230318183808659.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="小屏幕假装是4090"></p><p><img src="/3dmark%E8%B6%85%E9%A2%91%E8%AE%B0%E5%BD%95%E4%B9%8B3070/image-20230318183847979.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="用叠叠乐对比一下差距，分别是刀卡，双槽卡，三槽卡"></p><p><img src="/3dmark%E8%B6%85%E9%A2%91%E8%AE%B0%E5%BD%95%E4%B9%8B3070/image-20230318184214597.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="感觉颜值不如20系超级叼"></p><p>屁话不多说了，我新卡到手都是直接跑3dmark超频的，下面就直接上超频成绩吧。</p><h1 id="二-超频成绩展示（部分项目）"><a href="#二-超频成绩展示（部分项目）" class="headerlink" title="二.超频成绩展示（部分项目）"></a>二.超频成绩展示（部分项目）</h1><h2 id="1-Timespy-Dx12综合跑分"><a href="#1-Timespy-Dx12综合跑分" class="headerlink" title="1.Timespy(Dx12综合跑分)"></a>1.Timespy(Dx12综合跑分)</h2><p><img src="/3dmark%E8%B6%85%E9%A2%91%E8%AE%B0%E5%BD%95%E4%B9%8B3070/image-20230318184520008.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="同配置排名第二"></p><p><img src="/3dmark%E8%B6%85%E9%A2%91%E8%AE%B0%E5%BD%95%E4%B9%8B3070/image-20230318184622669.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="第一的evga挺猛的，还有不知道为什么我cpu分低了"></p><h2 id="2-PortRoyal（光追测试）"><a href="#2-PortRoyal（光追测试）" class="headerlink" title="2.PortRoyal（光追测试）"></a>2.PortRoyal（光追测试）</h2><p><img src="/3dmark%E8%B6%85%E9%A2%91%E8%AE%B0%E5%BD%95%E4%B9%8B3070/image-20230318184759304.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="光追同配置第一"></p><h2 id="3-FireStrike（Dx11-1080p）"><a href="#3-FireStrike（Dx11-1080p）" class="headerlink" title="3.FireStrike（Dx11 1080p）"></a>3.FireStrike（Dx11 1080p）</h2><p><img src="/3dmark%E8%B6%85%E9%A2%91%E8%AE%B0%E5%BD%95%E4%B9%8B3070/image-20230318184903623.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="第七，不想折腾了"></p><h2 id="4-FireStrike-Ex（Dx11-2k）"><a href="#4-FireStrike-Ex（Dx11-2k）" class="headerlink" title="4.FireStrike Ex（Dx11 2k）"></a>4.FireStrike Ex（Dx11 2k）</h2><p><img src="/3dmark%E8%B6%85%E9%A2%91%E8%AE%B0%E5%BD%95%E4%B9%8B3070/image-20230318184949264.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="第二"></p><h2 id="5-FireStrike-Ultra（Dx11-4k）"><a href="#5-FireStrike-Ultra（Dx11-4k）" class="headerlink" title="5.FireStrike Ultra（Dx11 4k）"></a>5.FireStrike Ultra（Dx11 4k）</h2><p><img src="/3dmark%E8%B6%85%E9%A2%91%E8%AE%B0%E5%BD%95%E4%B9%8B3070/image-20230318185021888.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="第一"></p><h2 id="6-两冷门项目WildLife"><a href="#6-两冷门项目WildLife" class="headerlink" title="6.两冷门项目WildLife"></a>6.两冷门项目WildLife</h2><p><img src="/3dmark%E8%B6%85%E9%A2%91%E8%AE%B0%E5%BD%95%E4%B9%8B3070/image-20230318185225962.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="跑的人很少"></p><p><img src="/3dmark%E8%B6%85%E9%A2%91%E8%AE%B0%E5%BD%95%E4%B9%8B3070/image-20230318185240138.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="不具有参考性"></p><h1 id="三-结尾"><a href="#三-结尾" class="headerlink" title="三.结尾"></a>三.结尾</h1><p>自己弄着玩的，如果是真的超频大佬的话优化空间很大，也不会像我这样cpu超频都搞不太定，我这就仅供娱乐了。</p><p>如果以后我又换卡，应该还会更类似的东西。。。</p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Rtx3070</tag>
      
      <tag>超频</tag>
      
      <tag>矿卡</tag>
      
      <tag>3dmark</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>R5-240oem加P106-100玩具双卡经验</title>
    <link href="/R5-240oem%E5%8A%A0P106-100%E7%8E%A9%E5%85%B7%E5%8F%8C%E5%8D%A1%E7%BB%8F%E9%AA%8C/"/>
    <url>/R5-240oem%E5%8A%A0P106-100%E7%8E%A9%E5%85%B7%E5%8F%8C%E5%8D%A1%E7%BB%8F%E9%AA%8C/</url>
    
    <content type="html"><![CDATA[<h1 id="一-为什么玩这个矿渣"><a href="#一-为什么玩这个矿渣" class="headerlink" title="一.为什么玩这个矿渣"></a>一.为什么玩这个矿渣</h1><p>首先是价格便宜，这一套也就100多点，性能在1060 5g -1060 6g之间（其实纯论性价比还得矿王rx580）</p><p>其次是方案成熟，在百度贴吧p106吧里提供了各路大神制作的魔改驱动和教程，P106作为立吧之本，适合小白尝试。</p><p>最后是因为我打算把之前的6700xt换成3070，6700xt已经被我挂咸鱼打包了，暂时把前几天到的p106利用起来，换n卡胜在驱动稳定以及对ai，深度学习的支持好，游戏性能实际是差不了多少的。</p><blockquote><p>碎碎谈：</p><p>最后这一波换卡浪费了我500元，虽然卖旧卡赚了200（过了年矿卡咋还涨价了），但是这多的300从丐版换了旗舰（最便宜的旗舰还是狗嘉的超级叼，火神&#x2F;超龙还贵200，猛禽贵400），台独技嘉苟都不买，新卡不推荐入。</p><p>要是去年就直接买3070（当时贵个200左右）应该会亏得少一点，不过应该也只会买个丐版。。。</p><hr><p>而且本人作为个A粉兼AMD精神股东，购入一张a卡也是不得不品鉴的过程，在长达4个月的时间里，我的所有电脑设备全是amd，台式机是5600+6700xt，笔记本是5700u核显，家里的老电脑是个老apu。。。Intel浓度几乎为零（虽然这学期我买了Intel AX210网卡，原因是之前买的蓝牙接受器不稳定，经常断，换pcie网卡蓝牙后就没问题了）。最后的最后，我还留了一张a卡（r5 240）来亮机。</p></blockquote><h1 id="二-看看配件"><a href="#二-看看配件" class="headerlink" title="二.看看配件"></a>二.看看配件</h1><p>碍国嘉p106-100 6g（b站某矿up直播抽中购买资格78元包邮入手，海鲜价大概100左右，可以换itx散热），戴尔办公机拆机r5-240 OEM 1G（海鲜市场60元包邮，超级亮机卡dp接口支持2k 144，gcn架构，支持dx12，就纯亮机用途而言比n卡gt710之类的便宜好用）</p><p>逐一亮相：</p><p>![专业矿卡P106背面](R5-240oem加P106-100玩具双卡经验&#x2F;屏幕截图 2023-03-08 231645.png)</p><p>![专业矿卡P106正面—碍国嘉](R5-240oem加P106-100玩具双卡经验&#x2F;屏幕截图 2023-03-08 231546.png)</p><p>![戴尔拆机卡](R5-240oem加P106-100玩具双卡经验&#x2F;屏幕截图 2023-03-08 231924.png)</p><p>![看看接口，p106是没有视频口的，挡板是NTR蓝宝石的](R5-240oem加P106-100玩具双卡经验&#x2F;屏幕截图 2023-03-08 231905.png)</p><h1 id="三-装装驱动"><a href="#三-装装驱动" class="headerlink" title="三.装装驱动"></a>三.装装驱动</h1><p>先把显卡插上，需要核显+pcie x16槽一个或者无核显平台两pcie x16槽，我所用的b450迫击炮max主板恰好有两个X 16槽满足了需求。</p><p>插上亮机卡和p106，使用DDU卸载旧N卡驱动</p><p>驱动下载见p106吧置顶。。。</p><p><a href="https://tieba.baidu.com/f?kw=p106&ie=utf-8&tp=0">https://tieba.baidu.com/f?kw=p106&amp;ie=utf-8&amp;tp=0</a></p><p>简单步骤：断网，安全模式装p106驱动，再正常启动，联网，windows会自动安装a卡驱动，再选择gpu调度选项，把需要显卡的应用都选为p106运行。。。</p><hr><blockquote><p>我实际遇到的困难：首先是系统不认卡，就是设备管理器和gpuz都无法识别p106，然后也无法上驱动，解决方法是先看设备管理器有无异常设备，再看鲁大师认不认卡（鲁大师可以识别就行，然后就可以把鲁大师删了），随便打个正常的驱动，等到gpuz能识别了，就可以去安全模式重新打驱动了。。。</p></blockquote><p><img src="/R5-240oem%E5%8A%A0P106-100%E7%8E%A9%E5%85%B7%E5%8F%8C%E5%8D%A1%E7%BB%8F%E9%AA%8C/image-20230309230519132.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="amd+nv双驱动，要是有个intel核显就是最混沌的一集了"></p><p><img src="/R5-240oem%E5%8A%A0P106-100%E7%8E%A9%E5%85%B7%E5%8F%8C%E5%8D%A1%E7%BB%8F%E9%AA%8C/image-20230308224429080.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="典中典亮机卡，还支持uefi"></p><p><img src="/R5-240oem%E5%8A%A0P106-100%E7%8E%A9%E5%85%B7%E5%8F%8C%E5%8D%A1%E7%BB%8F%E9%AA%8C/image-20230308224406837.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="装好后的gpuz"></p><p><img src="/R5-240oem%E5%8A%A0P106-100%E7%8E%A9%E5%85%B7%E5%8F%8C%E5%8D%A1%E7%BB%8F%E9%AA%8C/image-20230308224725147.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="跑分4000在1065-1066之间"></p><p><img src="/R5-240oem%E5%8A%A0P106-100%E7%8E%A9%E5%85%B7%E5%8F%8C%E5%8D%A1%E7%BB%8F%E9%AA%8C/image-20230308225704967.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="timespy 99-专业矿卡的含金量"></p><p><img src="/R5-240oem%E5%8A%A0P106-100%E7%8E%A9%E5%85%B7%E5%8F%8C%E5%8D%A1%E7%BB%8F%E9%AA%8C/image-20230308224549381.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="夹心面包，中间是网卡"></p><h1 id="四-游戏测试"><a href="#四-游戏测试" class="headerlink" title="四.游戏测试"></a>四.游戏测试</h1><p>我先试了黑魂三，2k全高差不多60帧的样子，法环不敢尝试怕过不了小蓝熊，空洞骑士1080p，114帧，感觉调用不是很稳定啊</p><p>开个动态壁纸，r5 240（只输出图像）都会占用100%，p106占用却不多，实际体验肯定是不如1060的。</p><p>不过作为过渡套装还是比较好的玩具，等下一张卖国嘉的卡到了就换下来了。</p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>矿卡</tag>
      
      <tag>P106</tag>
      
      <tag>魔改</tag>
      
      <tag>亮机卡</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>嵌入式程序设计ch2-微处理器体系架构</title>
    <link href="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1ch2-%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84/"/>
    <url>/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1ch2-%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<h1 id="嵌入式系统设计-微处理器体系架构"><a href="#嵌入式系统设计-微处理器体系架构" class="headerlink" title="嵌入式系统设计-微处理器体系架构"></a>嵌入式系统设计-微处理器体系架构</h1><h2 id="一-嵌入式微处理器体系架构"><a href="#一-嵌入式微处理器体系架构" class="headerlink" title="一.嵌入式微处理器体系架构"></a>一.嵌入式微处理器体系架构</h2><h3 id="冯-·-诺依曼结构-vS-哈佛结构（每节课都在提）"><a href="#冯-·-诺依曼结构-vS-哈佛结构（每节课都在提）" class="headerlink" title="冯 · 诺依曼结构 vS 哈佛结构（每节课都在提）"></a>冯 · 诺依曼结构 vS 哈佛结构（每节课都在提）</h3><p>🔷冯 · 诺依曼结构 </p><ul><li>由中央处理器（CPU）和存储器组成</li><li>通过一组总线（包括地址总线和数据总线）连接 </li><li>指令和数据以同等地位存储在同一存储器中 </li><li>对指令和数据的访问都是通过这组总线来实现的</li><li>存储器访问通过分时复用的方式进行</li></ul><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1ch2-%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84/image-20230308165707640.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="冯诺依曼"></p><p>🔷哈佛结构</p><ul><li>两个独立的存储模块，分别存储数据和指令 </li><li>两套独立的总线，分别作为CPU和两个存储器通信</li><li>指令和数据的访问可以同时进行，并且指令和数据可 以有不同的带宽</li><li>Microchip 公司的 PIC16 芯片的指令是 14 位宽度， 而数据是 8 位宽度</li></ul><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1ch2-%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84/image-20230308165834379.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="哈佛"></p><h3 id="CISC-amp-RISC-又又又出现了"><a href="#CISC-amp-RISC-又又又出现了" class="headerlink" title="CISC&amp;RISC(又又又出现了)"></a>CISC&amp;RISC(又又又出现了)</h3><p><strong>复杂指令集计算机（CISC）</strong></p><ul><li>依靠增加指令的复杂度，来改善计算性能 </li><li>指令格式不固定，指令可长可短，操作数可多可少 </li><li>CPU寻址方式复杂多样</li><li>采用微程序控制 </li><li>每条指令执行平均时钟周期数CPI超过5个时钟周期</li></ul><p>CISC指令的使用频率不均衡，且相差悬殊，20%&#x2F;80%定律 </p><p>CISC依靠增加指令数目，来改善其性能缺点</p><p> <strong>RISC</strong> </p><ul><li>RISC 统一了计算机的体系结构</li><li>指令非常少，通常只有几十条</li><li>每条指令长度统一，CPU寻址方式少 </li><li>便于应用流水线技术</li><li>大部分指令是单时钟周期完成</li></ul><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1ch2-%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84/image-20230308170329168.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="比较"></p><h3 id="嵌入式微处理器特点"><a href="#嵌入式微处理器特点" class="headerlink" title="嵌入式微处理器特点"></a>嵌入式微处理器特点</h3><ul><li>实时性：在处理器设计上要求有较短的响应时间</li><li>多任务：不相关的过程需要计算机同时处理，降低系统复杂性，保证实时性</li><li>存储保护：提高系统可靠性</li></ul><h3 id="嵌入式微处理器分类"><a href="#嵌入式微处理器分类" class="headerlink" title="嵌入式微处理器分类"></a>嵌入式微处理器分类</h3><p><strong>嵌入式微控制器</strong>（MCU）</p><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1ch2-%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84/image-20230309165738356.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="微控制器"></p><ul><li>微控制器是将一个计算机集成到一个芯片，形成单片机</li><li>通过单片机控制嵌入式设备</li><li>片内可以集成 ROM&#x2F;EPROM、RAM、总线、总线逻辑、定时&#x2F;计数器、看门狗、I&#x2F;O、串行口、脉宽调制输出、ADC、DAC、Flash RAM、EEPROM 等各种必要的功能部件和外设</li><li>芯片尺寸大大减小，系统总功耗和成本下降，可靠性提高</li></ul><p><strong>嵌入式微处理器</strong>(MPU)</p><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1ch2-%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84/image-20230309165805112.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="微控制器"></p><ul><li>由通用计算机中的 CPU 发展而来，只保留和嵌入式应用紧密相关的的功能硬件</li><li>低功耗和低资源实现嵌入式应用的特殊要求</li><li>主要面向结构更复杂、功能更丰富、性能要求更高的嵌入式应用</li></ul><h3 id="嵌入式微处理器分类-1"><a href="#嵌入式微处理器分类-1" class="headerlink" title="嵌入式微处理器分类"></a><strong>嵌入式微处理器分类</strong></h3><p><strong>数字信号处理器（DSP）</strong> </p><ul><li><p>专门用于信号处理的处理器</p></li><li><p>具有很高的编译效率和指令执行速度</p></li><li><p>应用在数字滤波、快速傅里叶变换、谱分析、语音编码、视频编</p></li><li><p>码、数据编码和雷达目标提取类型</p></li><li><p>单片化设计</p></li><li><p>集成在微控制器、微处理器、片上系统中的 DSP 协处理器</p></li></ul><p><strong>嵌入式片上系统（SOC）</strong> </p><ul><li>实现一个完整的硬件和软件系统</li><li>具有集成度高、处理能力强、功能组件丰富、体积小、重量轻、低功耗等特性</li></ul><p><strong>RISC-V架构</strong></p><ul><li>基于RISC原理建立的免费开放指令集架构</li><li>指令集完全开源、设计简单、易于移植Linux系统、采用模块化设计、拥有完整工具链</li><li>基本指令集共47条，可分为：整数运算指令、分支转移指令、加载&#x2F;存储指令、控制与状态寄存器访问指令、系统调用指令</li></ul><p><strong>人工智能芯片</strong></p><ul><li>人工智能时代的基础设施</li><li>在数据中心部署的云端和在消费者终端部署的终端</li><li>任务：训练和推理<ul><li>训练需要极高的计算性能、较高的精度以及处理海量数据的能力</li><li>推理对性能的要求并不高，对精度要求也更低，在特定的场景下，对通用性要求也低，能完成特定任务即可</li></ul></li></ul><p><strong>多核处理器</strong></p><ul><li>在一枚处理器中集成多个完整的计算内核，由总线控制器提供所有总线控制信号和命令信号</li><li>需解决的问题：器件资源分配策略、任务调度策略、节能策略、软硬件协同设计策略等</li></ul><h2 id="二-ARM微处理器体系架构"><a href="#二-ARM微处理器体系架构" class="headerlink" title="二.ARM微处理器体系架构"></a>二.ARM微处理器体系架构</h2><h3 id="ARM-的经营模式"><a href="#ARM-的经营模式" class="headerlink" title="ARM 的经营模式"></a>ARM 的经营模式</h3><ul><li>出售其知识产权，将技术授权给世界上许多著名的半导体、软件和 OEM 厂商，并提供技术服务</li></ul><p>ARM的版本：内核版本和处理器版本</p><ul><li><p>内核版本：ARM架构</p><ul><li>ARMv1, ARMv2, ARMv3 …ARMv8</li></ul></li><li><p>处理器版本：ARM处理器</p><ul><li>ARM1, ARM9, Cortex A …</li></ul></li></ul><p>ARM 是从 ARM7TDMI 开始的，在嵌入式系统领域得到广泛应用</p><h3 id="ARM产品路线图"><a href="#ARM产品路线图" class="headerlink" title="ARM产品路线图"></a>ARM产品路线图</h3><ul><li>经典系列，包括 ARM7、ARM9、ARM11 系列</li><li>Cortex-R 系列，提供非常高的性能和吞吐量</li><li>Cortex-A 系列，面向尖端的基于虚拟内存的操作系统和用户应用</li><li>Cortex-M 系列，用于注重成本节约的微处理器</li><li>本书将以ARM Cortex-M4为主，介绍嵌入式的开发设计</li></ul><h3 id="ARM-v7体系架构"><a href="#ARM-v7体系架构" class="headerlink" title="ARM v7体系架构"></a>ARM v7体系架构</h3><ul><li>支持Thumb-2技术：单指令多数据</li><li>在ARM的Thumb上发展的，保持了代码兼容性。</li><li>比纯32位代码少使用 31％的内存</li><li>比Thumb技术高出38％的性能</li><li>ARMv7架构还采用了NEON技术</li><li>将DSP和媒体处理能力提高了近4倍 </li><li>支持改良的浮点运算，满足3D图形、游戏以及传统嵌入式控制应用的需求</li><li>ARMv7支持JIT(Just In Time)技术</li><li>DAC(DynamicAdaptive Compilation)技术的使用</li></ul><h3 id="CORTEX-M4系统架构"><a href="#CORTEX-M4系统架构" class="headerlink" title="CORTEX-M4系统架构"></a>CORTEX-M4系统架构</h3><ul><li>ARMv7ME哈佛架构，带分支预测的3级流水</li><li>低成本、小管脚数和低功耗，并具有极高的运算能力和极强的中断响应能力</li><li>采用纯Thumb-2指令，具有32位高性能，ARM内核达到16位代码存储密度</li><li>可配置1-240个中断源，中断延迟最大12个，最小6个时钟周期</li><li>1.25DMIPS&#x2F;Mhz的性能和0.19mW&#x2F;Mhz的功耗</li><li>可选配的调试和跟踪模块</li></ul><h3 id="CORTEX-M4微处理器架构"><a href="#CORTEX-M4微处理器架构" class="headerlink" title="CORTEX-M4微处理器架构"></a>CORTEX-M4微处理器架构</h3><p>两种处理器模式： </p><ul><li>线程(Thread)模式</li><li>处理(Handler)模式</li></ul><p>软件的两种执行方式：</p><ul><li>特权级</li><li>用户级（非特权级）</li></ul><p>操作模式与执行特权方式的关系</p><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1ch2-%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84/image-20230309172339049.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="关系"></p><p>特权级可以访问处理器的所有资源，用户级是受限</p><p>对于用户级线程模式</p><ul><li>有限制地使用 MSR 和 MRS 指令，不能使用CPS指令禁止或使能中断</li><li>不能访问系统时钟、NVIC 或者系统控制模块。</li><li>可以受限制地访问内存或外设。</li><li>使用 SVC 指令通过系统调用，将控制转换到特权级。</li></ul><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1ch2-%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84/image-20230309172525416.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="示意图"></p><h3 id="CORTEX-M4内核流水线"><a href="#CORTEX-M4内核流水线" class="headerlink" title="CORTEX-M4内核流水线"></a>CORTEX-M4内核流水线</h3><ul><li>三级流水：取指、译码、执行</li><li>32位系统，总线宽度32位，一次取一条32位的指令</li><li>若是16位的thumb指令，处理器每隔一个周期做一次取指</li><li>当执行调转指令，整个流水线会刷新，从目的地取指</li><li>分支预测，减少流水线气泡过大</li></ul><h3 id="可编程模式"><a href="#可编程模式" class="headerlink" title="可编程模式"></a>可编程模式</h3><ul><li>处理器模式和软件执行的特权级别</li><li>核心寄存器</li><li>堆栈</li><li>异常中断所涉及到的寄存器</li><li>数据类型</li></ul><h3 id="CORTEX-M4寄存器"><a href="#CORTEX-M4寄存器" class="headerlink" title="CORTEX-M4寄存器"></a>CORTEX-M4寄存器</h3><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1ch2-%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84/image-20230309172857906.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="图"></p><h3 id="核心寄存器R0-R15"><a href="#核心寄存器R0-R15" class="headerlink" title="核心寄存器R0-R15"></a>核心寄存器R0-R15</h3><ul><li>通用寄存器R0~R12：用于数据操作，thumb-2的32位指令可访问</li><li>低组寄存器R0~R7：thumb16位指令可访问</li><li>高组寄存器R8~R12</li><li>堆栈指针R13(SP)：指示系统的栈空间</li><li>主栈指针MSP</li><li>进程栈指针PSP</li><li>链接寄存器R14(LR)</li><li>程序计数器R15(PC)</li></ul><h3 id="特殊寄存器"><a href="#特殊寄存器" class="headerlink" title="特殊寄存器"></a>特殊寄存器</h3><p>程序状态寄存器PSR：只有在特权级下才可访问</p><ul><li>应用状态寄存器APSR</li><li>中断状态寄存器IPSR</li><li>执行状态寄存器EPSR</li></ul><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1ch2-%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84/image-20230309173210255.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="寄存器"></p><h2 id="三-中断机制"><a href="#三-中断机制" class="headerlink" title="三.中断机制"></a>三.中断机制</h2><p>🔷绝大部分的处理器都支持中断机制</p><p>🔷中断由硬件电路产生，并改变 CPU 执行顺序</p><p>🔷类型</p><ul><li><strong>外部中断&#x2F;硬件中断</strong>：外部硬件设备为获得CPU的执行而产生的异步事件</li><li><strong>软件中断&#x2F;陷阱</strong>：程序中特殊指令产生的同步事件</li><li><strong>内部中断&#x2F;异常</strong>：出现一些异常情况下，CPU自发生成的同步事件</li></ul><h3 id="Cortex-M4处理器的异常来源"><a href="#Cortex-M4处理器的异常来源" class="headerlink" title="Cortex-M4处理器的异常来源"></a>Cortex-M4处理器的异常来源</h3><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1ch2-%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84/image-20230311003432661.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="|"></p><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1ch2-%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84/image-20230311003455984.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="上图指向下图"></p><h3 id="CORETEX-M4处理器的系统异常方式"><a href="#CORETEX-M4处理器的系统异常方式" class="headerlink" title="CORETEX-M4处理器的系统异常方式"></a>CORETEX-M4处理器的系统异常方式</h3><blockquote><ul><li>Reset复位：异常模式复位</li><li>NMI非屏蔽中断：除复位以外最高优先级的异常</li><li>硬件故障：异常处理错误或一种异常不能被其他异常机制管理</li><li>存储器管理故障：与内存保护相关的异常</li><li>总线故障：指令和数据内存处理相关的故障</li><li>用法故障：指令执行相关的故障</li><li>SVC：SVC指令触发的异常</li><li>PendSV：中断驱动的系统级服务请求</li><li>SysTick：系统定时器递减到0产生</li><li>Interrupt (ISQ)：外部中断,240个</li></ul></blockquote><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1ch2-%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84/image-20230311003659243.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="图例"></p><h3 id="中断优先级"><a href="#中断优先级" class="headerlink" title="中断优先级"></a>中断优先级</h3><ul><li>较小的值表示较高的优先级</li><li>除复位、硬错误和NMI以外所有的异常或中断都可配置优先级</li><li>NVIC支持优先级分组，可配置的优先级在0~15范围<ul><li>中断优先级寄存器项分为两个字段：上部字段和下部字段</li><li>上部字段定义组优先级</li><li>下部字段定义组中的子优先级</li><li>组优先级确定中断异常的抢占</li></ul></li></ul><h3 id="中断管理"><a href="#中断管理" class="headerlink" title="中断管理"></a>中断管理</h3><p>中断前的准备工作：</p><p>​▪ 设置所需的中断优先级（可选）</p><p>​▪ 使能外设中可以触发中断产生</p><p>​▪ 使能NVIC中的中断</p><h3 id="异常-x2F-中断处理过程"><a href="#异常-x2F-中断处理过程" class="headerlink" title="异常&#x2F;中断处理过程"></a>异常&#x2F;中断处理过程</h3><p>满足以下各条件，处理器会接收异常&#x2F;中断请求： </p><ul><li>处理器正在运行（未被暂停或复位状态）</li><li>异常&#x2F;中断处理使能状态</li><li>异常&#x2F;中断的优先级高于当前的等级</li><li>异常&#x2F;中断未被屏蔽</li></ul><p><strong>进入异常&#x2F;中断服务前需完成以下工作：</strong></p><ul><li>将多个寄存器和返回地址入栈</li><li>取出异常&#x2F;中断向量（异常&#x2F;中断对应的ISR入口地址）</li><li>取出将执行异常&#x2F;中断处理的指令</li><li>更新多个NVIC寄存器和内核寄存器（包括PSP, LR, PC, SP, 内核状态信息）</li><li>SP值自动调整，PC更新为异常&#x2F;中断处理的入口地址，LR被特殊值EXC_RETURN更新</li></ul><p><strong>执行异常&#x2F;中断服务：</strong> </p><ul><li>进入特权级处理模式</li><li>执行中断服务子例程</li></ul><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1ch2-%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84/image-20230311004154740.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="变化图"></p><p><strong>异常&#x2F;中断返回操作：</strong></p><ul><li>由特殊地址EXC_RETURN触发</li><li>EXC_RETURN在进入中断时被存入LR</li><li>EXC_RETURN写入PC时，触发异常&#x2F;中断返回操作</li></ul><h2 id="四-嵌入式汇编语言"><a href="#四-嵌入式汇编语言" class="headerlink" title="四.嵌入式汇编语言"></a>四.嵌入式汇编语言</h2><table><thead><tr><th>使用汇编程序编写代码的优点：</th></tr></thead><tbody><tr><td>针对性强</td></tr><tr><td>程序执行效率高</td></tr><tr><td>设备驱动程序精简</td></tr><tr><td>占用资源少</td></tr><tr><td>汇编语言能够更好地理解高级语言</td></tr></tbody></table><p><strong>ARM 微处理器</strong></p><ul><li>传统 ARM 处理器支持 32 位和 16 位的 Thumb指令集</li><li>Cortex-A 和 Cortex-R 系列处理器支持这两种运行状态</li><li>ARM 的 Cortex-M 系列处理器采用了 Thumb-2 技术，且只支持 Thumb 运行状态，不支持 ARM 指令集</li></ul><h3 id="汇编程序的结构"><a href="#汇编程序的结构" class="headerlink" title="汇编程序的结构"></a>汇编程序的结构</h3><ul><li>由段组成，段是相对独立的指令或数据单位，具有特定的名称</li><li>每个段由AREA伪指令定义</li><li>段属性可定义为READONLY(只读)或READWRITE(读 写) </li><li>段可分为：<ul><li>代码段：执行代码</li><li>数据段：存放运行所需的数据</li></ul></li></ul><h3 id="CORTEX-M4汇编语言"><a href="#CORTEX-M4汇编语言" class="headerlink" title="CORTEX-M4汇编语言"></a>CORTEX-M4汇编语言</h3><p>与机器指令通常是一对一. </p><p>基本特点: </p><ul><li>每行写一条指令. </li><li>标签提供地址的内容(通常从一行的第一列开始).</li><li>指令开始于后续列. </li><li>一条指令到一行的结束. </li><li>注释以分号开始，到一行的结束</li></ul><h3 id="汇编程序的结构-1"><a href="#汇编程序的结构-1" class="headerlink" title="汇编程序的结构"></a>汇编程序的结构</h3><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-symbol">AREA</span> HELLO, <span class="hljs-meta">CODE</span>, <span class="hljs-meta">READONLY</span><br><span class="hljs-symbol">ENTRY</span> <span class="hljs-comment">; 伪指令标识程序的入口点</span><br><span class="hljs-symbol">Start</span> <span class="hljs-comment">; Start函数的入口地址</span><br><span class="hljs-keyword">LDR</span> <span class="hljs-built_in">R0</span>, <span class="hljs-number">=0x1</span><br><span class="hljs-keyword">MOV</span> <span class="hljs-built_in">R1</span>, <span class="hljs-number">#1</span><br><span class="hljs-symbol">...</span><br><span class="hljs-symbol">END</span> <span class="hljs-comment">; 伪指令表示代码段结束</span><br></code></pre></td></tr></table></figure><h3 id="指令格式"><a href="#指令格式" class="headerlink" title="指令格式"></a>指令格式</h3><p>▪Cortex-M4指令的助记符格式如下：</p><p>&lt; opcode &gt;，{&lt; cond &gt;}， {S}，&lt; Rd &gt;, &lt; Rn &gt;，{ &lt; oprand2 &gt; }</p><ul><li>&lt;&gt;为必选项，{}为可选项</li><li>opcode：操作码，即指令助记符，如：ADD, LDR, STR等 </li><li>cond：条件码，描述指令执行的条件，如：EQ, LE等 </li><li>S：指令后加S，指令执行完成后自动更新状态寄存器的条件标志位</li><li>Rd：目标寄存器</li><li>Rn：第一个操作数寄存器</li><li>operand2：第二个操作数，可以是寄存器、立即数等</li></ul><blockquote><p>例：LDR R0, [R1] ; 将存储器地址为R1的字数据加载到寄存器R0中</p></blockquote><h3 id="寻址方式"><a href="#寻址方式" class="headerlink" title="寻址方式"></a>寻址方式</h3><p><strong>立即寻址</strong></p><p>也叫做立即数寻址，立即数以#为前缀如：</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-keyword">MOV</span> <span class="hljs-built_in">R0</span>, <span class="hljs-meta">#4           ;R0 ← 4</span><br><span class="hljs-keyword">ADD</span> <span class="hljs-built_in">R0</span>, <span class="hljs-built_in">R0</span>, <span class="hljs-meta">#0x10    ;R0 ← R0+0x10</span><br></code></pre></td></tr></table></figure><p><strong>寄存器寻址</strong></p><p>把寄存器中的数值作为操作数，也称为寄存器直接寻址如：</p><figure class="highlight tp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs tp">ADD <span class="hljs-keyword">R</span><span class="hljs-number">0</span>, <span class="hljs-keyword">R</span><span class="hljs-number">1</span>, <span class="hljs-keyword">R</span><span class="hljs-number">2</span> ; <span class="hljs-keyword">R</span><span class="hljs-number">0</span> ← <span class="hljs-keyword">R</span><span class="hljs-number">1</span>+<span class="hljs-keyword">R</span><span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p><strong>寄存器偏移寻址</strong></p><p>将第二个操作数，进行移位操作后赋值给第一个操作数如：</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-keyword">MOV</span> <span class="hljs-built_in">R0</span>, <span class="hljs-built_in">R1</span>, <span class="hljs-keyword">LSL</span> <span class="hljs-meta">#2 ;R0 ← R1 &lt;&lt; 2</span><br></code></pre></td></tr></table></figure><p><strong>寄存器间接寻址</strong></p><p>把寄存器中的值作为操作数的地址，通过该地址从存储器取出操作数如：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-keyword">LDRB</span> <span class="hljs-built_in">R0</span>, [<span class="hljs-built_in">R1</span>] <span class="hljs-comment">; read byte value from [R1]</span><br><span class="hljs-comment">; extending to 32bits on load R0 </span><br><span class="hljs-keyword">STRB</span> <span class="hljs-built_in">R0</span>, [<span class="hljs-built_in">R1</span>] <span class="hljs-comment">;[R1] ← R0</span><br></code></pre></td></tr></table></figure><p><strong>基址变址寻址</strong></p><p>将寄存器的值与地址偏移量相加得到地址</p><ul><li>感叹号表示前增量寻址模式</li><li>[R1], #2 表示后增量寻址模式</li></ul><p>如：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-keyword">LDR</span> <span class="hljs-built_in">R0</span>, [<span class="hljs-built_in">R1</span>, <span class="hljs-number">#2</span>] <span class="hljs-comment">;R0 ← [R1+2]</span><br><span class="hljs-keyword">LDR</span> <span class="hljs-built_in">R0</span>, [<span class="hljs-built_in">R1</span>, <span class="hljs-number">#2</span>]! <span class="hljs-comment">;R0 ← [R1+2], R1 ← R1+2</span><br><span class="hljs-keyword">LDR</span> <span class="hljs-built_in">R0</span>, [<span class="hljs-built_in">R1</span>], <span class="hljs-number">#2</span> <span class="hljs-comment">;R0 ← [R1],R1 ← R1+2</span><br><span class="hljs-keyword">LDR</span> <span class="hljs-built_in">R0</span>, [<span class="hljs-built_in">R1</span>, <span class="hljs-built_in">R2</span>] <span class="hljs-comment">;R0 ← [R1+R2]</span><br></code></pre></td></tr></table></figure><h3 id="数据处理指令"><a href="#数据处理指令" class="headerlink" title="数据处理指令"></a><strong>数据处理指令</strong></h3><p>寄存器与寄存器之间，寄存器与特殊寄存器之间，把立即数加载到寄存器</p><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1ch2-%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84/image-20230311010120530.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="表格"></p><h4 id="算数运算指令"><a href="#算数运算指令" class="headerlink" title="算数运算指令"></a><strong>算数运算指令</strong></h4><p>基本的算数运算指令包括：加法、减法运算，反向减法指令，有符号无符号加减法指令</p><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1ch2-%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84/image-20230311010158353.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="表格"></p><p><strong>乘法指令、乘加指令和除法指令</strong></p><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1ch2-%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84/image-20230311010237534.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="续表"></p><h4 id="逻辑运算指令"><a href="#逻辑运算指令" class="headerlink" title="逻辑运算指令"></a><strong>逻辑运算指令</strong></h4><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1ch2-%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84/image-20230311010322773.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="表"></p><h4 id="移位指令"><a href="#移位指令" class="headerlink" title="移位指令"></a><strong>移位指令</strong></h4><p><strong>逻辑移位，算术移位，循环移位</strong></p><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1ch2-%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84/image-20230311010445123.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="呃呃"></p><h4 id="比较与测试指令"><a href="#比较与测试指令" class="headerlink" title="比较与测试指令"></a>比较与测试指令</h4><p><strong>更改条件标志位</strong></p><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1ch2-%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84/image-20230311010522861.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="😢"></p><h4 id="位域操作指令"><a href="#位域操作指令" class="headerlink" title="位域操作指令"></a><strong>位域操作指令</strong></h4><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1ch2-%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84/image-20230311010715759.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="表"></p><h4 id="跳转指令"><a href="#跳转指令" class="headerlink" title="跳转指令"></a>跳转指令</h4><p>无条件跳转，函数跳转，条件跳转，IT-THEN指令块，查表跳转等</p><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1ch2-%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84/image-20230311010905251.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="！"></p><h3 id="存储器访问指令"><a href="#存储器访问指令" class="headerlink" title="存储器访问指令"></a>存储器访问指令</h3><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1ch2-%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84/image-20230311011011110.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="😓"></p><p><strong>批量加载&#x2F;存储数据指令</strong></p><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1ch2-%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84/image-20230311011036329.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="🤣"></p><p><strong>进栈出栈指令</strong></p><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1ch2-%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84/image-20230311011117669.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="⭐"></p><h3 id="汇编程序设计"><a href="#汇编程序设计" class="headerlink" title="汇编程序设计"></a>汇编程序设计</h3><h4 id="例1：C语言赋值语句对应的汇编程序：x-x3D-a-b-c"><a href="#例1：C语言赋值语句对应的汇编程序：x-x3D-a-b-c" class="headerlink" title="例1：C语言赋值语句对应的汇编程序：x&#x3D;a*b+c;"></a>例1：C语言赋值语句对应的汇编程序：x&#x3D;a*b+c;</h4><p> 对应的汇编程序：</p><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1ch2-%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84/image-20230311094338001.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="只有图片格式"></p><h4 id="例2：C语言逻辑表达式对应的汇编程序："><a href="#例2：C语言逻辑表达式对应的汇编程序：" class="headerlink" title="例2：C语言逻辑表达式对应的汇编程序："></a>例2：C语言逻辑表达式对应的汇编程序：</h4><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c">𝑧 = 𝑎 ⊕ 𝑐 <span class="hljs-string">||(𝑏&amp;𝑐); </span><br></code></pre></td></tr></table></figure><p> 对应的汇编程序：</p><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1ch2-%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84/image-20230311094551851.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="汇编"></p><p><strong>ARM控制流</strong></p><p>▪所有操作可通过测试PSR，有条件执行: </p><p>▪EQ, NE, CS, CC, MI, PL, VS, VC, HI, LS, GE, LT, GT, LE</p><p>▪分支操作:</p><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1ch2-%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84/image-20230311094659561.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="分支操作"></p><blockquote><p>条件码：</p><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1ch2-%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84/image-20230311095758959.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="图图"></p></blockquote><h4 id="例3：C语言条件语句对应的汇编程序："><a href="#例3：C语言条件语句对应的汇编程序：" class="headerlink" title="例3：C语言条件语句对应的汇编程序："></a>例3：C语言条件语句对应的汇编程序：</h4><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">if (a<span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-number">1</span>) b<span class="hljs-operator">=</span><span class="hljs-number">2</span><span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>对应的汇编程序：</p><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1ch2-%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84/image-20230311100133170.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="ok"></p><h4 id="例4：C语言经典条件语句对应的汇编程序"><a href="#例4：C语言经典条件语句对应的汇编程序" class="headerlink" title="例4：C语言经典条件语句对应的汇编程序"></a>例4：C语言经典条件语句对应的汇编程序</h4><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-keyword">if</span> (a&gt;1) <span class="hljs-attribute">b</span>=2; <span class="hljs-keyword">else</span> <span class="hljs-attribute">b</span>=b-a;<br></code></pre></td></tr></table></figure><p>对应的汇编程序：</p><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1ch2-%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84/image-20230311100211612.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="图"></p><h4 id="例5：C语言循环语句对应的汇编程序："><a href="#例5：C语言循环语句对应的汇编程序：" class="headerlink" title="例5：C语言循环语句对应的汇编程序："></a>例5：C语言循环语句对应的汇编程序：</h4><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-keyword">while</span>(a!=b)&#123;<br><span class="hljs-keyword">if</span>(a&gt;b)<br><span class="hljs-attribute">a</span>=a-b;<br><span class="hljs-keyword">else</span> <br><span class="hljs-attribute">b</span>=b-a;<br>&#125;<br><span class="hljs-attribute">gcd</span>=a;<br></code></pre></td></tr></table></figure><p>对应汇编：<br><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1ch2-%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84/image-20230311100349847.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="图"></p><h2 id="五-流水线技术"><a href="#五-流水线技术" class="headerlink" title="五.流水线技术"></a>五.流水线技术</h2><ul><li>通过多个功能部件并行工作来缩短指令的运行时间，提高系统的效率和吞吐率</li><li>指令执行以分解为多个阶段，各阶段使用硬件部件不同，这样指令执行就可重叠，实现指令并行</li><li>延迟：指一条指令从进入流水线到流出流水线所花费的时间</li><li>吞吐量：是指单位时间内执行的指令数</li><li>流水线技术增加了 CPU 的吞吐量，但并没有减少每条指令的延迟</li></ul><p><strong>三级流水线</strong>：包括取指、译码、执行三个阶段</p><p>实现逻辑最简单</p><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1ch2-%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84/image-20230311100450974.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="三级流水"></p><p><strong>五级流水线</strong>：取指、译码、执行、缓冲&#x2F;数据、回写五个阶段，实现逻辑最经典</p><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1ch2-%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84/image-20230311100641570.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="V"></p><p>超流水线超过了通常的5到6级，实现逻辑最复杂.</p><h3 id="CORTEX-M4的三级流水"><a href="#CORTEX-M4的三级流水" class="headerlink" title="CORTEX-M4的三级流水"></a>CORTEX-M4的三级流水</h3><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1ch2-%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84/image-20230311100723101.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="m4"></p><ul><li>取指阶段：<ul><li>取指用来计算下一个预取指令的地址，从指令存储空间取出指令，或者自动加载中断向量</li><li>包含一个预取指缓冲区，避免流水线“断流”</li></ul></li><li>译码阶段：<ul><li>译码对之前取指阶段送入的指令进行解码操作，分解出指令中的操作数和执行码</li><li>再由操作数相应的寻址方式生成操作数的地址，产生寄存器值</li></ul></li><li>执行阶段：<ul><li>用于执行指令，产生LSU的回写执行结果</li></ul></li></ul><h3 id="影响流水线性能的因素"><a href="#影响流水线性能的因素" class="headerlink" title="影响流水线性能的因素"></a>影响流水线性能的因素</h3><ul><li>数据冲突</li><li>跳转指令</li><li>流水线深度</li></ul><h1 id="本章小结"><a href="#本章小结" class="headerlink" title="本章小结"></a>本章小结</h1><ul><li><input checked="" disabled="" type="checkbox"> 冯·诺依曼结构和哈弗结构</li><li><input checked="" disabled="" type="checkbox"> 复杂指令集和简单指令集</li><li><input checked="" disabled="" type="checkbox"> Cortex-M4体系结构及汇编指令</li><li><input checked="" disabled="" type="checkbox"> 流水线技术</li></ul>]]></content>
    
    
    <categories>
      
      <category>学习资料</category>
      
    </categories>
    
    
    <tags>
      
      <tag>课件笔记</tag>
      
      <tag>嵌入式程序设计</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机组成原理-L02-ISA</title>
    <link href="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L02-ISA/"/>
    <url>/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L02-ISA/</url>
    
    <content type="html"><![CDATA[<h1 id="计算机组成与实践-指令集体系结构（ISA）"><a href="#计算机组成与实践-指令集体系结构（ISA）" class="headerlink" title="计算机组成与实践 -指令集体系结构（ISA）"></a><strong>计算机组成与实践</strong> -指令集体系结构（ISA）</h1><h2 id="֍ISA简介"><a href="#֍ISA简介" class="headerlink" title="֍ISA简介"></a>֍<strong>ISA</strong>简介</h2><h3 id="什么是指令集体系结构（ISA）？"><a href="#什么是指令集体系结构（ISA）？" class="headerlink" title="什么是指令集体系结构（ISA）？"></a>什么是指令集体系结构（ISA）？</h3><table><thead><tr><th><strong>指令（Instruction）</strong></th></tr></thead><tbody><tr><td>计算机语言中的基本单词称为指令。</td></tr></tbody></table><table><thead><tr><th><strong>指令集（Instruction Set）</strong></th></tr></thead><tbody><tr><td>一台计算机的全部指令称为该计算机的指令集。</td></tr></tbody></table><table><thead><tr><th><strong>指令集体系结构（Instruction Set Architecture）</strong></th></tr></thead><tbody><tr><td>硬件和底层软件之间的接口，被命名为计算机的<strong>指令集体系结构（ISA）</strong>或简称<strong>体系结构</strong></td></tr></tbody></table><h3 id="CISC-vs-RISC-貌似在各个课程里出现频率很高"><a href="#CISC-vs-RISC-貌似在各个课程里出现频率很高" class="headerlink" title="CISC vs. RISC(貌似在各个课程里出现频率很高)"></a><strong>CISC vs. RISC</strong>(貌似在各个课程里出现频率很高)</h3><p><strong>CISC</strong></p><p>🔷复杂指令集计算机(Complex Instruction Set Computers)</p><p>🔷指令数量多，使用频率差别大，可变长格式，支持多种寻址方式</p><p>🔷例如：Intel x86</p><p><strong>RISC</strong></p><p>🔷精简指令集计算机(Reduced Instruction Set Computers)</p><p>🔷指令数量少，使用频率接近，定长格式，大部分为单周期指令，寻址方式支持较少，通用寄存器，Load&#x2F;Store体系结构</p><p>🔷例如：MIPS、ARM、RISC-V</p><h3 id="汇编语言指令"><a href="#汇编语言指令" class="headerlink" title="汇编语言指令"></a><strong>汇编语言指令</strong></h3><table><thead><tr><th><strong>机器语言（machine language）</strong></th></tr></thead><tbody><tr><td>计算机直接识别的二进制代码，或指不经翻译即可为机器直接理解和接受的程序语言或指令代码。</td></tr></tbody></table><p><strong>机器语言：</strong></p><p>🔷设计能够方便简单搭建硬件的ISA</p><p>🔷编译器能够最优化性能和开销</p><p>MIPS：</p><p>🔷采取精简指令集（RISC）的处理器架构</p><p>🔷与其他ISA类似，最早由斯坦福大学开发</p><p>🔷MIPS32、MIPS64、microMIPS、nanoMIPS架构</p><h3 id="计算机设计原则"><a href="#计算机设计原则" class="headerlink" title="计算机设计原则"></a><strong>计算机设计原则</strong></h3><p>两个设计原则：</p><p>1、<strong>指令</strong>用<strong>数</strong>的形式表示</p><p>🔷00000000 10000010 00010000 00100000</p><p>🔷指令：<strong>add</strong> $2, $4, $2</p><p>🔷数字：00 82 10 2016</p><p>2、<strong>程序</strong>和<strong>数据</strong>都存入存储器中，并可以读写</p><p>🔷程序在计算机中以二进制文件的形式存储——二进制兼容性。</p><p>🔷计算机可以运行各种程序，二进制兼容使编译好的程序可以在不同计算机上运行。</p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L02-ISA/image-20230307231038056.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="程序都以二进制存储"></p><table><thead><tr><th><strong>存储程序概念（Stored-Program Concept）</strong></th></tr></thead><tbody><tr><td>多种类型的指令和数据均以数字形式存储于存储器中的概念，存储程序型计算机即源于此。</td></tr></tbody></table><h3 id="MIPS指令集"><a href="#MIPS指令集" class="headerlink" title="MIPS指令集"></a><strong>MIPS指令集</strong></h3><p><strong>指令类别：</strong></p><ul><li>算术指令</li><li>逻辑运算指令</li><li>数据传送指令</li><li>跳转和分支指令</li><li>特殊指令</li></ul><p><strong>寄存器：</strong></p><ul><li>R0-R31</li><li>PC</li><li>HI</li><li>LO</li></ul><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L02-ISA/image-20230307231218612.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="这个图在arm课里应该也出现了"></p><p>MIPS各种指令类型在SPEC2006中使用的频率</p><table><thead><tr><th><strong>指令类型</strong></th><th><strong>频率</strong></th><th></th></tr></thead><tbody><tr><td><strong>整数型</strong></td><td><strong>浮点型</strong></td><td></td></tr><tr><td>算术</td><td>16%</td><td>48%</td></tr><tr><td>数据传送</td><td>35%</td><td>36%</td></tr><tr><td>逻辑</td><td>12%</td><td>4%</td></tr><tr><td>分支</td><td>34%</td><td>8%</td></tr><tr><td>跳转</td><td>2%</td><td>0%</td></tr></tbody></table><h3 id="MIPS寄存器组"><a href="#MIPS寄存器组" class="headerlink" title="MIPS寄存器组"></a><strong>MIPS寄存器组</strong></h3><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L02-ISA/image-20230307231411759.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="MIPS寄存器示意"></p><ul><li>32个32 bits的寄存器</li><li>5个输入端口：</li><li>3个寄存器选择</li><li>1个数据输入</li><li>1个控制</li><li>2个输出端口</li></ul><blockquote><table><thead><tr><th><strong>编号</strong></th><th><strong>名称</strong></th><th><strong>用途</strong></th></tr></thead><tbody><tr><td>$0</td><td>$zero</td><td>常量0</td></tr><tr><td>$1</td><td>$at</td><td>保留给汇编器</td></tr><tr><td>$2-$3</td><td>$v0-$v1</td><td>函数调用返回值</td></tr><tr><td>$4-$7</td><td>$a0-$a3</td><td>函数调用参数</td></tr><tr><td>$8-$15</td><td>$t0-$t7</td><td>暂时的</td></tr><tr><td>$16-$23</td><td>$s0-$s7</td><td>保存的</td></tr><tr><td>$24-$25</td><td>$t8-$t9</td><td>暂时的</td></tr><tr><td>$26-$27</td><td>$k0-$k1</td><td>为操作系统／异常处理保留</td></tr><tr><td>$28</td><td>$gp</td><td>全局指针(Global  Pointer)</td></tr><tr><td>$29</td><td>$sp</td><td>堆栈指针(Stack  Pointer)</td></tr><tr><td>$30</td><td>$fp</td><td>帧指针(Frame  Pointer)</td></tr><tr><td>$31</td><td>$ra</td><td>返回地址(return  address)</td></tr></tbody></table></blockquote><p>访问速度比内存快：</p><ul><li>存储频繁访问的数据</li><li>存储空间小，内存有百万个字</li><li>64个寄存器比32个寄存器慢一倍</li></ul><p>方便编译程序访问：</p><ul><li>相较于栈，寄存器组支持随机访问</li><li>有效利用寄存器对于提高程序性能极为重要</li></ul><h3 id="MIPS指令字段"><a href="#MIPS指令字段" class="headerlink" title="MIPS指令字段"></a><strong>MIPS指令字段</strong></h3><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L02-ISA/image-20230307231854898.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="R型"></p><ul><li>op ：指令的基本操作， 通常称为操作码（ opcode ） </li><li>rs ：第一个源操作数寄存器</li><li>rt ：第二个源操作数寄存器</li><li>rd ：用于存放操作结果的目的寄存器</li><li>shamt ：位移量</li><li>funct：功能码，用于指明op字段中操作的特定变式</li></ul><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L02-ISA/image-20230307232116928.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="I型"></p><ul><li>op ：指令的基本操作， 通常称为操作码（ opcode ） </li><li>rs ：源操作数寄存器</li><li>rt ：目的操作数寄存器</li><li>Constant address：常数或地址</li></ul><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L02-ISA/image-20230307232200533.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="J型"></p><ul><li>op ：指令的基本操作， 通常称为操作码（ opcode ） </li><li>jump target：跳转的目的地址</li></ul><h3 id="MIPS的设计原则"><a href="#MIPS的设计原则" class="headerlink" title="MIPS的设计原则"></a><strong>MIPS的设计原则</strong></h3><table><thead><tr><th><strong>设计目标</strong></th></tr></thead><tbody><tr><td>最优性能、最小开销、减少设计时间、最小能耗</td></tr></tbody></table><p><strong>设计原则1：简单源于规整</strong></p><ul><li>规整的指令格式可以简化硬件设计，使计算高性能低功耗</li><li>指令格式少</li><li>前6位为操作码</li></ul><p><strong>设计原则2：越小越快</strong></p><ul><li>指令数量少</li><li>寄存器数量较少</li></ul><p><strong>设计原则3：加速大概率事件</strong></p><ul><li>操作数来自寄存器</li><li>允许立即数作为操作数</li></ul><p><strong>设计原则4：优秀的设计需要适宜的折中方案</strong></p><ul><li>三种指令格式</li></ul><h2 id="֍算术与逻辑运算指令"><a href="#֍算术与逻辑运算指令" class="headerlink" title="֍算术与逻辑运算指令"></a><strong>֍算术与逻辑运算指令</strong></h2><h3 id="MIPS算术指令"><a href="#MIPS算术指令" class="headerlink" title="MIPS算术指令"></a><strong>MIPS算术指令</strong></h3><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">add </span>$<span class="hljs-built_in">t0</span>, $<span class="hljs-built_in">s1</span>, $<span class="hljs-built_in">s2</span><br><br><span class="hljs-keyword">sub </span>$<span class="hljs-built_in">t0</span>, $<span class="hljs-built_in">s1</span>, $<span class="hljs-built_in">s2</span><br></code></pre></td></tr></table></figure><ul><li>每条MIPS指令仅执行<strong>1</strong>个操作（加、减等）</li><li>每条算术指令有<strong>3</strong>个操作数（$t0, $s1, $s2） ，2个源操作数（ $s1, $s2）和1个目的操作数（$t0）</li><li>3个操作数来自<strong>寄存器组</strong></li><li>采用<strong>R型</strong>指令格式，shamt字段没使用</li></ul><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L02-ISA/image-20230307233845022.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="R型指令"></p><h3 id="常数或立即数操作数"><a href="#常数或立即数操作数" class="headerlink" title="常数或立即数操作数"></a><strong>常数或立即数操作数</strong></h3><p>超过一半MIPS 算术运算指令用常数作为操作数</p><ul><li><p>提供其中一个操作数是常数的算术指令</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">addi </span>$<span class="hljs-built_in">s3</span>, $<span class="hljs-built_in">s3</span>, <span class="hljs-number">4</span><br></code></pre></td></tr></table></figure></li><li><p>采用<strong>I型</strong>指令格式</p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L02-ISA/image-20230307234942779.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="I型"></p></li><li><p><strong>常数存在指令中</strong></p></li><li><p>指令格式限制数值范围：-2^15到2^15-1</p></li></ul><h3 id="I型指令格式"><a href="#I型指令格式" class="headerlink" title="I型指令格式"></a><strong>I型指令格式</strong></h3><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L02-ISA/image-20230307235050249.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="I型指令"></p><h3 id="MIPS的逻辑运算"><a href="#MIPS的逻辑运算" class="headerlink" title="MIPS的逻辑运算"></a><strong>MIPS的逻辑运算</strong></h3><p>其他按位操作的逻辑运算指令</p><table><thead><tr><th><strong>R型指令格式</strong></th></tr></thead><tbody><tr><td><strong>and</strong>  $t0, $t1, $t2       #$t0&#x3D;$t1 &amp; $t2</td></tr><tr><td><strong>or</strong> $t0, $t1, $t2            #$t0&#x3D;$t1  |$2</td></tr><tr><td><strong>nor</strong>  $t0, $t1, $t2         #$t0&#x3D;not($t1  |$t2)</td></tr></tbody></table><table><thead><tr><th align="left"><strong>I型指令格式</strong></th></tr></thead><tbody><tr><td align="left"><strong>andi</strong> $t0,  $t1, 0xFF00     #$t0&#x3D;$t1 &amp; ff00</td></tr><tr><td align="left"><strong>ori</strong>   $t0, $t1, 0xFF00       #$t0&#x3D;$t1 |ff00</td></tr></tbody></table><h3 id="与（AND）操作"><a href="#与（AND）操作" class="headerlink" title="与（AND）操作"></a><strong>与（AND）操作</strong></h3><p>将源操作数中的某些位置0，称为<strong>掩码</strong>（mask）</p><p>选取某些位，将其他位置0</p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L02-ISA/image-20230308000043065.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="如图"></p><h3 id="或（OR）操作"><a href="#或（OR）操作" class="headerlink" title="或（OR）操作"></a><strong>或（OR）操作</strong></h3><p>两个操作位中任意一位为1 时结果就为1</p><p>将一些位置为1，其他位不变</p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L02-ISA/image-20230308000144096.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="OR"></p><h3 id="或非（NOR）操作"><a href="#或非（NOR）操作" class="headerlink" title="或非（NOR）操作"></a><strong>或非（NOR）操作</strong></h3><p>按位先或操作后非操作</p><p>将一些位置为1</p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L02-ISA/image-20230308000221100.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="NOR"></p><p>MIPS引入或非指令（nor）取代按位取反（not）</p><blockquote><p><strong>设计原则1：简单源于规整</strong></p></blockquote><h3 id="如何使用大常数？"><a href="#如何使用大常数？" class="headerlink" title="如何使用大常数？"></a><strong>如何使用大常数？</strong></h3><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L02-ISA/image-20230308000313975.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="I"></p><p>常数数值范围：-2^31~2^31-1</p><ul><li>将32 bits常量取入寄存器</li><li>使用两条指令：lui和ori</li></ul><p>1、取立即数到寄存器高16位指令</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">lui </span> $<span class="hljs-built_in">t0</span>, <span class="hljs-number">1010101010101010</span><br></code></pre></td></tr></table></figure><p>2、与立即数进行逻辑“或”运算</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">ori </span> $<span class="hljs-built_in">t0</span>, $<span class="hljs-built_in">t0</span>, <span class="hljs-number">1010101010101010</span><br></code></pre></td></tr></table></figure><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L02-ISA/image-20230308000419045.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="如何使用大常数"></p><h3 id="无符号二进制数"><a href="#无符号二进制数" class="headerlink" title="无符号二进制数"></a><strong>无符号二进制数</strong></h3><p>基本二进制表示方式</p><ul><li><p>n  bits数的表示</p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L02-ISA/image-20230308001123006.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="公式"></p></li><li><p>取值范围：0到2^n – 1</p></li><li><p>例子：</p><p>0000 0000 0000 0000 0000 0000 0000 10112<br> &#x3D; 0 + … + 1×2^3 + 0×2^2 +1×2^1 +1×2^0<br> &#x3D; 0 + … + 8 + 0 + 2 + 1 &#x3D; 11(下标10)</p></li><li><p>32 bits无符号数的数值范围是0 to 2^32-1</p></li></ul><h3 id="有符号二进制数：二进制补码"><a href="#有符号二进制数：二进制补码" class="headerlink" title="有符号二进制数：二进制补码"></a><strong>有符号二进制数：二进制补码</strong></h3><p>最高有效位为0表示正数，为1表示负数</p><p>n bits数的表示</p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L02-ISA/image-20230308001226376.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="公式"></p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L02-ISA/image-20230308001244452.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="直接截算了"></p><h3 id="有符号数取反"><a href="#有符号数取反" class="headerlink" title="有符号数取反"></a><strong>有符号数取反</strong></h3><p>🔷按位取反，再加1</p><p>🔷按位取反：1-&gt;0, 0-&gt;1</p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L02-ISA/image-20230308001332211.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="image-20230308001332211"></p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L02-ISA/image-20230308001352869.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="例子"></p><h3 id="符号扩展"><a href="#符号扩展" class="headerlink" title="符号扩展"></a><strong>符号扩展</strong></h3><p>🔷将一个用n 位表示的二进制数转化成一个用多于n 位表示的数</p><ul><li>保持数值不变</li></ul><p>🔷复制最高有效位（符号位）</p><ul><li>无符号数：用0填充左边的数位</li><li>有符号数：用1填充左边的数位</li></ul><p>🔷例子：8 bits数扩展为16 bits数</p><ul><li>+2: 0000 0010 &#x3D;&gt; 0000 0000 0000 0010</li><li>–2: 1111 1110 &#x3D;&gt; 1111 1111 1111 1110</li></ul><h3 id="逻辑操作"><a href="#逻辑操作" class="headerlink" title="逻辑操作"></a><strong>逻辑操作</strong></h3><p>按位操作的指令</p><table><thead><tr><th>逻辑操作</th><th>C</th><th>Java</th><th>MIPS</th></tr></thead><tbody><tr><td>左移</td><td>&lt;&lt;</td><td>&lt;&lt;</td><td>sll</td></tr><tr><td>右移</td><td>&gt;&gt;</td><td>&gt;&gt;&gt;</td><td>srl</td></tr><tr><td>按位与</td><td>&amp;</td><td>&amp;</td><td>and, andi</td></tr><tr><td>按位或</td><td>|</td><td>|</td><td>or，ori</td></tr><tr><td>按位取反</td><td>~</td><td>~</td><td>nor</td></tr></tbody></table><p>用于简化对字中若干位进行打包或者拆分操作，称为逻辑操作（logical operations）</p><h3 id="MIPS移位操作"><a href="#MIPS移位操作" class="headerlink" title="MIPS移位操作"></a><strong>MIPS移位操作</strong></h3><p>🔷按位操作的指令</p><p>🔷将所有位向左或者向右移位</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">sll </span>$<span class="hljs-built_in">t2</span>, $<span class="hljs-built_in">s0</span>, <span class="hljs-number">4</span><br><span class="hljs-keyword">srl </span>$<span class="hljs-built_in">t2</span>, $<span class="hljs-built_in">s0</span>, <span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><ul><li>逻辑左移sll：所有位所有位向左移动，空位用0填充</li><li>逻辑右移srl：所有位向右移动，空位用0填充</li><li>采用<strong>R</strong>型指令格式, rs字段没使用</li></ul><h3 id="R型指令格式"><a href="#R型指令格式" class="headerlink" title="R型指令格式"></a><strong>R型指令格式</strong></h3><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L02-ISA/image-20230308001744136.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="采用R型指令格式"></p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L02-ISA/image-20230308001810626.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="例子"></p><h3 id="算术与逻辑运算指令总结"><a href="#算术与逻辑运算指令总结" class="headerlink" title="算术与逻辑运算指令总结"></a><strong>算术与逻辑运算指令总结</strong></h3><table><thead><tr><th><strong>指令</strong></th><th><strong>格式</strong></th><th><strong>op</strong></th><th><strong>rs</strong></th><th><strong>rt</strong></th><th><strong>rd</strong></th><th><strong>shamt</strong></th><th><strong>funct</strong></th><th><strong>addr</strong></th></tr></thead><tbody><tr><td>add</td><td>R</td><td>0</td><td>reg</td><td>reg</td><td>reg</td><td>0</td><td>32</td><td>n.a.</td></tr><tr><td>sub</td><td>R</td><td>0</td><td>reg</td><td>reg</td><td>reg</td><td>0</td><td>34</td><td>n.a.</td></tr><tr><td>addi</td><td>I</td><td>8</td><td>reg</td><td>reg</td><td>n.a.</td><td>n.a.</td><td>n.a.</td><td>常数</td></tr><tr><td>and</td><td>R</td><td>0</td><td>reg</td><td>reg</td><td>reg</td><td>0</td><td>36</td><td>n.a.</td></tr><tr><td>or</td><td>R</td><td>0</td><td>reg</td><td>reg</td><td>reg</td><td>0</td><td>37</td><td>n.a.</td></tr><tr><td>xor</td><td>R</td><td>0</td><td>reg</td><td>reg</td><td>reg</td><td>0</td><td>38</td><td>n.a.</td></tr><tr><td>nor</td><td>R</td><td>0</td><td>reg</td><td>reg</td><td>reg</td><td>0</td><td>39</td><td>n.a.</td></tr><tr><td>sll</td><td>R</td><td>0</td><td>0</td><td>reg</td><td>reg</td><td>常数</td><td>0</td><td>n.a.</td></tr><tr><td>srl</td><td>R</td><td>0</td><td>0</td><td>reg</td><td>reg</td><td>常数</td><td>2</td><td>n.a.</td></tr><tr><td>andi</td><td>I</td><td>12</td><td>reg</td><td>reg</td><td>n.a.</td><td>n.a.</td><td>n.a.</td><td>常数</td></tr><tr><td>ori</td><td>I</td><td>13</td><td>reg</td><td>reg</td><td>n.a.</td><td>n.a.</td><td>n.a.</td><td>常数</td></tr></tbody></table><h2 id="֍数据传输指令"><a href="#֍数据传输指令" class="headerlink" title="֍数据传输指令"></a>֍<strong>数据传输指令</strong></h2><h3 id="MIPS的数据传输指令"><a href="#MIPS的数据传输指令" class="headerlink" title="MIPS的数据传输指令"></a><strong>MIPS的数据传输指令</strong></h3><p>为了进行算术运算</p><ul><li>将数据从存储器读入寄存器</li><li>将计算结果从寄存器写回存储器</li><li>数据传送指令（ data transfer instruction ） ：访问存储器的指令<img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L02-ISA/image-20230309222507254.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="load/store word"></li><li>存储器地址是32 bits，值为基址寄存器$s3的内容加上偏移量4</li></ul><h3 id="存储器地址"><a href="#存储器地址" class="headerlink" title="存储器地址"></a><strong>存储器地址</strong></h3><p>数据传送指令中的常量称为偏移量（ offset ）</p><p>存放基址的寄存器称为基址寄存器（ base register ）</p><p>MIPS 是按字节编址的，字的起始地址必须是4 的倍数（32-bit）或者8的倍数（64-bit）</p><p>(四位或者八位对齐)</p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L02-ISA/image-20230309222715460.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="对齐限制-alignment restriction "></p><h3 id="取字指令"><a href="#取字指令" class="headerlink" title="取字指令"></a><strong>取字指令</strong></h3><p>取字和存字指令都采用<strong>I</strong>型指令格式</p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L02-ISA/image-20230309223555757.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="对应图例"></p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L02-ISA/image-20230309223632268.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="寻址流程"></p><h3 id="字节寻址"><a href="#字节寻址" class="headerlink" title="字节寻址"></a><strong>字节寻址</strong></h3><ul><li><p>存储器中可以访问的最小单元是字节(8 bits)</p></li><li><p>一个字中的每个字节都应有自己的地址</p></li><li><p>字节地址与字地址的对应关系</p></li><li><p>大端编址(big-endian)：最<strong>左</strong>边的字节为字地址</p><ul><li>IBM 360&#x2F;370, MIPS, Sparc, HP PA</li></ul></li><li><p>小端编址(little-endian)：最<strong>右</strong>边的字节为字地址</p><ul><li>Intel 80x86, DEC Vax, DEC Alpha</li></ul></li></ul><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L02-ISA/image-20230309231046095.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="字节寻址"></p><p><strong>访问字节</strong></p><table><thead><tr><th>MIPS提供访问单个字节的指令</th></tr></thead><tbody><tr><td><strong>lb</strong>   $t0, 1($s3) #将存储器中的字节取入寄存器$t0</td></tr><tr><td><strong>sb</strong>   $t0, 6($s3) #将寄存器$t0存入存器中的字节</td></tr></tbody></table><p>lb：将字节存入寄存器的最低8 bits   (load byte)</p><p>sb：将寄存器最低8 bits存入存储器的字节中 (store byte)</p><blockquote><p>测试：</p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L02-ISA/image-20230310000502029.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="看看题目"></p><p>第一步，add指令使得s3中存放0，第二步s3+1的位置就是  90 （大端法以最左侧作为起始地址），t0被赋值0x00000090.</p><p>第三步，存出to到s3+6位置，即标号4块变为0xFFFF90FF.</p><p>如果是小端就改为0xFF12FFFF</p></blockquote><h2 id="֍决策指令"><a href="#֍决策指令" class="headerlink" title="֍决策指令"></a>֍<strong>决策指令</strong></h2><h3 id="MIPS决策指令"><a href="#MIPS决策指令" class="headerlink" title="MIPS决策指令"></a><strong>MIPS决策指令</strong></h3><table><thead><tr><th><strong>MIPS条件分支指令</strong></th></tr></thead><tbody><tr><td><strong>bne</strong>   $s0,  $s1, L1          #如果$s0!&#x3D;$s1,跳转到L1所指的指令      （n&#x3D;negative)(e&#x3D;equal)</td></tr><tr><td><strong>beq</strong>   $s0,  $s1, L1          #如果$s0&#x3D;$s1,跳转到L1所指的指令</td></tr></tbody></table><blockquote><p>​       <strong>if</strong> (i&#x3D;&#x3D;j) h &#x3D; i + j;</p><p>​    <strong>bne</strong> $s0, $s1, L1 </p><p>​    <strong>add</strong> $s3, $s0, $s1 </p><pre><code class="hljs">   **L1**：…</code></pre></blockquote><ul><li>条件分支语句：如果条件为真，则跳转到标签所指的语句执行；否则，顺序执行</li><li>采用I型指令格式</li></ul><p><strong>分支目的地址</strong></p><p>使用程序计数器（PC）和指令中的16 bits偏移量计算</p><p>提取一条指令后，PC自动加4，保存下一条指令的地址</p><p>限制了分支目的地址：分支指令地址-2^15到+2^15-1</p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L02-ISA/image-20230309235136726.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="示意图"></p><p>if (i&lt;j) h &#x3D; i + j</p><p><strong>小于则置位（set on less than）</strong>：slt</p><blockquote><p>  <strong>slt</strong> $t0, $s0, $s1 #如果$s0&lt;$s1,则$t0&#x3D;1；</p><p>​           #否则$t0&#x3D;0</p></blockquote><p>🔷采用R型指令格式</p><table><thead><tr><th><strong>slt的其他形式</strong></th></tr></thead><tbody><tr><td><strong>slti</strong>   $t0,  $s0, 25 #如果$s0&lt;25,则$t0&#x3D;1</td></tr><tr><td><strong>sltu</strong>   $t0,  $s0, $s1 #如果$s0&lt;$s1,则$t0&#x3D;1</td></tr><tr><td><strong>sltiu</strong> $t0,  $s0, 25 #如果$s0&lt;25,则$t0&#x3D;1</td></tr></tbody></table><p>通过slt，beq，bne和寄存器$zero组合来创建其他决策指令</p><ul><li><p>小于则分支：blt $s1, $s2, L1</p><blockquote><p><strong>slt</strong> $at, $s1, $s2         #如果$s1&lt;$s2,则$at&#x3D;1</p><p> <strong>bne</strong> $at, $zero, L1   #如果$at!&#x3D;0,则跳转到L1</p></blockquote></li><li><p>小于或等于则分支：ble $s1, $s2, L1</p></li><li><p>大于则分支：bgt $s1, $s2, L1</p></li><li><p>大于或等于则分支：bge $s1, $s2, L1</p></li></ul><p>这些指令以伪指令的形式包含在指令集中——编译器可以识别</p><h3 id="边界检查的简单方法"><a href="#边界检查的简单方法" class="headerlink" title="边界检查的简单方法"></a><strong>边界检查的简单方法</strong></h3><ul><li><p>检查数组下标越界的简单方法: 0≤i&lt;n</p><blockquote><p>$s0 &#x3D; 1111 1111 1111 1111 1111 1111 1111 1111</p><p>$s1 &#x3D; 0000 0000 0000 0000 0000 0000 0000 0001</p></blockquote></li><li><p>作为有符号比较</p><blockquote><p><strong>slt</strong> $t0, $s0, $s1 </p></blockquote><ul><li>$t0&#x3D;1</li></ul></li><li><p>作为无符号比较</p><blockquote><p><strong>sltu</strong> $t0, $s0, $s1 </p></blockquote><ul><li>$t1&#x3D;0</li></ul></li><li><p>无符号比较x&lt;y，同时可以检测x是否为负数</p><blockquote><p><strong>sltu</strong> $t0, $s0, $s1</p><p> <strong>beq</strong> $t0, $zero,IndexOutOfBounds</p></blockquote></li></ul><h3 id="无条件分支指令"><a href="#无条件分支指令" class="headerlink" title="无条件分支指令"></a><strong>无条件分支指令</strong></h3><p>MIPS还提供无条件分支指令或无条件跳转指令</p><blockquote><p><strong>j</strong> L1  #跳到标签L1所指的指令</p></blockquote><p>采用J型指令形式（理所当然的jump）</p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L02-ISA/image-20230309235844734.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="图示"></p><blockquote><p>测试：重新改写下面的指令，以支持更远距离的分支转移</p><p><strong>beq</strong> $s0, $s1, L1</p><p>更改为J型指令</p><p>bne $s0, $s1, L2</p><p>J L1</p><p>L2:</p><p>…..</p></blockquote><h2 id="֍过程指令"><a href="#֍过程指令" class="headerlink" title="֍过程指令"></a>֍<strong>过程指令</strong></h2><h3 id="过程（或程序）调用"><a href="#过程（或程序）调用" class="headerlink" title="过程（或程序）调用"></a><strong>过程（或程序）调用</strong></h3><p>过程运行中，程序必须遵从以下6个步骤：</p><ol><li>将参数放在过程可以访问的位置（$a0~$a3）</li><li>将控制转交给过程</li><li>获得过程所需的存储资源</li><li>执行需要的任务</li><li>将结果的值放在调用程序可以访问的位置（$v0-$v1）</li><li>将控制返回初始点（$ra）</li></ol><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L02-ISA/image-20230310001904348.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="tutu"></p><p>跳转和链接指令（jump-and-link instruction）</p><blockquote><p><strong>jal</strong> address      # $ra&#x3D;pc+4, 跳转到address</p></blockquote><ul><li>将PC+4存入寄存器$ra，链接函数返回后执行的指令地址</li><li>采用J型指令格式</li></ul><p>寄存器跳转指令（jump register）</p><blockquote><p><strong>jr</strong> $ra     # #跳转到寄存器$ra所指的地址</p></blockquote><p>采用R型指令格式</p><table><thead><tr><th><strong>程序调用例子</strong></th></tr></thead><tbody><tr><td>jal  gcd</td></tr><tr><td>gcd：…</td></tr><tr><td>jr    $ra</td></tr></tbody></table><h3 id="使用更多寄存器"><a href="#使用更多寄存器" class="headerlink" title="使用更多寄存器"></a><strong>使用更多寄存器</strong></h3><p>被调用者（callee）运行可能使用更多寄存器</p><p>调用者（ caller）所使用的寄存器必须恢复，需要将寄存器换出到存储器</p><p>使用栈（stack）：一种后进先出的数据结构</p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L02-ISA/image-20230310002201480.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="从高地址向低地址“增长”"></p><p>$sp($29)：保存栈顶的地址</p><p>压栈(push)：向栈增加数据</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-symbol">$sp</span> = <span class="hljs-symbol">$sp</span> - <span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><p>出栈(pop)：从栈中移除数据</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-symbol">$sp</span>= <span class="hljs-symbol">$sp</span>+ <span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><h3 id="在栈中为新数据分配空间"><a href="#在栈中为新数据分配空间" class="headerlink" title="在栈中为新数据分配空间"></a><strong>在栈中为新数据分配空间</strong></h3><p>🔷栈中包含过程所保存的寄存器和局部变量的片段称为过程帧（ procedure frame ）或活动记录（ activation record ）</p><p>🔷$fp是帧指针，指向一个过程帧的第一个字——$fp通常作为过程中数据的基址寄存器</p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L02-ISA/image-20230310002420039.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="图示"></p><h3 id="在堆中为数据分配空间"><a href="#在堆中为数据分配空间" class="headerlink" title="在堆中为数据分配空间"></a><strong>在堆中为数据分配空间</strong></h3><ul><li>用户代码段</li><li>静态数据：全局变量<ul><li>例如C语言中的静态变量，常数数组与字符串等</li></ul></li><li>动态数据：堆<ul><li>例如，C中malloc命令分配，Java中new命令来分配</li></ul></li><li>栈：<ul><li>例如局部的数组或结构体</li></ul></li></ul><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L02-ISA/image-20230310002531680.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="栈内数据"></p><h3 id="编译C语言：leaf过程"><a href="#编译C语言：leaf过程" class="headerlink" title="编译C语言：leaf过程"></a><strong>编译C语言：leaf过程</strong></h3><p>C语言代码：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">leaf_example</span> <span class="hljs-params">(<span class="hljs-type">int</span> g, <span class="hljs-type">int</span> h, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span></span><br><span class="hljs-function"></span><br><span class="hljs-function"></span>&#123;   <span class="hljs-type">int</span> f;<br><br>   f = (g + h) – (i + j);<br><br>   <span class="hljs-keyword">return</span> f;<br><br>&#125;<br></code></pre></td></tr></table></figure><table><thead><tr><th>假设g, h, i, j 放在寄存器$a0,  $a1, $a2, $a3</th></tr></thead><tbody><tr><td>leaf_example： <strong>addi</strong>    $sp,  $sp,  -8 #在栈中分配空间</td></tr><tr><td><strong>sw</strong>   $t1, 4($sp)   #保存寄存器</td></tr><tr><td><strong>sw</strong>   $t0, 0($sp)</td></tr><tr><td><strong>add</strong>    $t0, $a0, $a1</td></tr><tr><td>add  $t1, $a2, $a3</td></tr><tr><td><strong>sub</strong>   $v0, $t0, $t1</td></tr><tr><td><strong>lw</strong>   $t0, 0($sp)   #恢复寄存器</td></tr><tr><td><strong>lw</strong>   $t1, 4($sp)</td></tr><tr><td><strong>addi</strong>  $sp, $sp, 8</td></tr><tr><td><strong>jr</strong>   $ra   #跳转到caller</td></tr></tbody></table><h3 id="嵌套过程"><a href="#嵌套过程" class="headerlink" title="嵌套过程"></a><strong>嵌套过程</strong></h3><ul><li>嵌套过程：执行中调用其他过程的过程</li><li>递归过程：是调用自身的嵌套过程</li></ul><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs excel"><span class="hljs-built_in">int</span> <span class="hljs-built_in">fact</span>( <span class="hljs-built_in">int</span> <span class="hljs-built_in">n</span>)<br>       <br>&#123;   <span class="hljs-built_in">if</span> (<span class="hljs-built_in">n</span>&lt;<span class="hljs-number">1</span>)  return  (<span class="hljs-number">1</span>);<br>    else  return (<span class="hljs-built_in">n</span> * <span class="hljs-built_in">fact</span>(<span class="hljs-built_in">n</span>-<span class="hljs-number">1</span>));<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>fact (0) &#x3D; 1</p><p>fact (1) &#x3D; 1 * 1&#x3D; 1</p><p>fact (2) &#x3D; 2 * 1 * 1 &#x3D; 2</p><p>fact (3) &#x3D; 3 * 2 * 1 * 1 &#x3D; 6</p><p>.  .  .</p><hr><p>假设参数n保存在$a0，返回值保存在$v0</p><p>fact：</p><p>​<strong>addi</strong>  $sp, $sp, -8   #在栈中保存$ra和$a0</p><p>​<strong>sw</strong>   $ra, 4($sp)</p><p>​<strong>sw</strong>   $a0, 0($sp)</p><p>​<strong>slti</strong>  $t0, $a0, 1   #测试n&lt;1?</p><p>​<strong>beq</strong>   $t0, $zero, L1</p><p>​<strong>addi</strong>  $v0, $zero, 1  #将1置入$v0</p><p>​<strong>addi</strong>   $sp, $sp, 8</p><p>​<strong>jr</strong>    $ra       #返回到caller</p><p>L1:  </p><p>​<strong>addi</strong>  $a0, $a0, -1   #如果n&gt;&#x3D;1，参数n-1</p><p>​<strong>jal</strong>   fact       #调用fact并link</p><p>bk_f: </p><p>​<strong>lw</strong>   $a0, 0($sp)   #在栈中弹出$ra和$a0，恢复旧值</p><p>​<strong>lw</strong>    $ra, 4($sp)</p><p>​<strong>addi</strong>   $sp, $sp, 8</p><p>​<strong>mul</strong>   $v0, $a0, $v0</p><p>​<strong>jr</strong>    $ra       #返回到caller</p><hr><p>当fact返回之后执行bk_f代码段</p></blockquote><h2 id="֍其他"><a href="#֍其他" class="headerlink" title="֍其他"></a>֍<strong>其他</strong></h2><h3 id="并行与指令：同步"><a href="#并行与指令：同步" class="headerlink" title="并行与指令：同步"></a><strong>并行与指令：同步</strong></h3><ul><li><p>需要硬件支持多任务并行时的同步（synchronize），否则会产生数据竞争（data race）</p></li><li><p>数据竞争：假如来自不同线程的两个连续的访存请求访问同一个地址，并且至少其中一个是写操作，那么这两个存储访问形成数据竞争</p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L02-ISA/image-20230310092904534.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="数据竞争"></p></li><li><p>采用加锁和解锁创立一个仅允许单个处理器操作的区域，称为互斥（mutual exclusion）区</p></li></ul><h3 id="原子交换（atomic-exchange）"><a href="#原子交换（atomic-exchange）" class="headerlink" title="原子交换（atomic exchange）"></a><strong>原子交换（atomic exchange）</strong></h3><p>类似操作系统互斥的原子操作</p><ul><li>原子交换：对一个寄存器中的值和一个存储器中的值进行原子的交换，交换操作当成一条指令执行</li><li>实现原子交换需要一次存储器读和一次存储器写，并且是不可分割的</li><li>一种可行的方法是采用指对，第二条指令返回一个表明这对指令是否原子执行的标志值MIPS处理器采用ll指令和sc指令</li></ul><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">ll </span> $<span class="hljs-built_in">t1</span>, <span class="hljs-number">0</span>($<span class="hljs-built_in">s1</span>)  <span class="hljs-comment">#链接取数(load linked)</span><br><span class="hljs-keyword">sc </span> $<span class="hljs-built_in">t0</span>, <span class="hljs-number">0</span>($<span class="hljs-built_in">s1</span>)  <span class="hljs-comment">#条件存数(store conditional)</span><br></code></pre></td></tr></table></figure><h3 id="ll指令和sc指令"><a href="#ll指令和sc指令" class="headerlink" title="ll指令和sc指令"></a><strong>ll指令和sc指令</strong></h3><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">again：<span class="hljs-keyword">addi </span> $<span class="hljs-built_in">t0</span>, $<span class="hljs-built_in">zero</span>, $<span class="hljs-built_in">s4</span>   <span class="hljs-comment">#$t0=$s4(交换的值)</span><br>    <span class="hljs-keyword">ll </span>   $<span class="hljs-built_in">t1</span>, <span class="hljs-number">0</span>($<span class="hljs-built_in">s1</span>)       <span class="hljs-comment">#将存储器的值取入$t1</span><br>    <span class="hljs-keyword">sc </span>   $<span class="hljs-built_in">t0</span>, <span class="hljs-number">0</span>($<span class="hljs-built_in">s1</span>)       <span class="hljs-comment">#尝试将值保存到存储器</span><br>                            <span class="hljs-comment">#如果失败，$t0=0</span><br>    <span class="hljs-keyword">beq </span>  $<span class="hljs-built_in">t0</span>, $<span class="hljs-built_in">zero</span>, again <span class="hljs-comment">#如果失败继续尝试交换</span><br>    <span class="hljs-keyword">add </span>  $<span class="hljs-built_in">s4</span>, $<span class="hljs-built_in">zero</span>, $<span class="hljs-built_in">t1</span>   <span class="hljs-comment">#将值存入$s4,完成交换</span><br></code></pre></td></tr></table></figure><ul><li>ll指令：取数并保存ll指令的执行与读取的地址0($s1)</li><li>sc指令：检查是否有其他指令在ll指令之后对地址0($s1)进行操作，如果没有，$t0的值存入存储器，并将$t0置为1；如果有， $t0的值不存入，并将$t0置为0，表示操作失败</li></ul><h3 id="C程序翻译并执行程序"><a href="#C程序翻译并执行程序" class="headerlink" title="C程序翻译并执行程序"></a><strong>C程序翻译并执行程序</strong></h3><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L02-ISA/image-20230310093510640.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="流程图"></p><h2 id="֍小结"><a href="#֍小结" class="headerlink" title="֍小结"></a>֍<strong>小结</strong></h2><h3 id="MIPS寻址模式总结"><a href="#MIPS寻址模式总结" class="headerlink" title="MIPS寻址模式总结"></a><strong>MIPS寻址模式总结</strong></h3><p><strong>1.立即数寻址</strong></p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L02-ISA/image-20230310094001208.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="I型"></p><p><strong>2.寄存器寻址</strong></p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L02-ISA/image-20230310094055343.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="R型"></p><p><strong>3.基址寻址</strong></p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L02-ISA/image-20230310095440892.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="I型"></p><p><strong>4.PC相对寻址</strong></p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L02-ISA/image-20230310095631278.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="I型"></p><p><strong>5.伪直接寻址</strong></p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L02-ISA/image-20230310095732595.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="J型？"></p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a><strong>小结</strong></h3><ul><li><strong>设计原则</strong><ul><li>简单源于规整</li><li>越小越快</li><li>加速大概率事件</li><li>优秀的设计需要适宜的折中方案</li></ul></li><li><strong>软&#x2F;硬件层</strong><ul><li>汇编器、编译器、硬件</li></ul></li><li><strong>MIPS指令体系结构核心指令及指令格式</strong><ul><li>R型、I型、J型</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>学习资料</category>
      
    </categories>
    
    
    <tags>
      
      <tag>课件笔记</tag>
      
      <tag>计算机组成原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ARM体系结构与编程-第0章-RISC处理器体系结构概述</title>
    <link href="/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC0%E7%AB%A0-RISC%E5%A4%84%E7%90%86%E5%99%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0/"/>
    <url>/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC0%E7%AB%A0-RISC%E5%A4%84%E7%90%86%E5%99%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="ARM体系结构与编程"><a href="#ARM体系结构与编程" class="headerlink" title="ARM体系结构与编程"></a><strong>ARM体系结构与编程</strong></h1><blockquote><p>记录琚小明老师的arm体系结构课件</p><p><strong>教材</strong></p><p>《ARM体系结构与编程》，杜春雷编著，清华大学出版社</p><p><strong>参考资料</strong></p><p>《ARM 嵌入式系统结构与编程》，清华大学出版社2009年3月出版</p><p><strong><a href="http://www.arm.com/">http://www.arm.com/</a></strong></p><p><strong><a href="http://www.mips.com/">http://www.mips.com/</a></strong></p><p><strong>目的</strong></p><ul><li>熟悉ARM体系结构</li><li>掌握使用汇编语言设计、编写、调试和运行程序的方法</li></ul><p><strong>课程内容</strong></p><ul><li>RISC体系结构介绍（新增）</li><li>ARM处理器体系结构</li><li>ARM指令寻址方式</li><li>ARM指令集</li><li>ARM汇编语言语法结构</li><li>ARM集成开发环境ADS</li><li>ARM异常中断处理</li></ul></blockquote><h2 id="一-计算机语言发展简史"><a href="#一-计算机语言发展简史" class="headerlink" title="一.计算机语言发展简史"></a>一.计算机语言发展简史</h2><p><img src="/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC0%E7%AB%A0-RISC%E5%A4%84%E7%90%86%E5%99%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0/image-20230305233238790.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="汇编语言的重要性"></p><blockquote><p>🔷<strong>机器语言</strong>：依赖于机器的低级语言，书写格式为二进制代码。</p><p>​      <strong>优点</strong>：执行速度快，效率高。</p><p>​  <strong>缺点</strong>：表达的意义不直观，编写、阅读、调试较困难。  </p><p><strong>🔷汇编语言</strong>：是一种符号语言，与机器语言一一对应；使用助记符表示相应的操作，并遵循一定的语法规则。与机器语言有类似的优、缺点，但比机器语言更易于为人们所理解。</p><p><strong>🔷高级语言</strong>：面向人的语言，有多种类型。</p><p>​      <strong>优点</strong>：便于阅读，易学易用，不涉及硬件，具有通用性。</p><p>​      <strong>缺点</strong>：目标代码冗长，占用内存多，从而执行时间长，效率不高，不能对某些硬件进行操作。       </p></blockquote><p><strong>汇编语言的特点：</strong></p><ul><li>面向机器的低级语言，通常是为特定的计算机或计算机系列专门设计的。(ISA体系结构，面向特定的处理器)</li><li>保持了机器语言的优点，具有直接和简洁的特点。</li><li>可有效地访问、控制计算机的各种硬件设备，如磁盘、存储器、CPU、I&#x2F;O端口等。</li><li>目标代码简短，占用内存少，执行速度快，是高效的程序设  计语言。</li><li>经常与高级语言配合使用（混合编程），应用十分广泛。</li></ul><p><strong>汇编语言的应用：</strong></p><ul><li>70%以上的系统软件是用汇编语言编写的。</li><li>某些快速处理、位处理、访问硬件设备等高效程序是用汇编语言编写的。</li><li>某些高级绘图程序、视频游戏程序、图像解压缩程序是用汇编语言编写的。</li></ul><blockquote><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-comment">#include &quot;stdafx.h&quot;</span><br>   #include <span class="hljs-string">&quot;stdio.h&quot;</span><br>   int main(int argc, char* argv[])<br>   &#123;        int a,b,c;<br>             <span class="hljs-attribute">a</span>=1; <br>  <span class="hljs-attribute">b</span>=2;<br>  <span class="hljs-attribute">c</span>=a+b;<br>  printf(“<span class="hljs-attribute">c</span>=%d\n&quot;,c);<br>  return 0;<br>   &#125;<br></code></pre></td></tr></table></figure><p>以上程序段使用c++编译的目标文件达3.59kB</p><p>而汇编后的目标文件只有208字节</p></blockquote><h2 id="二-RISC处理器体系结构概述"><a href="#二-RISC处理器体系结构概述" class="headerlink" title="二.RISC处理器体系结构概述"></a>二.RISC处理器体系结构概述</h2><h3 id="ISA体系结构分类"><a href="#ISA体系结构分类" class="headerlink" title="ISA体系结构分类"></a>ISA体系结构分类</h3><p>根据指令使用数据的方式，指令系统分为以下几类</p><p>🔷堆栈型(Stack)：操作数在栈顶，运算操作不用指定操作数</p><p>🔷累加器型(Accumulator)：一个操作数总在累加器中，结果也写回累加器</p><p>🔷寄存器型(Register)，每个操作数都由指令指定</p><ul><li>​Register-Register型，又称为Load-Store型，所有运算操作的操作数都在寄存器中</li><li>​Register-Memory型</li><li>​Memory-Memory型</li></ul><p>上述三种指令系统类型也可以分别称为0地址指令，单地址指令，以及多地址指令</p><p>例子：不同指令系统完成C&#x3D;A+B的指令序列，假设A、B、C在内存中不同的单元</p><table><thead><tr><th>stack</th><th>accumulator</th><th>Register  (memory-memory)</th><th>Register  (register-memory)</th><th>Register  (load-store)</th></tr></thead><tbody><tr><td>push  A</td><td>load  A</td><td>add  R1,A,B</td><td>load  R1,A</td><td>load  R1,A</td></tr><tr><td>push  B</td><td>add  B</td><td>store  R1,C</td><td>add  R1,B</td><td>load  R2,B</td></tr><tr><td>add</td><td>store  C</td><td></td><td>store  R1,C</td><td>add  R3,R1,R2</td></tr><tr><td>pop  C</td><td></td><td></td><td></td><td>store  R3,C</td></tr></tbody></table><p>早期的计算机多用<strong>堆栈和累加器型</strong>指令</p><ul><li>出于降低硬件复杂度的考虑</li><li>现在已经不用（Intel有点例外）</li></ul><p>80年代后的机器主要是<strong>寄存器型</strong></p><ul><li>访问寄存器比访问存储器快</li><li>便于编译器使用和优化(操作单一，寄存器vs.内存)</li><li>寄存器可以用来存放变量，减少访存次数</li></ul><p>处理器是一个执行存储器中指令的有限状态机，采用存储程序数字计算机的原理。</p><p>存储程序数字计算机把指令和数据存放在同一个存储器系统中，指令和数据可以放在一起或分开存放。</p><ul><li>冯诺依曼结构</li><li>哈佛结构（感觉每堂课都在讲这个</li></ul><p><img src="/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC0%E7%AB%A0-RISC%E5%A4%84%E7%90%86%E5%99%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0/image-20230306003342226.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="冯诺依曼结构"></p><p><img src="/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC0%E7%AB%A0-RISC%E5%A4%84%E7%90%86%E5%99%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0/image-20230306003346046.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="哈佛结构"></p><blockquote><p>冯.诺依曼型计算机的逻辑结构的三层含义：</p><ul><li>计算机应包含运算器、控制器、存储器、输入设备和输出设备五大基本部件；</li><li>计算机内部采用二进制形式表示指令和数据；</li><li>事先将编好的程序和始数据放入存储器中，计算机工作的时候能够自动高速地从存储器中提取指令并执行。</li></ul></blockquote><h3 id="CISC和RISC"><a href="#CISC和RISC" class="headerlink" title="CISC和RISC"></a>CISC和RISC</h3><blockquote><p>复杂指令集计算机<strong>CISC</strong>（Complex Instruction Set Computer）增加指令的复杂度，一条指令在多个时钟周期内完成。</p><p>精简指令集计算机<strong>RISC</strong>（Reduced Instruction Set Computer）的思想起源于1980年斯坦福大学的一项处理器研究项目。RISC的指令是在单个时钟周期内完成的。</p></blockquote><h4 id="体系结构发展历程"><a href="#体系结构发展历程" class="headerlink" title="体系结构发展历程"></a>体系结构发展历程</h4><p>计算机自40年代中叶问世以来，其体系结构的发展经历了：</p><p>简单–&gt;复杂–&gt;极其复杂–&gt;简单–&gt;复杂–&gt;极其复杂</p><p>大规模集成电路VLSI技术的发展促进了处理器体系结构的发展。</p><h4 id="CISC"><a href="#CISC" class="headerlink" title="CISC"></a><strong>CISC</strong></h4><p>CISC的<strong>特点</strong>： （VAX机）</p><ul><li>指令格式不固定，指令可长可短，操作数可多可少；</li><li>寻址方式复杂多样，操作数可来自寄存器，也可来自存储器；</li><li>采用微程序控制，执行每条指令均需完成一个微指令序列；</li><li>CPI &gt; ５，指令越复杂，CPI越大。</li></ul><p>CISC的<strong>缺点</strong>：</p><ul><li>指令集虽大，但指令使用频度不均衡；**20%&#x2F;80%**<strong>定律</strong>：20%的指令的使用时间占80%的运行时间；常用指令数仅占指令集总数的10-20%。</li><li>微程序控制器制约了速度提高，因为存放微码的存储器速度比CPU慢5-10倍；CPI很大；</li><li>CISC不利于先进指令级并行（ILP）技术的采用；</li><li>编译器代码优化困难。</li></ul><h4 id="RISC"><a href="#RISC" class="headerlink" title="RISC"></a>RISC</h4><blockquote><h5 id="RISC的提出与发展："><a href="#RISC的提出与发展：" class="headerlink" title="RISC的提出与发展："></a>RISC的提出与发展：</h5><ul><li>Load&#x2F;Store结构提出： CDC6600(1963)–CRAY1(1976)</li><li>RISC思想最早在IBM公司提出，但不叫RISC，IBM801处理器是公认体现RISC思想的机器。</li><li>D. Patterson提出RISC名词，并研制了RISC-I,P实验样机。</li><li>J. Hennessy研制MIPS芯片（1982）。</li><li>85年后推出商品化RISC:  MIPS1(1986)和SPARC V1(1987)</li></ul></blockquote><p><strong>RISC的贡献</strong></p><ul><li>RISC统一了计算机的体系结构，在此前的计算机体系结构是五花八门的（累加器结构，栈结构，寄存器-内存结构等）</li><li>提高了性能，在80年代中期，CPU的MIPS数由80年代初的2-3MIPS提高到200-300MIPS.</li><li>Architecture与Compiler紧密相关（如静、动态调度，ILP)</li><li>流水线技术的应用</li></ul><h5 id="RISC的体系结构"><a href="#RISC的体系结构" class="headerlink" title="RISC的体系结构"></a>RISC的体系结构</h5><p>RISC处理器的思想、特点</p><ul><li>80%&#x2F;20%定律</li><li>精简指令集（reduced instruction set）</li></ul><p>典型的RISC处理器的结构：MIPS，ARM</p><p>流水线技术</p><h5 id="RISC基本设计思想："><a href="#RISC基本设计思想：" class="headerlink" title="RISC基本设计思想："></a>RISC基本设计思想：</h5><ul><li><p>减小CPI:</p><p> CPUtime&#x3D;Instr_Count * CPI * Clock_cycle</p></li><li><p>精简指令集:保留最基本的，去掉复杂的，使用频度不高的指令</p></li><li><p>采用Load&#x2F;Store结构，有助于大大减少指令格式，统一了存储器访问方式</p></li><li><p>采用硬接线控制代替微程序控制</p></li></ul><h5 id="RISC结构的特点："><a href="#RISC结构的特点：" class="headerlink" title="RISC结构的特点："></a>RISC结构的特点：</h5><ul><li>寻址方式少，指令格式少且规整，指令长度统一(32bit)，便于提高流水线效率。(见MIPS指令格式)</li><li>Load&#x2F;store指令结构</li><li>大寄存器文件（32个32位寄存器）</li><li>CPI接近于1，大多数指令单周期完成</li><li>硬接线控制器</li><li>有助于编译优化代码</li></ul><blockquote><h4 id="CISC-vs-RISC"><a href="#CISC-vs-RISC" class="headerlink" title="CISC vs. RISC"></a><strong>CISC vs. RISC</strong></h4><p>🔷CISC 复杂指令集计算机</p><ul><li>指令多，功能复杂，线路复杂</li><li>指令长度不一，编程简单，控制复杂；</li><li>寻址方式多，复杂；</li><li>每条指令的执行周期数CPI在1～20；</li></ul><p>🔷RISC 精简指令集计算机</p><ul><li>定长指令，条数少，多级流水线；</li><li>指令简化令机器结构简单，译码简单统一、优化；</li><li>寻址方式少，简单；</li><li>特定指令访问内存，如：Load,Store；</li><li>每条指令的执行周期数CPI在1～2；</li></ul></blockquote><h4 id="MIPS指令格式"><a href="#MIPS指令格式" class="headerlink" title="MIPS指令格式"></a>MIPS指令格式</h4><p><img src="/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC0%E7%AB%A0-RISC%E5%A4%84%E7%90%86%E5%99%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0/image-20230306085847294.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="三类汇编"></p><blockquote><p><strong>高性能典型RISC处理器</strong></p><ul><li>SUN公司的SPARC</li><li>MIPS公司的SGI：MIPS</li><li>HP公司的PA-RISC</li><li>IBM, Motorola公司的PowerPC</li><li>DEC、Compac公司的Alpha</li></ul></blockquote><p><img src="/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC0%E7%AB%A0-RISC%E5%A4%84%E7%90%86%E5%99%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0/image-20230306090003659.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="典型的RISC处理器：MIPS-五级流水"></p><blockquote><p><strong>什么是流水线（pipeline)</strong></p><p><strong>流水线</strong>是实现多条指令<strong>重叠执行</strong>的技术，是加快CPU执行速度的关键技术。</p><p>术语：</p><ul><li><p>流水级（pipe stage):流水线由多个流水级组成，通常一条指令由n级流水级完成。每个流水级完成指令的部分任务。</p></li><li><p>吞吐量（throughput):单位时间内流出流水线的指令数</p></li><li><p><strong>机器周期</strong>（machine cycle):不同流水线完成指令功能不等，所需时间有长有短，因此设计流水线的关键是合理划分指令功能，使每一流水级完成指令功能的时间大致相等。机器周期由最长流水级的时间决定，通常等于时钟周期。</p></li><li><p>理想流水线的加速因子（Speedup)</p><p>&#x3D;非流水线机器指令的平均执行时间&#x2F;</p><p>   流水线机器指令的平均执行时间</p><p> &#x3D;非流水线机器指令的平均执行时间&#x2F;</p><p>非流水线机器指令的平均执行时间&#x2F;流水级数</p><p>  &#x3D; 流水级数</p></li></ul></blockquote><p>以典型RISC体系结构计算机为例，RISC指令的流水线实现分五步（即5个时钟周期）完成：</p><h5 id="1、取指令周期（IF）"><a href="#1、取指令周期（IF）" class="headerlink" title="1、取指令周期（IF）"></a>1、取指令周期（IF）</h5><p>​       IR ¬ Mem[PC]</p><p>​       NPC ¬ PC + 4</p><h5 id="2-、译码-x2F-读寄存器周期（ID）"><a href="#2-、译码-x2F-读寄存器周期（ID）" class="headerlink" title="2 、译码&#x2F;读寄存器周期（ID）"></a>2 、译码&#x2F;读寄存器周期（ID）</h5><p>​       A ¬ Reg[IR 6..10]</p><p>​       B ¬ Reg[IR11..15]</p><p>​       Imm ¬ ( (IR16)16## IR16..31)</p><h5 id="3、执行-x2F-有效地址计算（EX）"><a href="#3、执行-x2F-有效地址计算（EX）" class="headerlink" title="3、执行&#x2F;有效地址计算（EX）"></a>3、执行&#x2F;有效地址计算（EX）</h5><ul><li>Load&#x2F;Store</li></ul><p>  ​      ALUoutput ¬A+Imm</p><ul><li>R-R ALU</li></ul><p>  ​     ALUoutput ¬A func B</p><ul><li><p>R-I ALU</p><p>​     ALUoutput ¬A op Imm</p></li><li><p>Branch</p></li></ul><p>  ​      ALUoutput ¬NPC + Imm;</p><p>  ​         Cond ¬A op 0</p><h5 id="4、存储器访问-x2F-转移完成（MEM）"><a href="#4、存储器访问-x2F-转移完成（MEM）" class="headerlink" title="4、存储器访问&#x2F;转移完成（MEM）"></a>4、存储器访问&#x2F;转移完成（MEM）</h5><ul><li><p>Load&#x2F;Store： </p><p>​    LMD ¬ Mem[ALUoutput]</p><p>​     Mem[ALUoutput] ¬ B</p></li><li><p>Branch</p></li></ul><p>  ​    if (Cond) then PC¬ALUoutput</p><p>  ​               else  PC ¬ NPC</p><h5 id="5、写回周期（WB）"><a href="#5、写回周期（WB）" class="headerlink" title="5、写回周期（WB）"></a>5、写回周期（WB）</h5><ul><li>R-R ALU</li></ul><p>  ​        Regs[IR16..20] ¬ ALUoutput</p><ul><li><p>R-I ALU</p><p>​       Regs[IR11..15] ¬ ALUoutput</p></li><li><p>Load</p></li></ul><p>  ​       Regs[IR11..15] ¬ LMD</p><p><img src="/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC0%E7%AB%A0-RISC%E5%A4%84%E7%90%86%E5%99%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0/image-20230306090417277.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="RISC五级流水线实现示意图"></p><p>🔷在两个相邻节拍间增加一暂存器（锁存器）用来保留指令的状态(及数据),共有IF&#x2F;ID,ID&#x2F;EX, EX&#x2F;MEM, MEM&#x2F;WB四个.</p><p><img src="/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC0%E7%AB%A0-RISC%E5%A4%84%E7%90%86%E5%99%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0/image-20230306090600659.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="五流水线中数据通路图"></p><h4 id="RISC与DSP处理器的比较"><a href="#RISC与DSP处理器的比较" class="headerlink" title="RISC与DSP处理器的比较"></a>RISC与DSP处理器的比较</h4><table><thead><tr><th>RISC处理器</th><th>DSP处理器</th></tr></thead><tbody><tr><td>简单指令集</td><td>复杂指令集</td></tr><tr><td>Load&#x2F;store体系结构</td><td>内存寻址方式</td></tr><tr><td>大的通用寄存器文件</td><td>特殊用途寄存器</td></tr><tr><td>高级语言支持</td><td>汇编语言支持</td></tr><tr><td>通用用途</td><td>信号处理</td></tr><tr><td>缓存（cache）机制</td><td>片上RAM</td></tr><tr><td>单数据通道</td><td>多数据通道</td></tr><tr><td>利用编译器产生汇编代码，目前有较好的编译器</td><td>目前没有较好的编译器，为了提高程序执行效率，代码关键部分采用手工书写</td></tr></tbody></table><blockquote><p>在DSP处理器中，除了Load&#x2F;store之外的其它指令也可以访问存储单元。这样，地址计算和算术运算共用一个执行单元便不再能满足指令的需要。面向存储器的指令类型需要由专门的地址计算单元负责计算访问存储单元的数据地址，然后利用从存储单元中得到的数据进行算术运算。所以，DSP处理器往往将地址计算级安排在存储单元访问级之前进行，而指令执行级则安排在存储单元访问级之后进行。</p><p>实例：MD32媒体处理器使用6级流水, 这六级流水的名称和功能分别是：</p><ul><li>IF级：取指令和计算新PC值。</li><li>ID级：指令译码。</li><li>DA级：计算源操作数的地址。</li><li>DM级：存储访问读写数据。</li><li>EX级：ALU操作和MAC操作。</li><li>WB级：将ALU和load指令的输出结果写入寄存器文件。</li><li><img src="/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC0%E7%AB%A0-RISC%E5%A4%84%E7%90%86%E5%99%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0/image-20230306090810855.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="实例：MD32媒体处理器的六级流水结构 "></li></ul></blockquote><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><ul><li>ISA处理器是如何实现中断机制的？</li><li>与X86处理器相比，RISC有哪些特点？ </li><li>指令和数据是怎么存放的？处理器如何获得指令和数据的？</li></ul><p><strong>复习：</strong></p><ul><li>二进制、八进制、十六进制数的表示及相互转换</li><li>原码、补码和反码的表示形式</li></ul><p><strong>练习</strong></p><ul><li>与X86处理器相比，RISC有哪些特点？</li><li>描述典型RISC 5级流水的基本功能。</li></ul>]]></content>
    
    
    <categories>
      
      <category>学习资料</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ARM体系结构与编程</tag>
      
      <tag>课件笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>嵌入式程序设计ch1-嵌入式系统概论</title>
    <link href="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1ch1-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/"/>
    <url>/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1ch1-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="嵌入式系统设计"><a href="#嵌入式系统设计" class="headerlink" title="嵌入式系统设计"></a>嵌入式系统设计</h1><blockquote><p>这个系列整理郭建老师的课件</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h3 id="教材："><a href="#教材：" class="headerlink" title="教材："></a>教材：</h3><p>• 嵌入式系统设计基础及应用——基于ARM Cortex-M4微处理器，北京：清华大学出版社，2022</p><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1ch1-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/image-20230305125828535.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="感觉就是老师卖书"></p><p>•嵌入式系统设计实验教程，北京：清华大学出版社, 2022</p><p>参考教材：</p><p>•Marilyn Wolf . 嵌入式计算系统设计原理.第四版. 北京: 机械工业出版社, 2018</p><h3 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a>主要内容</h3><p>•嵌入式系统的基础知识</p><p>•硬件部分</p><p>​–微处理器体系结构及指令系统</p><p>​–总线技术 </p><p>​–存储器系统</p><p>​–I&#x2F;O 接口</p><p>​–32位RISC微处理器ARM cortex M4 </p><p>​–ARM cortex M4的输入输出设备接口</p><p>•软件部分</p><p>​–程序设计与分析</p><p>​–嵌入式实时操作系统</p><p>​–嵌入式系统调试、测试与验证方法</p><p>​–……</p><p>•多核嵌入式微处理器</p><h3 id="嵌入式系统概念"><a href="#嵌入式系统概念" class="headerlink" title="嵌入式系统概念"></a>嵌入式系统概念</h3><p>•IEEE：</p><p>​–Devices used to control, monitor, or assist the operation of equipment, machinery or plants.</p><p>•Wolf:</p><p>​–any device that includes a programmable computer but is not itself a general-purpose computer.</p><p>•Microsoft </p><p>​–An embedded system is any computer system or computing device that performs a dedicated function or is designed for use with a specific embedded software application</p><h3 id="民用嵌入式设备或产品"><a href="#民用嵌入式设备或产品" class="headerlink" title="民用嵌入式设备或产品"></a>民用嵌入式设备或产品</h3><p>无人机，智能家居，机顶盒，数字示波器，智能机，可视电话，单反相机</p><h3 id="嵌入式系统高端应用的产品"><a href="#嵌入式系统高端应用的产品" class="headerlink" title="嵌入式系统高端应用的产品"></a>嵌入式系统高端应用的产品</h3><p>战斗机，无人驾驶，机器人，巡航导弹，坦克，玉兔月球车</p><h3 id="学习方法"><a href="#学习方法" class="headerlink" title="学习方法"></a>学习方法</h3><p>•嵌入式的特点学习。</p><p>​–动手，做一个简单的设备，如：电子时钟。</p><p>​–具有自学能力。</p><p>​•会看硬件的说明书</p><p>​•C++或C编写过应用程序</p><p>​•编写基于某种CPU（如ARM）的程序：代码裸奔</p><hr><p>我们把类似51单片机或者DSP上面跑的没有操作系统的程序叫做“代码裸奔”。因为有的时候，比如我们编写一个简单的程序，就只需要点几个LED检测几个按钮的状态，那么“代码裸奔”弄一个while(1)的死循环就足够了，杀鸡何必用牛刀。 编写这种裸奔的代码，也是学习嵌入式的必由之路，因为，你将会用C语言去对寄存器写控制字，这就是以后写驱动程序的基础呀。 另外需要说明的是，从概念上说，“代码裸奔”也已经属于嵌入式开发的范畴。</p><hr><p>​•到了最后一个阶段，开始找一个方向（mcos、Linux、VxWorks、WindowsCE、Palm等等），学习基于操作系统的嵌入式开发了。</p></blockquote><h2 id="第一章-嵌入式系统概论"><a href="#第一章-嵌入式系统概论" class="headerlink" title="第一章 嵌入式系统概论"></a>第一章 嵌入式系统概论</h2><h3 id="一-嵌入式系统概念"><a href="#一-嵌入式系统概念" class="headerlink" title="一. 嵌入式系统概念"></a>一. 嵌入式系统概念</h3><p>嵌入式实例：</p><h5 id="手机："><a href="#手机：" class="headerlink" title="手机："></a>手机：</h5><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1ch1-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/image-20230305131329474.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="示意图"></p><h5 id="汽车电子："><a href="#汽车电子：" class="headerlink" title="汽车电子："></a>汽车电子：</h5><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1ch1-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/image-20230305132019299.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="汽车电子是汽车行业最活跃的热点，§OSEK/VDX, AUTOSAR, ISO 26262"></p><p>高端的汽车中包含100 多个微处理器, 低端的汽车也至少用20多个微处理器</p><p>​4-bit 微处理器用于检查安全带是否系上</p><p>​微控制器控制面板系统,</p><p>​16&#x2F;32-bit 微处理器控制引擎</p><p><strong>防抱死制动系统(ABS)</strong>: 反复制动减少打滑</p><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1ch1-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/image-20230305132701358.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="允许ABS系统来调整刹车，以防止车轮被锁死"></p><p><strong>自动稳定控制系统(ASC+T)</strong>: 控制引擎以改善其稳定性</p><h5 id="航天航空"><a href="#航天航空" class="headerlink" title="航天航空:"></a>航天航空:</h5><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1ch1-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/image-20230305132750854.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="“玉兔号”月球车"></p><h4 id="上述示例特点："><a href="#上述示例特点：" class="headerlink" title="上述示例特点："></a>上述示例特点：</h4><p>   🔷专用目的</p><p>​🔷软硬件为特定应用而设计</p><p>​🔷实时</p><h4 id="嵌入式系统定义"><a href="#嵌入式系统定义" class="headerlink" title="嵌入式系统定义"></a>嵌入式系统定义</h4><p>​ IEEE：用于控制、监视或者辅助操作机器或设备的装置</p><p>​ 通用的定义：在产品内部，具有<strong>特定功能</strong>的计算机系统。</p><p>​ 通用计算机不是嵌入式设备，但可用于嵌入式设备的开发</p><h4 id="嵌入式系统分类"><a href="#嵌入式系统分类" class="headerlink" title="嵌入式系统分类"></a>嵌入式系统分类</h4><p>​实时（硬实时）：超过时限将产生不可接收的结果，如机毁人亡、系统崩溃</p><p>​非实时（软实时）：超过时限，可能会影响性能，但不会带来灾难性后果</p><h4 id="嵌入式系统特点"><a href="#嵌入式系统特点" class="headerlink" title="嵌入式系统特点"></a>嵌入式系统特点</h4><p>​🔷专用性强</p><p>​🔷资源受限</p><p>许多嵌入式系统受市场约束需要低的制造成本.</p><p>低内存, 低端处理器等.</p><p>​🔷知识集成度高</p><p>运行复杂的算法和多个算法.</p><p>​移动设备, 激光打印机.</p><p>​提供复杂的用户界面.</p><p>​🔷高实时性</p><p>在规定的时限内数据没有准备好，将中断</p><p>在规定的时限内没有获得数据，将会不安全</p><p>多速率操作.（例如多媒体数据流包括视频和音频）</p><p>​运行多个实时动作</p><p>​以不同的速率执行</p><p>​🔷高可靠性</p><p>许多嵌入式系统工作在遥远、无人值守及恶劣环境</p><h3 id="二-嵌入式系统组成"><a href="#二-嵌入式系统组成" class="headerlink" title="二.嵌入式系统组成"></a>二.嵌入式系统组成</h3><h4 id="嵌入式系统："><a href="#嵌入式系统：" class="headerlink" title="嵌入式系统："></a><strong>嵌入式系统：</strong></h4><p><strong>硬件–包括核心处理器以及外围器件组成</strong></p><p><strong>软件–包括固件、操作系统、中间件和应用程序</strong></p><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1ch1-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/image-20230305184432925.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="cpu，存储器，io"></p><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1ch1-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/image-20230305184453249.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="层次"></p><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1ch1-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/image-20230305184639569.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="§片上系统（SOC）：集成RAM、ROM、通信、I/O 等外设，从而简化了系统设计，提高了产品的可靠性"></p><h4 id="嵌入式微处理器"><a href="#嵌入式微处理器" class="headerlink" title="嵌入式微处理器"></a>嵌入式微处理器</h4><p><strong>特点</strong></p><p>🔷处理速度快</p><p>🔷功耗低</p><p>​不仅要求低功耗，还需具有管理外设功耗的能力</p><p>🔷接口丰富，I&#x2F;O能力强</p><p>🔷可靠性高，经常工作在无人值守的环境</p><p>🔷生命周期长</p><p>​应用需求比较稳定，长时间内不发生变化</p><p>🔷产品系列化</p><p>​呈现出系列化、家族化的特征</p><p><strong>分类</strong></p><p>🔷<strong>指令集特点：</strong></p><p>​复杂指令集处理器（CISC）和精简指令集处理器（RISC）</p><p>🔷<strong>处理器字长：</strong></p><p>​4位、8位、16位、32位和64位处理器</p><p>🔷<strong>内部总线结构和功能特点：</strong></p><p>​冯.劳伊曼结构（Von Neumann ）</p><p>​哈佛结构（Harvard）</p><p><strong>组成</strong></p><p>🔷内核：运算和控制单元、总线、存储管理单元及异常管理单元</p><p>🔷片内存储资源，集成高速RAM，有些MCU 和 SOC 内置 ROM 或 Flash ROM</p><p>🔷外设：外设控制器、通信、人机交互、信号I&#x2F;O</p><p>🔷电源：正常电压、耐受电压范围、最大电流</p><p>🔷封装形式：尺寸、外形、引脚方式</p><h3 id="三-嵌入式系统设计"><a href="#三-嵌入式系统设计" class="headerlink" title="三.嵌入式系统设计"></a>三.嵌入式系统设计</h3><h4 id="嵌入式操作系统分类"><a href="#嵌入式操作系统分类" class="headerlink" title="嵌入式操作系统分类"></a>嵌入式操作系统分类</h4><p>由<strong>应用对系统响应时限的要求</strong>划分</p><p>🔷<strong>实时操作系统（RTOS</strong>）</p><p>​必须在限定的时间内完成任务调度和任务执行</p><p>​    任务调度时间和稳定性有非常严格的要求</p><p>​分类</p><p>​硬实时（Hard real time）: 错过deadline会造成失败，或造成重大损失俄 eg：汽车刹车控制</p><p>​软实时（Soft real time）: 错过deadline会导致性能的降低.   eg：DVD播放画面延迟</p><p>示例：FreeRTOS，UCOS，RTX，RT-Thread，DJYOS等</p><p>🔷<strong>非实时操作系统</strong></p><p>示例：Linux、Android、iOS、VxWorks、Free RTOS、LiteOS、uC&#x2F;OS等。</p><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><p>🔷<strong>内核小</strong></p><p>​系统资源相对有限，内核通常小于传统操作系统的内核</p><p>🔷<strong>可裁剪性</strong></p><p>​有很强的个性化特征</p><p>🔷<strong>操作系统与系统硬件结合非常紧密</strong></p><p>​需要做有针对性的裁剪</p><p>🔷<strong>实时多任务调度，多速率操作</strong></p><p>​运行多个实时动作</p><p>​以不同的速率执行</p><h4 id="嵌入式系统设计方法"><a href="#嵌入式系统设计方法" class="headerlink" title="嵌入式系统设计方法"></a>嵌入式系统设计方法</h4><p><strong>Top-down 设计</strong></p><p>开始于最抽象的描述，直到最细节</p><p><strong>Bottom-up 设计</strong></p><p>开始于小的组件，到大系统</p><p><strong>需求分析</strong></p><p>功能性需求：系统的基本功能</p><p>非功能性需求：性能：速度、计算时间，成本，物理尺寸、重量，功耗，可靠性</p><h4 id="传统开发过程"><a href="#传统开发过程" class="headerlink" title="传统开发过程"></a>传统开发过程</h4><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1ch1-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/image-20230305185743948.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="传统流程"></p><p><strong>评价</strong>：直接简单，有缺陷，依赖于开发者的经验，硬软件设计过程独立，彼此缺少交互，性能对软硬件分别优化，难以整体提高系统性能</p><h4 id="软硬件协同设计"><a href="#软硬件协同设计" class="headerlink" title="软硬件协同设计"></a>软硬件协同设计</h4><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1ch1-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/image-20230305190013766.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="流程"></p><p><strong>评价</strong>：软硬件设计作为一个整体考虑，从系统需求出发，综合分析系统软硬件功能及现有资源，软硬件功能划分，确定系统架构，实现软硬件协同验证，使得系统运行在最优工作状态。</p><p><strong>分析</strong>：系统描述是设计者借助 EDA工具及一种或多种语言（systemVerilog），系统设计分为软硬件功能划分和系统映射两个阶段，综合实现是软件、硬件系统的具体实现过程，经过仿真验证后，按照系统设计的要求开发</p><h4 id="嵌入式系统软件调试环境"><a href="#嵌入式系统软件调试环境" class="headerlink" title="嵌入式系统软件调试环境"></a>嵌入式系统软件调试环境</h4><p>采用“宿主机&#x2F;目标板”模式：</p><p>–宿主机（ PC）上良好的开发和调试程序</p><p>–交叉编译环境生成目标代码和执行文件</p><p>–程序下载固化到目标机上</p><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1ch1-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/image-20230305190221007.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="使用计算机和开发板"></p><h4 id="开发实例分析（GPS-移动地图的设计）："><a href="#开发实例分析（GPS-移动地图的设计）：" class="headerlink" title="开发实例分析（GPS 移动地图的设计）："></a>开发实例分析（GPS 移动地图的设计）：</h4><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1ch1-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/image-20230305190558834.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="移动地图从GPS获得当前的位置，绘制地图."></p><p><strong>需求</strong>：</p><p>功能: 针对高速上的用户，显示道路和其它地标.</p><p>用户界面: 400 x 600 屏幕. 三个控制按钮.</p><p>性能: 地图平滑移动，显示在1秒中出现，核查位置在15秒内出现.</p><p>成本: 400元 零售价.</p><p>物理尺寸&#x2F;重量: 适合手掌.</p><p>功耗: 四节AA电池供电8小时.</p><p><strong>列出需求表</strong></p><table><thead><tr><th></th><th align="left">GPS 移动地图需求表</th></tr></thead><tbody><tr><td>名称</td><td align="left">GPS移动地图</td></tr><tr><td>目标</td><td align="left">驾驶使用的用户级地图</td></tr><tr><td>输入</td><td align="left">一个电源按钮，2个控制按钮</td></tr><tr><td>输出</td><td align="left">背光400*600像素的LCD（液晶）显示屏</td></tr><tr><td>功能</td><td align="left">使用5个接收器的GPS系统；三个用户可选的分辨率；总是显示当前的经纬度</td></tr><tr><td>性能</td><td align="left">在位置变动后的0.25s内更新屏幕</td></tr><tr><td>制造成本</td><td align="left">200元</td></tr><tr><td>功率</td><td align="left">100mW</td></tr><tr><td>物理尺寸和重量</td><td align="left">不超过2英寸´ 6英寸，12盎司（1英寸&#x3D;0.0254米；1盎司&#x3D;28.3495克）</td></tr></tbody></table><blockquote><p><strong>系统描述</strong>：</p><p>🔷对系统更精确的描述</p><p>​-不应隐含具体的功能</p><p>​-为结构设计过程提供输入</p><p>🔷包括功能和非功能元素</p><p>🔷可用执行或数学的形式来描述</p></blockquote><p><strong>GPS 系统描述</strong></p><p>从GPS中接收到的数据; 地图数据; 用户界面; 满足用户需求的必须操作; 保持系统运行所需的后备动作</p><blockquote><p><strong>系统设计</strong>：</p><p>🔷主要的组件满足规格说明</p><p>🔷软硬件划分</p><p>​硬件组件</p><p>​CPUs, 外设等</p><p>🔷软件组件</p><p>​主要的程序和它们的操作</p><p>🔷必须考虑功能和非功能性的需求</p></blockquote><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1ch1-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/image-20230305191027514.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="GPS 移动地图块图"></p><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1ch1-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/image-20230305191041928.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="GPS 移动地图的硬件结构"></p><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1ch1-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/image-20230305191055322.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="GPS 移动地图的软件结构"></p><blockquote><p><strong>软硬件综合实现</strong></p><p>在开始写代码之前要构造系统</p><p>​🔷有些组件是已经构造好的</p><p>​🔷有些可以对已经存在的设计进行修改</p><p>​🔷其它的需要从头设计</p><p><strong>系统仿真验证</strong></p><p>🔷得到可运行的系统</p><p>🔷仿真验证</p><p>​发现bugs——非常困难</p><p>​调试工具少</p><p>​有些不正确的工作很难修复</p></blockquote><h3 id="四-嵌入式系统发展"><a href="#四-嵌入式系统发展" class="headerlink" title="四.嵌入式系统发展"></a>四.嵌入式系统发展</h3><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1ch1-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/image-20230305191253556.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="嵌入式系统的发展伴随着计算机技术的发展"></p><h4 id="早期历史"><a href="#早期历史" class="headerlink" title="早期历史"></a>早期历史</h4><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1ch1-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/image-20230305191400450.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="40年代末: MIT设计的 Whirlwind是第一台支持实时操作的计算机."></p><ul><li>   设想作为一种控制飞机模拟器的装置.</li><li>   体积庞大</li><li>   从构件到系统的完整设计上是适应实时嵌入式计算的需求</li></ul><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1ch1-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/image-20230305191427179.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="第一个微处理器在70年代末的Intel 4004."></p><p>Intel4004 用于计算器中</p><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1ch1-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/image-20230305191450564.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="1972年HP-35 计算器，多块芯片实现CPU"></p><p>汽车基于微处理器的引擎控制系统的设计开始于70年代.</p><ul><li>控制燃料&#x2F;气体混合、活塞花点火时间等.</li><li>多模式操作：叫醒模式、导航模式、爬坡模式等.</li><li>提供低排放、高效燃油.</li></ul><p>现代物联网和人工智能是是嵌入式系统应用的重要领域</p><h4 id="微处理器变化"><a href="#微处理器变化" class="headerlink" title="微处理器变化"></a>微处理器变化</h4><ul><li><strong>微控制器</strong>：包括 I&#x2F;O设备, 板上存储.</li><li><strong>微处理器</strong>：由计算机的CPU发展而来</li><li><strong>数字信号处理(DSP)</strong>: 微处理器在数字信号处理能力上的优化.</li><li><strong>典型的嵌入式字的大小</strong>: 4-bit, 8-bit, 16-bit, 32-bit, 64-bit.</li><li><strong>语言</strong>：汇编语言到C语言等高级语言</li></ul><h3 id="五-小结"><a href="#五-小结" class="headerlink" title="五.小结"></a>五.小结</h3><p>🔷嵌入式系统是具有特定（或专用）功能的计算机系统</p><p>🔷嵌入式系统是由软硬件组成，具有丰富的外设</p><p>🔷嵌入式系统开发采用软硬件协同设计方法</p><p>🔷今年来，嵌入式系统的复杂程度和性能呈爆炸式增长</p>]]></content>
    
    
    <categories>
      
      <category>学习资料</category>
      
    </categories>
    
    
    <tags>
      
      <tag>课件笔记</tag>
      
      <tag>嵌入式程序设计</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机组成原理-L01-intro</title>
    <link href="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L01-intro/"/>
    <url>/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L01-intro/</url>
    
    <content type="html"><![CDATA[<h1 id="计算机组成与实践"><a href="#计算机组成与实践" class="headerlink" title="计算机组成与实践"></a><strong>计算机组成与实践</strong></h1><blockquote><p>这个系列用来整理老师（谷守珍）上课的ppt</p></blockquote><h2 id="一-课程信息"><a href="#一-课程信息" class="headerlink" title="一.课程信息"></a>一.课程信息</h2><h3 id="课程教材"><a href="#课程教材" class="headerlink" title="课程教材"></a>课程教材</h3><p>🔷《Computer Organization and Design, The Hardware&#x2F;Software Interface》(Fifth Edition)，作者：David A. Patterson和John. Hennessy</p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L01-intro/image-20230305105717963.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="image-20230305105717963"><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L01-intro/image-20230305105721293.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="image-20230305105721293"></p><p>🔷电子版，amazon.com</p><p>软件：Logisim</p><h3 id="课程教学内容及目标"><a href="#课程教学内容及目标" class="headerlink" title="课程教学内容及目标"></a><strong>课程教学内容及目标</strong></h3><p>🔷高级语言的程序如何翻译成硬件可执行的语言</p><p>​•硬件如何执行程序</p><p>🔷什么是软硬件之间的接口</p><p>​•软件如何指导硬件完成功能</p><p>🔷哪些因素决定了程序的性能</p><p>​•程序员如何改进程序性能</p><p>🔷哪些技术可以改进计算机性能</p><p>🔷串行处理为什么发展为并行处理</p><h3 id="如何学习这门课"><a href="#如何学习这门课" class="headerlink" title="如何学习这门课"></a><strong>如何学习这门课</strong></h3><p><strong>基础知识</strong></p><p>​♦基础的逻辑设计与电路知识</p><p>​♦FSMs，与或非逻辑</p><p>​♦处理器，存储器，I&#x2F;O基本知识</p><p>​♦编写、编译、运行程序</p><p><strong>推荐学习方式</strong></p><p>​♦关注并学习具体实例的运行</p><p>​♦以例子为基础，学习基本原理</p><h2 id="二-背景"><a href="#二-背景" class="headerlink" title="二.背景"></a>二.背景</h2><h3 id="计算机的发展"><a href="#计算机的发展" class="headerlink" title="计算机的发展"></a>计算机的发展</h3><p><strong>电子计算机时代</strong>（1947贝尔实验室第一个晶体管&#x2F;1951第一台商业计算机UNIVAC-1）–<strong>集成电路计算机时代</strong>(1958德州仪器发明集成电路&#x2F;代表IBM360)–<strong>微处理器（CPU）的诞生</strong>（1971，intel4004）</p><h3 id="电子技术的发展"><a href="#电子技术的发展" class="headerlink" title="电子技术的发展"></a><strong>电子技术的发展</strong></h3><p>🔷容量增大，性能提升</p><p>🔷制造成本降低</p><h3 id="半导体（Semiconductor）技术"><a href="#半导体（Semiconductor）技术" class="headerlink" title="半导体（Semiconductor）技术"></a><strong>半导体（Semiconductor）技术</strong></h3><p>🔷<strong>硅：</strong>导电能力不强，称为半导体</p><p>🔷<strong>加入其他材料，将硅转变成包含三种属性的区域</strong></p><p>•良好的导电体</p><p>•良好的绝缘体</p><p>•可控的导电体或绝缘体</p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L01-intro/image-20230305111401411.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="image-20230305111401411"></p><p>成品率：合格芯片数占总芯片数的百分比（想到显卡cpu都是按最高标准生产晶圆，合格的做成i9-13900，ad102（rtx6000Ada），不合格的就屏蔽部分做出i7-13700，ad102-300-A1（rtx4090）以及之后的各档次）</p><h3 id="集成电路成本"><a href="#集成电路成本" class="headerlink" title="集成电路成本"></a><strong>集成电路成本</strong></h3><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L01-intro/image-20230305112358864.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="image-20230305112358864"></p><p>🔷每个晶圆的价格和面积是固定的</p><p>🔷制造工艺决定瑕疵率</p><p>🔷体系结构和电路设计决定芯片面积</p><p>🔷芯片的成本取决于成品率以及芯片和晶圆的面积</p><h3 id="摩尔定律"><a href="#摩尔定律" class="headerlink" title="摩尔定律"></a>摩尔定律</h3><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L01-intro/image-20230305112446922.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="然而老黄天天说摩尔定律已死，这从他的定价可以看出"></p><h3 id="各厂商制程线路图"><a href="#各厂商制程线路图" class="headerlink" title="各厂商制程线路图"></a><strong>各厂商制程线路图</strong></h3><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L01-intro/image-20230305112527453.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="台积电搬到美国去了"></p><h3 id="芯片制程"><a href="#芯片制程" class="headerlink" title="芯片制程"></a><strong>芯片制程</strong></h3><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L01-intro/image-20230305112618902.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="示意图"></p><table><thead><tr><th><strong>栅极（Gate）</strong></th></tr></thead><tbody><tr><td>电流从源极（Source）流入漏极（Drain），栅极（Gate）相当于闸门，负责控制电流的通和断。</td></tr></tbody></table><table><thead><tr><th><strong>芯片“nm”的制程数值</strong></th></tr></thead><tbody><tr><td>指的是芯片中最小的栅极宽度。而栅极宽度决定了电流通过时的损耗，栅极越窄、功耗越低，性能越高。</td></tr></tbody></table><p>功耗计算：</p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L01-intro/image-20230305112710563.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="CMOS技术"></p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L01-intro/image-20230305112728412.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="公式"></p><p>我现在的r5 5600电压是1.26，主频4.7GHz</p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L01-intro/image-20230305112841824.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="目前我用的cpu"></p><p>🔷例子：设计新处理器</p><p>​•负载电容是旧处理器的85%</p><p>​•电压和开关频率减少15%</p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L01-intro/image-20230305113215908.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="用途"></p><p>🔷功耗墙(TDP,上面那颗就是65w)</p><p>​•不能再减少电压</p><p>​•不能解决散热问题</p><p>🔷怎样提升性能？</p><h3 id="单核处理器转向多核处理器"><a href="#单核处理器转向多核处理器" class="headerlink" title="单核处理器转向多核处理器"></a><strong>单核处理器转向多核处理器</strong></h3><p>原因：功耗, 指令级并行, 存储访问延迟影响</p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L01-intro/image-20230305113234190.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="image-20230305113234190"></p><p>🔷多核微处理器</p><p>​•单芯片集成更多处理器（processor）</p><p>🔷需要显性并行编程</p><p>​•与指令级并行相比</p><p>​•硬件可以同时执行多条指令</p><p>​•程序员不可见硬件并行</p><p>•难点</p><p>​•如何提升性能</p><p>​•负载均衡问题</p><p>​•通信与同步技术</p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L01-intro/image-20230305113513317.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="6C12T,六核十二线程"></p><h3 id="个人计算机（Personal-Computers）"><a href="#个人计算机（Personal-Computers）" class="headerlink" title="个人计算机（Personal Computers）"></a><strong>个人计算机（Personal Computers）</strong></h3><table><thead><tr><th><strong>个人计算机</strong></th></tr></thead><tbody><tr><td>通用型计算机  运行第三方软件  性价比高  (DIY)</td></tr></tbody></table><h3 id="服务器（-Server-Computers）"><a href="#服务器（-Server-Computers）" class="headerlink" title="服务器（ Server Computers）"></a><strong>服务器（ Server Computers）</strong></h3><table><thead><tr><th><strong>服务器</strong></th></tr></thead><tbody><tr><td>通过网络访问  执行大负载任务、高性能、高可靠性  高能耗、高成本  分为通用服务器和专用服务器，例如超级计算机（Supercomputers）是用于计算的专用服务器</td></tr></tbody></table><h3 id="嵌入式计算机（Embedded-Computers）"><a href="#嵌入式计算机（Embedded-Computers）" class="headerlink" title="嵌入式计算机（Embedded Computers）"></a><strong>嵌入式计算机（Embedded Computers）</strong></h3><table><thead><tr><th><strong>嵌入式计算机</strong></th></tr></thead><tbody><tr><td>面向单一任务  严格限制成本、性能、能耗</td></tr></tbody></table><h3 id="仓储规模计算机（WSC）"><a href="#仓储规模计算机（WSC）" class="headerlink" title="仓储规模计算机（WSC）"></a><strong>仓储规模计算机（WSC）</strong></h3><table><thead><tr><th><strong>仓储规模计算机（WSC）</strong></th></tr></thead><tbody><tr><td>WSC是云计算的核心  软件即服务（  Software as a Service ）  部分软件运行在移动端设备，部分软件运行在云端  重视互动应用程序、大规模存储、可靠性和很高的因特网带宽</td></tr></tbody></table><h3 id="个人移动终端（Personal-Mobile-Device，PMD）"><a href="#个人移动终端（Personal-Mobile-Device，PMD）" class="headerlink" title="个人移动终端（Personal Mobile Device，PMD）"></a><strong>个人移动终端（Personal Mobile Device，PMD）</strong></h3><table><thead><tr><th>个人移动终端</th></tr></thead><tbody><tr><td>电池供电  无线方式连接网络  个人移动终端销售量远大于桌面终端</td></tr></tbody></table><h2 id="三-课程内容简介"><a href="#三-课程内容简介" class="headerlink" title="三.课程内容简介"></a>三.课程内容简介</h2><h3 id="计算机构成"><a href="#计算机构成" class="headerlink" title="计算机构成"></a>计算机构成</h3><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L01-intro/image-20230305114047757.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="冯诺依曼"></p><table><thead><tr><th><strong>主要组成部件</strong></th></tr></thead><tbody><tr><td>数据通路（运算）单元  控制单元  存储器（缓存、内存和硬盘等）  输入设备（鼠标、键盘等）  输出设备（显示器和打印机等）</td></tr></tbody></table><p><strong>学习处理器（数据通路和控制单元）与存储器的基本设计方法、相互间的协调合作</strong></p><p>​🔷处理器与存储器由几百至几千万晶体管实现</p><p>​🔷深入到学习每个晶体管的功能不现实</p><p>​🔷需要采用抽象的方式来学习</p><h3 id="程序概念入门"><a href="#程序概念入门" class="headerlink" title="程序概念入门"></a><strong>程序概念入门</strong></h3><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L01-intro/image-20230305114238999.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="示意图"></p><p>🔷<strong>应用软件</strong></p><p>​🔷高级编程语言，例如C、Java、Python等</p><p>🔷<strong>系统软件</strong></p><p>​🔷编译程序：将高级语言程序翻译成</p><pre><code class="hljs">  硬件可执行的指令</code></pre><p>​🔷操作系统：为应用软件与硬件交互</p><p>​  提供服务的软件</p><p>​🔷处理基本输入输出</p><p>​🔷分配内外存</p><p>​🔷对任务进行调度，提供共享计算机资源的服务</p><p>🔷<strong>硬件</strong></p><p>🔷处理器，存储设备，I&#x2F;O控制器等</p><h3 id="高级程序语言"><a href="#高级程序语言" class="headerlink" title="高级程序语言"></a><strong>高级程序语言</strong></h3><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L01-intro/image-20230305114300928.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="各种语言"></p><p>​🔷程序员可以根据需要选择高级编程语言，以类似自然语言的方式编写程序代码</p><p>​🔷可读性高，容易纠错，提升了程序员的代码生产力</p><p>​🔷程序维护性高</p><p>​🔷不依赖于硬件平台，可移植性好</p><p>​🔷优化编译器可以基于机器平台进行高效的汇编代码优化</p><h3 id="高级程序语言的运行"><a href="#高级程序语言的运行" class="headerlink" title="高级程序语言的运行"></a><strong>高级程序语言的运行</strong></h3><p>高级程序语言程序（C语言）–编译–汇编语言程序（MIPS）–汇编– 机器代码（MIPS）</p><p>运行流程：</p><p>​①代码通过输入设备加载到计算机</p><p>​②代码输入到计算机后，保存在存储器中</p><p>​③处理器从存储器提取指令</p><p>​④控制器对指令进行译码，获得指令的执行信息</p><p>​⑤数据通路根据控制信号执行指令</p><p>​<img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L01-intro/image-20230305122944259.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="参考"></p><h3 id="指令集体系结构（ISA）"><a href="#指令集体系结构（ISA）" class="headerlink" title="指令集体系结构（ISA）"></a><strong>指令集体系结构（ISA）</strong></h3><p>硬件和底层软件之间的接口，被命名为计算机的<strong>指令集体系结构（instruction set architecture，ISA）或简称体系结构（architecture）</strong></p><p>​🔷<strong>体系结构</strong>有指令、寄存器、存储器访问、I&#x2F;O等编写机器语言程序所需的所有信息。</p><p>​🔷隐藏底层细节，使程序员只需要考虑功能</p><p>​🔷基本指令集和操作系统接口被称为<strong>应用二进制接口（Application binary interface，ABI）</strong></p><p>​🔷体系结构的实现：遵循体系结构抽象的硬件</p><h2 id="四-小结"><a href="#四-小结" class="headerlink" title="四.小结"></a>四.小结</h2><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L01-intro/image-20230305123217592.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="ee"></p><h3 id="软硬件协同工作："><a href="#软硬件协同工作：" class="headerlink" title="软硬件协同工作："></a>软硬件协同工作：</h3><p>​🔷多个层次间通过<strong>抽象</strong>相互合作</p><p>​🔷各项技术都在快速的发展</p><p>​🔷设计、测试与评估方法复杂</p>]]></content>
    
    
    <categories>
      
      <category>学习资料</category>
      
    </categories>
    
    
    <tags>
      
      <tag>课件笔记</tag>
      
      <tag>计算机组成原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>博客成功迁移至宿舍台式机</title>
    <link href="/%E6%96%B0%E5%AD%A6%E6%9C%9F%E4%BA%86%EF%BC%8C%E6%9C%AC%E5%8D%9A%E5%AE%A2%E6%88%90%E5%8A%9F%E8%BF%81%E7%A7%BB%E8%87%B3%E5%AE%BF%E8%88%8D%E5%8F%B0%E5%BC%8F%E6%9C%BA/"/>
    <url>/%E6%96%B0%E5%AD%A6%E6%9C%9F%E4%BA%86%EF%BC%8C%E6%9C%AC%E5%8D%9A%E5%AE%A2%E6%88%90%E5%8A%9F%E8%BF%81%E7%A7%BB%E8%87%B3%E5%AE%BF%E8%88%8D%E5%8F%B0%E5%BC%8F%E6%9C%BA/</url>
    
    <content type="html"><![CDATA[<p>打算这学期利用博客做好笔记。。。</p><p>这学期应该也会经常用到开发板，相关的实验记录也会陆续放出，敬请期待</p>]]></content>
    
    
    <categories>
      
      <category>记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>blog</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于真の仲间与退队流小说的闲聊</title>
    <link href="/%E5%85%B3%E4%BA%8E%E7%9C%9F%E3%81%AE%E4%BB%B2%E9%97%B4%E4%B8%8E%E9%80%80%E9%98%9F%E6%B5%81%E5%B0%8F%E8%AF%B4%E7%9A%84%E9%97%B2%E8%81%8A/"/>
    <url>/%E5%85%B3%E4%BA%8E%E7%9C%9F%E3%81%AE%E4%BB%B2%E9%97%B4%E4%B8%8E%E9%80%80%E9%98%9F%E6%B5%81%E5%B0%8F%E8%AF%B4%E7%9A%84%E9%97%B2%E8%81%8A/</url>
    
    <content type="html"><![CDATA[<h2 id="一-真之仲间事件的科普"><a href="#一-真之仲间事件的科普" class="headerlink" title="一.真之仲间事件的科普"></a>一.真之仲间事件的科普</h2><p>​想必传说系列JRPG的fans肯定比我了解太多😂,但大多数人肯定也是不太清楚这个所谓的”真の仲间”是个什么东西.说来惭愧,我是最近在阅读某小说的时候了解到这个事件的😥,这本小说的作者简单概述成某游戏把原定宣传的女主角作废,并以能力值低下为由踢出队伍,而被玩家大规模炎上的事故.</p><p>​虽然作者说的煞有其事,想来也很奇怪,游戏公司不赚钱的吗😓,这种事怎么可能发生,于是便搜索查找了一番,居然确有此事.这款游戏就是传说系列的第15作—Tales of Zestiria(译名:情热传说),简称TOZ,主题是让热情照耀世界的RPG.</p><blockquote><p><strong>传说系列</strong>（英文：Tales of；日文：テイルズ オブ）是由万代南梦宫控股公司（原南梦宫发行的奇幻日式电子角色扮演游戏系列。游戏在2011年前由南梦宫传说工作室开发，之后由南梦宫万代开发。自超级任天堂平台首作《幻想传说》于1995年发行以来，系列已经有20部正篇游戏和诸多游戏续作，以及漫画、动画和广播剧等跨媒体作品。</p></blockquote><p><img src="/%E5%85%B3%E4%BA%8E%E7%9C%9F%E3%81%AE%E4%BB%B2%E9%97%B4%E4%B8%8E%E9%80%80%E9%98%9F%E6%B5%81%E5%B0%8F%E8%AF%B4%E7%9A%84%E9%97%B2%E8%81%8A/tooz.jpg" srcset="/img/mahmoud-habibi.gif" lazyload alt="TOZ"></p><p>并且这件事甚至还引发了后续一系列”退队流”日轻的出现,可谓是影响深远了…</p><p>事件具体可以看这篇游侠网的<a href="https://www.gamersky.com/zl/201703/881365.shtml">专栏</a>,下面会在正文引用一些专栏内容和一些其他平台的评论来支援介绍…(此段并非我原创)</p><h4 id="临时更替的真之仲间"><a href="#临时更替的真之仲间" class="headerlink" title="临时更替的真之仲间"></a>临时更替的真之仲间</h4><p>2015年1月22日，《情热传说》在PS3平台独占发售。数天后，随着越来越多玩家通关，他们发现原本认为是女主角的“艾莉夏”竟然会在游戏中途永久离队，后期故事基本和她完全没有关系。艾莉夏离队后，队伍女主角由一名叫做“罗洁”的角色代替，并且还可以使用艾莉夏的DLC服装。(为什么突然想到品如的衣服🙃)</p><p>《情热传说》作为传说系列的第十五作以及二十周年纪念作,在发售前自然饱受玩家期待,游戏制作人马场英雄在发布会上诱导宣传艾利夏是女主角（艾莉夏是第一个宣传登场的女性角色，而且站在女主角位，并且光速决定手办化），而真女主角罗洁非常晚才出现在宣传图片里。</p><p><img src="/%E5%85%B3%E4%BA%8E%E7%9C%9F%E3%81%AE%E4%BB%B2%E9%97%B4%E4%B8%8E%E9%80%80%E9%98%9F%E6%B5%81%E5%B0%8F%E8%AF%B4%E7%9A%84%E9%97%B2%E8%81%8A/toz.jpg" srcset="/img/mahmoud-habibi.gif" lazyload alt="发售前的宣传资料里艾丽夏的妥妥的女主位"></p><p>在JRPG中，随着某些剧情发展,游戏中途队员离队也算是比较常见的情况了,在《情热传说》的剧情里，艾莉夏因为自身能力不足拖累主角史雷,无法成为主角的力量,提出离队,但主角的台词强行拔高罗洁,就像是在讽刺艾利夏无能不配当”真正的伙伴，这和20年来传说系列的画风差距太大，导致玩家根本无法接受. 罗洁替换掉艾莉夏的过程中，许多剧情和对白都经不起推敲，甚至有明显的赶工痕迹。罗洁本身的人设并不如艾莉夏抢眼，个人还是觉得公主(艾莉夏)可爱些，下面奉上著名的踩一捧一台词(真之仲间的出处)：</p><blockquote><p>莱拉：“那么要不要让罗洁小姐加入我们的旅途？”</p><p>ライラ「ロゼさんを私たちの旅に诱いませんか？」</p><p>斯雷：“咦，什么？为什么突然提这个？”</p><p>スレイ「え、なに？突然」</p><p>米克里欧：“我也赞同。对斯雷而言应该会是很棒的同伴。”</p><p>ミクリオ「仆も同意だ。スレイにはいい仲间になると思う」</p><p>斯雷：“怎么连米克里欧你也……”</p><p>スレイ「ミクリオまで…」</p><p>米克里欧：“老爷子有说啊，‘能够见闻到同样事物的才是真正的伙伴’。”</p><p>ミクリオ「ジイジが言ってた『同じものを见て、闻くことのできる真の仲间』だよ」</p><p>斯雷：“真正的伙伴吗……”</p><p>スレイ「真の仲间か…」</p><p>艾朵娜：“不是很棒吗？”</p><p>エドナ「良いんじゃない？」</p><p>莱拉：“罗洁小姐的灵应力和斯雷先生是处于伯仲之间的程度”</p><p>ライラ「ロゼさんの霊応力はスレイさんと比肩するほどのものです」</p><p>　　 “应该不会像艾莉夏小姐那时因为担当从士的代价让两人都过的很辛苦吧”</p><p>「アリーシャさんの时のように従士の代偿でお互い苦しむこともないと思いますわ」</p><p>艾朵娜：“大概有点理解如果只有斯雷一个人类的话有时会多麻烦呢”</p><p>エドナ「それに人间がスレイだけだと时々面倒なのもわかったし」</p></blockquote><h4 id="对不起，就算你掏了钱，也不能成为真正的伙伴呢"><a href="#对不起，就算你掏了钱，也不能成为真正的伙伴呢" class="headerlink" title="对不起，就算你掏了钱，也不能成为真正的伙伴呢"></a>对不起，就算你掏了钱，也不能成为真正的伙伴呢</h4><p>前期宣传艾利夏的时候就出了艾利夏的收费服装dlc，但是到最后艾利夏离队，这些艾利夏专用服装却是可以给给罗洁穿的，玩家不由得感觉官方是恶意营销欺骗。<br>愤怒的玩家对官方提出了抗议，然后官方表示有艾利夏的dlc，需要1300日元(含税1404)。</p><p><img src="/%E5%85%B3%E4%BA%8E%E7%9C%9F%E3%81%AE%E4%BB%B2%E9%97%B4%E4%B8%8E%E9%80%80%E9%98%9F%E6%B5%81%E5%B0%8F%E8%AF%B4%E7%9A%84%E9%97%B2%E8%81%8A/1300.jpg" srcset="/img/mahmoud-habibi.gif" lazyload alt="离谱"></p><p>玩家又火了，然后诞生了<code>“原来艾莉夏的剧情被做成DLC了？想要成为真正的伙伴就掏钱吧！官方是这个意思？”</code>的梗。</p><p>游戏分拆主要角色的剧情单卖DLC本就不能让玩家接受. 面对玩家的再次愤怒，官方把原本需要支付1300日元的艾莉夏剧情DLC在一段日期内提供给玩家免费下载。然而这一举动又刺激了玩家，下载了dlc的玩家发现，这个dlc和主线根本没关系,完全是日后谈，艾利夏本身的故事也完全没补完，也改变不了艾莉夏在剧情中尴尬的定位和永久离队的现实,结果梗就变变成了<code>&quot;对不起，就算你掏了钱，也不能成为真正的伙伴呢&quot;.</code></p><p><img src="/%E5%85%B3%E4%BA%8E%E7%9C%9F%E3%81%AE%E4%BB%B2%E9%97%B4%E4%B8%8E%E9%80%80%E9%98%9F%E6%B5%81%E5%B0%8F%E8%AF%B4%E7%9A%84%E9%97%B2%E8%81%8A/dlc.jpg" srcset="/img/mahmoud-habibi.gif" lazyload alt="dlc里的撕逼内容"></p><p>　感觉自己被官方欺骗的众多传说玩家引燃了互联网，甚至连官方与玩家互相交流的社群都被逼屏蔽了“诈骗”关键字。《情热传说》的口碑暴跌，游戏价格一度跌到连盒饭都买不到的水平，二手交易商直接放弃收购这款游戏。游戏发售一个月左右，原本计划在2月20日直播的《情热传说》节目被直接砍掉。在此期间游戏制作马场英雄被玩家多次要求澄清这件事情，而马场从没有正面回应玩家(被国内玩家戏称 “没马”的场英雄).直播的取消更是导致了玩家进一步愤怒。</p><p><img src="/%E5%85%B3%E4%BA%8E%E7%9C%9F%E3%81%AE%E4%BB%B2%E9%97%B4%E4%B8%8E%E9%80%80%E9%98%9F%E6%B5%81%E5%B0%8F%E8%AF%B4%E7%9A%84%E9%97%B2%E8%81%8A/%E6%B2%A1%E9%A9%AC.jpg" srcset="/img/mahmoud-habibi.gif" lazyload alt="马场英雄逃跑中"></p><p>然后，点燃最后一根稻草的是传说的手游。当时传说的手游随着热情传说的发售，更新了热情传说的各位角色。</p><p><img src="/%E5%85%B3%E4%BA%8E%E7%9C%9F%E3%81%AE%E4%BB%B2%E9%97%B4%E4%B8%8E%E9%80%80%E9%98%9F%E6%B5%81%E5%B0%8F%E8%AF%B4%E7%9A%84%E9%97%B2%E8%81%8A/%E6%89%8B%E6%B8%B8.jpg" srcset="/img/mahmoud-habibi.gif" lazyload alt="令人感慨的危机公关"></p><p>角色资料中，艾利夏的介绍里明确标记着“热情传说女主角”的字样。而官方在这件事情爆发后，对于这款手游出了一个更新包，而更新的内容仅仅是把艾利夏是“热情传说的女主角”几个字删掉。<br>这一系列不可意思神奇公关，最后导致这款游戏口碑调到谷底。</p><p>最后总结:</p><blockquote><p>明明有预约特典DLC却会永久离队<br>明明包含在四种预约特典挂饰却会永久离队<br>明明有专用服装DLC却会永久离队<br>明明是第一次广告宣传被介绍的角色却会永久离队<br>明明是第二个被介绍的角色却会永久离队<br>明明在专用杂志上面上封面好几次却会永久离队<br>明明是故事开头引导的角色却会永久离队<br>明明是最快速确定figure化却会永久离队<br>明明在游戏发表会上请声优到场却会永久离队<br>明明主角梦想是异种共存的情况下，身为队伍中唯一的普通人类却会永久离队<br>明明在脱队之后还会贩卖专用装备(枪)却会永久离队<br>明明是前传的女主角却会永久离队</p><p>—取自<a href="https://ngabbs.com/read.php?&tid=26839471&pid=517651178&to=1">nga评论</a></p></blockquote><h2 id="二-退队流轻小说"><a href="#二-退队流轻小说" class="headerlink" title="二.退队流轻小说"></a>二.退队流轻小说</h2><p>不可否认,这一类型的轻小说的兴起与前面所提到的”真正的伙伴”有着紧密关系,由讽刺《情热传说》而引发的退队流轻小说已经有不少动画化了,成为全新的异世界动漫<del>厕纸</del>类型，令人感慨。</p><p>下面举几个栗子，当然国内的网文也肯定有相同类型的作品，这里就懒得找了。</p><p><strong>《因为不是真正的伙伴而被逐出勇者队伍，流落到边境展开慢活人生》（真の仲間じゃないと勇者のパーティーを追い出されたので、辺境でスローライフすることにしました</strong>）</p><p><img src="/%E5%85%B3%E4%BA%8E%E7%9C%9F%E3%81%AE%E4%BB%B2%E9%97%B4%E4%B8%8E%E9%80%80%E9%98%9F%E6%B5%81%E5%B0%8F%E8%AF%B4%E7%9A%84%E9%97%B2%E8%81%8A/image-20230206215453557.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="这部连名字都蹭了真之仲间"></p><p><strong>《被勇者队伍开除的驯兽师，邂逅最强种猫耳少女 （勇者パーティーを追放されたビーストテイマー、最強種の猫耳少女と出会う）》</strong></p><p><img src="/%E5%85%B3%E4%BA%8E%E7%9C%9F%E3%81%AE%E4%BB%B2%E9%97%B4%E4%B8%8E%E9%80%80%E9%98%9F%E6%B5%81%E5%B0%8F%E8%AF%B4%E7%9A%84%E9%97%B2%E8%81%8A/image-20230206215728713.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="感觉像经典倒贴一样"></p><p><strong>《「你这种家伙别想打赢魔王」被踢出了勇者队伍，想在王都过上平静的生活》（「お前ごときが魔王に勝てると思うな」と勇者パーティを追放されたので、王都で気ままに暮らしたい</strong>）</p><p><img src="/%E5%85%B3%E4%BA%8E%E7%9C%9F%E3%81%AE%E4%BB%B2%E9%97%B4%E4%B8%8E%E9%80%80%E9%98%9F%E6%B5%81%E5%B0%8F%E8%AF%B4%E7%9A%84%E9%97%B2%E8%81%8A/image-20230206215608890.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="听说是什么百合克苏鲁文"></p><p><strong>《关于四个持有负面技能的人聚在一起，不知怎的发挥出相乘效果组成了最强队伍这档事》（マイナススキル持ち四人が集まったら、なんかシナジー発揮して最強パーティーができた件）</strong></p><p><img src="/%E5%85%B3%E4%BA%8E%E7%9C%9F%E3%81%AE%E4%BB%B2%E9%97%B4%E4%B8%8E%E9%80%80%E9%98%9F%E6%B5%81%E5%B0%8F%E8%AF%B4%E7%9A%84%E9%97%B2%E8%81%8A/image-20230206220158851.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="什么buff互叠"></p><p>其实也不难发现，退队流轻小说的退队只是开篇第一卷吸引读者的噱头，后面该组队的还是重新组队了，形成小说的真正主角团，随着故事的发展，又会与之前退队的队伍进行对手戏，其中肯定也少不了装逼打脸的戏份，大致阅读体验肯定和“三十年河东，三十年河西”的爽感类似，一般也不会回归旧队伍而是在新团体里发挥主干作用，当然不同作家的安排和剧情构筑肯定也不同，也会注意规避一些压抑主角的毒点。（这里点名批评棍勇🤯，退队重来怎么还是被虐）</p><h2 id="三-西游记-退队流是中华传统文学类型？"><a href="#三-西游记-退队流是中华传统文学类型？" class="headerlink" title="三.西游记-退队流是中华传统文学类型？"></a>三.西游记-退队流是中华传统文学类型？</h2><p>有一种脑干缺失的美，《西游记》也是退队流？</p><p>请看下文<a href="https://new.qq.com/rain/a/20220603A09EXT00">日漫退队流越来越火，《西游记》流传下来的套路，为何经久不息</a></p><p>此文作者提出：</p><blockquote><p>退队流标准的流程就是：队内作用不可或缺的主角，因为队长的误解，以及猪队友的煽风点火被赶出了队伍，队伍缺少他立刻难以为继，而我们的主角找到了一片新天地逍遥自在。</p></blockquote><p>其实当然时代不同，我们谈论到的日本轻小说退队流里的主角也并非完全是队内作用不可或缺的，也有许许多多的主角是原队伍的边缘人，队伍只是束缚了主角的才能，离开后反而得到发展，更类似现代人自负心态中的”今天你对我爱答不理，明天我让你高攀不起“，也又可能变成种田文学猴子经营花果山去了。而西游记里，悟空离队后取经寸步难行，最后又被唐僧请回去回归队伍，其实也是偏向于保守的做法，要换做轻小说来写，除非妖怪达到花果山下猴子才可能出山。</p><h2 id="四-收尾乱弹"><a href="#四-收尾乱弹" class="headerlink" title="四.收尾乱弹"></a>四.收尾乱弹</h2><p>其实我想写这篇缝合文章的时候一开始也是因为TOZ “真正的伙伴”这个案例太过恶劣而引起的，原本就是想写一篇为美少女伸冤的短文，结果网上找找资料，变成这个样子，也算是基本把退队流讲了个大概，虽然最后牵扯到西游记，我也只能觉得是证明了其自古有之而非其是启蒙日本轻小说退队流的主要原型，毕竟对日本作者而言，有年代更近更贴近现实的案例发生。。。</p><p>就以公主的手办结尾吧</p><p>图片出自<a href="https://www.hpoi.net/album/177837">hpoi手办维基</a>,作者<a href="https://www.hpoi.net/user/46162">Lolicon一official</a></p><p><img src="/%E5%85%B3%E4%BA%8E%E7%9C%9F%E3%81%AE%E4%BB%B2%E9%97%B4%E4%B8%8E%E9%80%80%E9%98%9F%E6%B5%81%E5%B0%8F%E8%AF%B4%E7%9A%84%E9%97%B2%E8%81%8A/1.jpg" srcset="/img/mahmoud-habibi.gif" lazyload></p><p><img src="/%E5%85%B3%E4%BA%8E%E7%9C%9F%E3%81%AE%E4%BB%B2%E9%97%B4%E4%B8%8E%E9%80%80%E9%98%9F%E6%B5%81%E5%B0%8F%E8%AF%B4%E7%9A%84%E9%97%B2%E8%81%8A/2.jpg" srcset="/img/mahmoud-habibi.gif" lazyload></p><p><img src="/%E5%85%B3%E4%BA%8E%E7%9C%9F%E3%81%AE%E4%BB%B2%E9%97%B4%E4%B8%8E%E9%80%80%E9%98%9F%E6%B5%81%E5%B0%8F%E8%AF%B4%E7%9A%84%E9%97%B2%E8%81%8A/3.jpg" srcset="/img/mahmoud-habibi.gif" lazyload></p><p><img src="/%E5%85%B3%E4%BA%8E%E7%9C%9F%E3%81%AE%E4%BB%B2%E9%97%B4%E4%B8%8E%E9%80%80%E9%98%9F%E6%B5%81%E5%B0%8F%E8%AF%B4%E7%9A%84%E9%97%B2%E8%81%8A/4.jpg" srcset="/img/mahmoud-habibi.gif" lazyload></p>]]></content>
    
    
    <categories>
      
      <category>杂谈</category>
      
    </categories>
    
    
    <tags>
      
      <tag>游戏</tag>
      
      <tag>轻小说</tag>
      
      <tag>acg</tag>
      
      <tag>退队流</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>春节复习开学考试Mark</title>
    <link href="/%E6%98%A5%E8%8A%82%E5%A4%8D%E4%B9%A0%E5%BC%80%E5%AD%A6%E8%80%83%E8%AF%95Mark/"/>
    <url>/%E6%98%A5%E8%8A%82%E5%A4%8D%E4%B9%A0%E5%BC%80%E5%AD%A6%E8%80%83%E8%AF%95Mark/</url>
    
    <content type="html"><![CDATA[<p>疫情又又又把期末考试推迟了,由于本人上网课不认真,所以要在假期内重新把上学期学的知识重新复习几遍.鉴于本人劣迹斑斑经常摸鱼,故立个帖子防止自己摸鱼浪费大好时光.</p><blockquote><p>个人感觉已考炸，下学期平时要好好学习了，临时抱佛脚无用也😢</p></blockquote><p>绩点3.0以下科目分析：</p><p>操作系统：平时分98，期末56，疫情网课+平时没好好学，期末抱佛脚也没用（理论懂做题不会。。。到大二了还是不适应）</p><p>操作系统实践：学校的煞笔大夏学堂提交不成功，具体情况为交上去了（网站上有），但是没有提交（也许是忘点了“提交”按钮了？），总之我是每次按时交的，结果被系统判为未交，<del>总之我上传博客的时候都还没提醒我</del>，助教也是等到期末最后时期（之前在群里提醒名单里也没有我）才提醒我。反正就是漏交了一次，被打为60分，结果凄凉。。。我自己的锅，下一次我提交作业一定记得验证是否提交成功😓，总评81，绩点1.9（舍友也是81，但绩点2.5。。。）</p><p>城市中国：一门选修课。总评92分，绩点2.9（满绩是4.0），华师大排名制绩点的恶臭</p><p>面向对象程序设计实践（C++):总评90，绩点2.7，华师大排名制绩点的恶臭</p><p>毛概：总评85，绩点2.9，疫情下期末要求写小论文，本人不会写申论的坏处，我自己背锅（然而我一个天天看reddit，辱bao的舍友毛概绩点3.9，令人感慨<del>ta这方面申论本领一直很强</del>）。</p><p>其他的绩点没出，暂且观望，ecnu排名制绩点无法完全和分数挂钩，只取决于排名, 绩点高低不是看自身绝对实力，而是看相对实力，我前三个学期因为网课摸鱼输太多了，明明每次都发誓要改悔，也没救，每学期成绩只徘徊在及格线之上😔，希望分专业方向之后能够进步一些吧，先减掉熬夜的坏习惯，成绩目标争取能达到本方向绩点前10。</p>]]></content>
    
    
    
    <tags>
      
      <tag>复习</tag>
      
      <tag>考试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>b站抽中新玩具-TTC兔轴</title>
    <link href="/b%E7%AB%99%E6%8A%BD%E4%B8%AD%E6%96%B0%E7%8E%A9%E5%85%B7-TTC%E5%85%94%E8%BD%B4/"/>
    <url>/b%E7%AB%99%E6%8A%BD%E4%B8%AD%E6%96%B0%E7%8E%A9%E5%85%B7-TTC%E5%85%94%E8%BD%B4/</url>
    
    <content type="html"><![CDATA[<h2 id="一-起因"><a href="#一-起因" class="headerlink" title="一.起因"></a>一.起因</h2><p>打开b站看看消息突然发现中奖了…虽然不是什么大奖,大概有8颗轴的样子,到手体验一下再写(本文只是个人生活分享,无干货…)</p><p><img src="/b%E7%AB%99%E6%8A%BD%E4%B8%AD%E6%96%B0%E7%8E%A9%E5%85%B7-TTC%E5%85%94%E8%BD%B4/image-20230121223355986.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="第二次b站中奖了,第一次是耕升官号抽中的显卡优惠"></p><h2 id="二-后续"><a href="#二-后续" class="headerlink" title="二.后续"></a>二.后续</h2><p>之前客服就说的30号后安排发货,今天2023&#x2F;2&#x2F;1 就收到了..</p><p><img src="/b%E7%AB%99%E6%8A%BD%E4%B8%AD%E6%96%B0%E7%8E%A9%E5%85%B7-TTC%E5%85%94%E8%BD%B4/image-20230201131328450.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="盒装"></p><p>原来不是8颗😂,左右各两颗兔轴og和兔轴rgb</p><p><img src="/b%E7%AB%99%E6%8A%BD%E4%B8%AD%E6%96%B0%E7%8E%A9%E5%85%B7-TTC%E5%85%94%E8%BD%B4/image-20230201131239684.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="og版编号665946和665947"></p><p>貌似og版还有编号?</p><p><img src="/b%E7%AB%99%E6%8A%BD%E4%B8%AD%E6%96%B0%E7%8E%A9%E5%85%B7-TTC%E5%85%94%E8%BD%B4/image-20230201131746655.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="装备前线发现的"></p><p>拿两颗不同的出来看看,一个是乳壳一个是透壳</p><p><img src="/b%E7%AB%99%E6%8A%BD%E4%B8%AD%E6%96%B0%E7%8E%A9%E5%85%B7-TTC%E5%85%94%E8%BD%B4/image-20230201131218776.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="这样的"></p><p>还送了个兔子键帽</p><p><img src="/b%E7%AB%99%E6%8A%BD%E4%B8%AD%E6%96%B0%E7%8E%A9%E5%85%B7-TTC%E5%85%94%E8%BD%B4/image-20230201131350243.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="正面"></p><p><img src="/b%E7%AB%99%E6%8A%BD%E4%B8%AD%E6%96%B0%E7%8E%A9%E5%85%B7-TTC%E5%85%94%E8%BD%B4/image-20230201131123695.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="背面"></p><p>感觉和我的键盘不是很搭😔,又换回去了</p><p><img src="/b%E7%AB%99%E6%8A%BD%E4%B8%AD%E6%96%B0%E7%8E%A9%E5%85%B7-TTC%E5%85%94%E8%BD%B4/image-20230201131543734.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="键帽高度不同"></p><p>对于轴体评测我也没啥研究,不过这款是静音轴,我还没用过,更没发言权, 看看官方介绍吧</p><p><img src="/b%E7%AB%99%E6%8A%BD%E4%B8%AD%E6%96%B0%E7%8E%A9%E5%85%B7-TTC%E5%85%94%E8%BD%B4/image-20230201131923064.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="装备前线的介绍"></p><p>我个人感受声音确实比较小,手感顺滑度也不错,不过静音轴有一种肉肉的感觉,有点像薄膜😶…</p><p>总之,要我自掏腰包买这款轴体去组装键盘,我是不干的,其一是ttc本来就卖得贵(一颗兔轴og要19r,一颗兔轴rgb要13r),对于学生党来说花费太大了,以我这67键就得花800元了,另一方面,我也没有静音需求,也不太追求这种手感…</p><p>不过还是感谢ttc免费送我的这几个玩具😁</p>]]></content>
    
    
    <categories>
      
      <category>杂谈</category>
      
    </categories>
    
    
    <tags>
      
      <tag>娱乐</tag>
      
      <tag>机械键盘</tag>
      
      <tag>欧皇事件</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>记一次难蚌的Github deploy错误</title>
    <link href="/%E8%AE%B0%E4%B8%80%E6%AC%A1%E9%9A%BE%E8%9A%8C%E7%9A%84Github-deploy%E9%94%99%E8%AF%AF/"/>
    <url>/%E8%AE%B0%E4%B8%80%E6%AC%A1%E9%9A%BE%E8%9A%8C%E7%9A%84Github-deploy%E9%94%99%E8%AF%AF/</url>
    
    <content type="html"><![CDATA[<h2 id="一-错误表现"><a href="#一-错误表现" class="headerlink" title="一.错误表现"></a>一.错误表现</h2><p>昨天晚上,我像往常一样,写完博客准备上传到Github,结果过了半天博客页面还没有刷新,点开仓库一看,文件已经更新了,但是action栏全是提交失败</p><p><img src="/%E8%AE%B0%E4%B8%80%E6%AC%A1%E9%9A%BE%E8%9A%8C%E7%9A%84Github-deploy%E9%94%99%E8%AF%AF/image-20230120101739080.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="一排都是,因为我重复hexo d了好几次"></p><p>出错的具体表现都是deploy超时</p><p><img src="/%E8%AE%B0%E4%B8%80%E6%AC%A1%E9%9A%BE%E8%9A%8C%E7%9A%84Github-deploy%E9%94%99%E8%AF%AF/image-20230120102930560.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="前两步都是正常的"></p><p>点开的显示排队中…</p><p><img src="/%E8%AE%B0%E4%B8%80%E6%AC%A1%E9%9A%BE%E8%9A%8C%E7%9A%84Github-deploy%E9%94%99%E8%AF%AF/image-20230120103158041.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="被超市了"></p><h2 id="二-解决方法-伪"><a href="#二-解决方法-伪" class="headerlink" title="二.解决方法(伪)"></a>二.解决方法(伪)</h2><p>我一开始就认为可能是插件错误,然后折腾了半天,先试着把昨天晚上下载的插件给卸了,再上传,失败.把之前备份的版本回退,上传也失败,最后反反复复的弄到了差不多凌晨2点半,中途还把博客搞崩了(网页因为提交不上去而404),最后放弃了打算第二天重新部署hexo博客了…</p><h2 id="三-解决方法"><a href="#三-解决方法" class="headerlink" title="三.解决方法(?)"></a>三.解决方法(?)</h2><p><del>最后的解决方法就是什么也不做</del></p><p><del>一眼丁真,鉴定为服务器抽风</del></p><p>今天早上提交一遍就传上去了,不然你也看不到这篇文章了</p><p><img src="/%E8%AE%B0%E4%B8%80%E6%AC%A1%E9%9A%BE%E8%9A%8C%E7%9A%84Github-deploy%E9%94%99%E8%AF%AF/image-20230120105015165.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="蚌埠了"></p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo</tag>
      
      <tag>blog</tag>
      
      <tag>error</tag>
      
      <tag>github</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2022年我Steam玩了什么游戏</title>
    <link href="/2022%E5%B9%B4%E6%88%91Steam%E7%8E%A9%E4%BA%86%E4%BB%80%E4%B9%88%E6%B8%B8%E6%88%8F/"/>
    <url>/2022%E5%B9%B4%E6%88%91Steam%E7%8E%A9%E4%BA%86%E4%BB%80%E4%B9%88%E6%B8%B8%E6%88%8F/</url>
    
    <content type="html"><![CDATA[<p>2022年买了不少游戏,大多成了<code>藏品</code>,没有太多想玩的欲望,<del>什么电子杨伟</del>,如果只是要单纯的列个表格出来,倒显得无趣了,我就简单聊一聊我玩过的印象比较深的游戏吧.</p><p><img src="/2022%E5%B9%B4%E6%88%91Steam%E7%8E%A9%E4%BA%86%E4%BB%80%E4%B9%88%E6%B8%B8%E6%88%8F/image-20230120112538519.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="账号1"></p><p><img src="/2022%E5%B9%B4%E6%88%91Steam%E7%8E%A9%E4%BA%86%E4%BB%80%E4%B9%88%E6%B8%B8%E6%88%8F/image-20230120112625771.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="账号1"></p><p><img src="/2022%E5%B9%B4%E6%88%91Steam%E7%8E%A9%E4%BA%86%E4%BB%80%E4%B9%88%E6%B8%B8%E6%88%8F/image-20230120120703443.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="账号1"></p><p><img src="/2022%E5%B9%B4%E6%88%91Steam%E7%8E%A9%E4%BA%86%E4%BB%80%E4%B9%88%E6%B8%B8%E6%88%8F/image-20230120121708479.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="账号2"></p><p><img src="/2022%E5%B9%B4%E6%88%91Steam%E7%8E%A9%E4%BA%86%E4%BB%80%E4%B9%88%E6%B8%B8%E6%88%8F/image-20230120120816428.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="账号2"><img src="/2022%E5%B9%B4%E6%88%91Steam%E7%8E%A9%E4%BA%86%E4%BB%80%E4%B9%88%E6%B8%B8%E6%88%8F/image-20230120120838868.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="账号2"></p><h2 id="一-上半年—疫情—轻薄本扛大旗"><a href="#一-上半年—疫情—轻薄本扛大旗" class="headerlink" title="一.上半年—疫情—轻薄本扛大旗"></a>一.上半年—疫情—轻薄本扛大旗</h2><p>2022年对于我来说可以简单分为上半年和下半年,上半年上海疫情闹得纷纷扬扬,我在宿舍差不多关了3个月,饭菜口味差天天吃盒饭,足不出户也洗不了澡,简直地狱.我在宿舍也只有一个轻薄本可玩…基本与3A无缘.</p><p>在这种情况下,我用核显打通了黑暗之魂3,AMD Ryzen 7 5700U这样一个低压zen2 cpu居然也能40帧(中低画质)左右,加上环印城和画中世界DLC总共80多个小时,期间还和两个室友三人联机.不过中途Fromsoft的服务器关了,不能再叫好哥哥帮忙了,按照黑魂3吧里的教程弄的私服又很不稳定,经常拉一个人要等半天…</p><p><img src="/2022%E5%B9%B4%E6%88%91Steam%E7%8E%A9%E4%BA%86%E4%BB%80%E4%B9%88%E6%B8%B8%E6%88%8F/image-20230120112738029.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="数据来自steam2022年度总结"></p><p>截图分享:</p><p><img src="https://steamuserimages-a.akamaihd.net/ugc/1867310691863302486/754863E88234BE96EADBA971DA4055367603C41D/" srcset="/img/mahmoud-habibi.gif" lazyload alt="和室友联机-前有巨大宝箱"></p><p><img src="https://steamuserimages-a.akamaihd.net/ugc/1867310691861002615/86801BBCF0394FCF69B18FE4F2F464275295A976/" srcset="/img/mahmoud-habibi.gif" lazyload alt="蹲沙虫"></p><p><img src="https://steamuserimages-a.akamaihd.net/ugc/1867310691863296860/97302B0F49B056EF6BB079DADD71E6B4E8B1F108/" srcset="/img/mahmoud-habibi.gif" lazyload alt="松果痰抖闪电鞭"></p><p>后面乘着打折入了只狼,游戏帧数就挺惨了,只有30帧不到,再加上操作和黑魂那一套完全不同,实在不习惯,打到蝴蝶夫人那里就弃了,之后有兴趣可能会捡回来接着玩.</p><p><img src="/2022%E5%B9%B4%E6%88%91Steam%E7%8E%A9%E4%BA%86%E4%BB%80%E4%B9%88%E6%B8%B8%E6%88%8F/image-20230120122611614.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="玩的时间不长"></p><p>中途的小游戏没啥可说的…都是打发打发时间玩的.</p><h2 id="二-下半年—高画质—台式机"><a href="#二-下半年—高画质—台式机" class="headerlink" title="二.下半年—高画质—台式机"></a>二.下半年—高画质—台式机</h2><p>我超,环!其实上半年刚出我就想买了,不过因为定价比较贵以及电脑性能带不动而作罢(然而我的舍友早就首发玩上了),期间还封校了,想换新电脑都没有条件,期间便混迹于卡吧图吧,一直蹲到矿潮快结束,大概是8月份配了一台r5 5600+Rtx2060的台式(后面显卡换了降价的6700xt并更换了2k高刷显示器),性能跟上了! 于是在国庆假期花费300大洋购买了游戏,用我的旧XBOX ones手柄通关了,法环的战技法术使用更多,还有骨灰这种官方逃课神器,其实相比魂三反倒变得简单了…</p><p>就我自己而言,玩法也不同了,我玩魂三的时候是纯纯战士加点,从法兰粪坑拿到流放者大刀就一直用翻滚加平A通关,基本没尝试过别的玩法.</p><p>法环自然要体验法爷,就点的法术加点了,前期用陨石球加名刀月影战技(虽然我玩的时候已经被削过了),后期用彗星亚兹勒和老婆🗡(祖传月光大剑)娱乐,打完皮蛋之后,用神躯化剑在鲜血王朝银行刷白金之子取钱,最后还是得叫上好哥哥才把女武神这个恶心boss给收拾掉了(手残…)</p><p><img src="/2022%E5%B9%B4%E6%88%91Steam%E7%8E%A9%E4%BA%86%E4%BB%80%E4%B9%88%E6%B8%B8%E6%88%8F/image-20230120134604964.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="steam锐评没有女朋友"></p><p><img src="https://steamuserimages-a.akamaihd.net/ugc/1889851107812850661/0C17ED1ACA042D92E1AFD852C6EA0DC03522246C/" srcset="/img/mahmoud-habibi.gif" lazyload alt="为菈妮😭"></p><p><img src="https://steamuserimages-a.akamaihd.net/ugc/1889851107812847854/AADAF0F4BAE9DB1E5160262FA6ED1658974F9422/" srcset="/img/mahmoud-habibi.gif" lazyload alt="我要狠狠地癫火😈"></p><p><img src="https://steamuserimages-a.akamaihd.net/ugc/1902233788136068948/1CCC1B7475A0AAF063F18982F8B9D1AB9A736893/" srcset="/img/mahmoud-habibi.gif" lazyload alt="地底的天空"></p><p><img src="https://steamuserimages-a.akamaihd.net/ugc/1821167636968926979/8E9CC5FD1D0707F3462340B4FB5D75C356351289/" srcset="/img/mahmoud-habibi.gif" lazyload alt="雷亚卢卡利亚魔法学院(个人感觉很有霍格沃茨那味儿)"></p><p>发现的小游戏,挺有意思的,据说是cy用关服的手游素材做的,算是简单的肉鸽,攻击是靠卡牌连携的和<code>ENDER LILIES</code> 手感类似,不过感觉人物机动性要好不少</p><p><img src="/2022%E5%B9%B4%E6%88%91Steam%E7%8E%A9%E4%BA%86%E4%BB%80%E4%B9%88%E6%B8%B8%E6%88%8F/image-20230120134644032.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="简单的肉鸽"></p><p>然后是巨硬的大作,地平线4,我就当开车看风景的,虽然我两年前就拿到驾照了,但这个游戏里开车感觉还是不习惯,拐弯经常撞…不过6700xt显卡能2k全高跑满显示器的170帧,开放世界赛车画面还是相当棒的,唯一的缺点是steam版没能体验到xbox手柄的扳机震动…</p><p><img src="/2022%E5%B9%B4%E6%88%91Steam%E7%8E%A9%E4%BA%86%E4%BB%80%E4%B9%88%E6%B8%B8%E6%88%8F/image-20230120204336447.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="开车咯"></p><p>这个装机模拟器,呃呃,5月的记录大概是实际动手装机前的演练,11月算是真正在玩,自己当电脑城奸商给顾客装机也挺有意思🧐,这个最烦人的就是拆电脑拧螺丝,还有别忘了给cpu涂硅脂.前期给别人装了好多赛扬和gtx960🤣</p><p><img src="/2022%E5%B9%B4%E6%88%91Steam%E7%8E%A9%E4%BA%86%E4%BB%80%E4%B9%88%E6%B8%B8%E6%88%8F/image-20230120205126183.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="赛博装机"></p><p>然后是最花钱的游戏—3dmark,估计我以后电脑升级都会跑几遍</p><p><img src="/2022%E5%B9%B4%E6%88%91Steam%E7%8E%A9%E4%BA%86%E4%BB%80%E4%B9%88%E6%B8%B8%E6%88%8F/image-20230120210215350.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="我的steam页"></p><p><img src="/2022%E5%B9%B4%E6%88%91Steam%E7%8E%A9%E4%BA%86%E4%BB%80%E4%B9%88%E6%B8%B8%E6%88%8F/image-20230120210244145.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="还差4个成就"></p><p>这四个成就因为我回老家只有笔记本就跑不了…神秘机器要去小黄鱼买es处理器来解锁,第三个基本要3080以上的显卡才能实现,最后的tse限制了<code>但是您的显卡至少要有 4 GB 的内存</code>核显就只能从内存那里共用2g的显存…还是等以后有时间升级配置了在学校跑吧.</p><p>前面的分别是我两张显卡的默频和超频分数以及轻薄本,还有一个我帮舍友的拯救者3060本子测试的(作为台式和笔记本对比项),可以发现a卡超频真的猛,直接提升了1000分(四舍五入就是一个笔记本核显)</p><p><img src="/2022%E5%B9%B4%E6%88%91Steam%E7%8E%A9%E4%BA%86%E4%BB%80%E4%B9%88%E6%B8%B8%E6%88%8F/image-20230120213534109.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="一张具有代表性的图片"></p><h2 id="三-尾声"><a href="#三-尾声" class="headerlink" title="三.尾声"></a>三.尾声</h2><p>今年在steam上给我印象最深的大概也就是列出的几款,总之玩得很开心,期待2023年的法环DLC,装甲核心发售后看情况考虑是否购买吧,虽然是fs新作,但我对这类雀食不太熟,还是不要盲目跟风了…</p><p>明年应该暂时不会再升级电脑,对于市面上的2k游戏,我已经可以做到不用看配置直接购买了,而不需要像法环那样拖了半年才开始玩,对于学习和游戏来说已经满足需求了.不过,要是真的出了很有性价比的硬件估计还是会换的,不过看现在独立显卡市场上老黄的那套溢价玩意,以及不那么yes的a卡,或许显卡以后真成奢侈品了,那就真成DIY地狱了…</p><p><img src="/2022%E5%B9%B4%E6%88%91Steam%E7%8E%A9%E4%BA%86%E4%BB%80%E4%B9%88%E6%B8%B8%E6%88%8F/%E9%BB%84%E7%8B%97.jpg" srcset="/img/mahmoud-habibi.gif" lazyload alt="卡吧p图版铭瑄黄狗升天"></p>]]></content>
    
    
    <categories>
      
      <category>杂谈</category>
      
    </categories>
    
    
    <tags>
      
      <tag>总结</tag>
      
      <tag>steam</tag>
      
      <tag>游戏</tag>
      
      <tag>娱乐</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>高通410Wifi棒子折腾记录</title>
    <link href="/%E9%AB%98%E9%80%9A410Wifi%E6%A3%92%E5%AD%90%E6%8A%98%E8%85%BE%E8%AE%B0%E5%BD%95/"/>
    <url>/%E9%AB%98%E9%80%9A410Wifi%E6%A3%92%E5%AD%90%E6%8A%98%E8%85%BE%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h2 id="一-外观及拆解"><a href="#一-外观及拆解" class="headerlink" title="一.外观及拆解"></a>一.外观及拆解</h2><p>这个随身wifi淘宝购入,花费14.5大洋,算不上车价,我也是突发兴趣去买的.不过看这个棒子早己被各路大佬玩开花了,我弄这个也没啥技术含量,没有卡槽就没必要搞基带了,只刷个debian,就当是分享经验算了…..</p><p><img src="/%E9%AB%98%E9%80%9A410Wifi%E6%A3%92%E5%AD%90%E6%8A%98%E8%85%BE%E8%AE%B0%E5%BD%95/%E5%A4%96%E8%A7%82.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="淘宝普通版样子"></p><p>用螺丝刀拧开两个小螺丝</p><p><img src="/%E9%AB%98%E9%80%9A410Wifi%E6%A3%92%E5%AD%90%E6%8A%98%E8%85%BE%E8%AE%B0%E5%BD%95/1.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="拧完还得用力掰开"></p><p>然后查看板子丝印,这一步是为了确定我们要刷的包,410的棒子大致有UFI001,UFI002,UFI003等种类</p><p><img src="/%E9%AB%98%E9%80%9A410Wifi%E6%A3%92%E5%AD%90%E6%8A%98%E8%85%BE%E8%AE%B0%E5%BD%95/2.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="这个是UFI001C,居然印在天线上,虽然直觉告诉我应该在pcb上"></p><p>然后我们可以看一下他的CPU,拆开最大的屏蔽罩,确定是高通410,旁边是金士顿的什么颗粒(应该是4G的硬盘)</p><p><img src="/%E9%AB%98%E9%80%9A410Wifi%E6%A3%92%E5%AD%90%E6%8A%98%E8%85%BE%E8%AE%B0%E5%BD%95/3.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="MSM8916就是高通410"> </p><p>我买的运气不好,没有卡槽,除非自己焊一个上去(我一个软件学生表示不会),否则不能用自己卡,旁边按钮是复位键,待会儿进入9008模式需要用</p><p><img src="/%E9%AB%98%E9%80%9A410Wifi%E6%A3%92%E5%AD%90%E6%8A%98%E8%85%BE%E8%AE%B0%E5%BD%95/4.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="小黑块是esim卡"></p><p>棒子的具体配置：</p><table><thead><tr><th>项目</th><th>参数</th></tr></thead><tbody><tr><td>CPU</td><td>Qualcomm Snapdragon MSM8916 Cortex-A53 × 4 @ 1.2GHz</td></tr><tr><td>RAM</td><td>512MB</td></tr><tr><td>ROM</td><td>4G</td></tr><tr><td>备注</td><td>CPU 即高通骁龙 410，是采用 28nm 工艺制程的 64 位 4 核处理器</td></tr></tbody></table><p>这个cpu性能大致和树莓派3+接近…</p><h2 id="二-备份"><a href="#二-备份" class="headerlink" title="二.备份"></a>二.备份</h2><p>所需软件链接: <a href="https://pan.baidu.com/s/1eiWrcMONoO8jDhCxfVlKMg">https://pan.baidu.com/s/1eiWrcMONoO8jDhCxfVlKMg</a> 提取码: dttr </p><h4 id="1-首先在电脑上安装9008驱动"><a href="#1-首先在电脑上安装9008驱动" class="headerlink" title="1.首先在电脑上安装9008驱动"></a>1.首先在电脑上安装9008驱动</h4><p><img src="/%E9%AB%98%E9%80%9A410Wifi%E6%A3%92%E5%AD%90%E6%8A%98%E8%85%BE%E8%AE%B0%E5%BD%95/image-20230117223914238.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="这个好像是vivo做的,我已经安好了"></p><p>有了驱动才能进入9008模式，我们才能备份</p><h4 id="2-下载好两个备份-x2F-刷写软件"><a href="#2-下载好两个备份-x2F-刷写软件" class="headerlink" title="2.下载好两个备份&#x2F;刷写软件"></a>2.下载好两个备份&#x2F;刷写软件</h4><p>在我们真正刷写前,先做好备份,避免刷机变砖</p><p><img src="/%E9%AB%98%E9%80%9A410Wifi%E6%A3%92%E5%AD%90%E6%8A%98%E8%85%BE%E8%AE%B0%E5%BD%95/image-20230117224000999.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="高通工具,使用前需破解注册码"></p><p>两个软件都可以备份,miko可以生成单个文件的救砖包，高通那个可以单独对分区备份和写入</p><p><img src="/%E9%AB%98%E9%80%9A410Wifi%E6%A3%92%E5%AD%90%E6%8A%98%E8%85%BE%E8%AE%B0%E5%BD%95/image-20230117224511592.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="还是按照压缩包内说明来"></p><p>首先保持按住wifi棒子上的复位键，插入电脑的usb口，驱动正确的情况下，打开电脑的设备管理器，端口栏会出现这个9008的标识。</p><p><img src="/%E9%AB%98%E9%80%9A410Wifi%E6%A3%92%E5%AD%90%E6%8A%98%E8%85%BE%E8%AE%B0%E5%BD%95/image-20230117225211339.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="我把棒子装回去了，懒得再拆开，这图是借别人的演示一下"></p><p>此时wifi棒子不会发光。</p><p>如果想单独对分区操作，进入高通软件，点击QUalcomn-&gt;partition-&gt;do job(scan)</p><p>成功后，左侧会显示棒子信息，右侧会出现棒子自带安卓系统的分区，点击需要操作的分区，选择backup(备份)或者write(写入)，我们就可以操作了（注意先scan再操作）.</p><p>如果想玩安卓，但棒子默认没开adb，也可以从这里提取system文件，利用rom操作软件直接添加环境变量再写入（我的棒子就是，但我通过这番操作已经开了adb了），可以参考这个up的视频<a href="https://www.bilibili.com/video/BV1C24y1Q7fN?share_source=copy_web">https://www.bilibili.com/video/BV1C24y1Q7fN?share_source=copy_web</a></p><p><img src="/%E9%AB%98%E9%80%9A410Wifi%E6%A3%92%E5%AD%90%E6%8A%98%E8%85%BE%E8%AE%B0%E5%BD%95/image-20230117225509245.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="image-20230117225509245"></p><p>miko软件的使用也类似，在9008模式下。</p><p>选择Read，Partition Backup&#x2F;Flash，选择生成路径，点击Load Partition Structure，再点击Read Full Image生成emmc全备份文件格式.bin，之后玩砖了直接刷进去就行。</p><blockquote><p> 如果要插卡玩，记得备份基带。                                                                                                                                           </p></blockquote><h2 id="三-debian刷入"><a href="#三-debian刷入" class="headerlink" title="三.debian刷入"></a>三.debian刷入</h2><p>酷安大佬<a href="https://www.coolapk.com/feed/36547490?shareKey=MDk1MjQ1Zjg1OTk1NjJkZjYzMDg">苏苏小亮亮</a>的debian和openwrt固件</p><p>刷之前先确定棒子已开启adb，使用命令 <code>adb devices</code> 查看连接的adb设备，如果报错说明驱动未安装，那就先安装驱动，如果为空行，说明棒子没开adb</p><p><img src="/%E9%AB%98%E9%80%9A410Wifi%E6%A3%92%E5%AD%90%E6%8A%98%E8%85%BE%E8%AE%B0%E5%BD%95/image-20230117231839232.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="大概这样就行"></p><p>然后下载对应固件包，解压</p><p>点击flash.bat</p><p><img src="/%E9%AB%98%E9%80%9A410Wifi%E6%A3%92%E5%AD%90%E6%8A%98%E8%85%BE%E8%AE%B0%E5%BD%95/image-20230117231937534.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="这里"></p><p>点开效果，如果adb连上了会帮你开启bootloader，我这是早就弄完的了，所以没有别的显示，如果正常随后一直按提示回车就安装好了</p><p><img src="/%E9%AB%98%E9%80%9A410Wifi%E6%A3%92%E5%AD%90%E6%8A%98%E8%85%BE%E8%AE%B0%E5%BD%95/image-20230117232031519.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="大概这样"></p><p>此时使用<code>adb shell</code>指令便可直接连上linux了，但我们的目的还没有完全实现，目前还不能通过ip来访问</p><p><img src="/%E9%AB%98%E9%80%9A410Wifi%E6%A3%92%E5%AD%90%E6%8A%98%E8%85%BE%E8%AE%B0%E5%BD%95/image-20230117232531490.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="还没结束"></p><p>再次打开设备管理器，我们会发现其他设备一栏有警告</p><p><img src="/%E9%AB%98%E9%80%9A410Wifi%E6%A3%92%E5%AD%90%E6%8A%98%E8%85%BE%E8%AE%B0%E5%BD%95/image-20230117232626780.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="RNDIS错误"></p><p>右键属性选择更新驱动，浏览电脑-&gt;可用程序列表中选择</p><p><img src="/%E9%AB%98%E9%80%9A410Wifi%E6%A3%92%E5%AD%90%E6%8A%98%E8%85%BE%E8%AE%B0%E5%BD%95/image-20230117232803601.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="image-20230117232803601"></p><p>网络适配器-&gt;microsoft-&gt;基于NDIS，直接安装</p><p><img src="/%E9%AB%98%E9%80%9A410Wifi%E6%A3%92%E5%AD%90%E6%8A%98%E8%85%BE%E8%AE%B0%E5%BD%95/image-20230117233053865.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="需要找一找"></p><p>装完后就能识别了</p><p><img src="/%E9%AB%98%E9%80%9A410Wifi%E6%A3%92%E5%AD%90%E6%8A%98%E8%85%BE%E8%AE%B0%E5%BD%95/image-20230117233219642.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="OK"></p><p><img src="/%E9%AB%98%E9%80%9A410Wifi%E6%A3%92%E5%AD%90%E6%8A%98%E8%85%BE%E8%AE%B0%E5%BD%95/image-20230117233238272.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="出现网络了"></p><p>我们直接在cmd输入</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">ssh</span> root@<span class="hljs-number">192.168.68.1</span><br></code></pre></td></tr></table></figure><p>默认密码为1</p><p><img src="/%E9%AB%98%E9%80%9A410Wifi%E6%A3%92%E5%AD%90%E6%8A%98%E8%85%BE%E8%AE%B0%E5%BD%95/image-20230117233419537.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="image-20230117233419537"></p><p>成功连上！之后就用<code>nmtui</code>命令联网，当作正常linux系统使用就行了</p><p><img src="/%E9%AB%98%E9%80%9A410Wifi%E6%A3%92%E5%AD%90%E6%8A%98%E8%85%BE%E8%AE%B0%E5%BD%95/image-20230117233535156.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="image-20230117233535156"></p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随身wifi</tag>
      
      <tag>debian</tag>
      
      <tag>刷机</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Emokable的从零搭建Hexo博客记录</title>
    <link href="/Emokable%E7%9A%84%E4%BB%8E%E9%9B%B6%E6%90%AD%E5%BB%BAHexo%E5%8D%9A%E5%AE%A2%E8%AE%B0%E5%BD%95/"/>
    <url>/Emokable%E7%9A%84%E4%BB%8E%E9%9B%B6%E6%90%AD%E5%BB%BAHexo%E5%8D%9A%E5%AE%A2%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<p>​截止到2023年1月10日,我搭建好这个博客有好几天了,最近也忙着在增改博客的功能.我尽量用简单的语言,记录一下我的工作, 如果大佬看到能给出一点建议就更好了.</p><h2 id="一-安装node-js-使用npm本地安装hexo博客"><a href="#一-安装node-js-使用npm本地安装hexo博客" class="headerlink" title="一.安装node.js ,使用npm本地安装hexo博客"></a>一.安装node.js ,使用npm本地安装hexo博客</h2><p>​首先是在笔记本上下载好node.js,官网下载：<a href="https://nodejs.org/en/">https://nodejs.org/en/</a> ,直接一路点点点,就行.我之前也在linux弄过,应该是把压缩包git下来,解压安装,总是还挺麻烦.</p><p><img src="/Emokable%E7%9A%84%E4%BB%8E%E9%9B%B6%E6%90%AD%E5%BB%BAHexo%E5%8D%9A%E5%AE%A2%E8%AE%B0%E5%BD%95/image-20230110202228211.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="node.JS官网"></p><p>安装完成后,检查是否正确安装,<code>node -v</code> 和 <code>npm -v</code> 查看版本号</p><p><img src="/Emokable%E7%9A%84%E4%BB%8E%E9%9B%B6%E6%90%AD%E5%BB%BAHexo%E5%8D%9A%E5%AE%A2%E8%AE%B0%E5%BD%95/image-20230110202950770.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="还要配置环境变量"></p><p>调用下述指令安装hexo</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmd">npm install -g hexo-cli<br></code></pre></td></tr></table></figure><p>可以使用<code>hexo -v</code> 查看是否安装</p><p><img src="/Emokable%E7%9A%84%E4%BB%8E%E9%9B%B6%E6%90%AD%E5%BB%BAHexo%E5%8D%9A%E5%AE%A2%E8%AE%B0%E5%BD%95/image-20230110204426640.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="会出现以下信息,就安装成功了"></p><p>自定位置,使用 <code>hexo init blog</code> 创建blog文件夹,并初始化</p><p>可以试试 <code>hexo -g</code> 静态部署,以及 <code>hexo -s</code> 开始本地服务器, 之后跳转到 <a href="http://localhost:4000/">http://localhost:4000</a> 查看本地网页,之后写完博客,也可以这样预览.</p><p><code>hexo new XXX(名字)</code> 就可以在本地,\source_posts\下生成同名md文件了, </p><p>然后就可以愉快的用Typora等编辑器写作了,不过此时博客还在本地,我们还需要借助github(或者gitee等类似网站来托管)</p><h2 id="二-部署hexo-静态博客-到github"><a href="#二-部署hexo-静态博客-到github" class="headerlink" title="二. 部署hexo 静态博客 到github"></a>二. 部署hexo 静态博客 到github</h2><p>这里我选择的是github, 主要是gitee pages开启需要实名认证,大概要等个一两天才能通过,之后的网站更新还需要手动去仓库刷新,不像github提交hexo -d 后自动就给网页更新了,总之,在网络条件允许的情况下,还是建议github.</p><p>首先要有个github 账号,新建一个XXX.github.io的仓库(xxx和账户同名),类型选公开,即public</p><p><img src="/Emokable%E7%9A%84%E4%BB%8E%E9%9B%B6%E6%90%AD%E5%BB%BAHexo%E5%8D%9A%E5%AE%A2%E8%AE%B0%E5%BD%95/image-20230110205344341.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="这样的就行"></p><p>点开setting下左侧栏的Pages页面,应该会有类似的提示,</p><p><img src="/Emokable%E7%9A%84%E4%BB%8E%E9%9B%B6%E6%90%AD%E5%BB%BAHexo%E5%8D%9A%E5%AE%A2%E8%AE%B0%E5%BD%95/image-20230110205619529.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="这样就说明个人网站ok了"></p><p>但目前为止我们还没有把本地的hexo博客和github结合起来,别急,接着编辑我们新建的blog文件夹下的</p><p><code>_config.yml</code>文件,拉到最底层,做如下修改, repo地址为自己仓库的地址</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-meta"># Docs: https:<span class="hljs-comment">//hexo.io/docs/one-command-deployment</span></span><br><span class="hljs-symbol">deploy:</span><br><span class="hljs-symbol"> type:</span> git<br><span class="hljs-symbol"> repo:</span> git@github.com:Emokable/Emokable.github.io.git<br><span class="hljs-symbol"> branch:</span> main<br></code></pre></td></tr></table></figure><p><img src="/Emokable%E7%9A%84%E4%BB%8E%E9%9B%B6%E6%90%AD%E5%BB%BAHexo%E5%8D%9A%E5%AE%A2%E8%AE%B0%E5%BD%95/image-20230110210250253.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="位置在这里"></p><p>如果没有设置过git ,还需要配置账号,生成ssh密钥</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">git config –<span class="hljs-keyword">global</span> <span class="hljs-keyword">user</span>.name yourname<br>git config –<span class="hljs-keyword">global</span> <span class="hljs-keyword">user</span>.email yourname@mail.com<br></code></pre></td></tr></table></figure><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">ssh-keygen -t rsa -C <span class="hljs-symbol">yourname@</span>mail.com<br></code></pre></td></tr></table></figure><p>之后用cat命令打开生成的id_rsa.pub文件,复制下来,粘贴到github里</p><p><img src="/Emokable%E7%9A%84%E4%BB%8E%E9%9B%B6%E6%90%AD%E5%BB%BAHexo%E5%8D%9A%E5%AE%A2%E8%AE%B0%E5%BD%95/image-20230110210722512.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="在个人中心里SSh and GPG key栏里"></p><p>认证完成后  ssh <a href="mailto:&#x67;&#105;&#x74;&#64;&#103;&#105;&#116;&#x68;&#x75;&#x62;&#x2e;&#x63;&#x6f;&#x6d;">&#x67;&#105;&#x74;&#64;&#103;&#105;&#116;&#x68;&#x75;&#x62;&#x2e;&#x63;&#x6f;&#x6d;</a> 查看是否成功</p><p><img src="/Emokable%E7%9A%84%E4%BB%8E%E9%9B%B6%E6%90%AD%E5%BB%BAHexo%E5%8D%9A%E5%AE%A2%E8%AE%B0%E5%BD%95/image-20230110210933475.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="Over!"></p><p>然后安装hexo git 插件</p><p><code>npm install hexo-deployer-git –-save</code></p><p>安装完成后, <code>hexo -cl</code>    <code>hexo -g</code>  <code>hexo -v</code> 三连击,上传本地博客,结束!</p><h2 id="三-DLC-1—更换hexo主题"><a href="#三-DLC-1—更换hexo主题" class="headerlink" title="三.DLC  1—更换hexo主题"></a>三.DLC  1—更换hexo主题</h2><p>正所谓科技以换皮为主, 一个好的博客 外在同样重要, 可以到官方的<a href="https://hexo.io/themes/index.html">主题站</a>去挑选喜欢的样式</p><p>我选择的是比较简约的fluid主题,当然还有别的好看的比如NexT,Butterfly之类的,配置方法参考各自的配置文档就行.</p><p>不过我现在用的fluid设置都还没吃透,就不详细讲了,有空再说吧…</p><h2 id="四-DLC-2—图文结合的博客"><a href="#四-DLC-2—图文结合的博客" class="headerlink" title="四.DLC  2—图文结合的博客"></a>四.DLC  2—图文结合的博客</h2><p>我是使用typora写作的,其实也还挺容易.先到<code>_config.yml</code>里修改</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">post_asset_folder:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>新建博客的时候同时创建用于存储图片的同名文件夹,再如下修改typora的偏好设置</p><p><img src="/Emokable%E7%9A%84%E4%BB%8E%E9%9B%B6%E6%90%AD%E5%BB%BAHexo%E5%8D%9A%E5%AE%A2%E8%AE%B0%E5%BD%95/image-20230110213928382.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="偏好设置里改一下"></p><p>这样写作的时候直接往typora里添加文件,图片就能直接自动添加到我们生成的同名文件夹里了,写完保存后,执行三连指令,我们的图片就出现在博客正文里了.</p><p><img src="/Emokable%E7%9A%84%E4%BB%8E%E9%9B%B6%E6%90%AD%E5%BB%BAHexo%E5%8D%9A%E5%AE%A2%E8%AE%B0%E5%BD%95/image-20230110214332671.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="都在里面"></p><p>不过我看网上还有图床cdn之类的优化方法,我还没有研究过,就先放着这里,等我弄懂了再细说</p><hr><blockquote><p>2023&#x2F;1&#x2F;12</p><p>图床的原理我基本明白了,最简单的就是直接在github建个仓库就行,使用picgo配置好仓库和上传图片的文件夹,同时typora里也要更改,自定义域名采用cdn加速格式：<a href="https://cdn.jsdelivr.net/gh/username/repo%EF%BC%8Cusername%E4%B8%BAGitHub%E7%94%A8%E6%88%B7%E5%90%8D%EF%BC%8Crepo%E4%B8%BA%E6%96%B0%E5%BB%BA%E7%9A%84%E4%BB%93%E5%BA%93%EF%BC%8C%E7%94%A8%E4%BA%8E%E5%AD%98%E5%82%A8%E5%9B%BE%E7%89%87,%E6%88%91%E6%9A%82%E6%97%B6%E8%BF%98%E6%B2%A1%E6%9C%89%E6%9B%B4%E6%94%B9%E7%9A%84%E5%BF%85%E8%A6%81,%E6%AF%95%E7%AB%9F%E7%8E%B0%E5%9C%A8%E7%BD%91%E9%A1%B5%E4%B9%9F%E5%B7%B2%E7%BB%8F%E9%87%87%E7%94%A8%E5%85%A8%E5%B1%80cdn%E5%8A%A0%E9%80%9F%E4%BA%86,%E5%90%8E%E7%BB%AD%E6%9C%89%E5%85%B4%E8%B6%A3%E6%88%91%E4%BC%9A%E8%80%83%E8%99%91%E4%BF%AE%E6%94%B9%E3%80%82">https://cdn.jsdelivr.net/gh/username/repo，username为GitHub用户名，repo为新建的仓库，用于存储图片,我暂时还没有更改的必要,毕竟现在网页也已经采用全局cdn加速了,后续有兴趣我会考虑修改。</a></p></blockquote><blockquote><p>2023&#x2F;1&#x2F;11:</p><h3 id="新增了压缩插件的使用-这个插件可以压缩图片-css-js-html加快博客加载速度"><a href="#新增了压缩插件的使用-这个插件可以压缩图片-css-js-html加快博客加载速度" class="headerlink" title="- 新增了压缩插件的使用,这个插件可以压缩图片,css,js,html加快博客加载速度"></a>- 新增了压缩插件的使用,这个插件可以压缩图片,css,js,html加快博客加载速度</h3><p>在博客根目录执行指令:</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">npm install hexo-<span class="hljs-keyword">all</span>-minifier <span class="hljs-comment">--save</span><br></code></pre></td></tr></table></figure><p>然后果不其然的安装报错了……(忘了截图了)</p><p>尝试换到cnpm淘宝版</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">npm install -g cnpm -registry=https:<span class="hljs-regexp">//</span>registry.npm.taobao.org  <span class="hljs-comment">#安装cnpm</span><br>cnpm install hexo-all-minifier --save    <br></code></pre></td></tr></table></figure><p>我只是换成cnpm就成功了,其他人如果安装失败也可以试试</p><p>然后在根目录_comfig.yml里增加</p><p>在博客根目录的站点配置文件<code>_config.yml</code>里添加配置项</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># minifier</span><br><span class="hljs-attr">all_minifier:</span> <span class="hljs-literal">true</span><br><span class="hljs-attr">html_minifier:</span><br><span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br><span class="hljs-attr">ignore_error:</span> <span class="hljs-literal">true</span><br><span class="hljs-attr">exclude:</span><br><span class="hljs-attr">css_minifier:</span><br><span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br><span class="hljs-attr">exclude:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">&#x27;*.min.css&#x27;</span><br><span class="hljs-attr">js_minifier:</span><br>  <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">mangle:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-comment">#output:</span><br>  <span class="hljs-attr">compress:</span><br>  <span class="hljs-attr">exclude:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">&#x27;*.min.js&#x27;</span><br><span class="hljs-attr">image_minifier:</span><br>  <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">interlaced:</span> <span class="hljs-literal">false</span><br>  <span class="hljs-attr">multipass:</span> <span class="hljs-literal">false</span><br>  <span class="hljs-attr">optimizationLevel:</span> <span class="hljs-number">2</span><br>  <span class="hljs-attr">pngquant:</span> <span class="hljs-literal">false</span><br>  <span class="hljs-attr">progressive:</span> <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p>我是选择了全部压缩的方案,但这样图片比较多的情况下,hexo g和hexo d的所需的时间会变长</p><p>此外再注意一点就是<code>ignore_error: true</code>这个选项,我选择了忽略错误,否则生成博客时,我的博客主题会在about页报错,运行时无法加载出about页…</p><blockquote><p>此处安装过程参考了<a href="https://www.julydate.com/post/60859300/#%E6%96%87%E4%BB%B6%E5%8E%8B%E7%BC%A9"> <strong>七夏浅笑</strong> </a>这篇博客.</p></blockquote></blockquote><blockquote><p>2023&#x2F;2&#x2F;28：</p><p>考完试了，尝试把本地服务器从笔记本移到学校台式机，这个压缩插件接口不兼容了，弃用</p><p><img src="/Emokable%E7%9A%84%E4%BB%8E%E9%9B%B6%E6%90%AD%E5%BB%BAHexo%E5%8D%9A%E5%AE%A2%E8%AE%B0%E5%BD%95/image-20230228000947630.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="暂时配置，想换3080以上n卡了"></p></blockquote><h2 id="五-DLC-3—评论区设置"><a href="#五-DLC-3—评论区设置" class="headerlink" title="五.DLC  3—评论区设置"></a>五.DLC  3—评论区设置</h2><p>我所使用的fluid主题里,是预留了评论区的位置的,其他主题应该也类似,只要选择好喜欢的评论插件,填写自己的地址就行.</p><p><img src="/Emokable%E7%9A%84%E4%BB%8E%E9%9B%B6%E6%90%AD%E5%BB%BAHexo%E5%8D%9A%E5%AE%A2%E8%AE%B0%E5%BD%95/image-20230110215330504.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="哈姆的哈比比"></p><p>这里以waline为例,首先去注册 <a href="https://console.leancloud.app/apps">Leanclound</a> 作为评论数据库，在 <a href="https://vercel.com/dashboard">Vercel</a> 上部署服务端。接着就按照 <a href="https://waline.js.org/guide/get-started/#leancloud-%E8%AE%BE%E7%BD%AE-%E6%95%B0%E6%8D%AE%E5%BA%93">Waline的官方文档</a> 进行操作,挺简单的,这里就懒得写了.</p><p>不过要注意,部署完成后尽快到<code>&lt;serverURL&gt;/ui/register</code> 进行注册,首个注册的人会被设定成管理员,之后也可以到这个界面去管理评论.</p><h2 id="六-DLC-4—看板娘设置"><a href="#六-DLC-4—看板娘设置" class="headerlink" title="六.DLC  4—看板娘设置"></a>六.DLC  4—看板娘设置</h2><p>哇,这个我现在还在搞,留个坑在这里,弄完了再写吧…</p><blockquote><p>2023&#x2F;1&#x2F;11 蚌埠住了,家人们,搞这个直接把hexo搞崩了,又把博客重新部署了一遍😔,心累,下次记得做好备份</p></blockquote><h2 id="七-DLC-5—个性域名和cdn加速"><a href="#七-DLC-5—个性域名和cdn加速" class="headerlink" title="七.DLC  5—个性域名和cdn加速"></a>七.DLC  5—个性域名和cdn加速</h2><p>原来的username.github.io被我换成了现在的emokable.top, 这个域名是namesilo上花1刀买的,可以用支付宝,不过我目前还没有在国内做备案的打算,不然国内找找肯定有更便宜的,这里各家购买方式不一,网上资料也很多,没什么写的必要(偷懒)…</p><p>买完后,进入到域名管理界面</p><p><img src="/Emokable%E7%9A%84%E4%BB%8E%E9%9B%B6%E6%90%AD%E5%BB%BAHexo%E5%8D%9A%E5%AE%A2%E8%AE%B0%E5%BD%95/image-20230112111331234.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="类似这种"></p><p>修改A和CNAME类,一个是github的ip,另一个是博客原地址,改完后,在博客本地,新建一个CNAME无后缀文件,里面内容是新申请的域名,比如我就填emokable.top</p><p><img src="/Emokable%E7%9A%84%E4%BB%8E%E9%9B%B6%E6%90%AD%E5%BB%BAHexo%E5%8D%9A%E5%AE%A2%E8%AE%B0%E5%BD%95/image-20230112111555108.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="image-20230112111555108"></p><p>最后到GitHub仓库的setting里更改就完成了</p><p><img src="/Emokable%E7%9A%84%E4%BB%8E%E9%9B%B6%E6%90%AD%E5%BB%BAHexo%E5%8D%9A%E5%AE%A2%E8%AE%B0%E5%BD%95/image-20230112112237364.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="可能要等一会儿"></p><p>不过这样直接改完会有一点小问题,就是网站ssl证书的问题,浏览器会有隐私提示,非常丑</p><p><img src="/Emokable%E7%9A%84%E4%BB%8E%E9%9B%B6%E6%90%AD%E5%BB%BAHexo%E5%8D%9A%E5%AE%A2%E8%AE%B0%E5%BD%95/image-20230112112437197.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="一开始是没有这个🔒符号的"></p><p>我是到cloudflare上开cdn服务自动添加的证书,现在就好看多了</p><p>首先进入官网,添加自己的域名(这里我已经弄好了),然后按着步骤来,中途会教你换一下域名服务器,需要到购买的域名后台去修改.</p><p><img src="/Emokable%E7%9A%84%E4%BB%8E%E9%9B%B6%E6%90%AD%E5%BB%BAHexo%E5%8D%9A%E5%AE%A2%E8%AE%B0%E5%BD%95/image-20230112132216980.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="在这里解析原来的域名"></p><p><img src="/Emokable%E7%9A%84%E4%BB%8E%E9%9B%B6%E6%90%AD%E5%BB%BAHexo%E5%8D%9A%E5%AE%A2%E8%AE%B0%E5%BD%95/image-20230112152243896.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="修改域名服务器为这俩"></p><p>之后就算开启了cloudflare的托管服务了,应该会自动安装好证书.</p><h2 id="八-DLC-6—博客备份-防止崩溃"><a href="#八-DLC-6—博客备份-防止崩溃" class="headerlink" title="八.DLC  6—博客备份,防止崩溃"></a>八.DLC  6—博客备份,防止崩溃</h2><p>之前搞崩了一次真的很难受,github仓库里只存了博客网页的文件,而本地文件是没有的,所以重新备份一遍吧</p><p>先创建新的分支</p><ul><li>登录GitHub网站，在博客的仓库下新建一个分支，命名为hexo</li><li>在创建好分支后，在setting中将新建的分支设置为default</li></ul><p>再配置用来备份文件夹</p><p>在本地的任意目录下执行git clone <a href="https://github.com/username/uesrname.github.io.git%EF%BC%8C">https://github.com/username/uesrname.github.io.git，</a><br>将克隆下来的目录中除了.git文件夹外的所有文件删除<br>将本地博客文件夹下除了.deploy_git的其他源文件全部复制过来(如果之前克隆过themes中的主体文件，要将主题文件中的.git目录删除掉)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">git add .<br>git commit -m &quot;备注&quot;<br>git push<br></code></pre></td></tr></table></figure><p>这样hexo博客的目录就备份好了,之后可以把.git文件夹移回原blog文件夹了,再次pull,重新提交,这样就不需要再弄插件了.</p><p>因为我们博客默认在main分支的,备份是在新建的hexo分区,因此使用hexo d和git push指向的分支各不干扰,写博客的时候正常写就行.</p><h2 id="九-DLC-7—设置博客rss订阅"><a href="#九-DLC-7—设置博客rss订阅" class="headerlink" title="九.DLC  7—设置博客rss订阅"></a>九.DLC  7—设置博客rss订阅</h2><p>简易信息聚合是“Really Simple Syndication”或“Richsite summary”(网站内容摘要)的中文名字。是站点用来和其他站点之间共享内容的一种简易方式。英文缩写为RSS技术。</p><p>RSS是一种信息聚合的技术，是某一站点和其他站点之间共享内容的一种简易信息发布与传递的方式，使得一个网站可以方便的调用其他提供<a href="https://baike.baidu.com/item/RSS%E8%AE%A2%E9%98%85?fromModule=lemma_inlink">RSS订阅</a>服务的网站内容，从而形成非常高效的信息聚合，让网站发布的内容在更大的范围内传播。他是一种用于共享新闻和其他WEB内容的数据交换规范，也是使用最广泛的一种扩展性标识语言。(<a href="https://baike.baidu.com/item/%E7%AE%80%E6%98%93%E4%BF%A1%E6%81%AF%E8%81%9A%E5%90%88/6453727">粘自百度百科</a>)</p><p>RSS算是比较古老的玩意了,而且需要阅读器支持,我用的是<a href="https://www.innoreader.com/">innoreader</a>,但大多数博客都有,所以我也做一个</p><p>首先安装插件</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">npm <span class="hljs-keyword">install</span> hexo-generator-feed<br></code></pre></td></tr></table></figure><p>然后在主目录下_config.yml添加</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-meta">#RSS订阅</span><br><span class="hljs-symbol">feed:</span> <br><span class="hljs-symbol">type:</span> atom <span class="hljs-meta">#RSS的类型(atom/rss2)</span><br><span class="hljs-symbol">path:</span> atom.xml <span class="hljs-meta">#文件路径,默认是atom.xml/rss2.xml</span><br><span class="hljs-symbol">limit:</span> <span class="hljs-number">20</span> <span class="hljs-meta">#展示文章的数量,使用0或则false代表展示全部</span><br><span class="hljs-symbol">hub:</span> <br><span class="hljs-symbol">content:</span>  <span class="hljs-meta">#在RSS文件中是否包含内容 ,有3个值 true/false默认不填为false</span><br><span class="hljs-symbol">content_limit:</span> <span class="hljs-number">140</span> <span class="hljs-meta">#指定内容的长度作为摘要,仅仅在上面content设置为false和没有自定义的描述出现</span><br><span class="hljs-symbol">content_limit_delim:</span> <span class="hljs-string">&quot; &quot;</span> <span class="hljs-meta">#上面截取描述的分隔符,截取内容是以指定的这个分隔符作为截取结束的标志.在达到规定的内容长度之前最后出现的这个分隔符之前的内容,防止从中间截断</span><br><span class="hljs-symbol">order_by:</span> -date<br><span class="hljs-symbol">icon:</span> <span class="hljs-meta">#icon.png</span><br></code></pre></td></tr></table></figure><p>这样在我们hexo g的时候就会生成atom.xml文件</p><p><img src="/Emokable%E7%9A%84%E4%BB%8E%E9%9B%B6%E6%90%AD%E5%BB%BAHexo%E5%8D%9A%E5%AE%A2%E8%AE%B0%E5%BD%95/image-20230112195456203.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="在/public下"></p><p>然后<a href="https://www.emokable.top/atom.xml">https://www.emokable.top/atom.xml</a> 就是我的rss订阅连接,打开能看到我们的短消息</p><p><img src="/Emokable%E7%9A%84%E4%BB%8E%E9%9B%B6%E6%90%AD%E5%BB%BAHexo%E5%8D%9A%E5%AE%A2%E8%AE%B0%E5%BD%95/image-20230112195636748.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="博客的所有内容"></p><p>最后看看阅读器效果</p><p><img src="/Emokable%E7%9A%84%E4%BB%8E%E9%9B%B6%E6%90%AD%E5%BB%BAHexo%E5%8D%9A%E5%AE%A2%E8%AE%B0%E5%BD%95/image-20230112200035731.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="文章已经有了"></p><h2 id="十-DLC-8—文章连接生成简化"><a href="#十-DLC-8—文章连接生成简化" class="headerlink" title="十.DLC  8—文章连接生成简化"></a>十.DLC  8—文章连接生成简化</h2><p>主题默认的文章连接是</p><p><code>:year/:month/:day/:tite</code>太长了,所以我最早考虑的是去掉日期(因为文章里面已经有日期了),只保留标题<code>permalink: :title/</code>.</p><p>但是这样虽然看起来简化了,实际上中文连接在互联网的支持还是不够</p><p><img src="/Emokable%E7%9A%84%E4%BB%8E%E9%9B%B6%E6%90%AD%E5%BB%BAHexo%E5%8D%9A%E5%AE%A2%E8%AE%B0%E5%BD%95/image-20230112214112913.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="虽然这样看上去还算正常"></p><p><img src="/Emokable%E7%9A%84%E4%BB%8E%E9%9B%B6%E6%90%AD%E5%BB%BAHexo%E5%8D%9A%E5%AE%A2%E8%AE%B0%E5%BD%95/image-20230112214238904.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="汉字会变成不知所谓的样子"></p><p>考虑过再次更改文章样式,比如换成随机数字字母或者拼音</p><p>参考了这篇博客<a href="https://cungudafa.gitee.io/post/9958.html">cungudafa姑 </a>,但最终还是没有采用……(人就是懒)</p><p><strong>字母</strong>:</p><p>安装插件:</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">npm install hexo-abbrlink <span class="hljs-comment">--save</span><br></code></pre></td></tr></table></figure><p>文章生成处修改为    <code>permalink: :abbrlink.html</code></p><p>在插入处增加代码段:</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">abbrlink:</span><br><span class="hljs-symbol">alg:</span> crc16<span class="hljs-meta">#算法,默认crc16,可选crc32</span><br><span class="hljs-symbol">rep:</span> hex<span class="hljs-meta">#进制, 默认dec-10进制,可选hex-16进制</span><br></code></pre></td></tr></table></figure><p><img src="/Emokable%E7%9A%84%E4%BB%8E%E9%9B%B6%E6%90%AD%E5%BB%BAHexo%E5%8D%9A%E5%AE%A2%E8%AE%B0%E5%BD%95/image-20230112214732469.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="此处修改,不过我最终还是换回去了"></p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs 1c">效果:<br>crc16 <span class="hljs-meta">&amp; hex https:<span class="hljs-comment">//www.emokable.com/66c8.html </span></span><br><br>crc16 <span class="hljs-meta">&amp; dec https:<span class="hljs-comment">//www.emokable.com/65535.html</span></span><br><br>crc32 <span class="hljs-meta">&amp; hex https:<span class="hljs-comment">//www.emokable.com/8ddf18fb.html </span></span><br><br>crc32 <span class="hljs-meta">&amp; dec https:<span class="hljs-comment">//www.emokable.com/1690090958.html</span></span><br></code></pre></td></tr></table></figure><p><strong>拼音:</strong></p><p>安装插件: </p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">npm install hexo-permalink-pinyin <span class="hljs-comment">--save</span><br></code></pre></td></tr></table></figure><p>在下方相同位置插入</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">permalink_pinyin:</span><br><span class="hljs-symbol">enable:</span> true<br><span class="hljs-symbol">separator:</span> <span class="hljs-string">&#x27;-&#x27;</span><span class="hljs-meta">#间隔符</span><br></code></pre></td></tr></table></figure><p>但最后我还是都没采用,因为我试了一下,网页是可以正常生成的,但是图片连接出了问题(我是引用的本地图片),最后懒得去矫正了,如果在写博客之前就修改应该是不错的选择.</p><h2 id="十一-DLC-9—添加站点运行时间"><a href="#十一-DLC-9—添加站点运行时间" class="headerlink" title="十一.DLC  9—添加站点运行时间"></a>十一.DLC  9—添加站点运行时间</h2><p>经常看到别人的博客下面都会有显示站点时间的字段,这既反映了博客搭建的历史,和博主的用心程度.所以我也搞一个.</p><p>不需要安装什么插件,直接进入博客主题目录下的这个路径</p><p><img src="/Emokable%E7%9A%84%E4%BB%8E%E9%9B%B6%E6%90%AD%E5%BB%BAHexo%E5%8D%9A%E5%AE%A2%E8%AE%B0%E5%BD%95/image-20230113131305582.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="不是fluid主题的按自己的来"></p><p>然后修改footer.esj,注意还是要根据博客主题找到恰当位置来改</p><p><img src="/Emokable%E7%9A%84%E4%BB%8E%E9%9B%B6%E6%90%AD%E5%BB%BAHexo%E5%8D%9A%E5%AE%A2%E8%AE%B0%E5%BD%95/image-20230113131655975.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="fluid要改的在footer文件里"></p><p><img src="/Emokable%E7%9A%84%E4%BB%8E%E9%9B%B6%E6%90%AD%E5%BB%BAHexo%E5%8D%9A%E5%AE%A2%E8%AE%B0%E5%BD%95/image-20230113131731088.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="一个是数据,一个是备案信息,我们修改数据就行了"></p><p>直接在末尾插入下述代码</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;sitetime&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">language</span>=<span class="hljs-string">javascript</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">siteTime</span>(<span class="hljs-params"></span>)&#123;</span><br><span class="language-javascript"><span class="hljs-variable language_">window</span>.<span class="hljs-built_in">setTimeout</span>(<span class="hljs-string">&quot;siteTime()&quot;</span>, <span class="hljs-number">1000</span>);</span><br><span class="language-javascript"><span class="hljs-keyword">var</span> seconds = <span class="hljs-number">1000</span>;</span><br><span class="language-javascript"><span class="hljs-keyword">var</span> minutes = seconds * <span class="hljs-number">60</span>;</span><br><span class="language-javascript"><span class="hljs-keyword">var</span> hours = minutes * <span class="hljs-number">60</span>;</span><br><span class="language-javascript"><span class="hljs-keyword">var</span> days = hours * <span class="hljs-number">24</span>;</span><br><span class="language-javascript"><span class="hljs-keyword">var</span> years = days * <span class="hljs-number">365</span>;</span><br><span class="language-javascript"><span class="hljs-keyword">var</span> today = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>();</span><br><span class="language-javascript"><span class="hljs-keyword">var</span> todayYear = today.<span class="hljs-title function_">getFullYear</span>();</span><br><span class="language-javascript"><span class="hljs-keyword">var</span> todayMonth = today.<span class="hljs-title function_">getMonth</span>()+<span class="hljs-number">1</span>;</span><br><span class="language-javascript"><span class="hljs-keyword">var</span> todayDate = today.<span class="hljs-title function_">getDate</span>();</span><br><span class="language-javascript"><span class="hljs-keyword">var</span> todayHour = today.<span class="hljs-title function_">getHours</span>();</span><br><span class="language-javascript"><span class="hljs-keyword">var</span> todayMinute = today.<span class="hljs-title function_">getMinutes</span>();</span><br><span class="language-javascript"><span class="hljs-keyword">var</span> todaySecond = today.<span class="hljs-title function_">getSeconds</span>();</span><br><span class="language-javascript"><span class="hljs-comment">/* </span></span><br><span class="hljs-comment"><span class="language-javascript">Date.UTC() -- 返回date对象距世界标准时间(UTC)1970年1月1日午夜之间的毫秒数(时间戳)</span></span><br><span class="hljs-comment"><span class="language-javascript">year - 作为date对象的年份，为4位年份值</span></span><br><span class="hljs-comment"><span class="language-javascript">month - 0-11之间的整数，做为date对象的月份</span></span><br><span class="hljs-comment"><span class="language-javascript">day - 1-31之间的整数，做为date对象的天数</span></span><br><span class="hljs-comment"><span class="language-javascript">hours - 0(午夜24点)-23之间的整数，做为date对象的小时数</span></span><br><span class="hljs-comment"><span class="language-javascript">minutes - 0-59之间的整数，做为date对象的分钟数</span></span><br><span class="hljs-comment"><span class="language-javascript">seconds - 0-59之间的整数，做为date对象的秒数</span></span><br><span class="hljs-comment"><span class="language-javascript">microseconds - 0-999之间的整数，做为date对象的毫秒数</span></span><br><span class="hljs-comment"><span class="language-javascript">        */</span></span><br><span class="language-javascript"><span class="hljs-keyword">var</span> t1 = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">UTC</span>(<span class="hljs-number">2023</span>,<span class="hljs-number">01</span>,<span class="hljs-number">09</span>,<span class="hljs-number">15</span>,<span class="hljs-number">00</span>,<span class="hljs-number">00</span>); <span class="hljs-comment">//北京时间2023年1月9日</span></span><br><span class="language-javascript"><span class="hljs-keyword">var</span> t2 = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">UTC</span>(todayYear,todayMonth,todayDate,todayHour,todayMinute,todaySecond);</span><br><span class="language-javascript"><span class="hljs-keyword">var</span> diff = t2-t1;</span><br><span class="language-javascript"><span class="hljs-keyword">var</span> diffYears = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(diff/years);</span><br><span class="language-javascript"><span class="hljs-keyword">var</span> diffDays = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>((diff/days)-diffYears*<span class="hljs-number">365</span>);</span><br><span class="language-javascript"><span class="hljs-keyword">var</span> diffHours = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>((diff-(diffYears*<span class="hljs-number">365</span>+diffDays)*days)/hours);</span><br><span class="language-javascript"><span class="hljs-keyword">var</span> diffMinutes = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>((diff-(diffYears*<span class="hljs-number">365</span>+diffDays)*days-diffHours*hours)/minutes);</span><br><span class="language-javascript"><span class="hljs-keyword">var</span> diffSeconds = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>((diff-(diffYears*<span class="hljs-number">365</span>+diffDays)*days-diffHours*hours-diffMinutes*minutes)/seconds);</span><br><span class="language-javascript"><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;sitetime&quot;</span>).<span class="hljs-property">innerHTML</span>=<span class="hljs-string">&quot; 存活&quot;</span>+<span class="hljs-comment">/*diffYears+&quot; 年 &quot;+*/</span>diffDays+<span class="hljs-string">&quot; 天 &quot;</span>+diffHours+<span class="hljs-string">&quot; 小时 &quot;</span>+diffMinutes+<span class="hljs-string">&quot; 分钟 &quot;</span>+diffSeconds+<span class="hljs-string">&quot; 秒&quot;</span>;</span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript"><span class="hljs-title function_">siteTime</span>();</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br></code></pre></td></tr></table></figure><p>效果如下:</p><p><img src="/Emokable%E7%9A%84%E4%BB%8E%E9%9B%B6%E6%90%AD%E5%BB%BAHexo%E5%8D%9A%E5%AE%A2%E8%AE%B0%E5%BD%95/image-20230113132446163.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="小站建立不久,历史底蕴尚浅"></p><p>突然发现fluid的<a href="https://hexo.fluid-dev.com/posts/fluid-footer-custom/">官方博客</a>也有这个功能的实现,我换成另一个版本的时间统计了.</p><p><img src="/Emokable%E7%9A%84%E4%BB%8E%E9%9B%B6%E6%90%AD%E5%BB%BAHexo%E5%8D%9A%E5%AE%A2%E8%AE%B0%E5%BD%95/image-20230113160744449.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="俩都可以用"></p><h2 id="十二-DLC-10—添加steam库支持"><a href="#十二-DLC-10—添加steam库支持" class="headerlink" title="十二. DLC  10—添加steam库支持"></a>十二. DLC  10—添加steam库支持</h2><p>本来想写写steam玩了什么游戏的,突然想到再博客里加这个功能,github一搜,便找到一个,这个功能的实现我是照搬的<a href="https://github.com/HCLonely/hexo-steam-games">这个项目</a>,如果感兴趣可以去点个star支持一下原作者.</p><h4 id="安装方法-（此插件原作者已修改过了，部分配置有所不同，目前还有一些bug，转至仓库页看吧）"><a href="#安装方法-（此插件原作者已修改过了，部分配置有所不同，目前还有一些bug，转至仓库页看吧）" class="headerlink" title="安装方法:（此插件原作者已修改过了，部分配置有所不同，目前还有一些bug，转至仓库页看吧）"></a><del>安装方法:</del>（此插件原作者已修改过了，部分配置有所不同，目前还有一些bug，转至仓库页看吧）</h4><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">npm install hexo-steam-games <span class="hljs-comment">--save</span><br></code></pre></td></tr></table></figure><p>将下面的配置写入站点的配置文件 <code>_config.yml</code> 里(不是主题的配置文件).</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">steam:</span><br>  <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span>   <span class="hljs-comment"># enable: 是否启用</span><br>  <span class="hljs-attr">steamId:</span> <span class="hljs-string">&#x27;76561199236571966&#x27;</span> <span class="hljs-comment">#steam 64位Id,steamId: steam 64位Id(需要放在引号里面，不然会有BUG), 需要将steam库设置为公开！</span><br>  <span class="hljs-attr">path:</span> <span class="hljs-comment">#path: 番剧页面路径，默认steamgames/index.html</span><br>  <span class="hljs-attr">title:</span> <span class="hljs-string">Steam游戏库</span>  <span class="hljs-comment">#该页面的标题</span><br>  <span class="hljs-attr">quote:</span> <span class="hljs-string">&#x27;&#x27;</span>  <span class="hljs-comment">#写在页面开头的一段话,支持html语法</span><br>  <span class="hljs-attr">tab:</span> <span class="hljs-string">recent</span>   <span class="hljs-comment">#all或recent, all: 所有游戏, recent: 最近游玩的游戏</span><br>  <span class="hljs-attr">length:</span> <span class="hljs-number">1000</span>  <span class="hljs-comment">#要显示游戏的数量，游戏太多的话可以限制一下</span><br>  <span class="hljs-attr">imgUrl:</span>  <span class="hljs-comment">#图片链接，在quote下面放一张图片，图片链接到Steam个人资料，可留空</span><br>  <span class="hljs-attr">proxy:</span>  <span class="hljs-comment">#如果无法访问steam社区的话请使用代理,这里我采用了和我的clash同样的代理方式</span><br>    <span class="hljs-attr">host:</span>  <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>  <span class="hljs-comment"># 代理ip或域名</span><br>    <span class="hljs-attr">port:</span>  <span class="hljs-number">7890</span>  <span class="hljs-comment">#代理端口</span><br>  <span class="hljs-attr">extra_options:</span>  <span class="hljs-comment">#此配置会扩展到Hexo的page变量中</span><br>    <span class="hljs-attr">key:</span> <span class="hljs-string">value</span><br></code></pre></td></tr></table></figure><p>再到主题页的_config.yml里去添加菜单选项,具体操作各异,就不细说了.</p><h4 id="使用语法"><a href="#使用语法" class="headerlink" title="使用语法:"></a>使用语法:</h4><p><code>hexo steam -u</code>命令更新steam游戏库数据</p><p><code>hexo steam -d </code>删除游戏库数据</p><p>由于steam日常被墙,<code>hexo steam -u</code>命令获取游戏库数据失败,可以按插件文档操作,手动获取</p><blockquote><ol><li><p>浏览器打开<code>https://steamcommunity.com/profiles/&#123;steamId&#125;/games?tab=&#123;tab&#125;</code>, <code>&#123;steamId&#125;</code>和<code>&#123;tab&#125;</code>分别替换为上面配置中提到的<code>steamId</code>和<code>tab</code></p></li><li><p>网页加载完成后，打开浏览器控制台(按<code>F12</code>)，输入以下代码并回车：</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs perl">let script = jQuery(<span class="hljs-string">&#x27;script[language=&quot;javascript&quot;]&#x27;</span>);<br>var games = [];<br><span class="hljs-keyword">for</span> (let i = <span class="hljs-number">0</span>; i &lt; script.length; i++) &#123;<br>  <span class="hljs-keyword">if</span> (script.e<span class="hljs-string">q(i)</span>.html().includes(<span class="hljs-string">&quot;rgGames&quot;</span>)) &#123;<br>    let rgGames = script.e<span class="hljs-string">q(i)</span>.html().match(<span class="hljs-regexp">/var.*?rgGames.*?=.*?(\[[\w\W]*?\&#125;\&#125;\]);/</span>);<br>    <span class="hljs-keyword">if</span> (rgGames) &#123;<br>      games = JSON.parse(rgGames[<span class="hljs-number">1</span>]);<br>      <span class="hljs-keyword">break</span>;<br>    &#125;<br>  &#125;<br>&#125;<br>document.write(JSON.stringify(games))<br></code></pre></td></tr></table></figure></li><li><p>将生成的内容复制到<code>博客根目录/node_modules/hexo-steam-games/data/games.json</code>文件内，如果没有对应的文件或目录，请自行创建</p></li></ol></blockquote><h2 id="十三-DLC-11—添加天气组件"><a href="#十三-DLC-11—添加天气组件" class="headerlink" title="十三. DLC  11—添加天气组件"></a>十三. DLC  11—添加天气组件</h2><p>我用的是和风天气提供的免费服务,当然其他的天气服务也可以,都是类似的操作..</p><p>点击这个网站里申请样式<a href="https://widget.qweather.com/">和风天气</a></p><p><img src="/Emokable%E7%9A%84%E4%BB%8E%E9%9B%B6%E6%90%AD%E5%BB%BAHexo%E5%8D%9A%E5%AE%A2%E8%AE%B0%E5%BD%95/image-20230125231454171.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="我用的简约插件"></p><p>然后自己选择显示的内容</p><p><img src="/Emokable%E7%9A%84%E4%BB%8E%E9%9B%B6%E6%90%AD%E5%BB%BAHexo%E5%8D%9A%E5%AE%A2%E8%AE%B0%E5%BD%95/image-20230125231602400.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="随便选啦~"></p><p>再到博客主题目录下layout&#x2F;_partials路径新建weather.ejs文件(或者你喜欢的名字),粘贴上面过程生成的所有代码.</p><p><img src="/Emokable%E7%9A%84%E4%BB%8E%E9%9B%B6%E6%90%AD%E5%BB%BAHexo%E5%8D%9A%E5%AE%A2%E8%AE%B0%E5%BD%95/image-20230125232252572.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="这里呀"></p><p>最后修改navigation.ejs,在合适位置插入</p><figure class="highlight erb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs erb"><span class="language-xml"><span class="hljs-comment">&lt;!-- 和风天气--&gt;</span>&gt;</span><br><span class="language-xml">    &lt;%-</span><span class="language-ruby"> partial(<span class="hljs-string">&#x27;_partials/weather.ejs&#x27;</span>)</span><span class="language-xml">%&gt;</span><br></code></pre></td></tr></table></figure><p>最后hexo g ,hexo s就可以调试测试是否正确显示了.</p><p><img src="/Emokable%E7%9A%84%E4%BB%8E%E9%9B%B6%E6%90%AD%E5%BB%BAHexo%E5%8D%9A%E5%AE%A2%E8%AE%B0%E5%BD%95/image-20230125232326292.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="这里"></p><p><img src="/Emokable%E7%9A%84%E4%BB%8E%E9%9B%B6%E6%90%AD%E5%BB%BAHexo%E5%8D%9A%E5%AE%A2%E8%AE%B0%E5%BD%95/image-20230125232353021.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="图例"></p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo</tag>
      
      <tag>blog</tag>
      
      <tag>fluid</tag>
      
      <tag>美化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络实践实验六-TCP</title>
    <link href="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E8%B7%B5%E5%AE%9E%E9%AA%8C%E5%85%AD-TCP/"/>
    <url>/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E8%B7%B5%E5%AE%9E%E9%AA%8C%E5%85%AD-TCP/</url>
    
    <content type="html"><![CDATA[<h1 id="华东师范大学软件学院实验报告"><a href="#华东师范大学软件学院实验报告" class="headerlink" title="华东师范大学软件学院实验报告"></a>华东师范大学软件学院实验报告</h1><table><thead><tr><th><strong>实验课程</strong>：计算机网络实践</th><th><strong>年级</strong>：21级</th><th><strong>实验成绩</strong>：</th></tr></thead><tbody><tr><td><strong>实验名称</strong>：TCP</td><td><strong>姓名</strong>：emokable</td><td></td></tr><tr><td><strong>实验编号</strong>：X</td><td><strong>学号</strong>：X</td><td><strong>实验日期</strong>：12月22日</td></tr><tr><td><strong>指导教师</strong>：章玥</td><td><strong>组号</strong>：</td><td><strong>实验时间</strong>：13:00-14:30</td></tr></tbody></table><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E8%B7%B5%E5%AE%9E%E9%AA%8C%E5%85%AD-TCP/clip_image001.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="img"> </p><h2 id="一、实验目的"><a href="#一、实验目的" class="headerlink" title="一、实验目的"></a><strong>一、实验目的</strong></h2><ol><li><p>熟悉使用wireshark软件进行抓取TCP数据包 ；</p></li><li><p>分析抓取到的TCP数据包，掌握TCP数据包结构；</p></li><li><p>掌握TCP数据包各字段的含义；</p></li><li><p>掌握TCP连接建立和释放的步骤；</p></li><li><p>掌握TCP数据传输过程；</p></li></ol><h2 id="二、实验内容与实验步骤"><a href="#二、实验内容与实验步骤" class="headerlink" title="二、实验内容与实验步骤"></a><strong>二、实验内容与实验步骤</strong></h2><p><strong><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E8%B7%B5%E5%AE%9E%E9%AA%8C%E5%85%AD-TCP/clip_image003.jpg" srcset="/img/mahmoud-habibi.gif" lazyload alt="img"></strong></p><ol><li><p>以<a href="http://old.ecnu.edu.cn/site/xiaoli/2016.jpg%E4%B8%BA%E4%BE%8B%EF%BC%8C%E4%BD%BF%E7%94%A8wget%E7%A1%AE%E8%AE%A4URL%E6%9C%89%E6%95%88%EF%BC%8C%E6%88%96%E8%80%85%E4%BD%BF%E7%94%A8%E4%BD%A0%E6%84%9F%E5%85%B4%E8%B6%A3%E7%9A%84URL%EF%BC%9B">http://old.ecnu.edu.cn/site/xiaoli/2016.jpg为例，使用wget确认URL有效，或者使用你感兴趣的URL；</a></p></li><li><p>启动Wireshark，在菜单栏的捕获-&gt;选项中进行设置，选择已连接的以太网，设置捕获过滤器为tcp and host xx.xx.xx，xx.xx.xx是要从中获取内容的服务器名称，如上述例子中的old.ecnu.edu.cn；</p></li><li><p>捕获开始后，重复第一步，重新发送请求；</p></li><li><p>命令完成后，停止捕获。</p></li></ol><h2 id="三、实验环境"><a href="#三、实验环境" class="headerlink" title="三、实验环境"></a><strong>三、实验环境</strong></h2><p>Windows10 21H2</p><p>Wireshark-win64-2.0.3</p><p>wget-1.17.1-win64</p><h2 id="四、实验过程与分析"><a href="#四、实验过程与分析" class="headerlink" title="四、实验过程与分析"></a><strong>四、实验过程与分析</strong></h2><p>输入wget <a href="http://old.ecnu.edu.cn/site/xiaoli/2016.jpg">http://old.ecnu.edu.cn/site/xiaoli/2016.jpg</a> 确认该链接无效</p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E8%B7%B5%E5%AE%9E%E9%AA%8C%E5%85%AD-TCP/clip_image005.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="img"></p><p>换一个试试wget <a href="http://staff.ustc.edu.cn/~zuojin/arts/19840205.pdf%EF%BC%88%E9%9A%8F%E4%BE%BF%E6%89%BE%E7%9A%84pdf%E6%96%87%E4%BB%B6%EF%BC%89">http://staff.ustc.edu.cn/~zuojin/arts/19840205.pdf（随便找的pdf文件）</a></p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E8%B7%B5%E5%AE%9E%E9%AA%8C%E5%85%AD-TCP/clip_image007.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="img"></p><p>启动Wireshark，在菜单栏的捕获-&gt;选项中进行设置，选择已连接的以太网，设置捕获过滤器为tcp and host staff.ustc.edu.cn，我们主要观察客户端与服务器之间的tcp流。如图</p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E8%B7%B5%E5%AE%9E%E9%AA%8C%E5%85%AD-TCP/clip_image009.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="img">   </p><p>当wget命令结束后，停止wireshark捕获，得到</p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E8%B7%B5%E5%AE%9E%E9%AA%8C%E5%85%AD-TCP/clip_image011.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="img"></p><h2 id="五、实验结果总结"><a href="#五、实验结果总结" class="headerlink" title="五、实验结果总结"></a><strong>五、实验结果总结</strong></h2><p>1、根据你的理解，绘制TCP报文段的结构图（包括头部各字段的位置及大小）。</p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E8%B7%B5%E5%AE%9E%E9%AA%8C%E5%85%AD-TCP/clip_image013.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="img"></p><p>源端口2byte -目的端口2byte</p><p>序列号4byte</p><p>确认号4byte</p><p>Flags 2byte 窗口2byte</p><p>检验和2byte 紧急指针2byte （以上位固定首部20byte）</p><p>长度2byte  tcp分段信息1440byte</p><p>Tcp段共计1460字节</p><h3 id="在你捕获到的结果中，找到设置了SYN标志的TCP段及其后的数据包，完成以下问题："><a href="#在你捕获到的结果中，找到设置了SYN标志的TCP段及其后的数据包，完成以下问题：" class="headerlink" title="在你捕获到的结果中，找到设置了SYN标志的TCP段及其后的数据包，完成以下问题："></a><strong>在你捕获到的结果中，找到设置了SYN标志的TCP段及其后的数据包，完成以下问题：</strong></h3><p>1、 绘制三次握手的时序图，直到并包括建立连接后计算机发送的第一个数据包（HTTP GET请求），包括</p><p>•    每个数据段的序列号和Ack标号；</p><p>•    本地计算机发送或接收每个数据段的时间（以毫秒为单位）；</p><p>•    本地计算机从发送SYN段到接收到SYN-ACK段的往返时间；</p><p>2、SYN数据包上携带哪些TCP 选项？</p><p>3、传输完成后，TCP连接会以四次挥手或一端发送RST数据包的方式断开，同1一样，绘制TCP连接释放的时序图（从发出第一个FIN或RST到连接断开为止）。</p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E8%B7%B5%E5%AE%9E%E9%AA%8C%E5%85%AD-TCP/clip_image014.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="img"></p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E8%B7%B5%E5%AE%9E%E9%AA%8C%E5%85%AD-TCP/clip_image016.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="img"></p><p>往返时间12.62ms</p><p>含有以下tcp选项，共12bytes</p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E8%B7%B5%E5%AE%9E%E9%AA%8C%E5%85%AD-TCP/clip_image018.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="img"></p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E8%B7%B5%E5%AE%9E%E9%AA%8C%E5%85%AD-TCP/clip_image020.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="img"></p><p>找不到四次挥手的数据包，只有两次挥手，重新按照提供的实验案例来分析</p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E8%B7%B5%E5%AE%9E%E9%AA%8C%E5%85%AD-TCP/clip_image022.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="img"></p><p>   <img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E8%B7%B5%E5%AE%9E%E9%AA%8C%E5%85%AD-TCP/clip_image002.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="docx转md这个表格只能截图了.."></p><ol start="4"><li>观察wireshark生成的IO图表</li></ol><h3 id="在“统计”菜单下，选择“IO图表”，以查看数据包速率。"><a href="#在“统计”菜单下，选择“IO图表”，以查看数据包速率。" class="headerlink" title="在“统计”菜单下，选择“IO图表”，以查看数据包速率。"></a><strong>在“统计”菜单下，选择“IO图表”，以查看数据包速率。</strong></h3><p>•    调整过滤器为“tcp.srcport&#x3D;&#x3D;80”仅查看下载数据包，重新绘图；</p><p>•    调整过滤器为“tcp.dstport&#x3D;&#x3D;80”仅查看上传数据包，重新绘图；</p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E8%B7%B5%E5%AE%9E%E9%AA%8C%E5%85%AD-TCP/clip_image031.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="img"></p><p><strong>通过你对数据传输的理解，回答以下问题：</strong></p><p>1、    实验中下载的大概速率为多少？（以packets&#x2F;s和bits&#x2F;s为单位）</p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E8%B7%B5%E5%AE%9E%E9%AA%8C%E5%85%AD-TCP/clip_image033.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="img"></p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E8%B7%B5%E5%AE%9E%E9%AA%8C%E5%85%AD-TCP/clip_image035.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="img"></p><p>下载速率最高100packets&#x2F;s，1.2*10^6bits&#x2F;s</p><p>2、    下载内容（即TCP有效负载）占下载率的百分比是多少？</p><p>筛选srcport&#x3D;&#x3D;80，选取其中一个数据包</p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E8%B7%B5%E5%AE%9E%E9%AA%8C%E5%85%AD-TCP/clip_image037.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="img"></p><p>1440&#x2F;1494&#x3D;96.64%</p><p>3．实验中上传的大概速率为多少？（以packets&#x2F;s和bits&#x2F;s为单位）</p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E8%B7%B5%E5%AE%9E%E9%AA%8C%E5%85%AD-TCP/clip_image039.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="img"></p><p>最高18packets&#x2F;s，7800bits&#x2F;s</p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E8%B7%B5%E5%AE%9E%E9%AA%8C%E5%85%AD-TCP/clip_image041.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="img"></p><ol start="4"><li>如果最近从服务器收到的TCP数据段的序列号是X，那么下一个发送TCP报文中的Ack号是多少？</li></ol><p>X+n，n为数据长度字节数</p><h3 id="在完成本实验后继续探索TCP协议："><a href="#在完成本实验后继续探索TCP协议：" class="headerlink" title="在完成本实验后继续探索TCP协议："></a><strong>在完成本实验后继续探索TCP协议：</strong></h3><p>•    探索TCP的拥塞控制和经典AIMD策略。</p><p>TCP 采用基于窗口的方法进行拥塞控制。该方法属于闭环控制法。TCP发送方维持一个拥塞窗口 CWND (Congestion Window)。拥塞窗口的大小取决于网络的拥塞程度，并且动态地在变化。只要网络没有出现拥塞，拥塞窗口就可以增大，发送更多分组，提高网络的利用率。但只要网络出现拥塞或有可能出现拥塞，减小拥塞窗口，减少分组数，缓解网络拥塞</p><p>更深入地探索TCP的可靠性机制。捕获包括段丢失的TCP连接，查看什么触发重新传输以及何时触发，另外查看往返时间估算工具。</p><p>触发超时重传：发送的请求报文没有到达对方；对方发送的ACK报文没有接收到速重传机制快速重传机制不以时间为驱动,而是以数据驱动为驱动.SACK&#x2F;d-sack，滑动窗口</p><p>•    查看包括SACK在内的选项的使用以了解详细信息。</p><p>SACK是一个TCP的选项，来允许TCP单独确认非连续的片段，用于告知真正丢失的包，只重传丢失的片段。要使用SACK，2个设备必须同时支持SACK才可以，建立连接的时候需要使用SACK Permitted的option，如果允许，后续的传输过程中TCP segment中的可以携带SACK option，这个option内容包含一系列的非连续的没有确认的数据的seq range。 </p><p>•    TCP是Web的基础传输层。可以通过设置并发连接来查看浏览器如何使用TCP。</p><h2 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a><strong>六、总结</strong></h2><p>学会通过 Wireshark 获取 TCP 消息，对TCP的连接（三次握手）和释放过程（四次挥手）有了更深的理解。了解了TCP数据包各字段的含义，掌握了TCP连接建立和释放的步骤，掌握了TCP数据传输阶段的过程。对TCP包头的结构更了解了。不过在实验抓包中发现有些http链接抓不到四次挥手，于是也部分借用了标准案例里的抓包来分析。</p><p>还有就是i&#x2F;o图表还是有些不一样，总感觉很怪。</p><hr><p>这个系列就到此为止,这学期操作系统的资料在学校电脑上而且很烦杂,回家懒得弄了…</p>]]></content>
    
    
    <categories>
      
      <category>学习资料</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络实践</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络实践实验五-UDP</title>
    <link href="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E8%B7%B5%E5%AE%9E%E9%AA%8C%E4%BA%94-UDP/"/>
    <url>/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E8%B7%B5%E5%AE%9E%E9%AA%8C%E4%BA%94-UDP/</url>
    
    <content type="html"><![CDATA[<h1 id="华东师范大学软件学院实验报告"><a href="#华东师范大学软件学院实验报告" class="headerlink" title="华东师范大学软件学院实验报告"></a>华东师范大学软件学院实验报告</h1><table><thead><tr><th><strong>实验课程</strong>：计算机网络实践</th><th><strong>年级</strong>：2021级</th><th><strong>实验成绩</strong>：</th></tr></thead><tbody><tr><td><strong>实验名称</strong>：UDP</td><td><strong>姓名</strong>：emokable</td><td></td></tr><tr><td><strong>实验编号</strong>：X</td><td><strong>学号</strong>：X</td><td><strong>实验日期</strong>：2022&#x2F;12&#x2F;15</td></tr><tr><td><strong>指导教师</strong>：章玥</td><td><strong>组号</strong>：</td><td><strong>实验时间</strong>：2022&#x2F;12&#x2F;15</td></tr></tbody></table><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E8%B7%B5%E5%AE%9E%E9%AA%8C%E4%BA%94-UDP/clip_image001.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="img"> </p><h2 id="一、实验目的"><a href="#一、实验目的" class="headerlink" title="一、实验目的"></a><strong>一、实验目的</strong></h2><ol><li><p>学会通过Wireshark获取UDP消息</p></li><li><p>掌握UDP数据包结构</p></li><li><p>掌握UDP数据包各字段的含义</p></li><li><p>了解UDP协议适用领域</p></li></ol><h2 id="二、实验内容与实验步骤"><a href="#二、实验内容与实验步骤" class="headerlink" title="二、实验内容与实验步骤"></a><strong>二、实验内容与实验步骤</strong></h2><p>UDP报文头部结构：</p><p><strong><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E8%B7%B5%E5%AE%9E%E9%AA%8C%E4%BA%94-UDP/clip_image003.jpg" srcset="/img/mahmoud-habibi.gif" lazyload alt="img"></strong></p><h2 id="三、实验环境"><a href="#三、实验环境" class="headerlink" title="三、实验环境"></a><strong>三、实验环境</strong></h2><p>Windows 10 专业版21H2</p><p>Wireshark-win64-2.0.3</p><p>wget-1.17.1-win64</p><h2 id="四、实验过程与分析"><a href="#四、实验过程与分析" class="headerlink" title="四、实验过程与分析"></a><strong>四、实验过程与分析</strong></h2><ol><li>启动Wireshark，在菜单栏的捕获-&gt;选项中进行设置，选择已连接的以太网，设置捕获过滤器为“udp”，关闭混杂模式；</li></ol><p><strong><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E8%B7%B5%E5%AE%9E%E9%AA%8C%E4%BA%94-UDP/clip_image005.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="img"></strong></p><p>   2.点击开始，打开浏览器，在地址栏中输入网址浏览，例如<a href="http://www.baidu.com;/">www.baidu.com；</a> </p><ol start="3"><li><p>打开Wireshark， 停止捕获；</p></li><li><p>查看Wireshark界面中抓取的UDP数据包。</p></li></ol><p><strong><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E8%B7%B5%E5%AE%9E%E9%AA%8C%E4%BA%94-UDP/clip_image007.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="img"></strong></p><h2 id="五、实验结果总结"><a href="#五、实验结果总结" class="headerlink" title="五、实验结果总结"></a><strong>五、实验结果总结</strong></h2><h3 id="通过查看UDP消息的详细信息，回答以下问题："><a href="#通过查看UDP消息的详细信息，回答以下问题：" class="headerlink" title="通过查看UDP消息的详细信息，回答以下问题："></a><strong>通过查看UDP消息的详细信息，回答以下问题：</strong></h3><p>1、 UDP数据包头中的Length字段包括哪些部分？UDP有效载荷，还是UDP有效载荷加上UDP头部的总长度，还是UDP有效载荷和UDP头部以及低层协议的头部三者总长度？</p><p>UDP数据包头部中的length指的不是UDP有效载荷，而是有效载荷加上UDP头的长度。</p><p>2、 UDP校验和为多少位？</p><p>**<img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E8%B7%B5%E5%AE%9E%E9%AA%8C%E4%BA%94-UDP/clip_image009.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="img">**如图，2个字节。</p><p>3、 整个UDP头部的长度为多少字节？</p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E8%B7%B5%E5%AE%9E%E9%AA%8C%E4%BA%94-UDP/clip_image011.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="img"></p><p>8个字节</p><h3 id="为了了解UDP在实践中是如何进行传输的，观察数据包的IP头部并思考以下问题："><a href="#为了了解UDP在实践中是如何进行传输的，观察数据包的IP头部并思考以下问题：" class="headerlink" title="为了了解UDP在实践中是如何进行传输的，观察数据包的IP头部并思考以下问题："></a><strong>为了了解UDP在实践中是如何进行传输的，观察数据包的IP头部并思考以下问题：</strong></h3><p>1、 将上层协议标识为UDP的IP头部的协议字段值为多少？</p><p> <strong><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E8%B7%B5%E5%AE%9E%E9%AA%8C%E4%BA%94-UDP/clip_image013.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="img"></strong></p><p>UDP值为0x11，十进制17.</p><p>2、查看源IP地址与目的IP地址都不是你的计算机的IP地址的数据包，并给出这些数据包的目的IP地址。</p><p><strong><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E8%B7%B5%E5%AE%9E%E9%AA%8C%E4%BA%94-UDP/clip_image015.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="img"></strong></p><p>目的ip：239.255.255.250</p><p>百度得知是由于路由器上开了UPnP服务，而这个服务会用SSDP（简单服务发现协议）就是用239.255.255.250的多播地址端口1900来发现UPnp服务，局域网内某台电脑上如果有UPnP服务，每隔一段时间这台机器就会向该多播地址宣告服务在网络上可取，而发送的方式就是基于UDP的HTTP多播方式。</p><p>3、一般UDP消息的长度为多少？</p><p>标识UDP长度为2个字节，共16位，故最大可有0xffff,65535字节。UDP长度包含20字节的IP头部，故UDP全长不超过65515字节，这其中包含8个字节的UDP头部长度，故实际载荷最大不超过65507字节。</p><h3 id="在完成本实验后继续探索UDP协议："><a href="#在完成本实验后继续探索UDP协议：" class="headerlink" title="在完成本实验后继续探索UDP协议："></a><strong>在完成本实验后继续探索UDP协议：</strong></h3><p>了解基于UDP的应用程序的流量，查看数据包大小和丢失率。</p><p>探索流和实时应用程序，查看哪些使用UDP以及哪些使用TCP进行传输。</p><p>Udp: 面向非连接的(正式通信前不必与对方建立连接，不管对方状态就直接发送，像短信，QQ)，不能提供可靠性、流控、差错恢复功能。</p><p>TCP: 面向连接、传输可靠(保证数据正确性,保证数据顺序)、用于传输大量数据(流模式)、速度慢，建立连接需要开销较多(时间，系统资源),http使用tcp</p><h2 id="六-个人总结"><a href="#六-个人总结" class="headerlink" title="六.个人总结"></a><strong>六.个人总结</strong></h2><p>这次是在宿舍台式机上做的实验，总算能用以太网</p>]]></content>
    
    
    <categories>
      
      <category>学习资料</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络实践</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络实践实验四-ARP</title>
    <link href="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E8%B7%B5%E5%AE%9E%E9%AA%8C%E5%9B%9B-ARP/"/>
    <url>/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E8%B7%B5%E5%AE%9E%E9%AA%8C%E5%9B%9B-ARP/</url>
    
    <content type="html"><![CDATA[<h1 id="华东师范大学软件工程学院实验报告"><a href="#华东师范大学软件工程学院实验报告" class="headerlink" title="华东师范大学软件工程学院实验报告"></a>华东师范大学软件工程学院实验报告</h1><table><thead><tr><th><strong>实验课程</strong>：计算机网络实践</th><th>年级：2021级</th><th><strong>实验成绩</strong>：</th></tr></thead><tbody><tr><td><strong>实验名称</strong>：实验四：ARP</td><td><strong>姓名</strong>：emokable</td><td></td></tr><tr><td><strong>实验编号</strong>：X</td><td><strong>学号</strong>：X</td><td><strong>实验日期</strong>：2022&#x2F;12&#x2F;8</td></tr><tr><td><strong>指导教师</strong>：章玥</td><td><strong>组号</strong>：</td><td><strong>实验时间</strong>：13:00</td></tr></tbody></table><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E8%B7%B5%E5%AE%9E%E9%AA%8C%E5%9B%9B-ARP/clip_image001.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="img"> </p><h2 id="一、实验目的"><a href="#一、实验目的" class="headerlink" title="一、实验目的"></a><strong>一、实验目的</strong></h2><ol><li><p>学会通过Wireshark获取ARP消息</p></li><li><p>掌握ARP数据包结构</p></li><li><p>掌握ARP数据包各字段的含义</p></li><li><p>了解ARP协议适用领域</p></li></ol><h2 id="二、实验内容与实验步骤"><a href="#二、实验内容与实验步骤" class="headerlink" title="二、实验内容与实验步骤"></a><strong>二、实验内容与实验步骤</strong></h2><h3 id="获取ARP消息"><a href="#获取ARP消息" class="headerlink" title="获取ARP消息"></a>获取ARP消息</h3><p>1.使用管理员权限打开命令行</p><p>2.输入ipconfig &#x2F;all，可以获得本地计算机的物理地址</p><p>3.输入netstat –r，可以获得本机路由表</p><p>4.输入arp –a，可以查看ARP cache</p><p>5.输入arp –d，可以清空ARP cache</p><h3 id="获取ARP消息-1"><a href="#获取ARP消息-1" class="headerlink" title="获取ARP消息"></a>获取ARP消息</h3><p>1.启动Wireshark，在菜单栏的捕获-&gt;选项中进行设置，选择已连接的以太网，设置捕获过滤器为ARP，将混杂模式设为关闭</p><p>2.点击开始</p><p>3.清空ARP cache</p><p>4.停止捕获</p><p>5.在显示过滤器中输入“eth.addr&#x3D;&#x3D;以太网地址”</p><h2 id="三、实验环境"><a href="#三、实验环境" class="headerlink" title="三、实验环境"></a><strong>三、实验环境</strong></h2><p>Windows10 22H2</p><p>Wireshark-win64-2.0.3</p><p>wget-1.17.1-win64</p><h2 id="四、实验过程与分析"><a href="#四、实验过程与分析" class="headerlink" title="四、实验过程与分析"></a><strong>四、实验过程与分析</strong></h2><p>打开命令行，输入ipconfig &#x2F;all获得本机物理地址。(笔记本使用wlan网络)</p><p><strong><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E8%B7%B5%E5%AE%9E%E9%AA%8C%E5%9B%9B-ARP/clip_image003.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="img"></strong></p><p>输入netstat –r，获得本机路由表</p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E8%B7%B5%E5%AE%9E%E9%AA%8C%E5%9B%9B-ARP/clip_image005.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="img"></p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E8%B7%B5%E5%AE%9E%E9%AA%8C%E5%9B%9B-ARP/clip_image007.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="img"></p><ol><li>启动Wireshark，在菜单栏的捕获-&gt;选项中进行设置，选择已连接的以太网，设置捕获过滤器为ARP，将混杂模式设为关闭</li></ol><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E8%B7%B5%E5%AE%9E%E9%AA%8C%E5%9B%9B-ARP/clip_image009.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="img"></p><p>2.点击开始</p><p>3.输入命令 arp –d ，清空arp存储。然后利用命令arp –a 检查是否成功清空了arp存储</p><p>输入arp –a，查看ARP cache</p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E8%B7%B5%E5%AE%9E%E9%AA%8C%E5%9B%9B-ARP/clip_image011.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="img"></p><p>使用管理员权限打开命令行,才能执行清空arp表的命令</p><p>4.然后浏览任意的网页，促使arp表更新。</p><p>5.在wireshark中捕获了arp报文之后，使用wireshark停止捕获。</p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E8%B7%B5%E5%AE%9E%E9%AA%8C%E5%9B%9B-ARP/clip_image013.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="img"></p><h2 id="五、实验结果总结"><a href="#五、实验结果总结" class="headerlink" title="五、实验结果总结"></a><strong>五、实验结果总结</strong></h2><p>1、通过语句“eth.addr&#x3D;&#x3D;01:02:03:04:05:06”的形式，在wireshark中设置过滤器，找出与自己mac地址相关的arp报文。 Arp报文包括请求报文和应答报文，仔细分析两种报文的格式。</p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E8%B7%B5%E5%AE%9E%E9%AA%8C%E5%9B%9B-ARP/clip_image015.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="img"></p><p><strong>请求:</strong></p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E8%B7%B5%E5%AE%9E%E9%AA%8C%E5%9B%9B-ARP/clip_image017.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="img"></p><p><strong>应答:</strong></p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E8%B7%B5%E5%AE%9E%E9%AA%8C%E5%9B%9B-ARP/clip_image019.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="img"></p><p>具体比较第3题有详细分析</p><p>2.画出你的计算机和本地路由间ARP的请求和应答数据包，标记出请求和应答，为每个数据包给出发送者和接受者的MAC和IP地址。</p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E8%B7%B5%E5%AE%9E%E9%AA%8C%E5%9B%9B-ARP/clip_image021.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="img"></p><ol start="3"><li><p>分析报文，回答问题：</p><p>a.什么样的操作码是用来表示一个请求？应答呢？</p></li></ol><p>Opcode :0x0001表示请求</p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E8%B7%B5%E5%AE%9E%E9%AA%8C%E5%9B%9B-ARP/clip_image023.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="img"></p><p>Opcode :0x0002表示应答</p><p><strong><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E8%B7%B5%E5%AE%9E%E9%AA%8C%E5%9B%9B-ARP/clip_image024.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="img"></strong></p><p>   b.一个请求的ARP的报头有多大？应答呢？</p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E8%B7%B5%E5%AE%9E%E9%AA%8C%E5%9B%9B-ARP/clip_image026.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="img"></p><p>硬件类型：2字节 协议类型：2字节<br> 硬件长度：1字节 协议长度：1字节</p><p>Opcode：2字节   共8字节</p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E8%B7%B5%E5%AE%9E%E9%AA%8C%E5%9B%9B-ARP/clip_image027.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="img"></p><p>硬件类型：2字节 协议类型：2字节<br> 硬件长度：1字节 协议长度：1字节</p><p>Opcode：2字节  共8字节</p><p>   c.对未知目标的MAC地址的请求是什么值？</p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E8%B7%B5%E5%AE%9E%E9%AA%8C%E5%9B%9B-ARP/clip_image029.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="img"></p><p>以太网报头中为ff:ff:ff:ff:ff:ff</p><p>ARP中为00:00:00:00:00:00 <img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E8%B7%B5%E5%AE%9E%E9%AA%8C%E5%9B%9B-ARP/clip_image031.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="img"></p><p>d.什么以太网类型值说明ARP是更高一层的协议？</p><p>以太网中的type为ARP，表明ARP为更高一层协议。</p><p>f.ARP应答是广播吗？</p><p>不是,是单播(只有请求是广播)</p><h3 id="在完成本实验后，思考下列问题："><a href="#在完成本实验后，思考下列问题：" class="headerlink" title="在完成本实验后，思考下列问题："></a>在完成本实验后，思考下列问题：</h3><p>去除过滤器，我们发现还有更多的arp报文。请研究这些额外的arp报文中，有什么其他的功能作用。</p><p>这些报文有的是别的主机发起的请求和回复,还有Gratuitous ARP也称为免费ARP。Gratuitous ARP不同于一般的ARP请求，它并不是期待得到IP相应的MAC地址，而是当主机启动的时候，将发送一个Gratuitous arp请求，即请求自己的IP地址的MAC地址.</p>]]></content>
    
    
    <categories>
      
      <category>学习资料</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络实践</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络实践实验三-IPV4</title>
    <link href="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E8%B7%B5%E5%AE%9E%E9%AA%8C%E4%B8%89-IPV4/"/>
    <url>/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E8%B7%B5%E5%AE%9E%E9%AA%8C%E4%B8%89-IPV4/</url>
    
    <content type="html"><![CDATA[<h1 id="华东师范大学软件学院实验报告"><a href="#华东师范大学软件学院实验报告" class="headerlink" title="华东师范大学软件学院实验报告"></a>华东师范大学软件学院实验报告</h1><table><thead><tr><th><strong>实验课程</strong>：计算机网络实践</th><th><strong>年</strong>级：2021</th><th><strong>实验成绩</strong>：</th></tr></thead><tbody><tr><td><strong>实验名称</strong>：ipv4</td><td><strong>姓名</strong>：emokable</td><td></td></tr><tr><td><strong>实验编号</strong>：X</td><td><strong>学号</strong>：X</td><td><strong>实验日期</strong>：2022&#x2F;12&#x2F;1</td></tr><tr><td><strong>指导教师</strong>：章玥</td><td><strong>组号</strong>：</td><td><strong>实验时间</strong>：13;00-14;30</td></tr></tbody></table><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E8%B7%B5%E5%AE%9E%E9%AA%8C%E4%B8%89-IPV4/clip_image001.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="img"> </p><h2 id="一、实验目的"><a href="#一、实验目的" class="headerlink" title="一、实验目的"></a><strong>一、实验目的</strong></h2><p>​1、学会通过Wireshark分析ip协议 </p><p>​2、了解IP数据报的组成 </p><p>​3、了解IP各部分的含义</p><h2 id="二、实验内容与实验步骤"><a href="#二、实验内容与实验步骤" class="headerlink" title="二、实验内容与实验步骤"></a><strong>二、实验内容与实验步骤</strong></h2><p>​1、获取IP packets </p><p>​2、分析IP packets </p><p>​3、分析Internet Path </p><p>​4、IP 报头checksum 计算</p><h2 id="三、实验环境"><a href="#三、实验环境" class="headerlink" title="三、实验环境"></a><strong>三、实验环境</strong></h2><p>Windows10 22H2</p><p>Wireshark-win64-2.0.3</p><p>wget-1.17.1-win64</p><p><strong>Traceroute工具</strong></p><p><strong>traceroute</strong>，现代Linux系统称为<strong>tracepath</strong>，Windows系统称为<strong>tracert</strong>，是一种电脑网络工具。它可显示数据包在IP网络经过的路由器的IP地址。</p><p>程序是利用增加存活时间（TTL）值来实现其功能的。每当数据包经过一个路由器，其存活时间就会减1。当其存活时间是0时，主机便取消数据包，并发送一个ICMP TTL数据包给原数据包的发出者。</p><p>程序发出的首3个数据包TTL值是1，之后3个是2，如此类推，它便得到一连串数据包路径。注意，IP不保证每个数据包走的路径都一样。</p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E8%B7%B5%E5%AE%9E%E9%AA%8C%E4%B8%89-IPV4/clip_image003.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="https://img-blog.csdn.net/20170301092349308"></p><h2 id="四、实验过程与分析"><a href="#四、实验过程与分析" class="headerlink" title="四、实验过程与分析"></a><strong>四、实验过程与分析</strong></h2><h3 id="实验步骤1-捕获IP-Packets"><a href="#实验步骤1-捕获IP-Packets" class="headerlink" title="实验步骤1-捕获IP Packets"></a>实验步骤1-捕获IP Packets</h3><p>​1、 启动Wireshark，在菜单栏的捕获-&gt;选项中进行设置，选择已连接的以太网，设置捕获过滤器为“tcp port 80”，将混杂模式设为关闭,勾选 enable network name resolution.然后开始捕获。</p><p>​2、 打开windows的命令行，在里面输入wget <a href="http://www.sina.com/">www.sina.com</a></p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E8%B7%B5%E5%AE%9E%E9%AA%8C%E4%B8%89-IPV4/clip_image005.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="img"></p><p>​3、停止捕获。</p><p><strong><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E8%B7%B5%E5%AE%9E%E9%AA%8C%E4%B8%89-IPV4/clip_image007.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="img"></strong></p><h3 id="实验步骤2-捕获Trace"><a href="#实验步骤2-捕获Trace" class="headerlink" title="实验步骤2-捕获Trace"></a><strong>实验步骤2-捕获Trace</strong></h3><p>​<strong>1.启动Wireshark，在菜单栏的捕获-&gt;选项中进行设置，选择已连接的以太网，设置捕获过滤器为“icmp”，将混杂模式设为关闭,勾选 enable network name resolution.然后开始捕获。</strong></p><p>​<strong>2.执行 tracert <a href="http://www.baidu.com/">www.baidu.com</a> 。</strong></p><p>​<strong>3.</strong> <strong>当命令执行结束，则Wireshake中停止捕获，查看Wireshark界面中的封包列表中如果出现数据包则说明抓包成功；</strong></p><p><strong><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E8%B7%B5%E5%AE%9E%E9%AA%8C%E4%B8%89-IPV4/clip_image009.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="img"></strong> </p><p><strong><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E8%B7%B5%E5%AE%9E%E9%AA%8C%E4%B8%89-IPV4/clip_image011.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="img"></strong></p><h2 id="五、实验结果总结"><a href="#五、实验结果总结" class="headerlink" title="五、实验结果总结"></a><strong>五、实验结果总结</strong></h2><p>选择你通过Wireshark捕获到任何一个报文，分析其IP报文头部</p><p><strong>1、</strong> 尽量不要打开教科书，请根据抓到的报文，描绘IP报文头的图片，并指出报文中每个fields的含义所在。<img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E8%B7%B5%E5%AE%9E%E9%AA%8C%E4%B8%89-IPV4/clip_image013.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="img"></p><p>根据wireshark给出的报文结构,从左到右依次可描述为</p><p>版本信息(1-4),头部长度(5-8),服务类型作用域(9-16),总长(17-32),</p><p>标识码(33-34),标志(49-51),段偏移(52-64),</p><p>存活时间(65-72),下一个高层协议(73-80),头部校验和(81-96),</p><p>源地址(97-128),</p><p>目的地址(129-160)</p><h3 id="通过观察Wireshark捕获的报文，来回答下面的问题："><a href="#通过观察Wireshark捕获的报文，来回答下面的问题：" class="headerlink" title="通过观察Wireshark捕获的报文，来回答下面的问题："></a>通过观察Wireshark捕获的报文，来回答下面的问题：</h3><p><strong>1.</strong>   <strong>你的计算机和远程服务器的IP地址是什么？</strong> </p><p><strong><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E8%B7%B5%E5%AE%9E%E9%AA%8C%E4%B8%89-IPV4/clip_image015.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="img"></strong></p><p>我的计算机ip为172.28.197.154,远程服务器为182.61.200.7</p><p><strong>2.“总长度”字段是否包括IP报头加上IP有效负载，或者仅包括IP有效负载？</strong></p><p>总长度包括ip报头与ip有效载荷。</p><p><strong>3.对于不同的数据包，“标识”字段的值如何变化，还是保持不变？例如，对于TCP连接中的所有数据包，它一直保持相同的值，还是对于每个数据包都不同？双向通信的报文是否相同？如果值发生变化，您能看到任何规律吗？</strong></p><p>标识字段值不相同，不同传输方向上部分相同。IPv4 头部中版本号、头部长度、段偏移这些值不变。IPv4 首部中总长度、标识码、生存时间、源地址、目的地址这些字段的值会变化。</p><h3 id="通过观察Wireshark-捕获的报文，来回答下面的问题："><a href="#通过观察Wireshark-捕获的报文，来回答下面的问题：" class="headerlink" title="通过观察Wireshark 捕获的报文，来回答下面的问题："></a><strong>通过观察Wireshark 捕获的报文，来回答下面的问题：</strong></h3><p><strong>4.</strong>   <strong>从您的计算机发送的数据包的TTL字段的初始值是多少？他们是maximum possible value吗？</strong></p><p><strong><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E8%B7%B5%E5%AE%9E%E9%AA%8C%E4%B8%89-IPV4/clip_image017.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="img"></strong></p><p>我的笔记本TTL初始值为64. TTL字段maximum possible value为255，我的电脑值较低。</p><ol><li><strong>查看数据包时如何判断它是否被分段？</strong></li></ol><p>如果收到的IP报头中Don’t fragment为1，则未分片；如果收到的IP报头中Don’t fragment为0，则分片。如图则分片了。</p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E8%B7%B5%E5%AE%9E%E9%AA%8C%E4%B8%89-IPV4/clip_image018.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="img"></p><p><strong>6.</strong>   <strong>IP数据报报头的长度是多少，它是如何被编码进报头长度域的？</strong></p><p>IP数据报报头的长度为20个字节, 头部的前20byte为固定长度，所有IP 数据报必须具有。在头部的固定部分的后面是一些可选字段，其长度是可变的（在图中未画出）。头部中的源地址和目的地址都是IP 协议地址。IP 报头长度域（IHL）以32位字进行计数。当它的值为n时，其所表达的字节数为4n个。本次试验中，报头长度为20&#x2F;4&#x3D;5。</p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E8%B7%B5%E5%AE%9E%E9%AA%8C%E4%B8%89-IPV4/clip_image020.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="img"></p><p><strong>观察traceroute的结果图，来进行结果分析：</strong></p><p>   <strong>使用traceroute的结果，绘制网络路径图。</strong></p><p><strong><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E8%B7%B5%E5%AE%9E%E9%AA%8C%E4%B8%89-IPV4/clip_image021.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="img"></strong> </p><p><strong>图中，显示您的计算机（放在最左侧）和远程服务器（放在最右侧），均显示IP地址，以及它们之间的路径上的路由器，这些路由器以从本机开始的跳数作为距离编号。您可以在捕获的跟踪数据包中找到计算机和远程服务器的IP地址。</strong></p><p><strong><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E8%B7%B5%E5%AE%9E%E9%AA%8C%E4%B8%89-IPV4/clip_image023.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="img"></strong></p><p><strong>观察IP报文的校验和：</strong></p><p><strong><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E8%B7%B5%E5%AE%9E%E9%AA%8C%E4%B8%89-IPV4/clip_image024.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="img"></strong></p><p>蓝色部分为ipv4协议位置,得到4500 005c c92a 0000 0e01 f37a ac1c c59a b63d c807(f37a为校验和,求和时舍去),加之和为 checksum&#x3D;40c81,将4加入,得0c85,取反即得到f37a,与实际校验值一致</p><p>1、IP报头的校验和可以用来验证一个数据包是否正确。选择一个从远程服务器发送到本计算机的包，计算它的checksum。在计算过程中，请添加注释，表明每个word对应的字段</p><p>计算对IP首部检验和的算法如下：</p><p>(1）把IP数据包的校验和字段置为0。</p><p>(2）把首部看成以16位为单位的数字组成，依次进行二进制求和（注意：求和时应将最高位的进位保存，所以加法应采用32位加法）。</p><p>(3）将上述加法过程中产生的进位（最高位的进位）加到低16位（采用32位加法时，即为将高16位与低16位相加，之后还要把该次加法最高位产生的进位加到低16位）。</p><p>(4）将上述的和取反，即得到校验和。</p><p>假设：抓个IP数据包，取IP数据报报头部分(20B)，数据如下</p><p> <em>45 00 00 30 80 4c 40 00 80 06 b5 2e d3 43 11 7b cb 51 15 3d</em></p><p>1 、把校验的两个字节变为0。</p><p><em>45 00 00 30 80 4c 40 00 80 06 00 00 d3 43 11 7b cb 51 15 3d</em></p><p>2、 每16位一加</p><p><em>4500 + 0030 + 804c + 4000 + 8006 + 0000 + d343 + 117b + cb51 + 153d &#x3D; 34ace</em></p><p>3、把结果的高16位与低16位相加</p><p><em>0003+4ace&#x3D; 4ad1</em></p><p>4、取反</p><p>4ad1 取反 就是最后的结果</p><h3 id="在完成本实验后探索协议和分层，思考下列问题："><a href="#在完成本实验后探索协议和分层，思考下列问题：" class="headerlink" title="在完成本实验后探索协议和分层，思考下列问题："></a><strong>在完成本实验后探索协议和分层，思考下列问题：</strong></h3><p>•    <strong>了解并尝试使用IPv6。 现代操作系统已经包含对IPv6的支持，因此您可能能够捕获网络上的IPv6流量。您还可以通过tunnels连接到IPv6</strong></p><p><strong><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E8%B7%B5%E5%AE%9E%E9%AA%8C%E4%B8%89-IPV4/clip_image026.jpg" srcset="/img/mahmoud-habibi.gif" lazyload alt="img"></strong></p><p>使用icmp6过滤得到ipv6</p><p><strong><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E8%B7%B5%E5%AE%9E%E9%AA%8C%E4%B8%89-IPV4/clip_image028.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="img"></strong></p><p>•    了解tunnels技术。</p><p>•    隧道（Tunnel）技术是一种基于IPv4隧道来传送IPv6数据报文的封装技术。将IPv6包作为无结构意义的数据，封装在IPv4包中，如此穿越IPv4网络进行通信，并且在隧道的两端可以分别对数据报文进行封装和解封装。隧道是一个虚拟的点对点的连接。隧道技术在定义上就是指包括数据封装、传输和解封装在内的全过程。</p><p>•    <strong>了解有关IP的地理位置信息，即IP地址和它对应的地理位置之间的信息</strong>。</p><p>IP地理位置是使用IP地址识别设备（例如移动电话，小工具，笔记本电脑，服务器等）的地理位置,通过学校信息化办公室可以看到我现在笔记本电脑wlan连接网络的IP物理位置是在</p><p>亚洲 中国 上海 上海 华东师范大学 中北校区 校园无线</p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E8%B7%B5%E5%AE%9E%E9%AA%8C%E4%B8%89-IPV4/clip_image030.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="img"></p><p>•    <strong>了解IPsec或IP security.它为IP数据包提供机密性和身份验证，通常用作VPN的一部分。</strong></p><p>VPN（Virtual Private Network，虚拟专用网）是一种在公用网络上建立专用网络的技术。它之所以称之为虚拟网，主要是因为VPN的两个节点之间并没有像传统专用网那样使用端到端的物理链路，而是架构在公用网络如Internet之上的逻辑网络，用户数据通过逻辑链路传输。IPsec VPN是指采用IPsec实现远程接入的一种VPN技术，通过在公网上为两个或多个私有网络之间建立IPsec隧道，并通过加密和验证算法保证VPN连接的安全。</p><p>IPsec VPN保护的是点对点之间的通信，通过IPsec VPN可以在主机和主机之间、主机和网络安全网关之间或网络安全网关（如路由器、防火墙）之间建立安全的隧道连接。其协议主要工作在IP层，在IP层对数据包进行加密和验证。</p><p>相对于其他VPN技术，IPsec VPN安全性更高，数据在IPsec隧道中都是加密传输，但相应的IPsec VPN在配置和组网部署上更复杂。</p>]]></content>
    
    
    <categories>
      
      <category>学习资料</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络实践</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络实践实验二-Ethernet</title>
    <link href="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E8%B7%B5%E5%AE%9E%E9%AA%8C%E4%BA%8C-Ethernet/"/>
    <url>/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E8%B7%B5%E5%AE%9E%E9%AA%8C%E4%BA%8C-Ethernet/</url>
    
    <content type="html"><![CDATA[<h1 id="华东师范大学软件学院实验报告"><a href="#华东师范大学软件学院实验报告" class="headerlink" title="华东师范大学软件学院实验报告"></a>华东师范大学软件学院实验报告</h1><table><thead><tr><th><strong>实验课程</strong>：计算机网络实践</th><th>年级：2021级</th><th><strong>实验成绩</strong>：</th></tr></thead><tbody><tr><td><strong>实验名称</strong>：实验二：Ethernet</td><td><strong>姓名</strong>：emokable</td><td></td></tr><tr><td><strong>实验编号</strong>：X</td><td><strong>学号</strong>：X</td><td><strong>实验日期</strong>：2022&#x2F;11&#x2F;24</td></tr><tr><td><strong>指导教师</strong>：章玥</td><td><strong>组号</strong>：</td><td><strong>实验时间</strong>：2022&#x2F;11&#x2F;24</td></tr></tbody></table><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E8%B7%B5%E5%AE%9E%E9%AA%8C%E4%BA%8C-Ethernet/clip_image001.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="img"> </p><h2 id="一、实验目的"><a href="#一、实验目的" class="headerlink" title="一、实验目的"></a><strong>一、实验目的</strong></h2><p>​<strong>1</strong>、掌握网络抓包工具Wireshark、网络诊断工具ping的用法；</p><p>​<strong>2</strong>、使用网络诊断工具ping触发网络消息；</p><p>​<strong>3</strong>、使用网络抓包工具Wireshark获取并分析以太网数据帧；</p><p>​<strong>4</strong>、掌握以太网帧的结构；</p><p>​<strong>5</strong>、分析以太网地址范围；</p><p>​<strong>6</strong>、分析以太网的广播帧。</p><h2 id="二、实验内容与实验步骤"><a href="#二、实验内容与实验步骤" class="headerlink" title="二、实验内容与实验步骤"></a><strong>二、实验内容与实验步骤</strong></h2><p>​1、启动Wireshark，在菜单栏的捕获-&gt;选项中进行设置，选择已连接的以太网，设置捕获过滤器为“icmp”，将混杂模式设为关闭,勾选 Resolve MAC addresses然后开始捕获。</p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E8%B7%B5%E5%AE%9E%E9%AA%8C%E4%BA%8C-Ethernet/clip_image003.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="img"></p><p>​2、打开命令行，输入ping <a href="http://www.baidu.com/">www.baidu.com</a>.</p><p>​3、打开Wireshark， 停止捕获。</p><h2 id="三、实验环境"><a href="#三、实验环境" class="headerlink" title="三、实验环境"></a><strong>三、实验环境</strong></h2><p>Windows10 22H2</p><p>Wireshark-win64-2.0.3</p><p>wget-1.17.1-win64</p><h2 id="四、实验过程与分析"><a href="#四、实验过程与分析" class="headerlink" title="四、实验过程与分析"></a><strong>四、实验过程与分析</strong></h2><ol><li>单播</li></ol><p>设置完wireshark后在windows终端输入ping baidu.com</p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E8%B7%B5%E5%AE%9E%E9%AA%8C%E4%BA%8C-Ethernet/clip_image005.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="img"></p><p>打开wireshark截获:</p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E8%B7%B5%E5%AE%9E%E9%AA%8C%E4%BA%8C-Ethernet/clip_image007.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="img"></p><p>2.组播,广播</p><p>​广播：一对所有主机</p><p>​组播：一对部分主机</p><p>使用“<strong>ether multicast</strong>”过滤器开始对广播和多播以太网帧进行捕获，等待30秒记录背景流量，然后停止捕获。(受实验室限制,使用现有抓包)</p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E8%B7%B5%E5%AE%9E%E9%AA%8C%E4%BA%8C-Ethernet/clip_image009.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="img"></p><h2 id="五、实验结果总结"><a href="#五、实验结果总结" class="headerlink" title="五、实验结果总结"></a><strong>五、实验结果总结</strong></h2><h3 id="分析以太网单播帧："><a href="#分析以太网单播帧：" class="headerlink" title="分析以太网单播帧："></a><strong>分析以太网单播帧：</strong></h3><p>1.基于对以太网帧格式的理解，绘制ping消息的图形，该图形以字节</p><p>单位显示以太网报头字段的位置和大小。图形可以简单地将框架显示为一个细长的矩形。先出现在包中的是最左边的字段，会先通过网络发送。在此图中，显示以太网报头和以太网负载的范围。最后添加一个虚线框来表示4字节校验和。</p><p>以太网结构图(以抓到的包为例):</p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E8%B7%B5%E5%AE%9E%E9%AA%8C%E4%BA%8C-Ethernet/clip_image011.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="img"> </p><p>2、画一个图,显示你的电脑,路由器和远程服务器的相对位置。标记你的电脑和路由器的以太网地址。标记你的计算机和远程服务器的IP地址。同时也在绘图中显示出以太网和其他网络。</p><p>Icmp包显示地址与本机一致</p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E8%B7%B5%E5%AE%9E%E9%AA%8C%E4%BA%8C-Ethernet/clip_image013.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="img"></p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E8%B7%B5%E5%AE%9E%E9%AA%8C%E4%BA%8C-Ethernet/clip_image015.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="img"></p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E8%B7%B5%E5%AE%9E%E9%AA%8C%E4%BA%8C-Ethernet/clip_image017.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="img"></p><p>可画出图案:</p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E8%B7%B5%E5%AE%9E%E9%AA%8C%E4%BA%8C-Ethernet/clip_image019.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="img"></p><h3 id="分析以太网广播帧或多播帧的格式回答下面问题："><a href="#分析以太网广播帧或多播帧的格式回答下面问题：" class="headerlink" title="分析以太网广播帧或多播帧的格式回答下面问题："></a><strong>分析以太网广播帧或多播帧的格式回答下面问题：</strong></h3><p>1.以太网广播帧的地址是什么,以Wireshark显示的标准形式写出。</p><p>Broadcast（ff:ff:ff:ff:ff:ff）</p><p>2.哪几个比特位的以太网地址是用来确定是单播或多播&#x2F;广播的?可以根据地址第8位判断是单播还是多播&#x2F;广播。如果为0则是单播，如果为1则是多播。如果地址均为1，即地址为ff.ff.ff.ff.ff.ff，则为广播</p><h3 id="IEEE-802-3数据包分析："><a href="#IEEE-802-3数据包分析：" class="headerlink" title="IEEE 802.3数据包分析："></a><strong>IEEE 802.3数据包分析</strong>：</h3><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E8%B7%B5%E5%AE%9E%E9%AA%8C%E4%BA%8C-Ethernet/clip_image021.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="img"></p><p>有两种类型的以太网帧，IEEE 802.3和DIX以太网。 DIX是常见的，也是我们上面实验中用到的，而IEEE 802.3则很少。 您可能会在捕获的抓取的包中看到一些IEEE 802.3帧。要搜索IEEE 802.3数据包，请输入显示过滤器（在Wireshark窗口的顶部面板上方）“ llc“ （小写），因为IEEE 802.3格式在其顶部具有LLC协议。 LLC也存在于IEEE 802.11无线网络之上，但在DIX以太网中却不存在。(如果一直没有IEEE 802.3的数据包，可以打开混杂模式，然后开始捕获。)</p><p>​1.与DIX以太网报头相比，IEEE 802.3和LLC组合报头有多长？您可以使用Wireshark解决此问题。请注意，Trailer &#x2F; Padding和Checksum可能显示为标头的一部分，但它们位于帧的末尾。</p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E8%B7%B5%E5%AE%9E%E9%AA%8C%E4%BA%8C-Ethernet/clip_image022.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="img"></p><p>802.3报头长14字节(目的地址6,源地址6,长度&#x2F;类型2),LCC报头(DSAP 1, SSAP 1, 控制1)3字节,一共17字节</p><ol start="2"><li>接收方计算机如何知道该帧是DIX以太网还是IEEE 802.3？ 提示：您可能需要同时使用Wireshark查看数据包示例并查找相关文献。</li></ol><p>当Type字段值小于等于1500（0x05DC）时，帧使用的是IEEE 802.3格式。当Type字段值大于等于1536（0x0600）时，帧使用的是Ethernet II(DIX)格式</p><ol start="3"><li>如果IEEE 802.3没有类型字段，那么如何确定下一层？使Wireshark查找解复用键</li></ol><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E8%B7%B5%E5%AE%9E%E9%AA%8C%E4%BA%8C-Ethernet/clip_image024.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="img"></p><p>802.3没有类型字段,但可以通过长度length来判断,因此0000-05DC都可以看作是802.3的解复用键,此处的解复用键就是0026</p><h2 id="六-个人总结"><a href="#六-个人总结" class="headerlink" title="六.个人总结"></a><strong>六.个人总结</strong></h2><p>这次实验算是做得比较容易的了,但是由于wlan的原因,后面的数据包都用的教材给的,算是丧失了一些实验的乐趣.</p>]]></content>
    
    
    <categories>
      
      <category>学习资料</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络实践</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>黄豆</title>
    <link href="/%E9%BB%84%E8%B1%86/"/>
    <url>/%E9%BB%84%E8%B1%86/</url>
    
    <content type="html"><![CDATA[<p>😀 😁 😂 🤣 😃 😄 😅 😆 😉 😊 😋 😎 😍 😘 🥰 😗 😙 😚 ☺️ 🙂 🤗 🤩 🤔 🤨 😐 😑 😶 🙄 😏 😣 😥 😮 🤐 😯 😪 😫 😴 😌 😛 😜 😝 🤤 😒 😓 😔 😕 🙃 🤑 😲 ☹️ 🙁 😖 😞 😟 😤 😢 😭 😦 😧 😨 😩 🤯 😬 😰 😱 🥵 🥶 😳 🤪 😵 😡 😠 🤬 😷 🤒 🤕 🤢 🤮 🤧 😇 🤠 🤡 🥳 🥴 🥺 🤥 🤫 🤭 🧐 🤓 😈 👿 👹 👺 💀 👻 👽 🤖 💩 😺 😸 😹 😻 😼 😽 🙀 😿 😾</p>]]></content>
    
    
    <categories>
      
      <category>抽象</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Emoji</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络实践实验一-Protocol-Layer</title>
    <link href="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E8%B7%B5%E5%AE%9E%E9%AA%8C%E4%B8%80-Protocol-Layer/"/>
    <url>/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E8%B7%B5%E5%AE%9E%E9%AA%8C%E4%B8%80-Protocol-Layer/</url>
    
    <content type="html"><![CDATA[<h1 id="华东师范大学软件工程学院实验报告"><a href="#华东师范大学软件工程学院实验报告" class="headerlink" title="华东师范大学软件工程学院实验报告"></a>华东师范大学软件工程学院实验报告</h1><table><thead><tr><th><strong>实验课程</strong>：计算机网络实践</th><th><strong>年级</strong>：2021级</th><th><strong>实验成绩</strong>：</th></tr></thead><tbody><tr><td><strong>实验名称</strong>：Protocol Layer</td><td><strong>姓名</strong>：emokable</td><td></td></tr><tr><td><strong>实验编号</strong>：X</td><td><strong>学号</strong>：X</td><td><strong>实验日期</strong>：2022&#x2F;11&#x2F;17</td></tr><tr><td><strong>指导教师</strong>：章玥</td><td><strong>组号</strong>：</td><td><strong>实验时间</strong>：2022&#x2F;11&#x2F;17</td></tr></tbody></table><h2 id="一、实验目的"><a href="#一、实验目的" class="headerlink" title="一、实验目的"></a><strong>一、实验目的</strong></h2><ol><li><p>学习协议和分层如何用数据包表示; </p></li><li><p>熟悉wireshark软件、curl、wget等常用软件的使用，掌握网络抓包的方法，能在所用电脑上进 行抓包; </p></li><li><p>了解IP数据包格式，能应用该软件分析数据包格式，查看抓到的包的内容，并分析对应的IP数据 包格式; </p></li><li><p>抓包分析数据包，估算协议的开销; </p></li><li><p>通过数据包抓取实验，将理论与实践相结合，深入理解协议层的字段与结构特征.</p></li></ol><h2 id="二、实验内容与实验步骤"><a href="#二、实验内容与实验步骤" class="headerlink" title="二、实验内容与实验步骤"></a><strong>二、实验内容与实验步骤</strong></h2><p>1.安装wget和wireshark</p><p>2.使用软件抓包</p><p>3.启动Wireshark点击-&gt;捕获-&gt;选项-&gt;输入tab-&gt;选择本地网卡，过滤条件（所选择接口的捕获过滤 器）为 “tcp port 80”，在选项tab中勾选解析网络名称，点击开始按钮;关闭不必要的浏览器标签和窗口,避免跟踪非目的流量； </p><p>4.在命令行中选取一个URL，用wget获取,打开Wireshark停止捕获。 (我选的网站为<a href="http://www.baidu.com/">http://www.baidu.com</a>)</p><p>5.查看Wireshark界面中的封包列表中如果出现数据包则说明抓包成功； </p><p>6.分析抓包数据的结构</p><h2 id="三、实验环境"><a href="#三、实验环境" class="headerlink" title="三、实验环境"></a><strong>三、实验环境</strong></h2><p>Windos10 22h2专业版</p><h2 id="四、实验过程与分析"><a href="#四、实验过程与分析" class="headerlink" title="四、实验过程与分析"></a><strong>四、实验过程与分析</strong></h2><h3 id="抓包结果总览"><a href="#抓包结果总览" class="headerlink" title="抓包结果总览"></a><strong>抓包结果总览</strong></h3><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E8%B7%B5%E5%AE%9E%E9%AA%8C%E4%B8%80-Protocol-Layer/clip_image002.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="img"></p><p>在抓取HTTP请求的GET方法时，分析其数据包，思考下列问题： </p><p>1、根据抓取的HTTP请求的GET方法的抓取结果，分析协议包的内容。</p><p>2、画一个关于使用GET方法的HTTP请求的图(与下图类似)，为了显示协议层的嵌套结构，请分别标出Ethernet， IP和TCP协议的头部的位置、大小以及其负载的范围。</p><p>3、根据数据包的抓取结果，分析协议开销。</p><p>4、 估计协议的开销或者是协议开销占用下载字节的百分比。对于下载的主要部分中的每一个包，我们需要分析 Ethernet，IP和TCP的开销，和有用的HTTP数据的开销，你认为这种开销是必要的吗？ （假设HTTP数据（头部和消息）是有用的，而TCP，IP和Ethernet头部认为是开销。）</p><p><strong>Ans:</strong></p><p>协议包主要包含以下信息：</p><p>Frame:  物理层的数据帧概况</p><p>Ethernet II: 数据链路层以太网帧头部信息</p><p>Internet Protocol Version 4: 互联网层IP包头部信息</p><p>Transmission Control Protocol: 传输层T的数据段头部信息，此处是TCP</p><p>Hypertext Transfer Protocol: 应用层的信息，此处是HTTP协议</p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E8%B7%B5%E5%AE%9E%E9%AA%8C%E4%B8%80-Protocol-Layer/clip_image004.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="img"><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E8%B7%B5%E5%AE%9E%E9%AA%8C%E4%B8%80-Protocol-Layer/clip_image006.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="img"></p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E8%B7%B5%E5%AE%9E%E9%AA%8C%E4%B8%80-Protocol-Layer/clip_image008.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="img"></p><p>协议开销为分析 Ethernet，IP和TCP的头部大小之和即14+20+20&#x3D;54</p><p>开销占比:54&#x2F;165*100%&#x3D;32.7%</p><p>这种开销是必要的,因为在网络的各层中存在着许多不同的协议，每个协议的定义与数据的划分都不相同，接收方和发送方的对等实体之间的协议必须保持一致，否则一方将无法识别另一方发出的信息，从而造成不可避免的灾难，增加的协议开销可以保证传输包的安全性和可检测性及可恢复性。</p><h3 id="观察下载的以太网和IP头包回答下面问题"><a href="#观察下载的以太网和IP头包回答下面问题" class="headerlink" title="观察下载的以太网和IP头包回答下面问题"></a><strong>观察下载的以太网和IP头包回答下面问题</strong></h3><p>1、以太网头部中哪一部分是解复用（解复用： 找到正确的上一层协议来处理到达的包的行为叫做 解复用）键并且告知它的下一个高层指的是IP，在这一包内哪一个值可以表示IP？ </p><p>2、IP头部中哪一部分是解复用键并且告知它的下一个高层指的是TCP，在这一包内哪一个值可以表示TCP？</p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E8%B7%B5%E5%AE%9E%E9%AA%8C%E4%B8%80-Protocol-Layer/clip_image010.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="img"></p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E8%B7%B5%E5%AE%9E%E9%AA%8C%E4%B8%80-Protocol-Layer/clip_image012.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="img"></p><p><strong>Ans:</strong></p><p>分析多路分解键，根据wireshark的功能，可以直接在下拉框找到IP、TCP协议对应的二进制符号</p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E8%B7%B5%E5%AE%9E%E9%AA%8C%E4%B8%80-Protocol-Layer/clip_image014.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="img"></p><p>表示IP的解复用键为IPv4(0x0800)</p><p>表示TCP的解复用键为TCP(6)</p><h3 id="思考题"><a href="#思考题" class="headerlink" title="思考题:"></a><strong>思考题</strong>:</h3><ol><li><p>这里找到了一个54Bytes大小的tcp数据包，并且不包含更高层数据在TCP协议中，建立连接需要三次握手，结束连接需要4次挥手。这几次的数据传递均是不包括高层协议数据的，目的是为了确保连接建立的稳定和准确<img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E8%B7%B5%E5%AE%9E%E9%AA%8C%E4%B8%80-Protocol-Layer/clip_image016.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="img"></p></li><li><p>MSS是TCP 数据包一次可以传输的最大数据段。在建立连接时二者协商MSS的大小。对于第一个包的首部中，Connection字段值为：keep-alive，表明后续仍有数据。最后一个包请求头中Connection字段值为：close，表明传输结束。同时最后一个包中还会包含FIN&#x3D;1来请求关闭连接</p></li><li><p>加密的目的是为了保密内容，所以加密的类型和加密密钥不能随着加密数据一同发送。加密协议的种类和密钥应该在传输数据前进行协商确定。相较于现有的直接传输，不同加密协议在传输之前需要有额外的数据传输进行密钥的协商，以确保整个加密是有效的</p></li><li><p>和加密不同，压缩是为了节省传输流量，而非对数据保密内容，所以压缩的协议可直接指明在下层协议头中，便于接收方解压</p></li></ol><h2 id="五、实验结果总结"><a href="#五、实验结果总结" class="headerlink" title="五、实验结果总结"></a><strong>五、实验结果总结</strong></h2><p>总的来说,这次实验算是第一次对计算机网络抓包进行研究,一开始还不太清楚自己要做什么,问了助教之后自己又想了一会儿才将抓到的东西和课堂上将过的结构联系起来,然后就比较好分析了.</p>]]></content>
    
    
    <categories>
      
      <category>学习资料</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络实践</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
