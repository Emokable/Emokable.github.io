<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>哈姆詤的箌悝糖</title>
  
  
  <link href="https://www.emokable.top/atom.xml" rel="self"/>
  
  <link href="https://www.emokable.top/"/>
  <updated>2023-12-23T14:08:01.973Z</updated>
  <id>https://www.emokable.top/</id>
  
  <author>
    <name>emokable</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>IoT-第3章-无线传感器网络-3-4-拓扑控制</title>
    <link href="https://www.emokable.top/IoT-%E7%AC%AC3%E7%AB%A0-%E6%97%A0%E7%BA%BF%E4%BC%A0%E6%84%9F%E5%99%A8%E7%BD%91%E7%BB%9C-3-4-%E6%8B%93%E6%89%91%E6%8E%A7%E5%88%B6/"/>
    <id>https://www.emokable.top/IoT-%E7%AC%AC3%E7%AB%A0-%E6%97%A0%E7%BA%BF%E4%BC%A0%E6%84%9F%E5%99%A8%E7%BD%91%E7%BB%9C-3-4-%E6%8B%93%E6%89%91%E6%8E%A7%E5%88%B6/</id>
    <published>2023-12-23T14:08:01.000Z</published>
    <updated>2023-12-23T14:08:01.973Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>IoT-第3章-无线传感器网络-3-3-路由技术</title>
    <link href="https://www.emokable.top/IoT-%E7%AC%AC3%E7%AB%A0-%E6%97%A0%E7%BA%BF%E4%BC%A0%E6%84%9F%E5%99%A8%E7%BD%91%E7%BB%9C-3-3-%E8%B7%AF%E7%94%B1%E6%8A%80%E6%9C%AF/"/>
    <id>https://www.emokable.top/IoT-%E7%AC%AC3%E7%AB%A0-%E6%97%A0%E7%BA%BF%E4%BC%A0%E6%84%9F%E5%99%A8%E7%BD%91%E7%BB%9C-3-3-%E8%B7%AF%E7%94%B1%E6%8A%80%E6%9C%AF/</id>
    <published>2023-12-23T14:07:48.000Z</published>
    <updated>2023-12-24T05:14:19.568Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第三章-无线传感器网络"><a href="#第三章-无线传感器网络" class="headerlink" title="第三章 无线传感器网络"></a>第三章 无线传感器网络</h1><h2 id="3-3-路由技术"><a href="#3-3-路由技术" class="headerlink" title="3.3 路由技术"></a>3.3 路由技术</h2><h3 id="关于路由协议"><a href="#关于路由协议" class="headerlink" title="关于路由协议"></a><strong>关于路由协议</strong></h3><ul><li><strong>路由协议的任务</strong><ul><li><strong>负责将数据分组从源节点通过网络转发到目的节点。</strong></li></ul></li><li><strong>路由协议的功能</strong><ul><li><strong>（1）寻找源节点和目的节点间的优化路径；</strong></li><li><strong>（2）将数据分组沿着优化路径正确转发。</strong></li></ul></li></ul><p><img src="/IoT-%E7%AC%AC3%E7%AB%A0-%E6%97%A0%E7%BA%BF%E4%BC%A0%E6%84%9F%E5%99%A8%E7%BD%91%E7%BB%9C-3-3-%E8%B7%AF%E7%94%B1%E6%8A%80%E6%9C%AF/image-20231224112349263.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="路由协议"></p><p>​<strong>路由协议的核心是路由选择算法。不同的路由选择算法通常会采用不同的评价因子及权重来进行最佳路径的计算，Internet路由协议常见的评价因子包括带宽、可靠性、延迟、负载、跳数和费用等。</strong></p><h3 id="有线Internet网络中的路由"><a href="#有线Internet网络中的路由" class="headerlink" title="有线Internet网络中的路由"></a><strong>有线Internet网络中的路由</strong></h3><p><img src="/IoT-%E7%AC%AC3%E7%AB%A0-%E6%97%A0%E7%BA%BF%E4%BC%A0%E6%84%9F%E5%99%A8%E7%BD%91%E7%BB%9C-3-3-%E8%B7%AF%E7%94%B1%E6%8A%80%E6%9C%AF/image-20231224112503614.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="有线路由"></p><h3 id="自组织网络（Ad-Hoc-Networks）"><a href="#自组织网络（Ad-Hoc-Networks）" class="headerlink" title="自组织网络（Ad Hoc Networks）"></a><strong>自组织网络（Ad Hoc Networks）</strong></h3><p><img src="/IoT-%E7%AC%AC3%E7%AB%A0-%E6%97%A0%E7%BA%BF%E4%BC%A0%E6%84%9F%E5%99%A8%E7%BD%91%E7%BB%9C-3-3-%E8%B7%AF%E7%94%B1%E6%8A%80%E6%9C%AF/image-20231224114655930.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="adhoc"></p><h4 id="Ad-Hoc-网络的特点"><a href="#Ad-Hoc-网络的特点" class="headerlink" title="Ad Hoc 网络的特点"></a>Ad Hoc 网络的特点</h4><p>•独立组网</p><p><img src="/IoT-%E7%AC%AC3%E7%AB%A0-%E6%97%A0%E7%BA%BF%E4%BC%A0%E6%84%9F%E5%99%A8%E7%BD%91%E7%BB%9C-3-3-%E8%B7%AF%E7%94%B1%E6%8A%80%E6%9C%AF/image-20231224114743320.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="adhoc"></p><p>​不需要任何预先网络基础设施</p><p>•动态拓扑</p><p>​节点移动&#x2F;开机&#x2F;关机</p><p>​节点无线发送功率变化、无线信道干扰或者地形等因素影响</p><p>•自组织</p><p>​无控制中心</p><p>​节点故障不会影响到整个网络</p><blockquote><p>节点之间通过无线连接形成的网络拓扑结构随时可能发生变化，而且变化的方式和速度可能都是无法预测的</p></blockquote><p>•多跳路由</p><p>​接收端和发送端可使用比两者直接通信小得多的功率进行通信，因此节省了能量消耗</p><p>​通过中间节点参与分组转发，能够有效降低对无线传输设备的设计难度和成本，同时扩大了自组织网络的覆盖范围</p><p><img src="/IoT-%E7%AC%AC3%E7%AB%A0-%E6%97%A0%E7%BA%BF%E4%BC%A0%E6%84%9F%E5%99%A8%E7%BD%91%E7%BB%9C-3-3-%E8%B7%AF%E7%94%B1%E6%8A%80%E6%9C%AF/image-20231224114800347.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="duotiao"></p><h4 id="传统的路由协议不适用于Ad-Hoc-网络"><a href="#传统的路由协议不适用于Ad-Hoc-网络" class="headerlink" title="传统的路由协议不适用于Ad Hoc 网络"></a>传统的路由协议不适用于Ad Hoc 网络</h4><ul><li>动态变化的网络拓扑结构<ul><li>节点加入、离开、移动等</li><li>路由算法还未收敛,网络拓扑结构就发生变化</li></ul></li><li>有限的系统带宽、能量等资源<ul><li>周期性地公告路由信息严重降低系统的性能</li></ul></li><li>间歇性的网络分割<ul><li>传统路由协议容易形成路由回路</li></ul></li><li>单向的无线传输信道<ul><li>传统路由协议一般假设链路是对称的</li></ul></li></ul><blockquote><p>•适应网络动态变化</p><p>•减少路由开销</p><p>•引入按需路由</p><p>•在路由时考虑能量等约束条件</p></blockquote><h4 id="Ad-Hoc-路由协议分类"><a href="#Ad-Hoc-路由协议分类" class="headerlink" title="Ad Hoc 路由协议分类"></a>Ad Hoc 路由协议分类</h4><ul><li><strong>表驱动(先验式proactive)</strong><ul><li><strong>Up-to-date routing information maintained</strong></li><li><strong>Routing overhead independent of route usage</strong></li></ul></li><li><strong>按需路由(反应式reactive)</strong><ul><li><strong>Routes maintained only for routes in use</strong></li><li><strong>Explicit route discovery mechanism</strong></li></ul></li><li><strong>混合路由（Hybrid Protocols）</strong><ul><li><strong>Combination of proactive and reactive</strong></li></ul></li></ul><p><img src="/IoT-%E7%AC%AC3%E7%AB%A0-%E6%97%A0%E7%BA%BF%E4%BC%A0%E6%84%9F%E5%99%A8%E7%BD%91%E7%BB%9C-3-3-%E8%B7%AF%E7%94%B1%E6%8A%80%E6%9C%AF/image-20231224114934665.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="分类"></p><h5 id="表驱动（Table-Driven）路由"><a href="#表驱动（Table-Driven）路由" class="headerlink" title="表驱动（Table Driven）路由"></a><strong>表驱动（Table Driven）路由</strong></h5><p>先验式(Proactive)路由</p><p><img src="/IoT-%E7%AC%AC3%E7%AB%A0-%E6%97%A0%E7%BA%BF%E4%BC%A0%E6%84%9F%E5%99%A8%E7%BD%91%E7%BB%9C-3-3-%E8%B7%AF%E7%94%B1%E6%8A%80%E6%9C%AF/image-20231224115344312.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="1"></p><ul><li><p>传统的分布式最短路径路由协议</p><ul><li>链路状态或者距离向量</li><li>所有节点周期性更新“可达”信息</li></ul></li><li><p>每个节点维护到网络中所有其它节点的路由</p></li><li><p>所有路由都已存在并且随时可用</p></li><li><blockquote><p>路由延时小，但是路由开销大</p></blockquote></li><li><p>DSDV、OLSR、TBRPF</p></li></ul><h5 id="按需（On-demand）路由"><a href="#按需（On-demand）路由" class="headerlink" title="按需（On-demand）路由"></a><strong>按需（On-demand）路由</strong></h5><p><img src="/IoT-%E7%AC%AC3%E7%AB%A0-%E6%97%A0%E7%BA%BF%E4%BC%A0%E6%84%9F%E5%99%A8%E7%BD%91%E7%BB%9C-3-3-%E8%B7%AF%E7%94%B1%E6%8A%80%E6%9C%AF/image-20231224115436665.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="2"></p><ul><li><p>反应式(Reactive)路由</p><ul><li><p>源节点根据需要通过路由发现过程来确定路由</p></li><li><p>控制消息采用泛洪（Flooding）方式</p></li><li><blockquote><p>路由延时大，但是路由开销小</p></blockquote></li></ul></li><li><p>两种实现技术</p><ul><li>源路由（分组携带完整的路由信息）</li><li>逐跳（Hop-by-Hop）路由</li></ul></li><li><p>DSR、AODV、DYMO</p></li></ul><h5 id="混合路由"><a href="#混合路由" class="headerlink" title="混合路由"></a><strong>混合路由</strong></h5><p><img src="/IoT-%E7%AC%AC3%E7%AB%A0-%E6%97%A0%E7%BA%BF%E4%BC%A0%E6%84%9F%E5%99%A8%E7%BD%91%E7%BB%9C-3-3-%E8%B7%AF%E7%94%B1%E6%8A%80%E6%9C%AF/image-20231224115527711.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="hybird"></p><ul><li>Ad Hoc网络划分为区域<ul><li>每个节点在区域内部采用表驱动路由</li><li>对于区域外节点采用按需路由</li></ul></li><li>簇和区域的不同<ul><li>簇内所有节点都与簇首直接通信，簇内节点间的通信一般是两跳</li><li>区域的大小没有限制，区域内的节点通信可以多跳</li></ul></li><li>ZRP：Zone Routing Protocol</li></ul><blockquote><p>减少了域内的路由延时</p><p>减少了域外的路由开销</p><p>区域半径的选择</p><ul><li>小: 节点移动快的密集网络</li><li>大: 节点移动慢的稀疏网络</li></ul></blockquote><h4 id="Example-Ad-Hoc-Network"><a href="#Example-Ad-Hoc-Network" class="headerlink" title="Example Ad Hoc Network"></a>Example Ad Hoc Network</h4><p><strong>AODV(Ad hoc On Demand Vector routing)按需距离矢量路由协议</strong></p><p><img src="/IoT-%E7%AC%AC3%E7%AB%A0-%E6%97%A0%E7%BA%BF%E4%BC%A0%E6%84%9F%E5%99%A8%E7%BD%91%E7%BB%9C-3-3-%E8%B7%AF%E7%94%B1%E6%8A%80%E6%9C%AF/image-20231224115615303.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="1"></p><p><img src="/IoT-%E7%AC%AC3%E7%AB%A0-%E6%97%A0%E7%BA%BF%E4%BC%A0%E6%84%9F%E5%99%A8%E7%BD%91%E7%BB%9C-3-3-%E8%B7%AF%E7%94%B1%E6%8A%80%E6%9C%AF/image-20231224115625311.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="Route Requests in AODV"></p><p><img src="/IoT-%E7%AC%AC3%E7%AB%A0-%E6%97%A0%E7%BA%BF%E4%BC%A0%E6%84%9F%E5%99%A8%E7%BD%91%E7%BB%9C-3-3-%E8%B7%AF%E7%94%B1%E6%8A%80%E6%9C%AF/image-20231224115634970.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="Route Requests in AODV"></p><p><img src="/IoT-%E7%AC%AC3%E7%AB%A0-%E6%97%A0%E7%BA%BF%E4%BC%A0%E6%84%9F%E5%99%A8%E7%BD%91%E7%BB%9C-3-3-%E8%B7%AF%E7%94%B1%E6%8A%80%E6%9C%AF/image-20231224115644042.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="Route Requests in AODV"></p><p><img src="/IoT-%E7%AC%AC3%E7%AB%A0-%E6%97%A0%E7%BA%BF%E4%BC%A0%E6%84%9F%E5%99%A8%E7%BD%91%E7%BB%9C-3-3-%E8%B7%AF%E7%94%B1%E6%8A%80%E6%9C%AF/image-20231224115653154.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="Reverse Path Setup in AODV"></p><p><img src="/IoT-%E7%AC%AC3%E7%AB%A0-%E6%97%A0%E7%BA%BF%E4%BC%A0%E6%84%9F%E5%99%A8%E7%BD%91%E7%BB%9C-3-3-%E8%B7%AF%E7%94%B1%E6%8A%80%E6%9C%AF/image-20231224115703415.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="Route Reply in AODV"></p><p><img src="/IoT-%E7%AC%AC3%E7%AB%A0-%E6%97%A0%E7%BA%BF%E4%BC%A0%E6%84%9F%E5%99%A8%E7%BD%91%E7%BB%9C-3-3-%E8%B7%AF%E7%94%B1%E6%8A%80%E6%9C%AF/image-20231224115818401.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="AODV Route Discovery"></p><h2 id="WSN特点对路由协议设计的影响"><a href="#WSN特点对路由协议设计的影响" class="headerlink" title="WSN特点对路由协议设计的影响"></a><strong>WSN特点对路由协议设计的影响</strong></h2><p>无线传感器网络的路由协议</p><p>（1）能量优先：考虑节点能耗，高效利用能量；</p><p>（2）基于局部信息：在局部网络拓扑信息的基础上选择合适的路径；</p><p>（3）以数据为中心：路由机制与数据融合技术结合；</p><p>（4）应用相关：应用千差万别，无通用的路由协议。</p><h3 id="能量感知路由"><a href="#能量感知路由" class="headerlink" title="能量感知路由"></a><strong>能量感知路由</strong></h3><h4 id="能量感知路由的考虑因素"><a href="#能量感知路由的考虑因素" class="headerlink" title="能量感知路由的考虑因素"></a><strong>能量感知路由的考虑因素</strong></h4><p><strong>根据节点的可用能量(power available, PA)或传输路径上的能量需求，选择数据的转发路径。</strong></p><p><img src="/IoT-%E7%AC%AC3%E7%AB%A0-%E6%97%A0%E7%BA%BF%E4%BC%A0%E6%84%9F%E5%99%A8%E7%BD%91%E7%BB%9C-3-3-%E8%B7%AF%E7%94%B1%E6%8A%80%E6%9C%AF/image-20231224120103976.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="1"></p><h4 id="能量路由策略"><a href="#能量路由策略" class="headerlink" title="能量路由策略"></a>能量路由策略</h4><p><strong>最少跳数路由：选取从数据源到汇聚节点跳数最少的路径。选择路径3。</strong></p><p><strong>最小能量消耗路由：从数据源到汇聚节点的所有路径中选取节点耗能之和最少的路径。选择路径1。</strong></p><p><strong>最大PA路由：从数据源到汇聚节点的所有路径中选取节点PA之和最大的路径。路径2、路径4的PA之和最大，但路径2包含路径1，不是高效的从而被排除。选择路径4。</strong></p><p><strong>最大最小PA节点路由：选择路径可用能量最大的路径（每条路径中可用能量最小的节点来表示这条路径的可用能量）。最大最小PA节点路由策略就是，选择路径3。</strong></p><h4 id="最小功率路由"><a href="#最小功率路由" class="headerlink" title="最小功率路由"></a><strong>最小功率路由</strong></h4><p> 在连接两个节点的所有路径中，选择路径总功率值最小的一条路径。</p><p> 很多情况下，无线节点具备功率控制能力，即可以根据不同的通信相邻状况选择合适的发送功率。采用最小功率路由协议，能够使得发送单个数据所消耗的功率最小化。</p><p>链路(i,j)成功传送单位数据所消耗的功率：</p><blockquote><p> P_Tx &#x3D; E + K_ⅹd_ijα</p><p> P_Rx &#x3D; E</p><p> P(i, j) &#x3D; P_Tx + P_Rx &#x3D; 2E + K_ⅹd_ijα</p><p><img src="/IoT-%E7%AC%AC3%E7%AB%A0-%E6%97%A0%E7%BA%BF%E4%BC%A0%E6%84%9F%E5%99%A8%E7%BD%91%E7%BB%9C-3-3-%E8%B7%AF%E7%94%B1%E6%8A%80%E6%9C%AF/image-20231224120306824.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="1"></p></blockquote><p>一条连接源节点i和目的节点j的路径上传送单位数据所消耗的总功率值等于组成该路径各条链路的功率值之和：</p><blockquote><p> C(s, d) &#x3D; Σ P(i, j),  all (i, j) ∈P, i ≠ j</p></blockquote><p> 当节点具备全局网络信息时，最小功率路径可以通过最短路算法或距离向量路由算法求得。</p><h5 id="最小功率路由–-PARO协议"><a href="#最小功率路由–-PARO协议" class="headerlink" title="最小功率路由– PARO协议"></a><strong>最小功率路由– PARO协议</strong></h5><p>工作原理：</p><p>​发送节点首先用最大功率直接与接收节点通信。</p><p>​如果某个节点监听到收发节点之间的通信，并认为如果自己充当中间转发节点能够有效降低端到端功率损耗，则发送一个信令消息通知收发节点并加入到路径之中。</p><p>​持续这一过程，直到不存在这样的节点，或者这样做的增益小于给定的一个门限值。</p><p>优点：局部性和简单性</p><p>缺点：</p><p>​要求节点最大功率能够覆盖全网，并且其启发式路径计算过程并不保证能够找到全局最优路径。</p><p>​倾向于选择短链路组成的路径，导致路径跳数较多，传输延迟较大。</p><p>​如果不考虑节点移动、链路动态等因素，则连接两个节点的最小功率路径是固定的，导致流量集中，网络中某些节点率先耗尽能量而失效。</p><h4 id="最大剩余能量路由"><a href="#最大剩余能量路由" class="headerlink" title="最大剩余能量路由"></a><strong>最大剩余能量路由</strong></h4><p> 在连接两个节点的所有路径中，选择瓶颈节点剩余能量最大的一条路径。</p><p> 路径 P 的剩余能量为：</p><p>  EP &#x3D; min{ Ex | x ∈ V(P)}</p><ul><li>在无线传感器网络的工作过程中，随着网络中节点的能量消耗，连接相同节点对的最大剩余能量路径也将随时间而变。</li><li>因此，最大剩余能量路由具有平衡网络中节点能量消耗的作用。</li><li>但是并没有考虑每分组端到端能耗的最小化。</li><li>最小功率路由的选择和最大剩余能量路由的选择是相互独立的。</li></ul><h4 id="最小不情愿度路由"><a href="#最小不情愿度路由" class="headerlink" title="最小不情愿度路由"></a><strong>最小不情愿度路由</strong></h4><p>一个节点x充当一条路径上中间转发节点的不情愿度的定义：</p><p> <em>f</em> (<em>x</em>) &#x3D; 1&#x2F;<em>Ex</em></p><p> （ Ex ：节点x的剩余能量，且归一化，分布在(0, 1] 区间内。）</p><p>路径P的不情愿度定义为该路径上所有中间节点的不情愿度之和：</p><p> <em>f</em> (P) &#x3D;  Σ <em>f</em> (<em>x</em>),  all x ∈V(P)</p><p>连接一对源节点和目的节点的最小不情愿度路径是所有路径中不情愿度 <em>f</em> (P) 最小的那条。</p><p>Minimum Reluctance Routing 协议</p><ul><li><strong>采用方法与AODV协议的寻径过程类似；</strong></li><li><strong>路径代价为节点剩余能量倒数之和；</strong></li><li><strong>源节点向网络洪泛一条寻径信令，携带已走过路径的代价（初值为0）；</strong></li><li><strong>中间节点如果收到多个信令，从中选择代价最小的一个；</strong></li><li><strong>中间节点转发该信令时，将自己剩余能量的倒数加到路径代价之上。</strong></li></ul><h4 id="基于组合能量代价的优化路由"><a href="#基于组合能量代价的优化路由" class="headerlink" title="基于组合能量代价的优化路由"></a><strong>基于组合能量代价的优化路由</strong></h4><p>采用更为复杂的组合链路代价函数，使得路由选择过程能够同时考虑链路功率和节点能耗的优化，以延长网络寿命。</p><p>对于网络 G(V, E),每条链路的不情愿度定义为</p><p> <em>f</em> (<em>x</em>) &#x3D; <em>p</em>(i, j) &#x2F; <em>Ej</em>2,  all (i, j) ∈E(G)</p><p>（ <em>p</em>(i, j) 为从 i 到 j 传送单位长度数据所需的最小功率。<em>E**j</em> 为剩余能量<em>。</em>）</p><p> 既考虑了如何降低端到端发送功率，又平衡了网络中节点的剩余能量。</p><p>结合链路分组传输成功率，进一步考虑链路的期望传输次数 T(i,j),进一步修正链路不情愿度为</p><p> <em>f</em> (<em>x</em>) &#x3D; <em>p</em>(i, j) · <em>T</em>(i, j) &#x2F; <em>Ej</em>2,  all (i, j) ∈E(G)</p><p> （ 其中 <em>T</em>(i, j) 为链路（i, j）传输成功率的倒数。）</p><p>  式中分子表示链路成功传输一个分组时发送方所消耗的期望能量。</p><p><strong>可以结合各个候选下一跳节点距离目的节点的欧氏距离对剩余前向路径的路径代价进行估算，从而估算出经过每个候选下一跳节点到目的节点的端到端路径代价，再从中选择最小的一个。</strong></p><h3 id="以数据为中心的路由"><a href="#以数据为中心的路由" class="headerlink" title="以数据为中心的路由"></a><strong>以数据为中心的路由</strong></h3><ul><li><strong>洪泛协议Flooding</strong> <ul><li><strong>泛洪式路由协议。</strong></li><li><strong>缺点：内爆，数据重叠，资源浪费。</strong></li></ul></li><li><strong>闲聊协议Gossiping</strong> <ul><li><strong>改进：非广播，随机选择一个或多个相邻节点进行数据转发，在节点密集的情况下减轻了内爆。</strong></li><li><strong>缺点：路径非最优，数据重叠，增加传输延迟。</strong></li></ul></li><li><strong>SPIN协议</strong></li><li><strong>定向扩散路由Directed Diffusion</strong></li></ul><h4 id="SPIN协议"><a href="#SPIN协议" class="headerlink" title="SPIN协议"></a><strong>SPIN协议</strong></h4><p><strong>工作原理</strong></p><ul><li><strong>协商：节点先发送元数据，协商确定其它节点是否需要该数据，再根据情况发送数据。</strong></li><li><strong>门限：基于门限的能量自适应机制。先检测自身的剩余能量，看情况而启动协商过程。</strong></li><li><strong>消息类型：广告（ADV），请求（REQ），数据（DATA）</strong></li><li><strong>优点：实现简单（只需知道一跳内信息），解决内爆、数据重叠等问题。</strong></li><li><strong>缺点：数据有时不能转发，较远节点无法得到；不保证传送可靠性</strong></li></ul><p><img src="/IoT-%E7%AC%AC3%E7%AB%A0-%E6%97%A0%E7%BA%BF%E4%BC%A0%E6%84%9F%E5%99%A8%E7%BD%91%E7%BB%9C-3-3-%E8%B7%AF%E7%94%B1%E6%8A%80%E6%9C%AF/image-20231224124930540.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="spin"></p><h4 id="DirectedDifussion-DD-定向扩散路由"><a href="#DirectedDifussion-DD-定向扩散路由" class="headerlink" title="DirectedDifussion(DD)定向扩散路由"></a><strong>DirectedDifussion(DD)定向扩散路由</strong></h4><p><strong>工作原理：</strong></p><p><strong>汇聚节点通过兴趣消息发出查询任务，采用泛洪方式传播兴趣消息到整个区域或部分区域内的所有传感器节点。在兴趣消息的传播过程中，协议逐跳地在每个传感器节点上建立反向的从数据源点到汇聚节点的数据传输梯度，传感器节点将采集到的数据沿着梯度方向传送到汇聚节点。</strong></p><p><strong>周期性的三个阶段：兴趣扩散、梯度建立、路径加强。</strong></p><p><img src="/IoT-%E7%AC%AC3%E7%AB%A0-%E6%97%A0%E7%BA%BF%E4%BC%A0%E6%84%9F%E5%99%A8%E7%BD%91%E7%BB%9C-3-3-%E8%B7%AF%E7%94%B1%E6%8A%80%E6%9C%AF/image-20231224125722999.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="DD"></p><h5 id="定向扩散路由的要素"><a href="#定向扩散路由的要素" class="headerlink" title="定向扩散路由的要素"></a><strong>定向扩散路由的要素</strong></h5><p><strong>组成元素</strong></p><ul><li><strong>数据（data）:以属性数值对命名</strong></li><li><strong>兴趣（interest）:对已命名数据的感知任务</strong></li><li><strong>梯度（gradient）:节点到兴趣消息传播路径中上游邻居节点的链路的任务相关性数值或度量</strong></li><li><strong>事件（event）:事件发生后，事件信息会沿着多条路径向兴趣的发出节点转发</strong></li><li><strong>加强（reinforcement）:一种从多条向汇聚节点发送感知数据的传输路径中选择一条优化路径的机制</strong></li></ul><h5 id="定向扩散路由的任务、兴趣"><a href="#定向扩散路由的任务、兴趣" class="headerlink" title="定向扩散路由的任务、兴趣"></a><strong>定向扩散路由的任务、兴趣</strong></h5><p><img src="/IoT-%E7%AC%AC3%E7%AB%A0-%E6%97%A0%E7%BA%BF%E4%BC%A0%E6%84%9F%E5%99%A8%E7%BD%91%E7%BB%9C-3-3-%E8%B7%AF%E7%94%B1%E6%8A%80%E6%9C%AF/image-20231224125817211.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="1"></p><h5 id="节点维护的兴趣列表"><a href="#节点维护的兴趣列表" class="headerlink" title="节点维护的兴趣列表"></a><strong>节点维护的兴趣列表</strong></h5><ul><li><strong>每个节点都在本地保存一个兴趣列表</strong><ul><li><strong>兴趣表项：发来该兴趣消息的邻居节点、数据发送速率、时间戳等任务相关信息</strong></li><li><strong>每个兴趣可能对应多个邻居节点</strong></li></ul></li><li><strong>节点收到邻居节点的兴趣消息时，首先检查兴趣列表</strong><ul><li><strong>如果有对应的表项： 更新表项的失效时间</strong></li><li><strong>如果只是参数类型相同，但不包含发送该兴趣消息的邻居节点： 在相应表项中添加这个邻居节点</strong></li><li><strong>其它情况：建立一个新表项来记录这个新的兴趣</strong></li></ul></li><li><strong>如果收到的兴趣消息和节点刚转发的兴趣一样，为避免消息循环则丢弃该信息；否则，转发收到的兴趣消息</strong></li></ul><p><img src="/IoT-%E7%AC%AC3%E7%AB%A0-%E6%97%A0%E7%BA%BF%E4%BC%A0%E6%84%9F%E5%99%A8%E7%BD%91%E7%BB%9C-3-3-%E8%B7%AF%E7%94%B1%E6%8A%80%E6%9C%AF/image-20231224125912867.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="1"></p><h5 id="定向扩散路由机制的三个阶段"><a href="#定向扩散路由机制的三个阶段" class="headerlink" title="定向扩散路由机制的三个阶段"></a>定向扩散路由机制的三个阶段</h5><p><strong>兴趣扩散阶段：汇聚节点周期性地向邻居节点广播兴趣消息。兴趣消息中含有任务类型，目标区域，数据发送速率，时间戳等参数。逐跳地在每个传感器节点上建立从数据源点到汇聚节点的数据传输梯度。</strong></p><p><strong>梯度建立（数据传播）阶段：当传感器节点采集到与兴趣匹配的数据时，把数据发送到梯度上的邻居节点，并按照梯度上的数据传输速率设定传感器模块采集数据的速率。</strong></p><p><strong>路径加强阶段：兴趣扩散阶段是为了建立源节点到汇聚节点的数据传输路径，数据源节点以较低的速率采集和发送数据，称这个阶段建立的梯度为探测梯度。汇聚节点在收到从源点发来的数据后，启动建立源节点的加强路径，后续数据将沿着加强路径以较高的数据速率进行传输。加强后的梯度称为数据梯度。</strong></p><p><img src="/IoT-%E7%AC%AC3%E7%AB%A0-%E6%97%A0%E7%BA%BF%E4%BC%A0%E6%84%9F%E5%99%A8%E7%BD%91%E7%BB%9C-3-3-%E8%B7%AF%E7%94%B1%E6%8A%80%E6%9C%AF/image-20231224125932321.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="三阶段"></p><h5 id="定向扩散路由的路径加强机制"><a href="#定向扩散路由的路径加强机制" class="headerlink" title="定向扩散路由的路径加强机制"></a>定向扩散路由的路径加强机制</h5><p><strong>假设以数据传输延迟作为路由加强的标准，汇聚节点选择首先发来消息的邻居节点作为加强路径的下一跳节点，向该邻居节点发送路径加强消息。路径加强消息包括新设定的较高发送数据速率值。邻居节点收到消息后，经过分析确定该消息描述的是一个已有的兴趣，只是增加了数据发送速率，则断定这是一条路径加强消息，从而更新相应兴趣表项到邻居节点的发送数据速率。同时，按照同样的规则选择加强路径的下一跳邻居节点。</strong></p><p><strong>路由加强的标准不是唯一的，可以选择在一定时间内发送数据最多的节点作为路径加强的下一跳节点，也可以选择数据传输最稳定的节点最为路径加强的下一跳节点。在加强路径上的节点如果发现下一跳节点的发送速率明显减小，或者收到来自其他节点的新位置估计，推断加强路径的下一跳节点失效，就需要使用上述的路径加强机制重新确定下一跳节点。</strong></p><h5 id="定向扩散路由的特点"><a href="#定向扩散路由的特点" class="headerlink" title="定向扩散路由的特点"></a>定向扩散路由的特点</h5><p><strong>定向扩散路由是一种典型的以数据为中心的路由机制。汇聚节点根据不同应用需求定义不同的任务类型、目标区域等参数的兴趣消息，通过向网络中兴趣传播消息启动路由建立过程。中间传感器节点通过兴趣表建立从数据源到汇聚节点的数据传输梯度、自动形成数据传输的多条路径。按照路径优化的标准。定向扩散路由使用路由加强机制生成一条优化的数据传输路径</strong></p><p><strong>但是，定向扩散路由在路由建立时需要一个兴趣扩散的洪泛传播，能量和时间开销都比较大，尤其是当底层MAC协议采用休眠机制时可能造成兴趣建立的不一致。</strong></p><h4 id="Rumor-谣传路由"><a href="#Rumor-谣传路由" class="headerlink" title="Rumor 谣传路由"></a>Rumor 谣传路由</h4><p>有些传感器网络应用中，数据传输量较少，此时定向扩散路由并不是高效的路由机制。谣传路由适用于数据传输量较小的传感器网络。</p><p>基本思想是：事件区域中的传感器节点产生代理，代理消息沿随机路径向外扩散传播，同时汇聚节点发送的查询消息也沿随机路径在网络中传播。当代理消息和查询消息的传输路径交叉在一起时，就会形成一条汇聚节点到事件区域的完整路径。</p><p><img src="/IoT-%E7%AC%AC3%E7%AB%A0-%E6%97%A0%E7%BA%BF%E4%BC%A0%E6%84%9F%E5%99%A8%E7%BD%91%E7%BB%9C-3-3-%E8%B7%AF%E7%94%B1%E6%8A%80%E6%9C%AF/image-20231224130039396.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="rumor"></p><p>优点： 代理消息、查询消息的单播随机转发，克服了使用泛洪方式建立转发路径带来的开销过大问题。</p><p>缺点：传输路径一般不是最优路径，并可能存在路由环路问题。</p><h3 id="地理位置信息路由"><a href="#地理位置信息路由" class="headerlink" title="地理位置信息路由"></a><strong>地理位置信息路由</strong></h3><p>   <strong>地理位置信息路由假设节点知道自己的地理位置信息，以及目的节点或者目的区域的地理位置，利用这些地理位置信息作为路由选择的依据，节点按照一定策略转发数据到目的节点。地理位置信息的精确度和代价相关，在不同的应用中会选择不同精确度的位置信息来实现数据的路由转发。</strong></p><ul><li><strong>基于位置的分组转发机制</strong></li><li><strong>从所有比当前节点更靠近目的节点的邻居中，选择下一跳合适节点。</strong></li><li><strong>最近邻选择法（短程多跳、降低能量消耗）</strong></li><li><strong>最接近目的节点选择法（减少总跳数、降低延迟）</strong></li><li><strong>最大剩余能量节点选择法（能耗均衡、延长网络寿命）</strong></li><li><strong>空洞绕行技术</strong><ul><li><strong>局部最小节点，空洞区域，</strong></li><li><strong>GPSR协议（贪婪+绕行）</strong></li></ul></li><li><strong>基于曲线的路由技术</strong><ul><li><strong>TBR (Trajectiry-Based Routing)协议</strong></li><li><strong>采用不同曲线（最靠近曲线、沿曲线前进距离最大、随机），提供多样性路径，达到流量均衡；控制路径长度；不受节点移动影响。</strong></li></ul></li></ul><h4 id="GPSR路由（Greedy-Perimeter-Stateless-Routing）"><a href="#GPSR路由（Greedy-Perimeter-Stateless-Routing）" class="headerlink" title="GPSR路由（Greedy Perimeter Stateless Routing）"></a><strong>GPSR路由（Greedy Perimeter Stateless Routing）</strong></h4><p><strong>根据节点自身位置和数据包目标位置来确定转发策略。</strong></p><p><strong>包含两个工作模式</strong></p><p>​–<strong>贪婪转发（greedy forwarding）：当节点收到数据包时，贪婪（局部最优）地选择离目标节点位置最近的邻居节点作为下一跳</strong>；</p><ul><li><strong>只需知道节点位置，不需要维护路由，节省了协议开销</strong></li><li><strong>路由空洞：每个节点只根据自身的邻居信息来选择下一跳，可能会出现节点周围没有比距离目标节点比自己更近的邻居节点，导致数据包无法继续转发。</strong></li></ul><p>​–<strong>空洞绕路（perimeter forwarding）：当节点没有离目标节点更近的邻居节点时（称为路由空洞），它使用右手法则绕过空洞区域。</strong></p><p><img src="/IoT-%E7%AC%AC3%E7%AB%A0-%E6%97%A0%E7%BA%BF%E4%BC%A0%E6%84%9F%E5%99%A8%E7%BD%91%E7%BB%9C-3-3-%E8%B7%AF%E7%94%B1%E6%8A%80%E6%9C%AF/image-20231224130257311.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="GPSR"></p><h5 id="GPRS中的空洞绕路"><a href="#GPRS中的空洞绕路" class="headerlink" title="GPRS中的空洞绕路"></a><strong>GPRS中的空洞绕路</strong></h5><p><strong>右手法则：分组总是沿着输入边逆时针方向的下一条边转发。</strong></p><p>–<strong>在区域内部使用右手法则时，行进路线沿顺时针方向；</strong></p><p>–<strong>在区域外部使用右手法则时，行进路线沿逆时针方向。</strong></p><p><img src="/IoT-%E7%AC%AC3%E7%AB%A0-%E6%97%A0%E7%BA%BF%E4%BC%A0%E6%84%9F%E5%99%A8%E7%BD%91%E7%BB%9C-3-3-%E8%B7%AF%E7%94%B1%E6%8A%80%E6%9C%AF/image-20231224130333552.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="空洞绕路"></p><p><strong>两种工作模式的切换</strong></p><p><strong>贪婪转发-&gt;空洞绕路：当节点邻居中没有更靠近目标节点的节点时，按照空洞绕路策略转发分组。</strong></p><p><strong>空洞绕路-&gt;贪婪转发：当一个邻居节点到目标节点的距离比目标节点到开始进行空洞绕路时节点的距离更近，就切换回贪婪转发模式</strong></p><h5 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a><strong>工作原理</strong></h5><p><strong>在数据查询类应用中，汇聚节点需要将查询命令发送到事件区域的所有节点。GEAR路由机制根据事件区域的地理位置信息，建立汇聚节点到事件区域的优化路径，避免了洪泛传播方式，从而减少路由开销。</strong></p><p><strong>GEAR路由假设已知事件区域的位置信息，每个节点知道自己的位置信息和剩余能量信息（及已消耗能量信息），并通过一个简单的HELLO消息交换机制将此信息发布给所有邻居节点。节点间的无线链路是对称的。</strong></p><p><strong>GEAR路由中查询消息传播包括两个阶段。</strong></p><p><strong>（1）sink发出查询命令，并根据事件区域的地理位置和节点能量消耗，将查询命令传送到区域内距汇聚节点最近的节点；</strong></p><p><strong>（2）获得查询命令的节点将查询命令传播到区域内的其他所有节点。</strong></p><p><strong>来自查询区域内的监测数据沿着查询消息的反向路径传送到sink。</strong></p><blockquote><p>GEAR 路由： 1）查询消息传送到事件区域 – 路径选择</p><p><strong>节点N维持自身到事件区域R的实际代价h(N, R)，并定时广播给邻居节点。</strong></p><p><strong>每当节点T需要转发一个目的为R的分组时，T中选取到R的代价最小的一个邻居作为下一跳节点。</strong></p><p><strong>即T根据所有邻居节点的h(Ni, R)值选取最小值Nmin</strong>  <strong>，并更新其自身的h(T, R)</strong> </p><p><strong>h(T, R) &#x3D;h(Nmin,R) + C(T,Nmin)</strong></p><p><strong>但在网络初始阶段，还未建立从sink到R的路径，节点没有实际代价，此时T计算邻居节点的估计代价c(N, R)作为代替。</strong></p><p><strong>节点N到事件区域R的估计代价c(N, R)，定义为节点到事件区域几何中心的距离d(N, R)（归一化）、节点已消耗能量e(N)（归一化）的加权平均：</strong></p><p> <strong>c(N, R)</strong>  <strong>&#x3D;α∙ d(N, R)+(1 -α) e(N)</strong>      <strong>0 &lt;α&lt; 1为 比例参数</strong></p><p><strong>（归一化：d(N, R)、e (N)分别按照邻居节点中的最大d值、最大e值取1按比例换算。）</strong></p><p><strong>c(N, R)的意义：考虑当邻居节点的（1）耗能值相同时；（2）距离值相同时</strong></p><p><strong>每跳如此操作，形成一条到达事件区域的查询路径。</strong></p><p>GEAR 路由： 1）路径选择 – 实际代价修正</p><p><strong>查询信息到达事件区域后，节点沿查询路径反方向传输监测数据。在此过程中，中间节点需要修正它们的实际代价。</strong></p><p><strong>为此，数据消息中捎带一个能耗字段（初始为0），数据消息传输每经过一个节点时，节点将自身传送消息到下一跳的能耗值累加在能耗字段上，然后转发到下一跳节点。能耗字段值实际上就是从节点发送分组到事件区域的总能耗。</strong></p><p><strong>下一次转发查询消息时，用节点记录的实际能耗值代替上述公式中的d(N, R)，计算它到事件区域的实际代价h(T, R)。节点用调整后的实际代价h(T, R)选择到事件区域的优化路径。</strong></p><p>GEAR 路由： 1）查询消息传送到事件区域 – 空洞绕行</p><p><img src="/IoT-%E7%AC%AC3%E7%AB%A0-%E6%97%A0%E7%BA%BF%E4%BC%A0%E6%84%9F%E5%99%A8%E7%BD%91%E7%BB%9C-3-3-%E8%B7%AF%E7%94%B1%E6%8A%80%E6%9C%AF/image-20231224130711509.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="空洞绕行"></p><p><strong>图例：从S开始的路径建立过程，采用上述的贪婪算法。</strong></p><p><strong>局部最优，有可能陷入路由空洞（C是S的邻居节点中到目标T实际代价最小的节点，但G,H,I为失效节点，C的所有邻居到目标T的实际代价都比C大）。</strong></p><p><strong>路径调整方法：</strong></p><ul><li><strong>节点C选取邻居节点中实际代价最小的节点B作为下一跳节点，并将自己的实际代价值设为B的实际代价加上C到B一跳通信的代价，并将此通知S。</strong></li><li><strong>当节点S再转发查询命令到节点T时就会选择B而不是C作为下一跳节点。</strong></li></ul><p><strong>或者使用相邻两跳节点的地理位置信息。</strong></p><p>GEAR 路由： 2）查询消息在事件区域内传播</p><ul><li><strong>当查询命令传送到事件区域后，如何传播到区域内所有节点</strong></li><li><strong>洪泛方式：适用于事件区域内节点少时，路由效率高。</strong></li><li><strong>迭代地理转发策略：适用于事件区域内节点多时，消息转发次数少。</strong><ul><li><strong>将本区域划分为若干子区域，并转发查询命令…以此迭代直至子区域仅一个节点。</strong></li></ul></li><li><strong>当查询命令到达区域内第一个节点时，如果该节点的邻居数量大于一个预设的阈值，则使用迭代地理转发，否则使用洪泛方式。</strong></li></ul><p><img src="/IoT-%E7%AC%AC3%E7%AB%A0-%E6%97%A0%E7%BA%BF%E4%BC%A0%E6%84%9F%E5%99%A8%E7%BD%91%E7%BB%9C-3-3-%E8%B7%AF%E7%94%B1%E6%8A%80%E6%9C%AF/image-20231224130806592.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="传播"></p><p><strong>GEAR路由中假设节点的地理位置固定或变化不频繁，适用于节点移动性不强的应用环境。</strong></p></blockquote><p><strong>例：在GEAR路由的区域外查询消息传播阶段，节点S有邻居节点A、B、C，它们到事件区域几何中心的距离分别为150、120、90，节点能耗值分别为3、5、10，加权系数设为0.7。试问节点S选取哪个节点作为下一跳？</strong></p><p><img src="/IoT-%E7%AC%AC3%E7%AB%A0-%E6%97%A0%E7%BA%BF%E4%BC%A0%E6%84%9F%E5%99%A8%E7%BD%91%E7%BB%9C-3-3-%E8%B7%AF%E7%94%B1%E6%8A%80%E6%9C%AF/image-20231224130833961.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="ans"></p><h3 id="多径路由"><a href="#多径路由" class="headerlink" title="多径路由"></a><strong>多径路由</strong></h3><p><strong>在传感器网络中，引入多路径路由是为了（1）提高数据传输可靠性、和（2）实现网络负载平衡。当主路径失效时，退而使用次优路径转发。在多路径路由中，如何建立数据源节点到汇聚节点的多条路径是首要问题。</strong></p><p><strong>基本思想：首先建立从数据源节点到汇聚节点的主路径，然后再建立多条备用路径；数据通过主路径进行传播，同时利用备用路径低速传送数据来维护路径的有效性；当主路径失效时，从备用路径中选择次优路径作为新的主路径。</strong></p><p><strong>两种算法：不相交多路径（disjoint multipath）和缠绕多路径（braid multipath）</strong></p><h4 id="不相交多路径法"><a href="#不相交多路径法" class="headerlink" title="不相交多路径法"></a><strong>不相交多路径法</strong></h4><p><strong>不相交路径是指从源节点到目的节点之间存在多条路径，但任意两条路径，除源节点和目标节点外都没有相交的节点。</strong></p><p><strong>采用定向发散DD路由，sink先洪泛兴趣消息形成传输梯度，然后建立源节点到sink的多条路径</strong></p><ul><li><strong>sink首先通过主路径增强消息建立主路径，然后发送次优路径增强消息给次优节点A，节点A再选择自己的最优节点B，把次优路径增强消息传递下去。</strong></li><li><strong>如果B在主路径上，则B发回否定增强消息给A，A选择次优节点传递次优增强消息；如果B不在主路径上，则B继续传递次优路径增强消息，直到构造一条次优路径。</strong></li><li><strong>同样方式，可继续构造下一跳次优路径。</strong></li></ul><p><img src="/IoT-%E7%AC%AC3%E7%AB%A0-%E6%97%A0%E7%BA%BF%E4%BC%A0%E6%84%9F%E5%99%A8%E7%BD%91%E7%BB%9C-3-3-%E8%B7%AF%E7%94%B1%E6%8A%80%E6%9C%AF/image-20231224130941803.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="构建法"></p><h4 id="缠绕多路径法（部分不相交）"><a href="#缠绕多路径法（部分不相交）" class="headerlink" title="缠绕多路径法（部分不相交）"></a><strong>缠绕多路径法（部分不相交）</strong></h4><p><strong>理想缠绕多路径（一次建立、节点需要知道全局网络拓扑信息）</strong></p><p><strong>理想缠绕多路径由一组缠绕路径形成；一条缠绕路径对应于主路径上的一个节点，在网络不包含该节点时，形成从源节点到目的节点的优化备用路径。主路径上每个节点都有一条对应的缠绕路径。</strong></p><p><img src="/IoT-%E7%AC%AC3%E7%AB%A0-%E6%97%A0%E7%BA%BF%E4%BC%A0%E6%84%9F%E5%99%A8%E7%BD%91%E7%BB%9C-3-3-%E8%B7%AF%E7%94%B1%E6%8A%80%E6%9C%AF/image-20231224131007127.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="理想"></p><p><strong>局部缠绕多路径（逐步探索、节点仅需局部信息）</strong></p><p><strong>建立主路径后，主路径上的每一个节点（除了源端和靠近源端的节点）都要发送备用路径增强消息给自己的次优节点A，次优节点A再寻找其最优节点B传播该备用路径增强消息。如果节点B不在主路径上，将继续向自己的最优节点传播，直到与主路径相交形成一条新的备用路径。</strong></p><p><img src="/IoT-%E7%AC%AC3%E7%AB%A0-%E6%97%A0%E7%BA%BF%E4%BC%A0%E6%84%9F%E5%99%A8%E7%BD%91%E7%BB%9C-3-3-%E8%B7%AF%E7%94%B1%E6%8A%80%E6%9C%AF/image-20231224131023649.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="局部"></p><h4 id="多径路由：可靠路由"><a href="#多径路由：可靠路由" class="headerlink" title="多径路由：可靠路由"></a><strong>多径路由：可靠路由</strong></h4><p><strong>多径路由可以克服主路径上单个节点失效的问题。备用路径之间具有不同的优先级，当主路径失效时，次优路径将被激活成为新的主路径。因此，少量节点失效并不影响网络功能正常执行。</strong></p><p><strong>但是，网络内的部分节点需要保存多条路径信息，增加了存储开销和协议复杂度。</strong></p><p><strong>传感器节点由于有限能量供应和工作环境恶劣经常面临失效问题，而某些应用对于数据传输的可靠性提出了较高要求。可靠路由协议主要从两个方面考虑</strong></p><ul><li><strong>一是利用节点的冗余性提供多条路径以保证通信可靠性</strong></li><li><strong>二是建立对传输可靠性的估计机制，从而保证每条传输的可靠性。</strong></li></ul><h3 id="QoS路由"><a href="#QoS路由" class="headerlink" title="QoS路由"></a><strong>QoS路由</strong></h3><h4 id="MMSpeed-Multi-path-Multi-SPEED-协议"><a href="#MMSpeed-Multi-path-Multi-SPEED-协议" class="headerlink" title="MMSpeed(Multi-path Multi-SPEED)协议"></a><strong>MMSpeed(Multi-path Multi-SPEED)协议</strong></h4><p><strong>MMSPEED是在SPEED基础上提出的一种同时考虑传输延迟和丢包率的QoS路由协议。</strong></p><ul><li><strong>SPEED仅能支持一种速率要求，而MMSPEED可以同时支持不同应用的多种速率；</strong></li><li><strong>SPEED不考虑端到端传输的可靠，而MMSPEED在速率的基础上，还支持不同的端到端可靠性要求；</strong></li><li><strong>SPEED没有考虑估计误差对端到端延迟的影响，MMSPEED在每一跳节点上都需要进行速率补偿和可靠性补偿，不断纠正由于估计误差造成的影响。</strong></li></ul><p><strong>协议包括两个基本组件：时延控制、可靠性控制</strong></p><h5 id="MMSPEED的两个基本组件"><a href="#MMSPEED的两个基本组件" class="headerlink" title="MMSPEED的两个基本组件"></a><strong>MMSPEED的两个基本组件</strong></h5><p><img src="/IoT-%E7%AC%AC3%E7%AB%A0-%E6%97%A0%E7%BA%BF%E4%BC%A0%E6%84%9F%E5%99%A8%E7%BD%91%E7%BB%9C-3-3-%E8%B7%AF%E7%94%B1%E6%8A%80%E6%9C%AF/image-20231224131150334.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="时延控制"></p><p><strong>速度层次：双层优先级保障</strong></p><ul><li><strong>多个转发队列的不同优先级：高优先级能够更快转发</strong></li><li><strong>利用跨层设计（MAC层），高优先级节点的发包间隔更短、回退窗口更小，更容易抢占信道。</strong></li></ul><p><img src="/IoT-%E7%AC%AC3%E7%AB%A0-%E6%97%A0%E7%BA%BF%E4%BC%A0%E6%84%9F%E5%99%A8%E7%BD%91%E7%BB%9C-3-3-%E8%B7%AF%E7%94%B1%E6%8A%80%E6%9C%AF/image-20231224131252000.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="时延"></p><p><img src="/IoT-%E7%AC%AC3%E7%AB%A0-%E6%97%A0%E7%BA%BF%E4%BC%A0%E6%84%9F%E5%99%A8%E7%BD%91%E7%BB%9C-3-3-%E8%B7%AF%E7%94%B1%E6%8A%80%E6%9C%AF/image-20231224131205581.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="可靠性控制"></p><ul><li><strong>通过多径传输实现</strong></li><li><strong>节点i估算它通过j到sink的端到端收包率RP &#x3D; ( 1 –eij)n，n为估计跳数</strong> </li><li><strong>每个节点都动态选择一到多条转发路径来满足数据流的可靠性要求</strong></li><li><strong>由一路分为多路时，每条路径上要求满足的端到端收包率会降低</strong></li></ul><p><img src="/IoT-%E7%AC%AC3%E7%AB%A0-%E6%97%A0%E7%BA%BF%E4%BC%A0%E6%84%9F%E5%99%A8%E7%BD%91%E7%BB%9C-3-3-%E8%B7%AF%E7%94%B1%E6%8A%80%E6%9C%AF/image-20231224131319942.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="可靠性"></p><h2 id="无线传感器网络路由协议特点"><a href="#无线传感器网络路由协议特点" class="headerlink" title="无线传感器网络路由协议特点"></a><strong>无线传感器网络路由协议特点</strong></h2><p><strong>（1）能量优先。传统路由协议在选择最优路径时，很少考虑节点的能量消耗问题。而无线传感器网络中节点的能量有限，延长整个网络的生存期成为传感器网络路由协议设计的重要目标，因此需要考虑节点的能量消耗以及网络能量均衡使用的问题。</strong></p><p><strong>（2）基于局部拓扑信息。无线传感器网络为了节省通信能量，通常采用多跳的通信模式，而节点有限的存储资源和计算资源，使得节点不能存储大量的路由信息，不能进行太复杂的路由计算。在节点只能获取局部拓扑信息和资源有限的情况下，如何实现简单高效的路由机制时无线传感器网络的一个基本问题。</strong></p><p><strong>（3）以数据为中心。传统的路由协议通常以地址作为节点的标识和路由的依据，而无线传感器网络中大量节点随机部署，所关注的是监测区域的感知数据，而不是具体哪个节点获取的信息，不依赖于全网惟一的标识。传感器网络通常包含多个传感器节点到少数汇聚节点的数据流，按照对感知数据的需求、数据通信模式和流向等，以数据为中心形成消息的转发路径。</strong></p><p><strong>（4）应用相关。传感器网络的应用环境千差万别，数据通信模式不同，没有一个路由机制适合所有的应用，这是传感器网络应用相关性的一个体现。设计者需要针对每一个具体应用的需求，设计与之适应的特定路由机制。</strong></p><h2 id="无线传感器网络路由机制的要求"><a href="#无线传感器网络路由机制的要求" class="headerlink" title="无线传感器网络路由机制的要求"></a><strong>无线传感器网络路由机制的要求</strong></h2><p><strong>（1）能量高效。传感器网络路由协议不仅要选择能量消耗小的消息传输路径，而且要从整个网络的角度考虑，选择使整个网络能量均衡消耗的路由。传感器节点的资源有限，传感器网络的路由机制要能够简单而且高效地实现信息传输。</strong></p><p><strong>（2）可扩展性。在无线传感器网络中，检测区域范围或节点密度不同，造成网络规模大小不同；节点失败、新节点加入以及节点移动等，都会使得网络拓扑结构动态发生变化，这就要求路由机制具有可扩展性，能够适应网络结构的变化。</strong></p><p><strong>（3）鲁棒性。能量用尽或环境因素造成传感器网络节点的失败，周围环境影响无线链路的通信质量以及无线链路本身的缺点等，这些无线传感器网络的不可靠性要求路由机制具有一定的容错能力。</strong></p><p><strong>（4）快速收敛性。传感器网络的拓扑结构动态变化，节点能量和通信带宽等资源有限，因此要求路由机制能够快速收敛，以适应网络拓扑的动态变化，减少通信协议开销，提高消息的传输效率。</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;第三章-无线传感器网络&quot;&gt;&lt;a href=&quot;#第三章-无线传感器网络&quot; class=&quot;headerlink&quot; title=&quot;第三章 无线传感器网络&quot;&gt;&lt;/a&gt;第三章 无线传感器网络&lt;/h1&gt;&lt;h2 id=&quot;3-3-路由技术&quot;&gt;&lt;a href=&quot;#3-3-路由技术&quot;</summary>
      
    
    
    
    <category term="学习资料" scheme="https://www.emokable.top/categories/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/"/>
    
    
    <category term="课件笔记" scheme="https://www.emokable.top/tags/%E8%AF%BE%E4%BB%B6%E7%AC%94%E8%AE%B0/"/>
    
    <category term="物联网技术与应用" scheme="https://www.emokable.top/tags/%E7%89%A9%E8%81%94%E7%BD%91%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%BA%94%E7%94%A8/"/>
    
    <category term="IoT" scheme="https://www.emokable.top/tags/IoT/"/>
    
  </entry>
  
  <entry>
    <title>I卡配IU之我购买了一张Intel显卡--DG1</title>
    <link href="https://www.emokable.top/I%E5%8D%A1%E9%85%8DIU%E4%B9%8B%E6%88%91%E8%B4%AD%E4%B9%B0%E4%BA%86%E4%B8%80%E5%BC%A0Intel%E6%98%BE%E5%8D%A1-DG1/"/>
    <id>https://www.emokable.top/I%E5%8D%A1%E9%85%8DIU%E4%B9%8B%E6%88%91%E8%B4%AD%E4%B9%B0%E4%BA%86%E4%B8%80%E5%BC%A0Intel%E6%98%BE%E5%8D%A1-DG1/</id>
    <published>2023-11-09T04:01:42.000Z</published>
    <updated>2023-11-11T12:23:38.064Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一-简介"><a href="#一-简介" class="headerlink" title="一.简介"></a>一.简介</h1><p>在去年很长的一段时间里，我的主力机配置都是r5 5600+ Msi b450m mortar max+ Radeon RX 6700xt 12g组成的3A平台</p><p>因为一些原因到今年还是换成了比较普遍的I U+N卡，最近逛咸鱼时发现二手平台上的所谓Intel第一张显卡DG1<del>实际上有更早的i740 GPU（Real3D i740 Starfighter），鱼上也有卖的，不过是AGP协议的（可见于上学期的嵌入式系统课）</del>掉到了200元以内，看了下参数感觉还是比较符合亮机卡的水平的，于是买了一张来作为收藏……顺便搭建一下3I平台来增添一点信仰值。这和我不多添100r买带核显的12400而买12400F绝没有半毛钱的关系&#x2F;(ㄒoㄒ)&#x2F;。</p><p>头图和内容无关，不是Arc独显买不起，而是Xe亮机卡更有性价比。</p><p><img src="https://n.sinaimg.cn/spider2020115/244/w600h444/20201105/6cff-kcpxnwv6744180.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="I740 agp"></p><p><img src="https://tpucdn.com/gpu-specs/images/b/8654-front.jpg" srcset="/img/mahmoud-habibi.gif" lazyload alt="我买的就是这款阿苏斯被动散热款 | TechPowerUp GPU Database"></p><p>报一报参数，DG1共有两个版本，一种是80eu的普通版，<del>我的就是</del>，另一种是96eu的max版本，在咸鱼价钱稍微贵一些，但其实性能相差也不大，这两样都和移动端非HX的Xe核显一样（12XXXHX 32eu;12450H 48eu；12500H&#x2F;12600H 80eu;12700H&#x2F;12900H 96eu），比桌面端的Xe强不少(UHD710,16EU,如G7400;UHD730,24EU如12100&#x2F;12400&#x2F;13100&#x2F;13400;UHD750&#x2F;UHD770,32EU，12500+&#x2F;13500+&#x2F;14600k+)</p><p>下面就看看实物图吧，看着薄薄一片，实则被动散热铁皮分量够，其实还挺重的</p><p><img src="/I%E5%8D%A1%E9%85%8DIU%E4%B9%8B%E6%88%91%E8%B4%AD%E4%B9%B0%E4%BA%86%E4%B8%80%E5%BC%A0Intel%E6%98%BE%E5%8D%A1-DG1/image-20231111201406048.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="空荡荡的机箱，散热器变双塔了"></p><p><img src="/I%E5%8D%A1%E9%85%8DIU%E4%B9%8B%E6%88%91%E8%B4%AD%E4%B9%B0%E4%BA%86%E4%B8%80%E5%BC%A0Intel%E6%98%BE%E5%8D%A1-DG1/image-20231111201445577.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="睾贵的阿苏斯显卡"></p><p><img src="/I%E5%8D%A1%E9%85%8DIU%E4%B9%8B%E6%88%91%E8%B4%AD%E4%B9%B0%E4%BA%86%E4%B8%80%E5%BC%A0Intel%E6%98%BE%E5%8D%A1-DG1/image-20231111201511874.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="接口齐全"></p><p><img src="/I%E5%8D%A1%E9%85%8DIU%E4%B9%8B%E6%88%91%E8%B4%AD%E4%B9%B0%E4%BA%86%E4%B8%80%E5%BC%A0Intel%E6%98%BE%E5%8D%A1-DG1/image-20231111201532294.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="亮机卡哪来的背板"></p><h1 id="二-点亮"><a href="#二-点亮" class="headerlink" title="二.点亮"></a>二.点亮</h1><p>关于I卡，一般都得在10代以上平台使用，还要关csm，开above 4G和Resizable bar这三样设置才行。然而DG1根本不支持开rebar，可有可无。</p><p>好在我使用的12代平台直接插上就能亮机，无需过多设置。</p><p><img src="/I%E5%8D%A1%E9%85%8DIU%E4%B9%8B%E6%88%91%E8%B4%AD%E4%B9%B0%E4%BA%86%E4%B8%80%E5%BC%A0Intel%E6%98%BE%E5%8D%A1-DG1/image-20231111185454037.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="不打驱动也能进系统"></p><p><img src="/I%E5%8D%A1%E9%85%8DIU%E4%B9%8B%E6%88%91%E8%B4%AD%E4%B9%B0%E4%BA%86%E4%B8%80%E5%BC%A0Intel%E6%98%BE%E5%8D%A1-DG1/image-20231111190133103.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="windows自动打的驱动"></p><p>图吧工具箱识别显存大小不对，GPUZ的频率也不对。。。</p><p>然后手动去官网打驱动</p><p><img src="/I%E5%8D%A1%E9%85%8DIU%E4%B9%8B%E6%88%91%E8%B4%AD%E4%B9%B0%E4%BA%86%E4%B8%80%E5%BC%A0Intel%E6%98%BE%E5%8D%A1-DG1/image-20231111190348274.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="Xe显卡"></p><p>打上后还是有识别错误，感觉Intel全力发展Arc显卡完全不再管这款80eu的大号核显了</p><p><img src="/I%E5%8D%A1%E9%85%8DIU%E4%B9%8B%E6%88%91%E8%B4%AD%E4%B9%B0%E4%BA%86%E4%B8%80%E5%BC%A0Intel%E6%98%BE%E5%8D%A1-DG1/image-20231111190427803.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="突破天际的频率"></p><h1 id="三-跑分"><a href="#三-跑分" class="headerlink" title="三.跑分"></a>三.跑分</h1><p>接着就是常规的跑分测试环节了，看看这张亮机卡&#x2F;大号核显性能如何。–<a href="http://www.3dmark.com/spy/42945698">链接</a></p><p><img src="/I%E5%8D%A1%E9%85%8DIU%E4%B9%8B%E6%88%91%E8%B4%AD%E4%B9%B0%E4%BA%86%E4%B8%80%E5%BC%A0Intel%E6%98%BE%E5%8D%A1-DG1/image-20231111191237344.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="1492分，接近1500了"></p><p>比我笔记本的Vega7核显1181分还是要强的–<a href="http://www.3dmark.com/spy/35558299">链接</a></p><p><img src="/I%E5%8D%A1%E9%85%8DIU%E4%B9%8B%E6%88%91%E8%B4%AD%E4%B9%B0%E4%BA%86%E4%B8%80%E5%BC%A0Intel%E6%98%BE%E5%8D%A1-DG1/image-20231111191055761.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="小新笔记本"></p><p>比比十年前的高端N卡是否有优势呢（忘了用12400F跑了，就拿之前5600的记录来看吧），还是差不不少呢–<a href="http://www.3dmark.com/spy/37450411">链接</a></p><p><img src="/I%E5%8D%A1%E9%85%8DIU%E4%B9%8B%E6%88%91%E8%B4%AD%E4%B9%B0%E4%BA%86%E4%B8%80%E5%BC%A0Intel%E6%98%BE%E5%8D%A1-DG1/image-20231111191600184.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="公版泰坦皮GTX770"></p><p>最后是主力3070–<a href="http://www.3dmark.com/spy/42841778">链接</a></p><p><img src="/I%E5%8D%A1%E9%85%8DIU%E4%B9%8B%E6%88%91%E8%B4%AD%E4%B9%B0%E4%BA%86%E4%B8%80%E5%BC%A0Intel%E6%98%BE%E5%8D%A1-DG1/image-20231111192329325.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="强大十倍"></p><p>再用更大众的鲁大师跑分来看看对比吧</p><p><img src="/I%E5%8D%A1%E9%85%8DIU%E4%B9%8B%E6%88%91%E8%B4%AD%E4%B9%B0%E4%BA%86%E4%B8%80%E5%BC%A0Intel%E6%98%BE%E5%8D%A1-DG1/image-20231111191749948.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="1号选手DG1跑出8.5w"></p><p><img src="/I%E5%8D%A1%E9%85%8DIU%E4%B9%8B%E6%88%91%E8%B4%AD%E4%B9%B0%E4%BA%86%E4%B8%80%E5%BC%A0Intel%E6%98%BE%E5%8D%A1-DG1/image-20231111191825109.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="二号选手gtx770，9.6w"></p><p><img src="/I%E5%8D%A1%E9%85%8DIU%E4%B9%8B%E6%88%91%E8%B4%AD%E4%B9%B0%E4%BA%86%E4%B8%80%E5%BC%A0Intel%E6%98%BE%E5%8D%A1-DG1/image-20231111191945906.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="三号选手3070 62w，内存分低是因为没超频3500"></p><p>最后再对比一下游戏差距叭，就拿最近玩的MC为例了</p><p>不打光影能有150帧，还算不错</p><p><img src="/I%E5%8D%A1%E9%85%8DIU%E4%B9%8B%E6%88%91%E8%B4%AD%E4%B9%B0%E4%BA%86%E4%B8%80%E5%BC%A0Intel%E6%98%BE%E5%8D%A1-DG1/image-20231111192656865.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="1"></p><p>试试第一个光影，直接不能渲染</p><p><img src="/I%E5%8D%A1%E9%85%8DIU%E4%B9%8B%E6%88%91%E8%B4%AD%E4%B9%B0%E4%BA%86%E4%B8%80%E5%BC%A0Intel%E6%98%BE%E5%8D%A1-DG1/image-20231111192736906.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="呃呃"></p><p>试试换一个光影，15帧电竞，和gtx770帧数差不多</p><p><img src="/I%E5%8D%A1%E9%85%8DIU%E4%B9%8B%E6%88%91%E8%B4%AD%E4%B9%B0%E4%BA%86%E4%B8%80%E5%BC%A0Intel%E6%98%BE%E5%8D%A1-DG1/image-20231111192821144.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="渲染正常了"></p><p>我的3070开光影大概能有70-100帧左右吧，差距也挺大了。看来DG1还是作为亮机卡比较合适。。。。。。</p><h1 id="四-整个花活"><a href="#四-整个花活" class="headerlink" title="四.整个花活"></a>四.整个花活</h1><p>继续玩我在b450平台上玩过的多卡。。。不过华擎这张板子的pcie划分很难受，只有一根全长的pcie 4.0x16插槽和一根pcie3.0*1的插槽，而且距离过近，也不适合插多卡（完全不如之前坏掉的b450迫击炮max）。</p><p><img src="/I%E5%8D%A1%E9%85%8DIU%E4%B9%8B%E6%88%91%E8%B4%AD%E4%B9%B0%E4%BA%86%E4%B8%80%E5%BC%A0Intel%E6%98%BE%E5%8D%A1-DG1/image-20231111193514764.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="b660m pg riptide"></p><p><img src="/I%E5%8D%A1%E9%85%8DIU%E4%B9%8B%E6%88%91%E8%B4%AD%E4%B9%B0%E4%BA%86%E4%B8%80%E5%BC%A0Intel%E6%98%BE%E5%8D%A1-DG1/image-20231111193537926.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="b450m mortar max"></p><p>A&#x2F;I亮机卡之战</p><p><img src="/I%E5%8D%A1%E9%85%8DIU%E4%B9%8B%E6%88%91%E8%B4%AD%E4%B9%B0%E4%BA%86%E4%B8%80%E5%BC%A0Intel%E6%98%BE%E5%8D%A1-DG1/image-20231111193130771.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="加上我的经典亮机卡"></p><p><img src="/I%E5%8D%A1%E9%85%8DIU%E4%B9%8B%E6%88%91%E8%B4%AD%E4%B9%B0%E4%BA%86%E4%B8%80%E5%BC%A0Intel%E6%98%BE%E5%8D%A1-DG1/image-20231111193622464.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="驱动并不冲突"></p><p>P106也行？我的评价是不如核显带P106的玩法</p><p><img src="/I%E5%8D%A1%E9%85%8DIU%E4%B9%8B%E6%88%91%E8%B4%AD%E4%B9%B0%E4%BA%86%E4%B8%80%E5%BC%A0Intel%E6%98%BE%E5%8D%A1-DG1/image-20231111193657156.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="x1槽的带宽会不会太低了些"></p><h1 id="五-后事处理"><a href="#五-后事处理" class="headerlink" title="五.后事处理"></a>五.后事处理</h1><p>本来这件事就属于冲动消费，也不打算自己长期使用，这张卡的归宿可能就是收藏起来长期吃灰（这张板子matx版型插不下更多卡了😡，不然我一定给插上），然后被我卖掉或者拿回老家当亮机卡发光发热（给父母办公看视频还不错嘛），不过DIY嘛，开心就行，以后我出去炫耀也可以说本人也是玩过Intel独显的男人，哈哈。折腾本身就是一种乐趣，拿到喜欢的电子产品高兴才是最重要的一件事……</p><p>下期预告：12代Non-K OC看到华擎妖板懂得都懂<del>才不是本人太懒了，素材存了好久都懒得写博客。。。</del></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一-简介&quot;&gt;&lt;a href=&quot;#一-简介&quot; class=&quot;headerlink&quot; title=&quot;一.简介&quot;&gt;&lt;/a&gt;一.简介&lt;/h1&gt;&lt;p&gt;在去年很长的一段时间里，我的主力机配置都是r5 5600+ Msi b450m mortar max+ Radeon RX </summary>
      
    
    
    
    
    <category term="DIY" scheme="https://www.emokable.top/tags/DIY/"/>
    
    <category term="显卡" scheme="https://www.emokable.top/tags/%E6%98%BE%E5%8D%A1/"/>
    
    <category term="Intel" scheme="https://www.emokable.top/tags/Intel/"/>
    
  </entry>
  
  <entry>
    <title>旧时代电子产品REborn-三星数码相册SPF-87H副屏数据监测</title>
    <link href="https://www.emokable.top/%E6%97%A7%E6%97%B6%E4%BB%A3%E7%94%B5%E5%AD%90%E4%BA%A7%E5%93%81REborn-%E4%B8%89%E6%98%9F%E6%95%B0%E7%A0%81%E7%9B%B8%E5%86%8CSPF-87H%E5%89%AF%E5%B1%8F%E6%95%B0%E6%8D%AE%E7%9B%91%E6%B5%8B/"/>
    <id>https://www.emokable.top/%E6%97%A7%E6%97%B6%E4%BB%A3%E7%94%B5%E5%AD%90%E4%BA%A7%E5%93%81REborn-%E4%B8%89%E6%98%9F%E6%95%B0%E7%A0%81%E7%9B%B8%E5%86%8CSPF-87H%E5%89%AF%E5%B1%8F%E6%95%B0%E6%8D%AE%E7%9B%91%E6%B5%8B/</id>
    <published>2023-10-30T12:56:12.000Z</published>
    <updated>2023-11-11T12:30:47.861Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一-起因"><a href="#一-起因" class="headerlink" title="一.起因"></a>一.起因</h1><p>前不久发现便携屏挺火的，有点动心，价格在大多百元以上，如果我自己是ITX装机或者又别的便携需求买一个倒是无所谓，可是宿舍已经又有一个2k高刷大屏幕了，但是仔细想想自己也没那啥需求，买一个也就纯纯玩具（浪费钱），所以话都说到这份上了还不如直接捡一个便宜的玩具来玩呢。我的需求也不是拿廉价的副屏幕来看文档，只是纯粹当个性能桌面摆件。恰巧搜到了一个三星数码相册改造成监控副屏的方案<a href="https://post.smzdm.com/p/and2q780/">这边是张大妈的文章</a>（可支持大多数三星的数码相册型号），而且是垃圾佬常用的<a href="https://forums.aida64.com/topic/2424-new-lcd-device-support-samsung-spf-digital-photo-frames/">AIDA64软件官方支持方案</a>，这下也不太需要自己去弄，买来装好驱动，即插即用就即可😊。</p><p><img src="/%E6%97%A7%E6%97%B6%E4%BB%A3%E7%94%B5%E5%AD%90%E4%BA%A7%E5%93%81REborn-%E4%B8%89%E6%98%9F%E6%95%B0%E7%A0%81%E7%9B%B8%E5%86%8CSPF-87H%E5%89%AF%E5%B1%8F%E6%95%B0%E6%8D%AE%E7%9B%91%E6%B5%8B/image-20231030213208761.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="兼容型号"></p><h1 id="二-简评"><a href="#二-简评" class="headerlink" title="二.简评"></a>二.简评</h1><p>电子相册现在肯定很多人是没有听说过了，毕竟这玩意儿十几年前就得卖几百上千（三星），现在基本也是销声匿迹，当时买得起的肯定也是副歌们了，就拿我买的SPF-87H为例</p><p><img src="/%E6%97%A7%E6%97%B6%E4%BB%A3%E7%94%B5%E5%AD%90%E4%BA%A7%E5%93%81REborn-%E4%B8%89%E6%98%9F%E6%95%B0%E7%A0%81%E7%9B%B8%E5%86%8CSPF-87H%E5%89%AF%E5%B1%8F%E6%95%B0%E6%8D%AE%E7%9B%91%E6%B5%8B/image-20231030211404660.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="12年报价"></p><p>这是2009年的评测文章<a href="https://lcd.zol.com.cn/134/1345497.html">https://lcd.zol.com.cn/134/1345497.html</a></p><p><img src="/%E6%97%A7%E6%97%B6%E4%BB%A3%E7%94%B5%E5%AD%90%E4%BA%A7%E5%93%81REborn-%E4%B8%89%E6%98%9F%E6%95%B0%E7%A0%81%E7%9B%B8%E5%86%8CSPF-87H%E5%89%AF%E5%B1%8F%E6%95%B0%E6%8D%AE%E7%9B%91%E6%B5%8B/image-20231030211757342.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="距今已经14年了"></p><p><img src="/%E6%97%A7%E6%97%B6%E4%BB%A3%E7%94%B5%E5%AD%90%E4%BA%A7%E5%93%81REborn-%E4%B8%89%E6%98%9F%E6%95%B0%E7%A0%81%E7%9B%B8%E5%86%8CSPF-87H%E5%89%AF%E5%B1%8F%E6%95%B0%E6%8D%AE%E7%9B%91%E6%B5%8B/image-20231030211457796.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="09年要卖上1500rmb"></p><blockquote><p> 在三星SPF-87H的外包装上我们就能清晰的看到这款产品的部分卖点，8英寸的屏幕尺寸，内置1GB的内存容量，迷你显示器功能和超薄机身设计。</p></blockquote><p><img src="https://img2.zol.com.cn/product/31_500x2000/584/cedJ1OIiWpUZ.jpg" srcset="/img/mahmoud-habibi.gif" lazyload alt="抢先体验！三星超时尚相框新品(视频) "></p><p><img src="https://img2.zol.com.cn/product/31_500x2000/673/ceARz444653cI.jpg" srcset="/img/mahmoud-habibi.gif" lazyload alt="抢先体验！三星超时尚相框新品(视频) "></p><p><img src="https://img2.zol.com.cn/product/31_500x2000/679/cec1Z4ENmh9z6.jpg" srcset="/img/mahmoud-habibi.gif" lazyload alt="抢先体验！三星超时尚相框新品(视频) "></p><p>当然现在这款电子相册在海鲜市场只需要几十块就能入手了，成色好的可能要60多，像我淘的这个成色略差（两角漏光），且缺少数据线，只花了35大洋就包邮到学校了。</p><p><img src="/%E6%97%A7%E6%97%B6%E4%BB%A3%E7%94%B5%E5%AD%90%E4%BA%A7%E5%93%81REborn-%E4%B8%89%E6%98%9F%E6%95%B0%E7%A0%81%E7%9B%B8%E5%86%8CSPF-87H%E5%89%AF%E5%B1%8F%E6%95%B0%E6%8D%AE%E7%9B%91%E6%B5%8B/image-20231030212518748.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="万能海鲜市场"></p><p><img src="/%E6%97%A7%E6%97%B6%E4%BB%A3%E7%94%B5%E5%AD%90%E4%BA%A7%E5%93%81REborn-%E4%B8%89%E6%98%9F%E6%95%B0%E7%A0%81%E7%9B%B8%E5%86%8CSPF-87H%E5%89%AF%E5%B1%8F%E6%95%B0%E6%8D%AE%E7%9B%91%E6%B5%8B/image-20231030215302138.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="盒子"></p><p>到手第一件事就是检查有无问题，还好并无大碍，插上数据线后的第一个难题就是电脑无反应，设备管理器里也没有任何新东西，驱动装上后也没反应。。。。。。折腾半天发现是我买的mini B线材问题，检查后发现里面只有两根供电线，没有数据线。无奈只好重新下单购买，这次我选择了一个这样带辅助供电的线材，这样子可以不用外接12V小砖块电源了，全靠主板供电就行。</p><p><img src="/%E6%97%A7%E6%97%B6%E4%BB%A3%E7%94%B5%E5%AD%90%E4%BA%A7%E5%93%81REborn-%E4%B8%89%E6%98%9F%E6%95%B0%E7%A0%81%E7%9B%B8%E5%86%8CSPF-87H%E5%89%AF%E5%B1%8F%E6%95%B0%E6%8D%AE%E7%9B%91%E6%B5%8B/image-20231030213615055.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="一边是Type A另一边是mini usb和辅助供电的type A"></p><h1 id="三-操作流程"><a href="#三-操作流程" class="headerlink" title="三.操作流程"></a>三.操作流程</h1><p>1.打开DIY爱好者和垃圾佬必备的图吧工具箱(<a href="https://www.tbtool.cn/?gozelm=a3oj1">没有的自己下一个</a>)，找到AIDA64，并打开AIDA64</p><p>2.主界面点击 文件-&gt;设置-&gt;LCD，选择Samsung，点击启用SPF LCD支持的选项，如果出现和我一样的绿色SPF Init OK字样，并且屏幕上显示AIDA64字样，则表示接管成功</p><p><img src="/%E6%97%A7%E6%97%B6%E4%BB%A3%E7%94%B5%E5%AD%90%E4%BA%A7%E5%93%81REborn-%E4%B8%89%E6%98%9F%E6%95%B0%E7%A0%81%E7%9B%B8%E5%86%8CSPF-87H%E5%89%AF%E5%B1%8F%E6%95%B0%E6%8D%AE%E7%9B%91%E6%B5%8B/image-20231030214338831.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="这样的"></p><p>接下来就只需要在LCD项目里导入模板修改就行了</p><p><img src="/%E6%97%A7%E6%97%B6%E4%BB%A3%E7%94%B5%E5%AD%90%E4%BA%A7%E5%93%81REborn-%E4%B8%89%E6%98%9F%E6%95%B0%E7%A0%81%E7%9B%B8%E5%86%8CSPF-87H%E5%89%AF%E5%B1%8F%E6%95%B0%E6%8D%AE%E7%9B%91%E6%B5%8B/image-20231030214639874.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="我copy了论坛上的一个主题"></p><p>如果绿字处显示错误，那么就点击出现的网址下载驱动安装，安装结束再进行尝试。</p><p>注意我这个东西，需要在USB插入后的5s内点击“启用SPF LCD支持”内才能顺利接管，具体就听USB设备音效判断即可（5s真男人）。</p><p><img src="/%E6%97%A7%E6%97%B6%E4%BB%A3%E7%94%B5%E5%AD%90%E4%BA%A7%E5%93%81REborn-%E4%B8%89%E6%98%9F%E6%95%B0%E7%A0%81%E7%9B%B8%E5%86%8CSPF-87H%E5%89%AF%E5%B1%8F%E6%95%B0%E6%8D%AE%E7%9B%91%E6%B5%8B/image-20231030215015787.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="设备管理器里的样子"></p><p>想要开机自启也很简单，设置开机自启即可</p><p><img src="/%E6%97%A7%E6%97%B6%E4%BB%A3%E7%94%B5%E5%AD%90%E4%BA%A7%E5%93%81REborn-%E4%B8%89%E6%98%9F%E6%95%B0%E7%A0%81%E7%9B%B8%E5%86%8CSPF-87H%E5%89%AF%E5%B1%8F%E6%95%B0%E6%8D%AE%E7%9B%91%E6%B5%8B/image-20231030215618969.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="设置"></p><p>发现我现在用的ASRock主板关机后USB是可以设置供电的，这样也不需要再对相册进行设定了，不需要关闭相册，正常开关机相册会自动被AIDA64接管</p><h1 id="四-具体效果展示"><a href="#四-具体效果展示" class="headerlink" title="四.具体效果展示"></a>四.具体效果展示</h1><p><img src="/%E6%97%A7%E6%97%B6%E4%BB%A3%E7%94%B5%E5%AD%90%E4%BA%A7%E5%93%81REborn-%E4%B8%89%E6%98%9F%E6%95%B0%E7%A0%81%E7%9B%B8%E5%86%8CSPF-87H%E5%89%AF%E5%B1%8F%E6%95%B0%E6%8D%AE%E7%9B%91%E6%B5%8B/image-20231030215126371.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="效果"></p><p><img src="/%E6%97%A7%E6%97%B6%E4%BB%A3%E7%94%B5%E5%AD%90%E4%BA%A7%E5%93%81REborn-%E4%B8%89%E6%98%9F%E6%95%B0%E7%A0%81%E7%9B%B8%E5%86%8CSPF-87H%E5%89%AF%E5%B1%8F%E6%95%B0%E6%8D%AE%E7%9B%91%E6%B5%8B/image-20231030215150341.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="桌面摆件"></p><p><img src="/%E6%97%A7%E6%97%B6%E4%BB%A3%E7%94%B5%E5%AD%90%E4%BA%A7%E5%93%81REborn-%E4%B8%89%E6%98%9F%E6%95%B0%E7%A0%81%E7%9B%B8%E5%86%8CSPF-87H%E5%89%AF%E5%B1%8F%E6%95%B0%E6%8D%AE%E7%9B%91%E6%B5%8B/image-20231030215317705.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="接口，单线就行"></p><p>居然不是萌萌二次元，果然数据展示还是要有点战斗感啊:)</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一-起因&quot;&gt;&lt;a href=&quot;#一-起因&quot; class=&quot;headerlink&quot; title=&quot;一.起因&quot;&gt;&lt;/a&gt;一.起因&lt;/h1&gt;&lt;p&gt;前不久发现便携屏挺火的，有点动心，价格在大多百元以上，如果我自己是ITX装机或者又别的便携需求买一个倒是无所谓，可是宿舍已经</summary>
      
    
    
    
    
    <category term="DIY" scheme="https://www.emokable.top/tags/DIY/"/>
    
    <category term="魔改" scheme="https://www.emokable.top/tags/%E9%AD%94%E6%94%B9/"/>
    
    <category term="SUMSUNG" scheme="https://www.emokable.top/tags/SUMSUNG/"/>
    
    <category term="副屏幕" scheme="https://www.emokable.top/tags/%E5%89%AF%E5%B1%8F%E5%B9%95/"/>
    
    <category term="AIDA64" scheme="https://www.emokable.top/tags/AIDA64/"/>
    
  </entry>
  
  <entry>
    <title>IoT__第3章__无线传感器网络__3.2_MAC协议</title>
    <link href="https://www.emokable.top/IoT-%E7%AC%AC3%E7%AB%A0-%E6%97%A0%E7%BA%BF%E4%BC%A0%E6%84%9F%E5%99%A8%E7%BD%91%E7%BB%9C-3-2-MAC%E5%8D%8F%E8%AE%AE/"/>
    <id>https://www.emokable.top/IoT-%E7%AC%AC3%E7%AB%A0-%E6%97%A0%E7%BA%BF%E4%BC%A0%E6%84%9F%E5%99%A8%E7%BD%91%E7%BB%9C-3-2-MAC%E5%8D%8F%E8%AE%AE/</id>
    <published>2023-10-30T12:50:42.000Z</published>
    <updated>2023-12-20T12:47:22.904Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第三章-无线传感器网络"><a href="#第三章-无线传感器网络" class="headerlink" title="第三章 无线传感器网络"></a>第三章 无线传感器网络</h1><h2 id="3-2-MAC协议"><a href="#3-2-MAC协议" class="headerlink" title="3.2 MAC协议"></a>3.2 <strong>MAC协议</strong></h2><p><strong>竞争型MAC协议—局部同步local synchronization</strong></p><ul><li><strong>IEEE 802.11 MAC层</strong></li><li><strong>S-MAC协议</strong></li><li><strong>T-MAC协议</strong></li></ul><p><strong>竞争型MAC协议—异步no synchronization</strong></p><ul><li><strong>B-MAC协议</strong></li><li><strong>RI-MAC协议</strong></li></ul><p><strong>调度型（分配型）MAC协议—全局同步global synchronization</strong></p><ul><li><strong>TRAMA协议</strong></li><li><strong>DMAC协议</strong></li></ul><p><strong>混合型MAC协议</strong></p><ul><li><strong>Z-MAC</strong></li><li><strong>Funneling-MAC</strong></li></ul><h2 id="3-2-1-1-IEEE-802-11-MAC层"><a href="#3-2-1-1-IEEE-802-11-MAC层" class="headerlink" title="3.2.1.1    IEEE 802.11 MAC层"></a>3.2.1.1    <strong>IEEE 802.11 MAC层</strong></h2><h3 id="ALOHA协议"><a href="#ALOHA协议" class="headerlink" title="ALOHA协议"></a><strong>ALOHA协议</strong></h3><p><strong>Pure ALOHA协议</strong>  </p><p><img src="/IoT-%E7%AC%AC3%E7%AB%A0-%E6%97%A0%E7%BA%BF%E4%BC%A0%E6%84%9F%E5%99%A8%E7%BD%91%E7%BB%9C-3-2-MAC%E5%8D%8F%E8%AE%AE/image-20231220190414294.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="pure"></p><p>Ø<strong>当站点有数据需要发送时，直接向信道发送数据帧。</strong></p><p>Ø<strong>如果发生数据冲突，发送站点等待随机时间，再进行重发，直到发送成功，或最后放弃。</strong></p><p><strong>Slotted ALOHA协议</strong>  </p><p><img src="/IoT-%E7%AC%AC3%E7%AB%A0-%E6%97%A0%E7%BA%BF%E4%BC%A0%E6%84%9F%E5%99%A8%E7%BD%91%E7%BB%9C-3-2-MAC%E5%8D%8F%E8%AE%AE/image-20231220190430564.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="slotted"></p><p>Ø<strong>信道上的时间被划分成离散的时隙，其大小相当于帧的传输时间。所有站点的时钟保持同步。站点只有在时隙开始时才能传输数据。</strong></p><p>Ø<strong>只有那些都在同一个时槽进行传输的帧才有可能冲突，冲突危险区比Pure ALOHA降低了一半 。</strong></p><h3 id="CSMA（载波侦听多路访问协议）"><a href="#CSMA（载波侦听多路访问协议）" class="headerlink" title="CSMA（载波侦听多路访问协议）"></a><strong>CSMA（载波侦听多路访问协议）</strong></h3><p><strong>Pure ALOHA和SlottedALOHA都没有利用到以太网和无线分组网的一个主要特性，那就是与帧的传输时间相比，传播时间是很短的：当一个站点发送帧后，具有载波侦听的其它站点很快就会知道。</strong></p><p><strong>CSMA</strong></p><p>Ø<strong>非坚持CSMA协议（NonpersistentCSMA）</strong></p><p>Ø<strong>1-坚持CSMA协议 （1-persistent CSMA）</strong></p><p>Ø<strong>P-坚持CSMA协议（P-persistent CSMA）</strong></p><h4 id="几种CSMA-协议"><a href="#几种CSMA-协议" class="headerlink" title="几种CSMA 协议"></a><strong>几种CSMA 协议</strong></h4><p><strong>与ALOHA的区别：提供载波侦听功能</strong></p><p><strong>节点在发送数据之前，对信道进行侦听，根据信道的忙闲程度再决定是否发送。（更“礼貌”，性能更好）</strong></p><ul><li><p><strong>非坚持CSMA协议</strong></p><ul><li><strong>侦听信道，</strong><ul><li><strong>1) 若信道空闲：发送数据帧。</strong></li><li><strong>2) 若信道忙：等待一段随机时间，重新再侦听。</strong></li></ul></li></ul></li><li><p><strong>1-坚持CSMA</strong>  <strong>协议</strong> </p><ul><li><strong>侦听信道，</strong><ul><li><strong>1) 若信道空闲：发送数据帧。</strong></li><li><strong>2) 若信道忙：仍坚持侦听，一直侦听到信道空闲。</strong></li></ul></li></ul></li><li><p><strong>p -坚持CSMA 协议</strong> (<strong>IEEE 802.11无线局域网使用p-坚持CSMA协议的改进版</strong>)</p><ul><li><strong>侦听信道，</strong><ul><li><strong>1) 若信道空闲：以概率</strong>  <strong>p发送数据帧；以概率</strong>  <strong>1-p</strong>  <strong>延迟一段时间τ，重新侦听。</strong></li><li><strong>2) 若信道忙：仍坚持侦听，一直侦听到信道空闲。</strong></li></ul></li></ul></li></ul><p><img src="/IoT-%E7%AC%AC3%E7%AB%A0-%E6%97%A0%E7%BA%BF%E4%BC%A0%E6%84%9F%E5%99%A8%E7%BD%91%E7%BB%9C-3-2-MAC%E5%8D%8F%E8%AE%AE/image-20231220190740601.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="各种协议的性能对比"></p><h3 id="CSMA-x2F-CD-带冲突检测的载波侦听多路访问"><a href="#CSMA-x2F-CD-带冲突检测的载波侦听多路访问" class="headerlink" title="CSMA&#x2F;CD 带冲突检测的载波侦听多路访问"></a><strong>CSMA&#x2F;CD 带冲突检测的载波侦听多路访问</strong></h3><p><img src="/IoT-%E7%AC%AC3%E7%AB%A0-%E6%97%A0%E7%BA%BF%E4%BC%A0%E6%84%9F%E5%99%A8%E7%BD%91%E7%BB%9C-3-2-MAC%E5%8D%8F%E8%AE%AE/image-20231220190856217.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="cd"></p><p><strong>虽然 CSMA 协议能够通过载波侦听减少数据冲突发生的机会，但由于传播时延的存在，仍然不可避免会发生数据冲突。</strong></p><p><strong>CSMA&#x2F;CD：在 CSMA 的基础上，增加冲突检测的功能，即站点在传输时能够侦听到是否发生冲突。</strong></p><p><strong>CSMA&#x2F;CD 协议思路</strong></p><ul><li><strong>当站点侦听到信道空闲时就发送数据，同时继续侦听下去。</strong></li><li><strong>冲突检测：站点在传输的同时侦听信道，一旦检测到本站传输帧与别的站点传输帧发生冲突时，立即放弃当前帧的发送（而不是继续完成传输），这样可以使信道很快地空闲下来。</strong></li><li><strong>是经典以太网的基础</strong></li></ul><h3 id="无线局域网协议"><a href="#无线局域网协议" class="headerlink" title="无线局域网协议"></a><strong>无线局域网协议</strong></h3><p><strong>隐藏终端问题（hidden station problem）</strong></p><p><strong>暴露终端问题（exposedstation problem）</strong></p><p><strong>冲突避免多路访问（MACA, Multiple Access with CollisionAviodance）</strong></p><ul><li><strong>RTS（Request To Send）帧</strong></li><li><strong>CTS（Clear To Send）帧</strong></li></ul><p><img src="/IoT-%E7%AC%AC3%E7%AB%A0-%E6%97%A0%E7%BA%BF%E4%BC%A0%E6%84%9F%E5%99%A8%E7%BD%91%E7%BB%9C-3-2-MAC%E5%8D%8F%E8%AE%AE/image-20231220190943960.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="ex"></p><p><img src="/IoT-%E7%AC%AC3%E7%AB%A0-%E6%97%A0%E7%BA%BF%E4%BC%A0%E6%84%9F%E5%99%A8%E7%BD%91%E7%BB%9C-3-2-MAC%E5%8D%8F%E8%AE%AE/image-20231220191007273.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="冲突避免多路访问协议MACA：RTS / CTS"></p><h4 id="802-11-MAC子层协议"><a href="#802-11-MAC子层协议" class="headerlink" title="802.11 MAC子层协议"></a><strong>802.11 MAC子层协议</strong></h4><ul><li><strong>操作模式：分布式协调功能DCF、点协调功能PCF（较少用到）</strong></li><li><strong>使用CSMA&#x2F;CA的虚拟信道侦听，借助于</strong></li><li><strong>网络分配向量NAV：记录信道的忙碌时段</strong></li><li><strong>图例：</strong><ul><li><strong>A发送给B，C在A范围内，D在B范围内、但不在A范围内</strong></li></ul></li></ul><p><img src="/IoT-%E7%AC%AC3%E7%AB%A0-%E6%97%A0%E7%BA%BF%E4%BC%A0%E6%84%9F%E5%99%A8%E7%BD%91%E7%BB%9C-3-2-MAC%E5%8D%8F%E8%AE%AE/image-20231220191137670.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="ex"></p><h4 id="CSMA-x2F-CA的基本过程"><a href="#CSMA-x2F-CA的基本过程" class="headerlink" title="CSMA&#x2F;CA的基本过程"></a><strong>CSMA&#x2F;CA的基本过程</strong></h4><ul><li><strong>CSMA&#x2F;CA（带冲突避免的CSMA）协议</strong><ul><li><strong>当一个节点要传输一个无线帧时，它首先侦听信道状态。</strong></li><li><strong>如果信道空闲，而且经过一个帧间间隔时间DIFS，信道仍为空闲，则站点立即开始发送信息。</strong></li><li><strong>如果信道忙，则站点一直侦听信道，直到信道的空闲时间超过DIFS。当信道空闲下来时，节点使用二进制退避算法来避免发生碰撞。</strong></li></ul></li></ul><p><img src="/IoT-%E7%AC%AC3%E7%AB%A0-%E6%97%A0%E7%BA%BF%E4%BC%A0%E6%84%9F%E5%99%A8%E7%BD%91%E7%BB%9C-3-2-MAC%E5%8D%8F%E8%AE%AE/image-20231220191216747.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="ca"></p><p><img src="/IoT-%E7%AC%AC3%E7%AB%A0-%E6%97%A0%E7%BA%BF%E4%BC%A0%E6%84%9F%E5%99%A8%E7%BD%91%E7%BB%9C-3-2-MAC%E5%8D%8F%E8%AE%AE/image-20231220191228424.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="CSMA/CA协议下的收发（例）"></p><p><strong>802.11提供了几种基本帧间间隔，对应于访问无线信道的优先级。</strong></p><p><img src="/IoT-%E7%AC%AC3%E7%AB%A0-%E6%97%A0%E7%BA%BF%E4%BC%A0%E6%84%9F%E5%99%A8%E7%BD%91%E7%BB%9C-3-2-MAC%E5%8D%8F%E8%AE%AE/image-20231220191253819.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="CSMA/CA的帧间间隔"></p><h4 id="无线传感器网络MAC协议概述"><a href="#无线传感器网络MAC协议概述" class="headerlink" title="无线传感器网络MAC协议概述"></a><strong>无线传感器网络MAC协议概述</strong></h4><p><strong>在设计无线传感器网络的MAC协议时，需要着重考虑以下几个方面：</strong></p><p><strong>（1）节省能量</strong></p><p>•<strong>满足应用要求下，尽量节省使用节点能量。</strong></p><p><strong>（2）可扩展性</strong></p><p>•<strong>适应动态变化的网络拓扑。</strong></p><p><strong>（3）网络效率</strong></p><p>•<strong>包括网络的公平性、实时性、网络吞吐容量以及带宽利用率。</strong></p><h4 id="WSN-MAC技术需求"><a href="#WSN-MAC技术需求" class="headerlink" title="WSN MAC技术需求"></a><strong>WSN MAC技术需求</strong></h4><p>What is a good MAC protocol for WSNs?</p><ul><li>energy efficiency</li><li>scalability (to the change in network size,nide density and topology)</li><li>fairness</li><li>latency</li><li>throughput</li><li>bandwidth utilization</li></ul><p>Major sources of energy waste</p><ul><li><strong>collision</strong>: increasing latency as well</li><li><strong>idle listening</strong>: listening to receive possible traffic that is not sent</li><li><strong>overhearing</strong>: a node picks up packets that are destined to other nodes</li><li><strong>overhead</strong>：control packet overhead</li></ul><h4 id="WSN-MAC协议的研究关注点"><a href="#WSN-MAC协议的研究关注点" class="headerlink" title="WSN MAC协议的研究关注点"></a><strong>WSN MAC协议的研究关注点</strong></h4><ul><li><strong>能量效率</strong><ul><li><strong>冲突重传</strong>  <strong>collision and retransmission</strong></li><li><strong>空闲侦听</strong>  <strong>idle listening</strong></li><li><strong>串听</strong>      <strong>overhearing</strong></li><li><strong>控制开销</strong>  <strong>control overhead</strong></li></ul></li><li><strong>可扩展性</strong> </li><li><strong>网络效率</strong> <ul><li><strong>延迟、吞吐量、公平性…</strong></li></ul></li><li><strong>算法复杂度</strong> </li><li><strong>与其它层协议的协同</strong></li></ul><p><strong>重要性依次递减！</strong></p><h4 id="WSN-MAC协议概述"><a href="#WSN-MAC协议概述" class="headerlink" title="WSN MAC协议概述"></a><strong>WSN MAC协议概述</strong></h4><p><strong>传感器节点无线通信模块的状态包括发送状态、接收状态、侦听状态、休眠状态等。</strong></p><ul><li><strong>无线通信模块在发送状态的消耗能量最多，</strong></li><li><strong>在休眠状态的消耗能量最少，</strong></li><li><strong>接收状态和侦听状态下的能量消耗略小于发送状态。</strong></li></ul><p><strong>基于上述原因，传感器网络MAC协议为了减少能量的消耗，通常采用“侦听&#x2F;休眠”交替的无线信道使用策略。</strong></p><p><strong>为使节点休眠时不错过发给它的数据，或减少节点的过度侦听，邻居节点间需要协调侦听和休眠的周期。</strong></p><h2 id="3-2-1-2-S-MAC协议"><a href="#3-2-1-2-S-MAC协议" class="headerlink" title="3.2.1.2   S-MAC协议"></a>3.2.1.2   <strong>S-MAC协议</strong></h2><p><strong>S-MAC协议：</strong></p><p><strong>在802.11 MAC协议基础上，针对传感器网络的节省能量需求而提出的传感器网络MAC协议。</strong></p><p><strong>S-MAC协议假设：通常情况下</strong></p><ul><li><strong>传感器网络的数据传输量少,速率较低，</strong></li><li><strong>节点协作完成共同的任务，</strong></li><li><strong>网络内部能够进行数据的处理和融合以减少数据通信量，</strong></li><li><strong>数据传输经常具有方向性，</strong></li><li><strong>网络能够容忍一定程度的通信延迟。</strong></li></ul><p><strong>主要设计目标：提供良好的扩展性，减少节点能量的消耗。</strong></p><p><strong>针对碰撞重传、串音、空闲侦听和控制消息等可能造成传感器网络消耗更多能量的主要因素，S-MAC协议采用以下机制：</strong></p><p>​–<strong>周期性侦听&#x2F;休眠的低占空比工作方式，控制节点尽可能处于睡眠状态来降低节点能量的消耗；</strong></p><p>​–<strong>邻居节点之间通过协商同步的一致性睡眠调度机制形成虚拟簇，减少节点的空闲侦听时间；</strong></p><p>​–<strong>通过流量自适应侦听机制，减少消息在网络中的传输延迟；</strong></p><p>​–<strong>通过“消息传递”（消息分割和突发传递）机制，减少节点的串听和控制消息的开销。</strong></p><p>​–<strong>尽管每一跳(per-hop)的公平性、延时性能有所降低，但全局(end-to-end)性能不受影响</strong></p><h3 id="S-MAC协议──（1）周期性侦听-x2F-休眠"><a href="#S-MAC协议──（1）周期性侦听-x2F-休眠" class="headerlink" title="S-MAC协议──（1）周期性侦听&#x2F;休眠"></a><strong>S-MAC协议──（1）周期性侦听&#x2F;休眠</strong></h3><h4 id="节点按照周期性的侦听-x2F-休眠时序工作"><a href="#节点按照周期性的侦听-x2F-休眠时序工作" class="headerlink" title="节点按照周期性的侦听&#x2F;休眠时序工作"></a><strong>节点按照周期性的侦听&#x2F;休眠时序工作</strong></h4><ul><li><strong>节点独立调度（schedule）其工作状态，周期性转入休眠，醒来后侦听信道状态，判断是否需要发送或接收数据。</strong></li><li><strong>调度周期：节点的“侦听-休眠”的时序。</strong></li><li><strong>占空比：侦听时段&#x2F; (侦听+休眠)时段</strong></li><li><strong>为了减少能量消耗，节点尽量处于低功耗的休眠状态–&gt;低占空比</strong></li></ul><p><img src="/IoT-%E7%AC%AC3%E7%AB%A0-%E6%97%A0%E7%BA%BF%E4%BC%A0%E6%84%9F%E5%99%A8%E7%BD%91%E7%BB%9C-3-2-MAC%E5%8D%8F%E8%AE%AE/image-20231220191900110.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="周期"></p><h4 id="节点周期的同步"><a href="#节点周期的同步" class="headerlink" title="节点周期的同步"></a><strong>节点周期的同步</strong></h4><ul><li><strong>调度周期的同步：在相同时间侦听，在相同时间休眠。</strong></li><li><strong>希望在相邻节点之间建立同步，以保证可能的收发节点之间具有共同的调度周期。</strong></li><li><strong>所以，节点间需要交换各自的调度信息（广播给邻居节点）。</strong></li><li><strong>通常只能保持局部的同步，很难做到全网同步。</strong></li></ul><p><img src="/IoT-%E7%AC%AC3%E7%AB%A0-%E6%97%A0%E7%BA%BF%E4%BC%A0%E6%84%9F%E5%99%A8%E7%BD%91%E7%BB%9C-3-2-MAC%E5%8D%8F%E8%AE%AE/image-20231220191948525.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="同步"></p><h4 id="相邻节点之间的通信"><a href="#相邻节点之间的通信" class="headerlink" title="相邻节点之间的通信"></a><strong>相邻节点之间的通信</strong></h4><ul><li><strong>假设A、C的周期为schedule1，B、D的周期为schedule2</strong></li><li><strong>周期相同：A、C按照schedule1交互，B、D按照schedule2交互</strong></li><li><strong>周期不同：如果A要和B交互时，则A需要等候B的侦听时间</strong></li><li><strong>如果多个A1… Ak要和B交互，则它们需要竞争信道（RTS&#x2F;CTS）</strong></li><li><strong>当节点开始传输数据时，就不用遵守休眠周期了，待传输结束再休眠</strong></li></ul><h4 id="节点的调度信息的创建和维护"><a href="#节点的调度信息的创建和维护" class="headerlink" title="节点的调度信息的创建和维护"></a><strong>节点的调度信息的创建和维护</strong></h4><p><strong>节点维护一张调度表，用以保存它所有邻居的调度信息</strong></p><p>​1.<strong>节点监听一段时间，如果没有收到其它节点的调度信息，则随机选择一个将来的休眠时间，并立即使用SYNC报文来广播此调度信息（t 秒后本人将休眠等）。称这类节点为synchronizer。</strong></p><p>​2.<strong>如果节点在监听时段内收到了其它节点的调度信息，则将自己的调度周期设为此调度信息，然后等待一个随机时间 td之后广播自己的调度信息。称这类节点为follower。</strong></p><p>​3.<strong>如果节点在已经选择并广播了自己的调度信息后，收到了其它节点的调度信息，则采用所有的调度信息（在所有侦听时间醒来）。</strong></p><p><strong>有可能两（多）个节点各自独立地创建了调度周期，则位于它们之间的边界节点将会同时采用这两（多）个调度周期</strong></p><h4 id="同步保持"><a href="#同步保持" class="headerlink" title="同步保持"></a><strong>同步保持</strong></h4><ul><li><strong>由于时钟漂移的存在，需要在节点之间周期性地重发调度信息，以达到精确同步。</strong></li><li><strong>相邻节点之间通过SYNC消息保持同步</strong></li><li><strong>SYNC 消息是一个很短的控制分组，它包含有发送节点的地址、及其下一次休眠时间（相对于开始发送SYNC消息的时间）等</strong></li><li><strong>当节点接收到SYNC 消息后，将会更新它调度表内的相应条目。</strong></li><li><strong>每个节点通过SYNC 消息来定期广播自己的调度信息，可以使新加入的节点与已有节点保持同步。</strong></li><li><strong>侦听时间分成两部分，用于 SYNC 分组、DATA 分组的收发</strong></li></ul><p><img src="/IoT-%E7%AC%AC3%E7%AB%A0-%E6%97%A0%E7%BA%BF%E4%BC%A0%E6%84%9F%E5%99%A8%E7%BD%91%E7%BB%9C-3-2-MAC%E5%8D%8F%E8%AE%AE/image-20231220192111001.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="同步保持"></p><h4 id="虚拟簇"><a href="#虚拟簇" class="headerlink" title="虚拟簇"></a><strong>虚拟簇</strong></h4><p>​–<strong>在一个分布式多跳网络中，实现所有相邻节点休眠时间的同步通常是比较困难的。因此，S-MAC允许一个节点采用多个休眠调度，以使采用不同调度周期的节点可以通过这类节点进行数据转发。</strong></p><p>​–<strong>通过相邻节点之间的同步，使得周期具有相同调度周期的节点形成一个虚拟簇，簇内节点间可以正常通信。</strong></p><p>​–<strong>对于具有多个调度周期的节点，成为虚拟簇的边界节点，可以同时与多个虚拟簇的节点通信。</strong></p><p>​–<strong>S-MAC协议可以形成众多不同的虚拟簇，对大规模部署的传感器网络具有良好的扩展性。</strong></p><p><img src="/IoT-%E7%AC%AC3%E7%AB%A0-%E6%97%A0%E7%BA%BF%E4%BC%A0%E6%84%9F%E5%99%A8%E7%BD%91%E7%BB%9C-3-2-MAC%E5%8D%8F%E8%AE%AE/image-20231220192158212.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="簇"></p><h3 id="S-MAC协议──（2）消息冲突和串音避免"><a href="#S-MAC协议──（2）消息冲突和串音避免" class="headerlink" title="S-MAC协议──（2）消息冲突和串音避免"></a><strong>S-MAC协议──（2）消息冲突和串音避免</strong></h3><p><img src="/IoT-%E7%AC%AC3%E7%AB%A0-%E6%97%A0%E7%BA%BF%E4%BC%A0%E6%84%9F%E5%99%A8%E7%BD%91%E7%BB%9C-3-2-MAC%E5%8D%8F%E8%AE%AE/image-20231220192235893.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="1"></p><p><strong>冲突避免</strong></p><ul><li><strong>采用 802.11 CSMA&#x2F;CA，即 RTS&#x2F;CTS&#x2F;DATA&#x2F;ACK 过程</strong></li><li><strong>802.11MAC 层的 NAV 虚拟载波侦听 + 物理层的物理载波侦听</strong></li></ul><p><strong>串音避免</strong></p><ul><li><strong>802.11 MAC 由于虚拟载波侦听的需要，要求长期保持对所有邻居流量的侦听，因此串听了大量并非发给它的消息，造成能量浪费，尤其在节点密度大、流量负载重的场合。</strong></li><li><strong>S-MAC的串音避免： 当节点收到RTS&#x2F;CTS ，如果目标不是自己，则进入休眠。</strong></li><li><strong>节点的NAV数据可以作为它休眠时间长度的依据之一。</strong></li><li><strong>例：A传输数据给B，哪些节点应该休眠以避免串听？</strong></li></ul><p><img src="/IoT-%E7%AC%AC3%E7%AB%A0-%E6%97%A0%E7%BA%BF%E4%BC%A0%E6%84%9F%E5%99%A8%E7%BD%91%E7%BB%9C-3-2-MAC%E5%8D%8F%E8%AE%AE/image-20231220192319593.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="ex"></p><h3 id="S-MAC协议──（3）自适应侦听"><a href="#S-MAC协议──（3）自适应侦听" class="headerlink" title="S-MAC协议──（3）自适应侦听"></a><strong>S-MAC协议──（3）自适应侦听</strong></h3><p><strong>流量自适应侦听</strong> </p><p>​<strong>–传感器网络采用多跳通信,节点的周期性休眠导致通信延迟增加，延迟会随着跳数的增多而累加。利用WSN数据传送的方向性特点，采用流量自适应侦听可以减少通信延迟的累加效应。</strong></p><p>​<strong>–基本原理： 在一次侦听周期中，当节点邻居节点传输结束后：</strong></p><p><strong>如果节点（例如C）在这段侦听时间内收到CTS分组，并发现自己正好是通信的下一跳，它就休眠一段时间（此时邻居在接收数据）、并及时醒来，在本调度周期内接收数据，而无需等到下一次调度周期，从而减少了数据的传输延迟。</strong></p><p><strong>如果节点在这段侦听时间内没有收到给自己的CTS分组，则按时返回休眠状态，直至下一次侦听周期。</strong></p><p><img src="/IoT-%E7%AC%AC3%E7%AB%A0-%E6%97%A0%E7%BA%BF%E4%BC%A0%E6%84%9F%E5%99%A8%E7%BD%91%E7%BB%9C-3-2-MAC%E5%8D%8F%E8%AE%AE/image-20231220192513886.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="tu"></p><h3 id="S-MAC协议──（4）消息传递"><a href="#S-MAC协议──（4）消息传递" class="headerlink" title="S-MAC协议──（4）消息传递"></a><strong>S-MAC协议──（4）消息传递</strong></h3><p><strong>消息传递机制</strong></p><p>​<strong>802.11 MAC 支持将长消息分割成几个短消息进行传送，每次传送都使用 RTS&#x2F;CTS 以预约一个短消息时间；</strong></p><p>​<strong>S-MAC 对于长消息采用了专门的消息传递机制：将长消息分割成几个短消息，让它们在预约时间内突发传送，只使用一次RTS&#x2F;CTS 来预约整个长消息时间。</strong></p><p>​<strong>接收节点对每个短消息都要发一个 ACK 应答，未收到ACK的发送节点将会重传该短消息。这里的多次ACK具有防止隐藏终端的作用（例：节点醒来或新节点加入、并且它是接收节点的邻居而非发送节点的邻居）。</strong></p><p><strong>S-MAC 消息传递 vs. 802.11 MAC</strong></p><ul><li><strong>802.11 MAC协议的RTS&#x2F;CTS只预约下一个短消息的时间（公平性），邻居节点必须多次侦听每个短消息的时间。</strong></li><li><strong>S-MAC协议的RTS&#x2F;CTS控制消息和数据消息携带的时间是整个长消息传输的剩余时间（全部预约、分段传输，达到传递长消息时的能量高效），邻居节点仅需一次侦听整个长消息的时间。</strong></li><li><strong>因此，S-MAC通过消息传递机制，减少了邻居的串听。</strong></li></ul><p><img src="/IoT-%E7%AC%AC3%E7%AB%A0-%E6%97%A0%E7%BA%BF%E4%BC%A0%E6%84%9F%E5%99%A8%E7%BD%91%E7%BB%9C-3-2-MAC%E5%8D%8F%E8%AE%AE/image-20231220192616013.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="vs"></p><p><img src="/IoT-%E7%AC%AC3%E7%AB%A0-%E6%97%A0%E7%BA%BF%E4%BC%A0%E6%84%9F%E5%99%A8%E7%BD%91%E7%BB%9C-3-2-MAC%E5%8D%8F%E8%AE%AE/image-20231220192658751.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="ex"></p><p><img src="/IoT-%E7%AC%AC3%E7%AB%A0-%E6%97%A0%E7%BA%BF%E4%BC%A0%E6%84%9F%E5%99%A8%E7%BD%91%E7%BB%9C-3-2-MAC%E5%8D%8F%E8%AE%AE/image-20231220192713811.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="ex2"></p><h3 id="S-MAC协议──小结"><a href="#S-MAC协议──小结" class="headerlink" title="S-MAC协议──小结"></a><strong>S-MAC协议──小结</strong></h3><p><strong>优缺点</strong></p><ul><li><strong>S-MAC协议比IEEE 802.11协议具有更高的能量效率（节省超过90%）、更强的可扩展性，能够更好地适应网络拓扑结构的变化。</strong></li><li><strong>但由于采用固定的休眠占空比，信道的带宽利用率受到一定影响；虚拟簇节点使用大量SYNC广播分组，当网络业务负载较大时，控制开销带来的能耗代价将成为负担。</strong></li><li><strong>S-MAC协议最主要的缺点是较大的传输迟延，因为它是以牺牲迟延换取能量节省的。</strong></li></ul><h2 id="3-2-1-3-T-MAC协议"><a href="#3-2-1-3-T-MAC协议" class="headerlink" title="3.2.1.3  T-MAC协议"></a>3.2.1.3  <strong>T-MAC协议</strong></h2><p>•<strong>T-MAC协议：在S-MAC协议的基础上提出。</strong></p><p>•<strong>传感器网络MAC协议最重要的设计目标是减少能量消耗，而空闲侦听的能量消耗占绝对大的比例，特别是在消息传输频率较低的情况下。</strong></p><p>•<strong>S-MAC协议通过采用周期性侦听&#x2F;睡眠工作方式来减少空闲侦听，周期长度固定不变，节点的侦听活动时间也是固定。</strong></p><p>•<strong>T-MAC协议中，发送数据时仍为RTS&#x2F;CTS&#x2F;DATA&#x2F;ACK的通信过程，节点周期性唤醒进行侦听，如果在一个给定时间TA(time active)内没有发生下面任何一个激活事件，则活动结束。</strong></p><p>​-<strong>周期时间定时器溢出</strong></p><p>​-<strong>在无线信道上收到数据</strong></p><p>​-<strong>通过接收信号强度指示RSSI感知存在无线通信</strong></p><p>​-<strong>节点数据包或确认消息发送完毕</strong></p><p>​-<strong>通过侦听RTS&#x2F;CTS分组，确认邻居的数据交换已经结束。</strong></p><h3 id="S-MAC与T-MAC协议的对比"><a href="#S-MAC与T-MAC协议的对比" class="headerlink" title="S-MAC与T-MAC协议的对比"></a><strong>S-MAC与T-MAC协议的对比</strong></h3><p><img src="/IoT-%E7%AC%AC3%E7%AB%A0-%E6%97%A0%E7%BA%BF%E4%BC%A0%E6%84%9F%E5%99%A8%E7%BD%91%E7%BB%9C-3-2-MAC%E5%8D%8F%E8%AE%AE/image-20231220192913972.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="vs"></p><h3 id="T-MAC协议的基本数据交换"><a href="#T-MAC协议的基本数据交换" class="headerlink" title="T-MAC协议的基本数据交换"></a><strong>T-MAC协议的基本数据交换</strong></h3><p>•<strong>TA取值</strong></p><p>  <strong>在每个活动期间开始，T-MAC协议按照突发方式发送所有数据。TA决定每个周期最小的空闲侦听时间，它的取值对于T-MAC协议性能至关重要,</strong></p><pre><code class="hljs">                                                                   **TA&gt; C+ R + T**</code></pre><p>  <strong>其中，C为竞争信道时间，R、T为发送RTS、CTS分组的时间。</strong></p><p><img src="/IoT-%E7%AC%AC3%E7%AB%A0-%E6%97%A0%E7%BA%BF%E4%BC%A0%E6%84%9F%E5%99%A8%E7%BD%91%E7%BB%9C-3-2-MAC%E5%8D%8F%E8%AE%AE/image-20231220192939088.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="交换"></p><h3 id="T-MAC协议：早睡问题"><a href="#T-MAC协议：早睡问题" class="headerlink" title="T-MAC协议：早睡问题"></a><strong>T-MAC协议：早睡问题</strong></h3><p><strong>假设传输方向A→B →C →D。</strong></p><p><strong>如果节点A通过竞争首先获得发送，A向B发送RTS消息，B应答CTS。</strong></p><p><strong>C收到B发出的CTS消息而转入睡眠状态，当B接收完数据，节点C醒来以便接收节点B发送给它的数据。</strong></p><p><strong>D可能不知道A与B的通信存在，在A→B时的通信状态结束后就已经处于睡眠状态，这样，节点C只能等到下一个周期才能传输数据到D。</strong></p><p><strong>这种通信延迟称为早睡问题（加剧于T-MAC的提前结束活动）。</strong></p><p><img src="/IoT-%E7%AC%AC3%E7%AB%A0-%E6%97%A0%E7%BA%BF%E4%BC%A0%E6%84%9F%E5%99%A8%E7%BD%91%E7%BB%9C-3-2-MAC%E5%8D%8F%E8%AE%AE/image-20231220193013975.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="early sleep"></p><h4 id="1）未来请求发送-future-request-to-send-FRTS"><a href="#1）未来请求发送-future-request-to-send-FRTS" class="headerlink" title="1）未来请求发送(future request-to-send, FRTS)"></a><strong>1）未来请求发送(future request-to-send, FRTS)</strong></h4><p><strong>当节点C收到B发送给A的CTS分组后，立刻向下一跳D发出FRTS分组。</strong></p><p><strong>FRTS分组包含节点D接收数据前需要等待的时间长度，节点D要在休眠相应长度时间后醒来接收数据。</strong></p><p><strong>由于节点C发送的FRTS分组可能干扰节点A发送的数据，所以节点A需要推迟发送数据的时间。节点A通过在接收到CTS分组后发送一个与FRTS分组长度相同的DS (data-send)分组实现对信道的占用。DS分组不包含有用信息。</strong></p><p><strong>节点A在DS分组之后开始发送正常的数据信息。FRTS方法可以提高吞吐率，但DS分组和FRTS分组带来了额外的通信开销。</strong></p><p><img src="/IoT-%E7%AC%AC3%E7%AB%A0-%E6%97%A0%E7%BA%BF%E4%BC%A0%E6%84%9F%E5%99%A8%E7%BD%91%E7%BB%9C-3-2-MAC%E5%8D%8F%E8%AE%AE/image-20231220193043844.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="FRTS"></p><p><img src="/IoT-%E7%AC%AC3%E7%AB%A0-%E6%97%A0%E7%BA%BF%E4%BC%A0%E6%84%9F%E5%99%A8%E7%BD%91%E7%BB%9C-3-2-MAC%E5%8D%8F%E8%AE%AE/image-20231220193054291.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="FRTS"></p><h4 id="2）满缓冲区优先-full-buffer-priority"><a href="#2）满缓冲区优先-full-buffer-priority" class="headerlink" title="2）满缓冲区优先(full buffer priority)"></a><strong>2）满缓冲区优先(full buffer priority)</strong></h4><p><strong>当节点的缓冲区接近占满时，对收到的RTS不作应答，而是立即向目标接收者发送RTS消息，并传输数据给目标节点。</strong></p><p>​–<strong>节点B向节点C发送RTS分组，节点C因缓冲区快满不发送CTS，而是向节点D发送RTS，将它的（缓冲区内）数据发送给节点D。</strong></p><p>​–<strong>该方法的优点是减少了早睡问题发生的可能，并起到了一定的网络流量的控制作用，带来的问题是增加了冲突的可能性。</strong></p><p><img src="/IoT-%E7%AC%AC3%E7%AB%A0-%E6%97%A0%E7%BA%BF%E4%BC%A0%E6%84%9F%E5%99%A8%E7%BD%91%E7%BB%9C-3-2-MAC%E5%8D%8F%E8%AE%AE/image-20231220193729431.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="fbp"></p><h4 id="T-MAC协议：小结"><a href="#T-MAC协议：小结" class="headerlink" title="T-MAC协议：小结"></a><strong>T-MAC协议：小结</strong></h4><p>•<strong>T-MAC协议根据当前的网络通信情况，通过提前结束活动周期来减少空闲侦听，但带来了早睡问题，需要FRTS等方案。</strong></p><p>•<strong>性能对比</strong></p><p>​–<strong>在负载恒定不变的情况下，T-MAC协议与采用固定占空比的S-MAC协议相比，节能效率相仿；</strong></p><p>​–<strong>在负载恒定不变的情况下，T-MAC协议与未采用占空比模式的CSMA协议相比，能够节省多达98%的能量；</strong></p><p>​–<strong>在负载动态可变的情况下，T-MAC协议与S-MAC协议相比，更加节省能量。</strong></p><p><img src="/IoT-%E7%AC%AC3%E7%AB%A0-%E6%97%A0%E7%BA%BF%E4%BC%A0%E6%84%9F%E5%99%A8%E7%BD%91%E7%BB%9C-3-2-MAC%E5%8D%8F%E8%AE%AE/image-20231220193800904.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="ex"></p><h2 id="3-2-2-竞争型MAC协议—异步no-synchronization"><a href="#3-2-2-竞争型MAC协议—异步no-synchronization" class="headerlink" title="3.2.2 竞争型MAC协议—异步no synchronization"></a>3.2.2 <strong>竞争型MAC协议—异步no synchronization</strong></h2><p><strong>上述基于竞争的MAC协议具有良好的扩展性，并且不要求严格的时钟同步，但它们往往只是从发送数据的节点考虑问题，对接收节点的考虑相对较少。</strong></p><p><strong>在基于竞争的MAC协议中，节点发送数据时竞争使用无线信道，并通知接收节点及时处于接收状态。节点处于休眠状态可能造成通信暂时中断，增大消息的传播延迟，所以在节省节点能量和增大消息延迟之间需要权衡。</strong></p><h3 id="竞争型MAC协议：局部同步-gt-异步"><a href="#竞争型MAC协议：局部同步-gt-异步" class="headerlink" title="竞争型MAC协议：局部同步-&gt;异步"></a><strong>竞争型MAC协议：局部同步-&gt;异步</strong></h3><p><strong>基于周期性侦听&#x2F;休眠的方式：减少因空闲侦听造成的能量消耗</strong></p><p><strong>固定占空比方式（局部同步，S-MAC为例）的缺点</strong></p><ul><li><strong>需要依靠大量的控制开销来建立和维护节点间的周期性同步</strong></li><li><strong>节点在没有数据收发时，仍然需要在整个侦听周期内保持侦听状态，对网络业务负载变化的适应性较差。</strong></li></ul><p><strong>异步占空比方式</strong></p><ul><li><strong>基于异步周期性侦听&#x2F;休眠调度机制的协议（B-MAC、RI-MAC 等）</strong></li><li><strong>由各个节点独自决定自己的休眠和唤醒时间，不需要在所有节点之间建立和保持同步，只在发送者&#x2F;接受者有数据需要传送时直接和目标节点建立同步</strong></li><li><strong>分类：发送方发起（B-MAC）、接收方发起（RI-MAC）</strong></li></ul><h3 id="B-MAC协议"><a href="#B-MAC协议" class="headerlink" title="B-MAC协议"></a><strong>B-MAC协议</strong></h3><p><strong>采用前导采样（preamble sampling）来实现收&#x2F;发节点之间的同步，也称为低功耗侦听（LPL）</strong></p><p><img src="/IoT-%E7%AC%AC3%E7%AB%A0-%E6%97%A0%E7%BA%BF%E4%BC%A0%E6%84%9F%E5%99%A8%E7%BD%91%E7%BB%9C-3-2-MAC%E5%8D%8F%E8%AE%AE/image-20231220194239824.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="b-mac"></p><p><strong>侦听周期Tp是一个重要参数，它直接影响节点的能耗</strong></p><ul><li><strong>如果Tp很小，接收节点会因频繁的唤醒侦听而浪费能量</strong></li><li><strong>如果Tp很大，发送节点会因传输很长的前导分组而增加能量消耗</strong></li></ul><p><strong>Preamble长度</strong></p><ul><li><strong>为避免分组空传，前导序列长度需要大于接收方的休眠时间</strong></li></ul><h4 id="B-MAC：低功耗侦听LPL的工作原理"><a href="#B-MAC：低功耗侦听LPL的工作原理" class="headerlink" title="B-MAC：低功耗侦听LPL的工作原理"></a><strong>B-MAC：低功耗侦听LPL的工作原理</strong></h4><p><strong>LPL机制的成功执行依赖于节点对信道状态的准确感知</strong></p><p><strong>采用空闲信道评估机制（clear channel assessment, CCA）</strong></p><p><strong>CCA主要考虑无线信道的两个特征：</strong></p><ul><li><strong>噪声信号易受环境影响而动态变化</strong></li><li><strong>数据包在信道上传输时表现在相对稳定的信道能量</strong></li></ul><p><strong>因此，不能仅仅依靠单独采样，而是需要一定时间内的多次采样。</strong></p><p><strong>CCA机制的工作流程</strong></p><ul><li><strong>噪声基准估计阶段：发送节点首先进行空闲信道采样，计算和更新噪声基准值。</strong></li><li><strong>传输信号检测阶段：发送数据之前，节点需要再次对当前信道信息采样，检测多个连续采样值中是否存在孤立点（低值点）</strong><ul><li><strong>如果存在，则认为信道空闲，节点开始发送数据；</strong></li><li><strong>如果不存在，则认为信道忙，节点退避一段时间后再重复上述。</strong></li></ul></li></ul><h3 id="RI-MAC协议"><a href="#RI-MAC协议" class="headerlink" title="RI-MAC协议"></a><strong>RI-MAC协议</strong></h3><p><strong>任何数据帧的传输都由接收节点发起，即由接收节点发送一个信标分组（beacon）来主动通知发送节点开始数据分组传输。</strong></p><p><img src="/IoT-%E7%AC%AC3%E7%AB%A0-%E6%97%A0%E7%BA%BF%E4%BC%A0%E6%84%9F%E5%99%A8%E7%BD%91%E7%BB%9C-3-2-MAC%E5%8D%8F%E8%AE%AE/image-20231220194418968.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="rimac"></p><h2 id="3-2-3-调度型（分配型）MAC协议—全局同步global-synchronization"><a href="#3-2-3-调度型（分配型）MAC协议—全局同步global-synchronization" class="headerlink" title="3.2.3  调度型（分配型）MAC协议—全局同步global synchronization"></a>3.2.3  <strong>调度型（分配型）MAC协议—全局同步global synchronization</strong></h2><h3 id="竞争型-gt-分配型"><a href="#竞争型-gt-分配型" class="headerlink" title="竞争型-&gt; 分配型"></a><strong>竞争型-&gt; 分配型</strong></h3><p><strong>随着网络流量的增大，竞争型的MAC协议中节点发生冲突的概率增大，这样不仅降低了网络带宽利用率，而且浪费大量能量。</strong></p><p><strong>分配型的MAC协议通常采用TDMA、CDMA、FDMA或者SDMA等技术，将一条物理信道划分为许多子信道，然后将这些子信道根据节点的需求动态或固定（静态）地分配给节点，避免不必要的冲突发生。</strong></p><p><strong>经常采用TDMA，具有较高的时间同步要求。</strong></p><p><strong>分配型MAC需要理想的介质和环境，不存在其他竞争网络或行为异常的节点。</strong></p><h3 id="TRAMA协议"><a href="#TRAMA协议" class="headerlink" title="TRAMA协议"></a><strong>TRAMA协议</strong></h3><p><strong>流量自适应介质访问(Traffic adaptive medium access, TRAMA)协议</strong></p><ul><li><strong>将信道按时间划分为连续的时隙</strong></li><li><strong>每个节点掌握其两跳范围内的邻居节点信息</strong></li><li><strong>采用分布式选举机制确定每个时隙的无冲突发送者：</strong></li><li><strong>根据节点的ID号及当前时隙号，各节点利用哈希函数分布式地计算出所有节点在每个时隙上的优先级，并将当前时隙分配给优先级最高的节点。</strong></li><li><strong>同时，通过避免将时隙分配给没有业务流量的节点，让没有通信任务的节点转入休眠状态。</strong></li></ul><h4 id="TRAMA协议的三部分"><a href="#TRAMA协议的三部分" class="headerlink" title="TRAMA协议的三部分"></a><strong>TRAMA协议的三部分</strong></h4><p><strong>（1）邻居协议NP（neighbor protocol)</strong> </p><p><strong>NP协议在随机访问周期内执行，节点间通过NP协议需要获得一致的两跳邻居拓扑结构及各节点的业务流量信息。</strong></p><p><strong>协议要求节点周期性通告自己的编号ID，是否有数据需要发送以及能够直接通信的邻居节点的相关信息，并实现节点间的时间同步。</strong></p><p><strong>（2）调度交换协议SEP（schedule exchange protocol)</strong> </p><p><strong>SEP协议用来建立和维护发送者和接收者的调度信息。在调度访问周期内，节点周期性地通过调度分组向邻居广播它的调度信息。</strong></p><p><strong>（3）自适应选举算法AEA（adaptive election algorithm)</strong> </p><p><strong>AEA用来通过计算两跳范围内所有节点的优先级，分布式地决定各个节点在当前时隙内的活动策略（发送、接收、休眠）。</strong></p><p><strong>节点s在时隙t的优先级通过伪随机的哈希函数计算：</strong></p><p> <strong>priority(s, t) &#x3D; hash(s∙t)</strong></p><p><strong>各节点最终确定的在每个时隙上优先级最高的优胜节点是一致的。</strong></p><h4 id="TRAMA协议的时隙组织"><a href="#TRAMA协议的时隙组织" class="headerlink" title="TRAMA协议的时隙组织"></a><strong>TRAMA协议的时隙组织</strong></h4><p><strong>连续时隙组成的信道被划分为周期性交替的随机访问阶段（包含通告时隙）、调度访问阶段（包含传输时隙）</strong></p><p><strong>随机访问阶段主要用于网络维护，如节点失效、新节点加入引起的网络拓扑结构变化</strong></p><p><strong>调度访问阶段用于确定每个时隙的发送者和接收者，实现无冲突的数据传输</strong></p><p><img src="/IoT-%E7%AC%AC3%E7%AB%A0-%E6%97%A0%E7%BA%BF%E4%BC%A0%E6%84%9F%E5%99%A8%E7%BD%91%E7%BB%9C-3-2-MAC%E5%8D%8F%E8%AE%AE/image-20231220194655014.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="TRAMA"></p><h3 id="DMAC协议"><a href="#DMAC协议" class="headerlink" title="DMAC协议"></a><strong>DMAC协议</strong></h3><p><strong>DMAC协议的基本思想</strong></p><pre><code class="hljs"> **传感器网络中一种重要的通信模式是多个传感器节点向一个汇聚节点发送数据。所有传感器节点转发收到的数据，形成一个以汇聚节点为根节点的树型网络结构，称为采集树(data gathering tree)。**  **在基于竞争方式的MAC协议中,节点采用周期性的活动/休眠策略来减少能量消耗，但会出现数据在转发过程中“走走–停停”的通信停顿问题。在数据采集树结构中，这种传输延迟会随着路径上的跳数比例增加。**  **DMAC协议就是针对这种数据采集树结构提出的，目标是减少数据的传输延迟和网络的能量消耗。**</code></pre><p><img src="/IoT-%E7%AC%AC3%E7%AB%A0-%E6%97%A0%E7%BA%BF%E4%BC%A0%E6%84%9F%E5%99%A8%E7%BD%91%E7%BB%9C-3-2-MAC%E5%8D%8F%E8%AE%AE/image-20231220194837972.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="针对数据采集树的DMAC协议"></p><h4 id="DMAC协议的工作原理"><a href="#DMAC协议的工作原理" class="headerlink" title="DMAC协议的工作原理"></a><strong>DMAC协议的工作原理</strong></h4><p><strong>DMAC的核心思想是采用交错调度机制。</strong></p><p><strong>将节点划分为接收时间，发送时间和睡眠时间。其中接收时间和发送时间相等，均为发送一个数据的分组时间。</strong></p><p><strong>每个节点的调度具有不同的偏移，下层节点的发送时间对应上层节点的接收时间。这样，数据能够连续地从数据源节点传送到汇聚节点，减少在网络中的传输延迟。</strong></p><p><img src="/IoT-%E7%AC%AC3%E7%AB%A0-%E6%97%A0%E7%BA%BF%E4%BC%A0%E6%84%9F%E5%99%A8%E7%BD%91%E7%BB%9C-3-2-MAC%E5%8D%8F%E8%AE%AE/image-20231220194908799.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="原理"></p><h2 id="3-2-4-混合型MAC协议"><a href="#3-2-4-混合型MAC协议" class="headerlink" title="3.2.4  混合型MAC协议"></a>3.2.4  <strong>混合型MAC协议</strong></h2><p><strong>同时包含了竞争型协议和分配型协议设计要素</strong></p><ul><li><strong>通过周期性分配型的MAC协议的优点减少空闲侦听、碰撞重传；</strong></li><li><strong>发挥竞争型协议的灵活性和低复杂性。</strong></li></ul><p><strong>但是，设计难度大，实现困难。</strong></p><p><strong>典型的协议主要有 Z-MAC、Funneling-MAC，二者均为 CSMA 与 TDMA 的混合型 MAC 协议</strong></p><h3 id="Z-MAC协议"><a href="#Z-MAC协议" class="headerlink" title="Z-MAC协议"></a><strong>Z-MAC协议</strong></h3><p><strong>协议运行包含两个阶段</strong></p><ul><li><strong>启动阶段：发现邻居，获得两跳网络拓扑，时隙分配</strong></li><li><strong>运行阶段：对节点进行传输控制</strong></li></ul><p><strong>在低流量条件下使用CSMA信道访问方式，可提高信道利用率并降低延时；</strong></p><p><strong>在高流量条件下使用TDMA信道方式，可减少冲突和串听。</strong></p><p><strong>特点：</strong></p><ul><li><strong>适合于中、高网络流量的传感器网络应用，具有比传统TDMA协议更好的可靠性和容错能力</strong></li><li><strong>在最坏情况下，性能接近于CSMA。</strong></li><li><strong>缺点：启动阶段的初始化操作复杂，局部范围通信量大，并且需要全局时间同步，节点有时存在隐藏终端问题。</strong></li></ul><h3 id="Funneling-MAC协议"><a href="#Funneling-MAC协议" class="headerlink" title="Funneling-MAC协议"></a><strong>Funneling-MAC协议</strong></h3><p><strong>传感器网络常见的单跳传输、多跳聚合的通信方式，造成sink附近的数据传输量大，容易发生冲突、拥塞和丢包，这种现象被称为漏斗效应（funneling effect）。</strong></p><p><img src="/IoT-%E7%AC%AC3%E7%AB%A0-%E6%97%A0%E7%BA%BF%E4%BC%A0%E6%84%9F%E5%99%A8%E7%BD%91%E7%BB%9C-3-2-MAC%E5%8D%8F%E8%AE%AE/image-20231220195038590.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="漏斗"></p><h4 id="Funneling-MAC协议的工作原理"><a href="#Funneling-MAC协议的工作原理" class="headerlink" title="Funneling-MAC协议的工作原理"></a><strong>Funneling-MAC协议的工作原理</strong></h4><p><strong>协议基本思想：全网采用CSMA，漏斗区域采用TDMA</strong></p><p><strong>工作过程</strong></p><ul><li><strong>节点默认采用CSMA，局部TDMA由sink节点发起。</strong></li><li><strong>当网络中的流量达到一定程度时，sink广播信标分组（beacon）触发TDMA。</strong></li><li><strong>收到信标分组的节点称为F-节点，采用CSMA和TDMA结合通信。</strong></li><li><strong>F-节点所在的区域称为强度区域，其范围由sink节点根据网络的实时流量情况，通过控制信标分组的发送功率动态调节。</strong></li><li><strong>为实现同步，所有的F-节点在收到信标分组时统一初始化时钟。</strong></li><li><strong>Sink节点负责F-节点的时隙调度。</strong></li><li><strong>协议采用超帧结构。</strong></li></ul><h4 id="Funneling-MAC协议的超帧结构"><a href="#Funneling-MAC协议的超帧结构" class="headerlink" title="Funneling-MAC协议的超帧结构"></a><strong>Funneling-MAC协议的超帧结构</strong></h4><p><strong>一个超帧由一个CSMA帧和一个TDMA帧构成，两个信标分组之间包含多个超帧。</strong></p><p><strong>F-节点依靠sink节点广播的信标分组将自己的时钟与超帧同步，使用CSMA帧和TDMA帧交替访问信道。</strong></p><ul><li><strong>CSMA帧</strong><ul><li><strong>通信过程中临时产生的新数据，还没有被分配通信时隙</strong></li><li><strong>网络中突发性的事件信息、实时性要求高的控制信息</strong></li></ul></li><li><strong>TDMA帧</strong><ul><li><strong>各个F-节点在分配的时隙内转发数据</strong></li></ul></li><li><strong>Sink节点的时隙分配表紧随信标分组发送</strong></li></ul><p><img src="/IoT-%E7%AC%AC3%E7%AB%A0-%E6%97%A0%E7%BA%BF%E4%BC%A0%E6%84%9F%E5%99%A8%E7%BD%91%E7%BB%9C-3-2-MAC%E5%8D%8F%E8%AE%AE/image-20231220195207150.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="ex"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;第三章-无线传感器网络&quot;&gt;&lt;a href=&quot;#第三章-无线传感器网络&quot; class=&quot;headerlink&quot; title=&quot;第三章 无线传感器网络&quot;&gt;&lt;/a&gt;第三章 无线传感器网络&lt;/h1&gt;&lt;h2 id=&quot;3-2-MAC协议&quot;&gt;&lt;a href=&quot;#3-2-MAC协</summary>
      
    
    
    
    <category term="学习资料" scheme="https://www.emokable.top/categories/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/"/>
    
    
    <category term="课件笔记" scheme="https://www.emokable.top/tags/%E8%AF%BE%E4%BB%B6%E7%AC%94%E8%AE%B0/"/>
    
    <category term="物联网技术与应用" scheme="https://www.emokable.top/tags/%E7%89%A9%E8%81%94%E7%BD%91%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%BA%94%E7%94%A8/"/>
    
    <category term="IoT" scheme="https://www.emokable.top/tags/IoT/"/>
    
  </entry>
  
  <entry>
    <title>IoT__第3章__无线传感器网络__3.1_简述</title>
    <link href="https://www.emokable.top/IoT-%E7%AC%AC3%E7%AB%A0-%E6%97%A0%E7%BA%BF%E4%BC%A0%E6%84%9F%E5%99%A8%E7%BD%91%E7%BB%9C-3-1-%E7%AE%80%E8%BF%B0/"/>
    <id>https://www.emokable.top/IoT-%E7%AC%AC3%E7%AB%A0-%E6%97%A0%E7%BA%BF%E4%BC%A0%E6%84%9F%E5%99%A8%E7%BD%91%E7%BB%9C-3-1-%E7%AE%80%E8%BF%B0/</id>
    <published>2023-10-30T12:50:32.000Z</published>
    <updated>2023-12-20T11:02:17.704Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第三章-无线传感器网络"><a href="#第三章-无线传感器网络" class="headerlink" title="**第三章 **无线传感器网络"></a>**第三章 **无线传感器网络</h1><h2 id="3-1-简述"><a href="#3-1-简述" class="headerlink" title="3.1 简述"></a>3.1 <strong>简述</strong></h2><h2 id="传感器网络-Sensor-Networks"><a href="#传感器网络-Sensor-Networks" class="headerlink" title="传感器网络 Sensor Networks"></a><strong>传感器网络</strong> <strong>Sensor Networks</strong></h2><p>传感器网络是一种由传感器节点组成的网络，其中每个传感器节点具有传感器、微处理器和通信接口电路，节点之间通过通信链路组成网络，共同协作来监测各种物理量和事件。简称传感网。</p><p>有线传感器网络</p><ul><li>较多用于自动化领域，可以构成网络控制系统，把单个分散的测量控制设备当成为网络节点，通过底层控制网络把它们连接起来，共同完成信息汇集、自动控制的任务。</li><li>现场总线系统可以在一对导线上挂接多个传感器、执行器、开关、按钮和控制设备等。</li><li>Profibus、LonWorks、HART、CAN (车内总线)、M-bus** (仪表总线) …</li></ul><p>无线传感器网络</p><ul><li>低功耗、短距离、无线移动网络</li><li>简称：无线传感网</li></ul><h3 id="无线传感网-（WSN-Wireless-Sensor-Network）"><a href="#无线传感网-（WSN-Wireless-Sensor-Network）" class="headerlink" title="无线传感网 （WSN: Wireless Sensor Network）"></a><strong>无线传感网 （WSN: Wireless Sensor Network）</strong></h3><p><img src="/IoT-%E7%AC%AC3%E7%AB%A0-%E6%97%A0%E7%BA%BF%E4%BC%A0%E6%84%9F%E5%99%A8%E7%BD%91%E7%BB%9C-3-1-%E7%AE%80%E8%BF%B0/image-20231030220308197.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="WSN"></p><p><img src="/IoT-%E7%AC%AC3%E7%AB%A0-%E6%97%A0%E7%BA%BF%E4%BC%A0%E6%84%9F%E5%99%A8%E7%BD%91%E7%BB%9C-3-1-%E7%AE%80%E8%BF%B0/image-20231030220319583.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="1"></p><p><img src="/IoT-%E7%AC%AC3%E7%AB%A0-%E6%97%A0%E7%BA%BF%E4%BC%A0%E6%84%9F%E5%99%A8%E7%BD%91%E7%BB%9C-3-1-%E7%AE%80%E8%BF%B0/image-20231030220325971.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="应用"></p><h4 id="WSN-的早期需求来源：态势感知"><a href="#WSN-的早期需求来源：态势感知" class="headerlink" title="WSN 的早期需求来源：态势感知"></a><strong>WSN</strong> <strong>的早期需求来源：态势感知</strong></h4><p><img src="/IoT-%E7%AC%AC3%E7%AB%A0-%E6%97%A0%E7%BA%BF%E4%BC%A0%E6%84%9F%E5%99%A8%E7%BD%91%E7%BB%9C-3-1-%E7%AE%80%E8%BF%B0/image-20231030220354462.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="1"></p><h4 id="无线传感器网络的早期发展"><a href="#无线传感器网络的早期发展" class="headerlink" title="无线传感器网络的早期发展"></a><strong>无线传感器网络的早期发展</strong></h4><p><img src="/IoT-%E7%AC%AC3%E7%AB%A0-%E6%97%A0%E7%BA%BF%E4%BC%A0%E6%84%9F%E5%99%A8%E7%BD%91%E7%BB%9C-3-1-%E7%AE%80%E8%BF%B0/image-20231030220412458.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="1"></p><p><img src="/IoT-%E7%AC%AC3%E7%AB%A0-%E6%97%A0%E7%BA%BF%E4%BC%A0%E6%84%9F%E5%99%A8%E7%BD%91%E7%BB%9C-3-1-%E7%AE%80%E8%BF%B0/image-20231030220427850.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="2"></p><p><img src="/IoT-%E7%AC%AC3%E7%AB%A0-%E6%97%A0%E7%BA%BF%E4%BC%A0%E6%84%9F%E5%99%A8%E7%BD%91%E7%BB%9C-3-1-%E7%AE%80%E8%BF%B0/image-20231030220441709.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="3"></p><h4 id="无线传感器网络的应用优势"><a href="#无线传感器网络的应用优势" class="headerlink" title="无线传感器网络的应用优势"></a><strong>无线传感器网络的应用优势</strong></h4><p><strong>分布节点中多角度和多方位信息的综合有效地提高了信噪比</strong></p><p><strong>低成本、高冗余的设计提供了较强的容错能力</strong></p><p><strong>节点与探测目标的近距离接触消除了环境噪声对系统性能的影响</strong></p><p><strong>节点中多种传感器的混合应用提高了探测的性能指标</strong></p><p><strong>多节点联合，形成覆盖面积较大的实时探测区域</strong></p><p><strong>个别移动节点对拓扑结构的调整有效消除了探测阴影和盲点</strong></p><p><img src="/IoT-%E7%AC%AC3%E7%AB%A0-%E6%97%A0%E7%BA%BF%E4%BC%A0%E6%84%9F%E5%99%A8%E7%BD%91%E7%BB%9C-3-1-%E7%AE%80%E8%BF%B0/image-20231030220736956.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="1"></p><p><img src="/IoT-%E7%AC%AC3%E7%AB%A0-%E6%97%A0%E7%BA%BF%E4%BC%A0%E6%84%9F%E5%99%A8%E7%BD%91%E7%BB%9C-3-1-%E7%AE%80%E8%BF%B0/image-20231030220743864.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="2"></p><p><img src="/IoT-%E7%AC%AC3%E7%AB%A0-%E6%97%A0%E7%BA%BF%E4%BC%A0%E6%84%9F%E5%99%A8%E7%BD%91%E7%BB%9C-3-1-%E7%AE%80%E8%BF%B0/image-20231030220749756.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="3"></p><h4 id="无线传感器网络的技术定位"><a href="#无线传感器网络的技术定位" class="headerlink" title="无线传感器网络的技术定位"></a><strong>无线传感器网络的技术定位</strong></h4><p><img src="/IoT-%E7%AC%AC3%E7%AB%A0-%E6%97%A0%E7%BA%BF%E4%BC%A0%E6%84%9F%E5%99%A8%E7%BD%91%E7%BB%9C-3-1-%E7%AE%80%E8%BF%B0/image-20231030220811581.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="定位"></p><h4 id="无线传感器网络的技术特点"><a href="#无线传感器网络的技术特点" class="headerlink" title="无线传感器网络的技术特点"></a><strong>无线传感器网络的技术特点</strong></h4><p><img src="/IoT-%E7%AC%AC3%E7%AB%A0-%E6%97%A0%E7%BA%BF%E4%BC%A0%E6%84%9F%E5%99%A8%E7%BD%91%E7%BB%9C-3-1-%E7%AE%80%E8%BF%B0/image-20231030220903857.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="1"></p><p><strong>节点</strong></p><p>–<strong>微型化：嵌入物理世界</strong></p><p>–<strong>智能化：增强的数据处理</strong></p><p>–<strong>自治化：容错性</strong></p><p>–<strong>多样化：尽可能感知周围感兴趣的物质现象</strong></p><p><strong>网络</strong></p><p>–<strong>密集性：抵抗敌意和恶意破坏</strong></p><p>–<strong>灵活性：快速构建信息基础设施</strong></p><p>–<strong>自组织：鲁棒性</strong></p><p>–<strong>多跳性：低能耗</strong></p><h4 id="无线传感器网络的体系结构"><a href="#无线传感器网络的体系结构" class="headerlink" title="无线传感器网络的体系结构"></a><strong>无线传感器网络的体系结构</strong></h4><p><strong>传感器网络结构</strong></p><p><img src="/IoT-%E7%AC%AC3%E7%AB%A0-%E6%97%A0%E7%BA%BF%E4%BC%A0%E6%84%9F%E5%99%A8%E7%BD%91%E7%BB%9C-3-1-%E7%AE%80%E8%BF%B0/image-20231030221000179.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="1"></p><p><strong>传感器网络系统通常包括传感器节点、汇聚节点和管理节点。</strong></p><p>大量<strong>传感器节点</strong>（sensor nodes）都随机部署在<strong>监测区域</strong>（sensor field）内部或附近，能够通过自组织方式构成网络。传感器节点监测的<strong>数据</strong>沿着其他传感器节点逐跳地进行传输，在传输过程中监测数据可能被多个节点处理，经过多跳后路由到<strong>汇聚节点</strong>，最后通过互联网或卫星到达管理节点。用户通过<strong>管理节点</strong>对传感器网络进行配置和管理，发布监测任务以及收集监测数据。</p><p><strong>传感器节点</strong>是一个微型的嵌入式系统，处理能力、存储能力和通信能力相对较弱。每个传感器节点兼顾传统网络节点的终端和路由功能，除了进行信息收集和数据处理外，还要对其它传感器节点发出来的数据进行存储、管理和融合等处理，同时与其它节点协作完成一些特定的任务。</p><p><strong>汇聚节点</strong>（sink node）的处理能力、存储能力和通信能力相对较强，它连接无线传感器网络与Internet等外部网络，实现两种协议之间的通讯协议转换，同时发布管理节点的监测任务，并把收集到的信息数据转发到外部网络上。</p><h5 id="传感器节点结构"><a href="#传感器节点结构" class="headerlink" title="传感器节点结构"></a><strong>传感器节点结构</strong></h5><p><strong>传感器节点一般由传感模块、处理模块、无线通信模块和能量供应模块组成。</strong></p><ul><li>传感器模块负责监测区域内信息的采集和数据转换；</li><li>处理模块负责控制整个传感器节点的操作，存储和处理本身采集的数据以及其他节点发来的数据；</li><li>无线通信模块负责与其他传感器节点进行无线通信，交换控制消息和收发采集数据；</li><li>能量供应模块为传感器节点提供运行所需的能量。</li></ul><p><img src="/IoT-%E7%AC%AC3%E7%AB%A0-%E6%97%A0%E7%BA%BF%E4%BC%A0%E6%84%9F%E5%99%A8%E7%BD%91%E7%BB%9C-3-1-%E7%AE%80%E8%BF%B0/image-20231030221419077.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="2"></p><h5 id="传感器节点硬件架构（例）"><a href="#传感器节点硬件架构（例）" class="headerlink" title="传感器节点硬件架构（例）"></a><strong>传感器节点硬件架构（例）</strong></h5><p><img src="/IoT-%E7%AC%AC3%E7%AB%A0-%E6%97%A0%E7%BA%BF%E4%BC%A0%E6%84%9F%E5%99%A8%E7%BD%91%E7%BB%9C-3-1-%E7%AE%80%E8%BF%B0/image-20231030221447224.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="1"></p><h5 id="传感器节点（例）-Motes"><a href="#传感器节点（例）-Motes" class="headerlink" title="传感器节点（例） Motes"></a><strong>传感器节点（例）</strong> Motes</h5><p><strong>Devices that incorporate communications, processing, sensors, and batteries into a small package</strong> </p><p><strong>Atmel microcontroller with sensors and a communication unit</strong></p><ul><li><strong>RF transceiver, laser module, or a corner cube reflector</strong> </li><li><strong>temperature, light, humidity, pressure, 3 axis magnetometers, 3 axis accelerometers</strong></li></ul><p><strong>TinyOS</strong></p><p><img src="/IoT-%E7%AC%AC3%E7%AB%A0-%E6%97%A0%E7%BA%BF%E4%BC%A0%E6%84%9F%E5%99%A8%E7%BD%91%E7%BB%9C-3-1-%E7%AE%80%E8%BF%B0/image-20231030221541629.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="1"></p><h5 id="传感器节点"><a href="#传感器节点" class="headerlink" title="传感器节点"></a><strong>传感器节点</strong></h5><p>传感器节点是一个微型化的嵌入式系统，它构成了传感网的基础层支持平台。</p><p>典型的传感器节点由数据采集的感知模块、数据处理和存储模块、无线通信模块、能源供给模块4个部分组成，</p><ul><li>感知模块由传感器、A&#x2F;D转换器组成，负责感知监控对象的信息；</li><li>能源供给单元负责供给节点工作所消耗的能量，一般为小体积的电池；</li><li>无线通信模块完成节点间的交互通信工作，一般为无线电收发装置；</li><li>数据处理模块包括存储器和微处理器等部分，负责控制整个传感器节点的操作，存储和处理本身采集的数据以及其它节点发来的数据。</li><li>同时，有些节点上还装配有能源再生装置、移动或执行机构、定位系统及复杂信号处理（包括声音、图像、数据处理及数据融合）等扩展设备以获得更完善的功能。</li></ul><p><img src="/IoT-%E7%AC%AC3%E7%AB%A0-%E6%97%A0%E7%BA%BF%E4%BC%A0%E6%84%9F%E5%99%A8%E7%BD%91%E7%BB%9C-3-1-%E7%AE%80%E8%BF%B0/image-20231030221654283.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="1"></p><h5 id="传感器网络协议栈"><a href="#传感器网络协议栈" class="headerlink" title="传感器网络协议栈"></a><strong>传感器网络协议栈</strong></h5><p><img src="/IoT-%E7%AC%AC3%E7%AB%A0-%E6%97%A0%E7%BA%BF%E4%BC%A0%E6%84%9F%E5%99%A8%E7%BD%91%E7%BB%9C-3-1-%E7%AE%80%E8%BF%B0/image-20231030221735340.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="A"></p><p><img src="/IoT-%E7%AC%AC3%E7%AB%A0-%E6%97%A0%E7%BA%BF%E4%BC%A0%E6%84%9F%E5%99%A8%E7%BD%91%E7%BB%9C-3-1-%E7%AE%80%E8%BF%B0/image-20231030221740807.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="B"></p><ul><li>物理层提供简单但健壮的信号调制和无线收发技术，主要解决编码调制、通信速率，通信频段的选取等问题 。</li><li>数据链路层负责数据成帧、多路复用、帧检测、媒体访问和差错控制，保证了传感器网络内点到点和点到多点的连接 。</li><li>网络层负责路由生成与路由选择。</li><li>传输层负责数据流的传输控制，是保证通信服务质量的重要部分。</li><li>应用层包括一系列基于监测任务的应用软件。</li><li>能量管理平台管理传感器节点如何使用能源，在各个协议层都需要考虑节省能量。</li><li>移动管理平台检测并注册传感器应用的移动，维护到汇聚节点的路由，使得传感器节点能够动态跟踪其邻居的位置。</li><li>任务管理平台在一个给定的区域内平衡和调度监测任务</li></ul><blockquote><p><strong>协议栈</strong> <strong>B</strong> <strong>细化并改进了协议栈</strong> <strong>A</strong></p><p>•<strong>定位和时间同步子层，既要依赖于数据通道进行协作定位和时间同步协商，同时又要为网络协议各层提供信息支持，如基于时分复用的MAC协议，基于地理位置的路由协议等都需要定位和同步信息。</strong></p><p>•<strong>右边的诸多机制一部份融合到各层协议中，用以优化和管理协议流程；另一部分独立在协议外层，通过各种收集和配置接口对相应机制进行配置和监控。</strong></p><p>•<strong>QoS管理在各协议层设计队列管理、优先级机制或带宽预留等机制，并对特定应用的数据给于特别处理。</strong></p><p>•<strong>拓扑控制利用物理层、链路层或路由层完成拓扑生成，反过来又为它们提供基础信息支持，优化MCA层协议和路由协议的协议过程，减少网络能量消耗。</strong></p><p>•<strong>网络管理则要求协议各层嵌入各种信息接口，并定时收集协议运行状态和流量信息，协调控制网络中各个协议组件的运行。</strong></p></blockquote><h5 id="传感器网络的特点"><a href="#传感器网络的特点" class="headerlink" title="传感器网络的特点"></a><strong>传感器网络的特点</strong></h5><ul><li>节点数量大，密度高</li><li>拓扑动态变化</li><li>节点异构，或只有少量特殊节点；</li><li>分布式：没有预先指定的中心，所有节点通过分布式算法相互协调；</li><li>自组织：传感器网络的部署和初始化等不需要外界干预；</li><li>节点资源受限，特别是能量非常有限；</li><li>以数据为中心的网络，节点具有数据处理的能力；</li><li>与应用紧密耦合的网络</li><li>大规模网络</li><li>自组织网络</li><li>动态性网络</li><li>可靠性网络</li><li>应用性相关的网络</li><li>以数据为中心的网络</li></ul><h5 id="传感器节点的能耗分布"><a href="#传感器节点的能耗分布" class="headerlink" title="传感器节点的能耗分布"></a><strong>传感器节点的能耗分布</strong></h5><p>E(trans.) ≈ E(rece.) ≈ E(idle) &gt;&gt; E(sleep) ≈ E(sens.) ≈ E(cpu)</p><p><img src="/IoT-%E7%AC%AC3%E7%AB%A0-%E6%97%A0%E7%BA%BF%E4%BC%A0%E6%84%9F%E5%99%A8%E7%BD%91%E7%BB%9C-3-1-%E7%AE%80%E8%BF%B0/image-20231030222316048.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="1"></p><blockquote><p><strong>降低功耗的举措</strong></p><p><strong>减少通信流量</strong></p><p><strong>采用多跳通信方式</strong></p><p><strong>增加休眠时间</strong></p><p><strong>……</strong> </p></blockquote><h2 id="无线传感器网络与物联网"><a href="#无线传感器网络与物联网" class="headerlink" title="无线传感器网络与物联网"></a><strong>无线传感器网络与物联网</strong></h2><p>•<strong>无线传感器网络为物联网奠定了传感和监控的技术基础</strong></p><p>•<strong>无线传感器网络位于物联网联接物理空间的感知层面</strong></p><p>•<strong>物联网是广义联网的无线传感器网络</strong></p><p>•<strong>物联网不仅仅感知，还要做到控制</strong></p><p>•<strong>物联网面临更多的技术挑战</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;第三章-无线传感器网络&quot;&gt;&lt;a href=&quot;#第三章-无线传感器网络&quot; class=&quot;headerlink&quot; title=&quot;**第三章 **无线传感器网络&quot;&gt;&lt;/a&gt;**第三章 **无线传感器网络&lt;/h1&gt;&lt;h2 id=&quot;3-1-简述&quot;&gt;&lt;a href=&quot;#3-1</summary>
      
    
    
    
    <category term="学习资料" scheme="https://www.emokable.top/categories/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/"/>
    
    
    <category term="课件笔记" scheme="https://www.emokable.top/tags/%E8%AF%BE%E4%BB%B6%E7%AC%94%E8%AE%B0/"/>
    
    <category term="物联网技术与应用" scheme="https://www.emokable.top/tags/%E7%89%A9%E8%81%94%E7%BD%91%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%BA%94%E7%94%A8/"/>
    
    <category term="IoT" scheme="https://www.emokable.top/tags/IoT/"/>
    
  </entry>
  
  <entry>
    <title>IoT-第2章-感知识别-2-3-传感器</title>
    <link href="https://www.emokable.top/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-3-%E4%BC%A0%E6%84%9F%E5%99%A8/"/>
    <id>https://www.emokable.top/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-3-%E4%BC%A0%E6%84%9F%E5%99%A8/</id>
    <published>2023-10-29T13:27:55.000Z</published>
    <updated>2023-10-30T12:44:16.323Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第二章-物联网感知识别"><a href="#第二章-物联网感知识别" class="headerlink" title="第二章 物联网感知识别"></a><strong>第二章 物联网感知识别</strong></h1><h2 id="2-3-传感器技术"><a href="#2-3-传感器技术" class="headerlink" title="2.3 传感器技术"></a><strong>2.3</strong> <strong>传感器技术</strong></h2><p><strong>自动门、自动水龙头、安检门</strong></p><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-3-%E4%BC%A0%E6%84%9F%E5%99%A8/image-20231029212914051.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="当有金属物体穿越安检门时报警"></p><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-3-%E4%BC%A0%E6%84%9F%E5%99%A8/image-20231029212932145.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="水龙头"></p><h3 id="传感器的作用"><a href="#传感器的作用" class="headerlink" title="传感器的作用"></a><strong>传感器的作用</strong></h3><ul><li><strong>一般的仪器、仪表要求输入的信号必须为电信号</strong> <strong>，计算机及各种电子设备只能处理电信号 ，</strong></li><li><strong>而表征物质特性或其运动形式的参数 中有很多都是非电量，如大家在自然界经常接触到的温度、压力、距离、流量、重量、速度、加速度、浓度、酸碱度、湿度、光 、磁场等 。</strong></li><li><strong>上述的非电量需要转换成与非电量有一定关系的电量，再运用电子设备和仪器测量，实现这种转换技术的器件就是传感器。</strong></li></ul><h3 id="传感器的定义与组成"><a href="#传感器的定义与组成" class="headerlink" title="传感器的定义与组成"></a><strong>传感器的定义与组成</strong></h3><p>根据国家标准（GB&#x2F;T 7665-2005）传感器通用术语的规定，传感器是能感受规定的被测量并按照一定的规律转换成可用输出信号的器件或装置。</p><p>传感器通常由对被测量敏感的元件和转换元件组成，</p><p>•<strong>敏感元件</strong>是指传感器中能直接感受或响应被测量的部分，如应变式压力传感器中的弹性膜片，就是敏感元件。</p><p>•<strong>转换元件</strong>是指传感器中能将敏感元件感受或响应到的被测量转换成适于传输或测量的电信号（电压、电流）部分，如电阻应变片就是转换元件。</p><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-3-%E4%BC%A0%E6%84%9F%E5%99%A8/image-20231029213047059.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="组成图"></p><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-3-%E4%BC%A0%E6%84%9F%E5%99%A8/image-20231029213955894.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="各类传感器"></p><h3 id="传感器的分类"><a href="#传感器的分类" class="headerlink" title="传感器的分类"></a><strong>传感器的分类</strong></h3><h4 id="1．按被测物理量划分"><a href="#1．按被测物理量划分" class="headerlink" title="1．按被测物理量划分"></a><strong>1．按被测物理量划分</strong></h4><p><strong>这一种方法是根据被测量的性质进行分类，如被测量分别为温度、湿度、压力、位移、流量、加速度、光，则对应的传感器分别为温度传感器、湿度传感器，压力传感器、位移传感器、流量传感器、加速度传感器、光电传感器。</strong></p><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-3-%E4%BC%A0%E6%84%9F%E5%99%A8/image-20231029214022444.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="物理量"></p><h4 id="2．按传感器工作原理划分"><a href="#2．按传感器工作原理划分" class="headerlink" title="2．按传感器工作原理划分"></a><strong>2．按传感器工作原理划分</strong></h4><p>​    这一种分类方法是以工作原理来划分，将物理、化学、生物等学科的原理、规律和效应作为分类的依据，据此可将传感器分为电阻式、电感式、电容式、阻抗式、磁电式、热电式、压电式、光电式、超声式、微波式等类别。这种分类方法有利于传感器的专业工作者从原理与设计上作归纳性的分析研究。</p><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-3-%E4%BC%A0%E6%84%9F%E5%99%A8/image-20231029214053494.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="工作原理"></p><h3 id="传感技术的特点"><a href="#传感技术的特点" class="headerlink" title="传感技术的特点"></a><strong>传感技术的特点</strong></h3><p><strong>1、用传感技术进行检测时，响应速度快，精确度高，灵敏度高；</strong></p><p><strong>2、能在特殊环境下连续进行检测，便于自动记录。</strong></p><p>能在人类无法存在的高温、高压、恶劣环境中，和对人类五官不能感觉到的信息（如超声波、红外线等），进行连续检测，记录变化的数据。</p><p><strong>3、可与计算机相连，进行数据的自动运算、分析和处理</strong></p><p>   传感器将非电物理量转换成电信号后，通过接口电路变成计算机能够处理的信号，进行自动运算、分析和处理。</p><p><strong>4、品种繁多，应用广泛</strong></p><p>​    现代信息系统中待测的信息量很多，一种待测信息可由几种传感器来测量，一种传感器也可测量多种信息，因此传感器种类繁多，应用广泛，从航空、航天、兵器、交通、机械、电子、冶炼、轻工、化工、煤炭、石油、环保、医疗、生物工程等领域，到农、林、牧、副、渔业，以及人们的衣、食、住、行等生活的方方面面，几乎无处不使用传感器，无处不需要传感器。</p><h3 id="传感器的发展趋势"><a href="#传感器的发展趋势" class="headerlink" title="传感器的发展趋势"></a>传感器的发展趋势</h3><p><strong>1．新材料的开发、应用</strong></p><p>如：半导体材料 、功能陶瓷材料 、功能金属、功能有机聚合物、非晶态材料、固体材料及薄膜材料等，都可进一步提高传感器的产品质量，降低生产成本。</p><p><strong>2．新工艺、新技术的应用</strong></p><p>将半导体的精密细微加工技术应用在传感器的制造中，可极大提高传感器的性能指标，并为传感器的集成化、超小型化提供技术支撑。借助半导体的蒸镀技术、扩散技术、光刻技术、静电封闭技术、全固态封接技术，也可取得类似的功效。</p><p><strong>3．向小型化、集成化方向发展</strong></p><p>由于航空技术的发展，以及医疗器件和一些特殊场合的需要，传感器必须向小型化、微型化方向发展，以便减小体积和质量。</p><p> <strong>4.</strong> <strong>向多功能化方向发展</strong></p><p>传感器多功能化也是传感器今后发展的一个重要方向，在一块集成传感器上综合多个传感器的功能，可以同时测量多个被测量，它可以借助于敏感元件中的不同物理结构或化学物质及其不同的表征方式，用单独一个传感器系统来同时实现多种传感器的功能。</p><p><strong>5．传感器的智能化</strong></p><p>将传统的传感器和微处器及相关电路组成一体化的结构就是智能传感器。因为它本身带有微型计算机，具有自动校准、自动补偿、自动诊断、数据处理、远距离双向通信、信息存储记忆和数字信号输出等功能。</p><p><strong>6．传感器的网络化</strong></p><p>将传感器和计算机与网络技术有机结合，使传感器成 为网 络中的智能节点。这种努力使多个传感器组成网络直接通信，实现数据的实施发布、共享，以及网络控制器对节点的控制操作。另外，通过Internet网，传感器与用户之间可异地交换信息，厂商能直接与异地用户交流，能及时完成传感器故障诊断，指导用户维修或交换新仪器改进的数据，软件升级等工作。另外，在微机电技术、自组织网络技术、低功耗射频通信技术及低功耗微型计算机技术的共同促进下，传感器朝微型化和网络化的方向迅速发展，产生了无线传感器网络。</p><h3 id="传感器的基本特性"><a href="#传感器的基本特性" class="headerlink" title="传感器的基本特性"></a><strong>传感器的基本特性</strong></h3><p>传感器的基本特性一般是指传感器的输出与输入之间的关系，有静态和动态之分。通常是以建立数学模型来体现的，为了简化传感器的静、动态特性，可以分开来研究。</p><h3 id="1．传感器的静态特性"><a href="#1．传感器的静态特性" class="headerlink" title="1．传感器的静态特性"></a><strong>1．传感器的静态特性</strong></h3><p><strong>静态特性是指在静态信号作用下，传感器输出与输入量间的一种函数关系，其静态特性可表示为</strong></p><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-3-%E4%BC%A0%E6%84%9F%E5%99%A8/image-20231029214459270.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="公"></p><p>  <strong>常用的静态性能指标包括灵敏度、精确度、测量范围、量程、线性度及误差等。</strong></p><h4 id="（1）灵敏度"><a href="#（1）灵敏度" class="headerlink" title="（1）灵敏度"></a><strong>（1）灵敏度</strong></h4><p><strong>传感器的灵敏度是指达到稳定状态时，输出增量与输入增量的比值</strong></p><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-3-%E4%BC%A0%E6%84%9F%E5%99%A8/image-20231029214523850.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="灵敏度"></p><p><strong>线性传感器的灵敏度就是其静态特性的斜率</strong></p><p><strong>非线性传感器的灵敏度则是其静态特性曲线某点处切线的斜率</strong></p><h4 id="（2）线性度"><a href="#（2）线性度" class="headerlink" title="（2）线性度"></a><strong>（2）线性度</strong></h4><p><strong>线性度是传感器输出量与输入量之间的实际关系曲线偏离直线的程度，又称非线性误差。</strong></p><p><strong>如图所示，即为在垂直方向上最大偏差</strong> <strong>|Δymax|</strong> <strong>与最大输出</strong> <strong>ymax</strong> <strong>的百分比。图中</strong> <strong>a0</strong> <strong>称为零位输出，即被测量为零时传感器的指示值。</strong></p><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-3-%E4%BC%A0%E6%84%9F%E5%99%A8/image-20231029214840938.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="线性度"></p><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-3-%E4%BC%A0%E6%84%9F%E5%99%A8/image-20231029214848575.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="传感器的线性度误差"></p><h4 id="（3）重复性"><a href="#（3）重复性" class="headerlink" title="（3）重复性"></a><strong>（3）重复性</strong></h4><p>   <strong>重复性表示传感器在输入量按同一方向作全量程连续多次变动时所得到的特性曲线的不一致程度，如图所示，用公式表示为</strong></p><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-3-%E4%BC%A0%E6%84%9F%E5%99%A8/image-20231029214912352.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="重复性"></p><p><strong>式中，⊿mmax取⊿</strong> <strong>m1、</strong> <strong>⊿</strong> <strong>m2中最大的计算，ymax为满量程输出值。</strong></p><p><strong>传感器输出特性的不重复性主要是由传感器的机械部分的磨损、间隙、松动、部件内摩擦、积尘、电路元件老化、工作点漂移等原因产生的。</strong></p><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-3-%E4%BC%A0%E6%84%9F%E5%99%A8/image-20231029214932446.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="线性度"></p><h4 id="（4）迟滞现象"><a href="#（4）迟滞现象" class="headerlink" title="（4）迟滞现象"></a><strong>（4）迟滞现象</strong></h4><p>   <strong>迟滞现象是传感器在正向行程（输入量增大）和反向行程（输入量减小）期间输出—输入曲线不重合的程度，如图所示。</strong></p><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-3-%E4%BC%A0%E6%84%9F%E5%99%A8/image-20231029215003318.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="1"></p><p>或</p><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-3-%E4%BC%A0%E6%84%9F%E5%99%A8/image-20231029215010336.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="2"></p><p><strong>迟滞现象反映了传感器机械结构和制造工艺上的缺陷，如轴承摩擦、间隙、螺钉松动、元件腐蚀等。</strong> </p><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-3-%E4%BC%A0%E6%84%9F%E5%99%A8/image-20231029215022563.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="迟滞"></p><h4 id="（5）精确度"><a href="#（5）精确度" class="headerlink" title="（5）精确度"></a><strong>（5）精确度</strong></h4><p>   <strong>传感器的精确度是指传感器的输出指示值与被测量约定真值的一致程度，反映了传感器测量结果的可靠程度。在工程应用中，为了简单表示测量结果的可靠性程度，引入精确度这个等级概念，用</strong> <strong>A</strong> <strong>表示，它表示允许的最大绝对误差与满度量程的比值的百分数，即</strong></p><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-3-%E4%BC%A0%E6%84%9F%E5%99%A8/image-20231029215045582.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="精确度"></p><p>式中 <em>A</em>——传感器精确度；</p><p>​     ⊿ <em>A</em>——测量范围内允许的最大绝对误差；</p><p>​     <em>y</em>max ——满度量程输出值。</p><p>常用的档次为 0.1、0.2、0.5、1.0、1.5、2.5、4.0、5.0。例如，0.5级的仪表表示其允许的最大使用误差为 0.5%。</p><h4 id="（6）分辨力"><a href="#（6）分辨力" class="headerlink" title="（6）分辨力"></a><strong>（6）分辨力</strong></h4><p>  <strong>传感器的分辨力是在规定测量范围内所能检测的输入量的最小变化量的能力。通常是以最小量程单位值表示。当被测量的变化值小于分辨力时，传感器对输入量的变化无任何反应。</strong></p><h4 id="（7）稳定性"><a href="#（7）稳定性" class="headerlink" title="（7）稳定性"></a><strong>（7）稳定性</strong></h4><p>  <strong>传感器的稳定性是指在室温条件下经过一定的时间间隔，传感器的输出与起始标定时的输出之间的差异。通常有长期稳定性（如年、月、日）和短期稳定性（如时、分、秒）之分，传感器的稳定性常用长期稳定性表示。</strong></p><h4 id="（8）漂移"><a href="#（8）漂移" class="headerlink" title="（8）漂移"></a><strong>（8）漂移</strong></h4><p>  <strong>传感器的漂移是指在外界的干扰下，输出量发生与输入量无关的不需要的变化。漂移包括零点漂移和灵敏度漂移等。零点漂移和灵敏度漂移又可分为时间漂移和温度漂移。</strong></p><ul><li><strong>时间漂移是指在规定的条件下，零点或灵敏度随时间的缓慢变化；</strong></li><li><strong>温度漂移为环境温度变化而引起的零点或灵敏度的变化。</strong></li></ul><h3 id="2．传感器的动态特性"><a href="#2．传感器的动态特性" class="headerlink" title="2．传感器的动态特性"></a><strong>2．传感器的动态特性</strong></h3><p>传感器的动态特性是指传感器在测量快速变化的输入信号情况下，输出对输入的响应特性。传感器测量静态信号时，由于被测量不随时间变化，测量和记录的过程不受时间限制。但是在工程实践中，检测的是大量随时间变化的动态信号，这就要求传感器不仅能精确地测量信号的幅值大小，而且还能显示被测量随时间变化的规律，即正确的再现被测量波形。传感器测量动态信号的能力用动态特性来表示。</p><p>在动态测量中，当被测量作周期性变化时，传感器的输出值随着周期性变化，其频率与前者相同，但输出幅值和相位随频率的变化而变化，这种关系称为频率特性。输出信号的幅值随频率变化而改变的特性称为幅频特性；输出信号的相位随频率的变化而改变的特性称为相频特性，幅值下降到稳定幅值的0.707倍时所对应的频率称为截止频率。</p><ul><li><strong>传感器静态特性是输入信号不随时间变化时的输出与输入之间的关系。</strong></li><li><strong>静态特性指标：灵敏度、线性度、重复性、迟滞现象、精确度、分辨力、稳定性和漂移。</strong></li><li><strong>传感器的动态特性是输入信号随时间周期性作变化时的输出与输入之间的关系。</strong></li></ul><h4 id="力敏传感器及其应用"><a href="#力敏传感器及其应用" class="headerlink" title="力敏传感器及其应用"></a><strong>力敏传感器及其应用</strong></h4><p>力敏传感器，顾名思义就是能对各种力或能转化为力的物理量产生反应，并能将其转变为电参数的装置或元件。很显然，要成为真正实用意义上的力敏传感器，这个由力转化为电参数的过程最好能成线性关系。</p><p>根据由力至电参数转变的方式不同，力敏传感器一般有电阻应变式传感器、电位计式传感器、电感式传感器、压电式传感器、电容式传感器等，它们可用来测量力值。</p><h3 id="电阻应变式传感器"><a href="#电阻应变式传感器" class="headerlink" title="电阻应变式传感器"></a>电阻应变式传感器</h3><p>  电阻应变式传感器是目前工程测力传感器中应用最普遍的一种传感器，它测量精度高，范围广，频率响应特性较好，结构简单，尺寸小，易实现小型化，并能在高温、强磁场等恶劣环境下使用，并且工艺性好，价格低廉。它主要应用在力作用下，将材料应变转变为电阻值的变化，从而实现力值的测量。组成电阻应变片的材料一般为金属或半导体材料。</p><h4 id="电阻应变式传感器工作原理"><a href="#电阻应变式传感器工作原理" class="headerlink" title="电阻应变式传感器工作原理"></a><strong>电阻应变式传感器工作原理</strong></h4><p><strong>（1）应变效应</strong></p><p>由物理学可知，电阻丝的电阻 <em>R</em> 与电阻丝的电阻率、导体长度及截面积存在如下关系</p><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-3-%E4%BC%A0%E6%84%9F%E5%99%A8/image-20231029221136388.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="f"></p><p>当电阻丝受到拉力作用时，长度伸长 <em>Δ**l</em>，横截面收缩 <em>Δ**S</em>，电阻率也将变化 <em>Δρ</em>，此时电阻值产生 ΔR 变化。</p><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-3-%E4%BC%A0%E6%84%9F%E5%99%A8/image-20231029221151327.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="**电阻丝应变效应**"></p><p><strong>电阻应变式传感器的结构及特性</strong> :</p><p><strong>金属电阻应变片分为金属丝式和金属箔式两种。</strong></p><p><strong>① 金属丝式电阻应变片。金属丝式电阻应变片的基本结构图如图所示。由敏感栅1、基底2和盖层3、引线4和黏结剂几个基本部分组成。</strong></p><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-3-%E4%BC%A0%E6%84%9F%E5%99%A8/image-20231029221241302.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="**金属丝式电阻应变片的基本结构图** "></p><p>  <strong>②</strong> <strong>金属箔式应变片。如图所示，它与金属丝式电阻应变片相比，有如下优点：用光刻技术能制成各种复杂形状的敏感栅；横向效应小；散热性好，允许通过较大电流，可提高相匹配的电桥电压，从而提高输出灵敏度；疲劳寿命长，蠕变小；生产效率高。</strong></p><p>  <strong>但是，制造箔式应变片的电阻值的分散性要比丝式应变片的大，有的能相差几十欧姆，需要调整阻值。金属箔式应变片因其一系列优点而将逐渐取代丝式应变片，并占主要地位。</strong></p><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-3-%E4%BC%A0%E6%84%9F%E5%99%A8/image-20231029221257100.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="金属箔"></p><blockquote><p><strong>各种箔式应变片</strong></p><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-3-%E4%BC%A0%E6%84%9F%E5%99%A8/image-20231029221321136.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="第二个有点像学校的校徽"></p></blockquote><p><strong>电阻应变片传感器基本应用电路</strong></p><p> <strong>将电阻应变片粘贴于待测构件上，应变片电阻随着构件应变而改变，将应变片电阻接入相应的电路中，使其转化为电流或电压输出，即可测出力值。</strong></p><p><strong>通常将应变片接入电桥来实现电阻至电压或电流的转换。根据电桥电源不同，又分直流电桥和交流电桥。这里主要介绍直流电桥。</strong></p><p><strong>如图所示为一直流电桥，计算可知：</strong></p><p><strong>∆U&#x3D;(R_1 R_3-R_2</strong> *<em>R_4)&#x2F;(R_1+R_2 )(R_3+R_4 ) <em>E</em></em></p><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-3-%E4%BC%A0%E6%84%9F%E5%99%A8/image-20231029221439447.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="电桥"></p><p><strong>若使此电桥平衡，即</strong> <strong>ΔU &#x3D; 0，只要</strong> <strong>R1</strong> <strong>R3</strong> <strong>–</strong> <strong>R2</strong> <strong>R4</strong> <strong>&#x3D;</strong> <strong>0</strong> <strong>。一般我们取</strong> <strong>R1</strong> <strong>&#x3D;</strong> <strong>R2</strong> <strong>&#x3D;</strong> <strong>R3</strong> <strong>&#x3D;</strong> <strong>R4</strong> <strong>&#x3D;</strong> <strong>R</strong> <strong>即可实现。</strong></p><p><strong>按上述，取</strong> <strong>R1</strong> <strong>&#x3D;</strong> <strong>R2</strong> <strong>&#x3D;</strong> <strong>R3</strong> <strong>&#x3D;</strong> <strong>R4</strong> <strong>&#x3D;</strong> <strong>R</strong> <strong>即可实现电桥平衡。</strong></p><p><strong>现将</strong> <strong>R1</strong> <strong>换成电阻应变片，即组成半桥单臂电桥，随构件产生应变造成传感器电阻变化时，上式变成</strong></p><p><strong>∆U&#x3D;∆R&#x2F;(4R+2∆R) E</strong></p><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-3-%E4%BC%A0%E6%84%9F%E5%99%A8/image-20231029221548915.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="image-20231029221548915"></p><p><strong>一般</strong> <strong>ΔU</strong> <strong>&lt;&lt;</strong> <strong>R</strong> <strong>，可忽略，由此可得</strong></p><p><strong>∆U≈1&#x2F;4  ∆R&#x2F;R E</strong></p><p> <strong>可见，输出电压与电阻变化率成线性关系，即和应变力成线性关系，由此即可测出力值。由上式可得半桥单臂工作输出的电压灵敏度</strong>  <strong>k_u&#x3D;∆U&#x2F;(∆R∕R)&#x3D; E&#x2F;4</strong> </p><p>  <strong>为了提高输出电压灵敏度，可以采用半桥双臂或全桥双肩电路。</strong></p><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-3-%E4%BC%A0%E6%84%9F%E5%99%A8/image-20231029221635236.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="图"></p><p><strong>即半桥双臂可使电压灵敏度比半桥单臂提高一倍，而全桥电路电压灵敏度又比半桥双臂电压灵敏度提高一倍。可见，利用全桥，并提高供电电压</strong> <strong>E，可提高灵敏度系数。</strong></p><h5 id="温度误差及其补偿"><a href="#温度误差及其补偿" class="headerlink" title="温度误差及其补偿"></a>温度误差及其补偿</h5><p><strong>（1） 温度误差</strong></p><p><strong>用作测量应变的金属应变片，希望其阻值仅随应变力变化，而不受其它因素的影响。但是，环境温度的变化，会造成阻值的额外变化。</strong></p><p>Ø<strong>阻温效应： 当环境温度改变时，由于热输出会引起电阻率的变化，而且与构件应变所造成的电阻变化有相同的数量级，从而产生很大的测量误差。</strong></p><p>Ø<strong>附加应变： 当环境温度改变时，构件和应变片产生变形，使应变片产生附加应变，从而使应变片在被测应力作用下产生</strong> <strong>Δ</strong> <strong>R</strong> <strong>的基础上附加了</strong> <strong>ΔRi</strong> <strong>，使测力结果发生误差。</strong></p><p><strong>（2） 温度补偿</strong></p><p><strong>一般采用桥路补偿法、应变片补偿法或热敏电阻补偿法。</strong></p><p><strong>桥路补偿法： 如图所示，当</strong> <strong>ab</strong> <strong>间接入应变片传感器，bc</strong> <strong>间也接入同样的应变片，但</strong> <strong>bc</strong> <strong>间接入的应变片不受构件应变力的作用，将它用同样的方法粘贴在与</strong> <strong>ab</strong> <strong>间应变片所贴构件材料相同的材料上，并与</strong> <strong>ab</strong> <strong>间应变片处于同一温度场，这样</strong> <strong>ab、bc</strong> <strong>间应变片的阻温效应相同，电阻的变化量</strong> <strong>ΔRi</strong> <strong>也相同，由电桥理论可知，它们起了互相抵消作用，对输出电压没有影响。</strong></p><p><strong>（阻温 ）</strong></p><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-3-%E4%BC%A0%E6%84%9F%E5%99%A8/image-20231029221729720.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="温度补偿"></p><blockquote><p><strong>应变片补偿法分自补偿和互补偿两种。</strong></p><p>•<strong>自补偿法：其原理是合理选择应变片阻温系数及线膨胀系数，使之与被测构件线膨胀系数匹配，使应变片温度变化</strong> <strong>Δt</strong> <strong>时，由热造成的输出值为</strong> <strong>0。（阻温</strong> <strong>+</strong> <strong>附加）</strong></p><p>•<strong>应变片互补偿法：其原理是检测用的应变片敏感栅由两种材料组成，在温度变化</strong> <strong>Δt</strong> <strong>时，它们的阻值变化量</strong> <strong>ΔR</strong> <strong>相同，但符号相反，这样就可抵消由于温度变化而造成传感器误输出。使用中要注意选配敏感栅电阻丝材料。</strong> <strong>（阻温</strong> <strong>）</strong></p><p><strong>热敏电阻补偿法</strong></p><p>•<strong>如图所示，图中</strong> <strong>R5</strong> <strong>为分流电阻，Rt</strong> <strong>为</strong> <strong>NTC热敏电阻，使</strong> <strong>Rt</strong> <strong>与应变式传感器处在同一温度场中，适当调整</strong> <strong>R5</strong> <strong>值，可使</strong> <strong>ΔR</strong> <strong>附加的热输出为零。（阻温）</strong></p><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-3-%E4%BC%A0%E6%84%9F%E5%99%A8/image-20231029221756683.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="热敏电阻补偿"></p></blockquote><p><strong>电阻应变式传感器应用于测力（如称重）</strong></p><p>•<strong>电阻应变式传感器广泛应用在测力及可以转化为力值的量（如加速度等）。</strong> </p><p>•<strong>图中</strong> <strong>1、2、3、4</strong> <strong>为四个相同的应变片，沿同一高度圆周均布，接入全桥测量电路。在外力</strong> <strong>F</strong> <strong>的作用下应变片</strong> <strong>1、3</strong> <strong>的电阻变大，应变片</strong> <strong>2、4</strong> <strong>的电阻变小。</strong></p><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-3-%E4%BC%A0%E6%84%9F%E5%99%A8/image-20231029221827761.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="图"></p><p>•<strong>测量电路输出电压为</strong>  <strong>∆U&#x3D;U</strong> <strong>∆R&#x2F;R</strong> <strong>&#x3D;k</strong> <strong>F</strong> <strong>，（k</strong> <strong>值与圆筒截面积、圆筒材料泊松比、弹性元件的弹性模量、馈电电源等相关）</strong></p><p>•<strong>∆U</strong> <strong>与所称重量成线性关系，将</strong> <strong>∆U经过放大等一系列处理电路，可送显示仪表直接读出称重量。</strong></p><h5 id="加速度传感器"><a href="#加速度传感器" class="headerlink" title="加速度传感器"></a><strong>加速度传感器</strong></h5><p><strong>将被测加速度</strong> <strong>a</strong> <strong>通过一个悬臂梁将力</strong> <strong>F</strong> <strong>&#x3D; ma</strong> <strong>转化成应变片的应力，从而达到测量加速度</strong> <strong>a</strong> <strong>的目的。</strong></p><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-3-%E4%BC%A0%E6%84%9F%E5%99%A8/image-20231029221856717.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="原理，悬梁臂是敏感元件，应变片是转换元件"></p><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-3-%E4%BC%A0%E6%84%9F%E5%99%A8/image-20231029222002107.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="例子"></p><p><strong>力敏传感器应用实例：电子秤</strong> </p><p><strong>如图所示是采用微处理器的电子秤原理图</strong>：</p><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-3-%E4%BC%A0%E6%84%9F%E5%99%A8/image-20231029222028557.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="电子秤"></p><h3 id="电感式传感器"><a href="#电感式传感器" class="headerlink" title="电感式传感器"></a>电感式传感器</h3><h4 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a><strong>工作原理</strong></h4><p><strong>电感式传感器是利用线圈自感或互感的变化来实现测量的一种装置，可以用来测量位移、振动、压力、流量、重量、力矩和应变等多种物理量。</strong></p><p><strong>电感式传感器的核心部分是可变自感或可变互感，在被测量转换成线圈自感或互感的变化时，一般要利用磁场作为媒介或利用铁磁体的某些现象。这类传感器的主要特征是具有绕组。</strong></p><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-3-%E4%BC%A0%E6%84%9F%E5%99%A8/image-20231029225957628.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="1"></p><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-3-%E4%BC%A0%E6%84%9F%E5%99%A8/image-20231029230002834.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="2"></p><h4 id="优点和缺点"><a href="#优点和缺点" class="headerlink" title="优点和缺点"></a><strong>优点和缺点</strong></h4><p><strong>（1）优点：结构简单可靠，输出功率大，抗干扰能力强，对工作环境要求不高，分辨力较高（如在测量长度时一般可达0.1mm），示值误差一般为示值范围的0.1%~0.5%，稳定性好。</strong></p><p><strong>（2）缺点：频率响应低，不宜用于快速动态测量。一般来说，电感式传感器的分辨力和示值误差与示值范围有关。示值范围大时，分辨力和示值精度将相应降低。</strong></p><h4 id="种类"><a href="#种类" class="headerlink" title="种类"></a><strong>种类</strong></h4><p><strong>有利用自感原理的自感式传感器，有利用互感原理的差动变压器式传感器。此外，还有利用涡流原理的涡流式传感器，利用压磁原理的压磁式传感器和利用互感原理的感应同步器等。</strong></p><h3 id="变压器式传感器"><a href="#变压器式传感器" class="headerlink" title="变压器式传感器"></a><strong>变压器式传感器</strong></h3><h4 id="工作原理-1"><a href="#工作原理-1" class="headerlink" title="工作原理"></a><strong>工作原理</strong></h4><p><strong>变压器式传感器是将非电量转换为线圈间互感的一种磁电动机构，很像变压器的工作原理，因此常称其为变压器式传感器。这种传感器多采用差动形式。</strong></p><p>Ø<strong>气隙型差动变压器式</strong></p><p>Ø<strong>截面积型差动变压器式</strong></p><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-3-%E4%BC%A0%E6%84%9F%E5%99%A8/image-20231029230100908.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="1"></p><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-3-%E4%BC%A0%E6%84%9F%E5%99%A8/image-20231029230103577.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="2"></p><h4 id="气隙型差动变压器式传感器"><a href="#气隙型差动变压器式传感器" class="headerlink" title="气隙型差动变压器式传感器"></a><strong>气隙型差动变压器式传感器</strong></h4><p><strong>当没有非电量输入时，衔铁</strong> <strong>C</strong> <strong>与铁芯</strong> <strong>A、B</strong> <strong>的间隔相同，则绕组</strong> <strong>W1a</strong> <strong>和</strong> <strong>W2a</strong> <strong>间的互感</strong> <strong>ma</strong> <strong>与绕组</strong> <strong>W1b</strong> <strong>和</strong> <strong>W2b</strong> <strong>间的互感</strong> <strong>mb</strong> <strong>相等。</strong></p><p><strong>当衔铁位置改变时，ma</strong> <strong>和</strong> <strong>mb</strong> <strong>的差值即反映被测量值的大小。</strong></p><p><strong>为反映差值互感，将两个一次绕组的同名端顺向串联，并施加交流电压</strong> <strong>u，二次绕组的同名端反向串联，同时测量串联后的合成电动势</strong> <strong>e2</strong> <strong>为：e2</strong> <strong>&#x3D;</strong> <strong>e2a</strong> <strong>-</strong> <strong>e2b</strong></p><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-3-%E4%BC%A0%E6%84%9F%E5%99%A8/image-20231029230133461.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="气隙"></p><h4 id="截面积型差动变压器式传感器"><a href="#截面积型差动变压器式传感器" class="headerlink" title="截面积型差动变压器式传感器"></a><strong>截面积型差动变压器式传感器</strong></h4><p>n<strong>改变气隙有效截面积，输入非电量为角位移Δα。它是一个山字形铁芯</strong> <strong>A上 绕有三个绕组。</strong> <strong>W1</strong> <strong>为一次绕组，W2a</strong> <strong>及</strong> <strong>W2b</strong> <strong>为两个二次绕组。</strong></p><p>n<strong>衔铁</strong> <strong>B</strong> <strong>以</strong> <strong>O</strong> <strong>点为轴转动时，由于改变了铁芯与衔铁间磁路上的垂直有效截面积</strong> <strong>s，也就改变了绕组间的互感，使其中一个互感增大，另一个互感减小，因此两个二次绕组中的感应电动势也随之改变。</strong></p><p>n<strong>将绕组</strong> <strong>w2a</strong> <strong>和</strong> <strong>w2b</strong> <strong>反相串联并测量合成电动势</strong> <strong>e2，就可以判断出非电量的大小及方向。</strong></p><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-3-%E4%BC%A0%E6%84%9F%E5%99%A8/image-20231029230159818.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="截面积"></p><h4 id="差动变压器应用实例"><a href="#差动变压器应用实例" class="headerlink" title="差动变压器应用实例"></a><strong>差动变压器应用实例</strong></h4><p><strong>一般来说，较小位移量的测量采用差动变压器，</strong></p><ul><li><strong>电子秤：用差动变压器把弹簧的位移变为电信号，换算为重量</strong></li><li><strong>偏心测量仪：以起始点作为基准，最后换算为转体的偏心程度</strong></li></ul><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-3-%E4%BC%A0%E6%84%9F%E5%99%A8/image-20231029230232645.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="左秤，右偏心测量仪"></p><h4 id="电感式传感器应用实例：测量列车运行"><a href="#电感式传感器应用实例：测量列车运行" class="headerlink" title="电感式传感器应用实例：测量列车运行"></a><strong>电感式传感器应用实例：测量列车运行</strong></h4><p><strong>测量列车运行的速度和加速度，组成包括：</strong></p><ul><li><strong>安装在列车头底部的一块强磁体</strong></li><li><strong>埋设在轨道地面的一组线圈</strong></li><li><strong>电流测量仪</strong></li></ul><p><strong>当列车经过线圈上方时，线圈中产生的电流被记录下来，即能求出列车在各位置的速度和加速度。</strong></p><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-3-%E4%BC%A0%E6%84%9F%E5%99%A8/image-20231030000647953.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="车"></p><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-3-%E4%BC%A0%E6%84%9F%E5%99%A8/image-20231030084134887.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="原理"></p><p><strong>力敏传感器是将动态或静态力的大小转换成便于测量的电量的装置。</strong></p><ul><li><p><strong>电阻应变式传感器：其将外力转化成电阻值的变化，再利用电桥电路检测出电阻值的变化值，从而得出对应的力变化量。</strong></p></li><li><p><strong>电感式传感器：其将外力引起的微小位移量转化成电感参数的变化，从而得出相应力的变化量。如位移量很小，可采用差动变压器来放大信号的方式，以提高传感器的灵敏度。</strong></p></li><li><p><strong>电容式传感器</strong></p></li><li><p><strong>…</strong></p></li></ul><h3 id="电容式传感器"><a href="#电容式传感器" class="headerlink" title="电容式传感器"></a>电容式传感器</h3><h4 id="电容式传感器的工作原理和结构"><a href="#电容式传感器的工作原理和结构" class="headerlink" title="电容式传感器的工作原理和结构"></a><strong>电容式传感器的工作原理和结构</strong></h4><p><strong>由绝缘介质分开的两个平行金属板组成的平板电容器，如果不考虑边缘效应，其电容量为：</strong> <strong>C&#x3D;ϵA&#x2F;d</strong></p><p><strong>式中：ε——电容极板间介质的介电常数，ε&#x3D;ε0εr，<br> 　　　　其中ε0为真空介电常数，εr为极板间介质的相对介电常数；</strong></p><pre><code class="hljs">         　**A——两平行板所覆盖的面积；**      **d——两平行板之间的距离。**</code></pre><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-3-%E4%BC%A0%E6%84%9F%E5%99%A8/image-20231030084432070.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="示意图"></p><p><strong>当被测参数变化使得公式中的</strong> <strong>A、d</strong> <strong>或</strong> <strong>ε</strong> <strong>发生变化时，电容量</strong> <strong>C</strong> <strong>也随之变化。</strong></p><p><strong>如果保持其中两个参数不变，而仅改变其中一个参数，就可把该参数的变化转换为电容量</strong> <strong>C</strong> <strong>的变化，通过测量电路就可转换为电量输出。</strong></p><p><strong>电容式传感器可分为变极距型、变面积型和变介电常数型三种。</strong></p><h5 id="变极距型电容传感器"><a href="#变极距型电容传感器" class="headerlink" title="变极距型电容传感器"></a><strong>变极距型电容传感器</strong></h5><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-3-%E4%BC%A0%E6%84%9F%E5%99%A8/image-20231030090108053.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="图"></p><p><strong>当</strong> <strong>εr</strong> <strong>和</strong> <strong>A</strong> <strong>为常数，初始极距为</strong> <strong>d0</strong> 时，初始电容量为 </p><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-3-%E4%BC%A0%E6%84%9F%E5%99%A8/image-20231030090035023.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="1"></p><hr><p> <strong>若电容器极板间距离由初始值</strong> <strong>d0</strong> <strong>缩小了</strong> <strong>Δd，电容量增大了</strong> **ΔC，则有 </p><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-3-%E4%BC%A0%E6%84%9F%E5%99%A8/image-20231030090046783.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="C"></p><hr><p><strong>如图，传感器的输出特性不是线性关系。</strong></p><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-3-%E4%BC%A0%E6%84%9F%E5%99%A8/image-20231030090056541.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="特性"></p><h5 id="采用云母片的变极距型电容传感器"><a href="#采用云母片的变极距型电容传感器" class="headerlink" title="采用云母片的变极距型电容传感器"></a><strong>采用云母片的变极距型电容传感器</strong></h5><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-3-%E4%BC%A0%E6%84%9F%E5%99%A8/image-20231030090423651.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="云母片"></p><ul><li><strong>在</strong> <strong>d0</strong> <strong>较小时，对于同样的</strong> <strong>Δd</strong> <strong>变化所引起的</strong> <strong>ΔC</strong> <strong>更大，从而使传感器灵敏度提高。</strong></li><li><strong>但</strong> <strong>d0</strong> <strong>过小，容易引起电容器击穿或短路。</strong></li><li><strong>为此，极板间可采用高介电常数的材料（云母、塑料膜等）作介质。此时电容</strong> <strong>C</strong> **变为<br>**</li></ul><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-3-%E4%BC%A0%E6%84%9F%E5%99%A8/image-20231030090442649.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="C"></p><p> 式中：εg——云母的相对介电常数，εg&#x3D;7；<br>　　**ε0——空气的介电常数，ε0&#x3D;1；<br>** 　　**d0——空气隙厚度；<br>** 　　<strong>dg——云母片的厚度。</strong></p><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-3-%E4%BC%A0%E6%84%9F%E5%99%A8/image-20231030090520233.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="云母片"></p><p><strong>云母片的相对介电常数是空气的</strong> <strong>7</strong> <strong>倍，其击穿电压不小于1000kV&#x2F;mm，而空气仅为3kV&#x2F;mm。因此有了云母片，极板间起始距离可大大减小。</strong></p><p><strong>一般起始电容在20～100pF，极板间距离在25～200μm。最大位移应小于间距的1&#x2F;10，故在微位移测量中应用最广。</strong></p><h5 id="变面积型电容式传感器"><a href="#变面积型电容式传感器" class="headerlink" title="变面积型电容式传感器"></a><strong>变面积型电容式传感器</strong></h5><p>被测量通过动极板移动引起两极板有效覆盖面积 A 改变，从而得到电容量的变化。</p><p>当动极板相对于定极板沿长度方向平移Δx时，电容变化量为<br> <img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-3-%E4%BC%A0%E6%84%9F%E5%99%A8/image-20231030090625375.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="电容"></p><p> 式中 <strong>C0</strong> <strong>&#x3D;</strong> <strong>ε0εrba&#x2F;d</strong> <strong>为初始电容。</strong></p><p>电容相对变化量为：</p><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-3-%E4%BC%A0%E6%84%9F%E5%99%A8/image-20231030090645315.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="相对变化"></p><p>很明显，这种形式的传感器其电容量 <strong>C</strong> 与水平位移Δx呈线性关系。</p><h5 id="电容式角位移传感器"><a href="#电容式角位移传感器" class="headerlink" title="电容式角位移传感器"></a><strong>电容式角位移传感器</strong></h5><p><strong>当动极板有一个角位移</strong> <strong>θ</strong> <strong>时，与定极板间的有效覆盖面积就发生改变，从而改变了两极板间的电容量。</strong></p><p><strong>当</strong> <strong>θ</strong> <strong>&#x3D; 0</strong> 时，有 </p><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-3-%E4%BC%A0%E6%84%9F%E5%99%A8/image-20231030091024036.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="电容"></p><p> 式中：εr——介质相对介电常数；<br> 　　d0——两极板间距离；</p><p>​A0——两极板间初始覆盖面积。</p><p>当θ ≠ 0时，有</p><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-3-%E4%BC%A0%E6%84%9F%E5%99%A8/image-20231030091047699.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="1"></p><p><strong>可见，传感器的电容量</strong> <strong>C</strong> <strong>与角位移</strong>θ呈线性关系。</p><h5 id="变介质型电容式传感器"><a href="#变介质型电容式传感器" class="headerlink" title="变介质型电容式传感器"></a><strong>变介质型电容式传感器</strong></h5><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-3-%E4%BC%A0%E6%84%9F%E5%99%A8/image-20231030091616241.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="1"></p><p><strong>变介质型电容传感器有较多的结构形式，可以用来测量纸张、绝缘薄膜等的厚度，也可用来测量粮食、纺织品、木材或煤等非导电固体介质的湿度。</strong></p><p><strong>图中，两平行电极固定不动，极距为</strong> <strong>d0，相对介电常数为</strong> <strong>εr2</strong> <strong>的电介质以不同深度嵌入电容器中，从而改变两种介质的极板覆盖面积。</strong></p><p><strong>传感器总电容量</strong> <strong>C</strong> 为 </p><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-3-%E4%BC%A0%E6%84%9F%E5%99%A8/image-20231030091640362.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="C"></p><p> **式中：L0、b0——极板的长度、宽度；<br>**L——第二种介质进入极板间的长度。</p><p><strong>若电介质</strong> <strong>εr1</strong> <strong>&#x3D;</strong> <strong>1，则当</strong> <strong>L</strong> <strong>&#x3D;</strong> <strong>0</strong> <strong>时，传感器初始电容</strong> <strong>C0</strong> <strong>&#x3D;</strong> <strong>ε0εr1L0b0&#x2F;d0。</strong></p><p><strong>当被测介质</strong> <strong>εr2</strong> <strong>进入极板间</strong> <strong>L深度后，引起电容相对变化量为</strong></p><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-3-%E4%BC%A0%E6%84%9F%E5%99%A8/image-20231030091713179.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="C"></p><p><strong>可见，电容量的变化与电介质</strong> <strong>εr2</strong> 的移动量 L成线性关系。</p><h4 id="电介质材料的相对介电常数"><a href="#电介质材料的相对介电常数" class="headerlink" title="电介质材料的相对介电常数"></a><strong>电介质材料的相对介电常数</strong></h4><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-3-%E4%BC%A0%E6%84%9F%E5%99%A8/image-20231030091743840.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="介电"></p><h5 id="应用：电容式液位变换器结构原理"><a href="#应用：电容式液位变换器结构原理" class="headerlink" title="应用：电容式液位变换器结构原理"></a><strong>应用：电容式液位变换器结构原理</strong></h5><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-3-%E4%BC%A0%E6%84%9F%E5%99%A8/image-20231030092020143.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="一案例"></p><p><strong>如图是一种利用改变极板间介质的方式测量液位高低的电容式传感器结构原理图。</strong></p><p><strong>设被测介质的介电常数为 ε1，液面高度为 h，变换器总高度为 H，内筒外径为 d，外筒内径为 D，则此时变换器电容值为</strong></p><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-3-%E4%BC%A0%E6%84%9F%E5%99%A8/image-20231030092011822.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="电容"></p><p>　　**式中：ε——空气介电常数；<br>　　    **C0——由变换器的基本尺寸决定的初始电容值，即</p><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-3-%E4%BC%A0%E6%84%9F%E5%99%A8/image-20231030092045801.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="初始"></p><p><strong>可见，此变换器的电容增量正比于被测液位高度</strong>h。</p><h4 id="变极距型差动平板式电容传感器"><a href="#变极距型差动平板式电容传感器" class="headerlink" title="变极距型差动平板式电容传感器"></a><strong>变极距型差动平板式电容传感器</strong></h4><p><strong>在实际应用中，为了提高灵敏度，减小非线性误差，大多采用差动式结构。</strong></p><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-3-%E4%BC%A0%E6%84%9F%E5%99%A8/image-20231030092154754.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="变极距"></p><p><strong>电容传感器做成差动式之后，灵敏度增加了一倍，而且非线性误差则大大降低了。</strong></p><h5 id="应用：-（差动）电容式加速度传感器"><a href="#应用：-（差动）电容式加速度传感器" class="headerlink" title="应用： （差动）电容式加速度传感器"></a><strong>应用：</strong> <strong>（差动）电容式加速度传感器</strong></h5><p><strong>有两个固定极板（与壳体绝缘），中间有一用弹簧片支撑的质量块，此质量块的两个端面经过磨平抛光后作为可动极板（与壳体电连接）。</strong></p><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-3-%E4%BC%A0%E6%84%9F%E5%99%A8/image-20231030092447889.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="1"></p><p>　　<strong>当传感器壳体随被测对象沿垂直方向作直线加速运动时，质量块在惯性空间中相对静止，两个固定电极将相对于质量块在垂直方向产生大小正比于被测加速度的位移。此位移使两电容的间隙发生变化，一个增加，一个减小，从而使C1、C2产生大小相等、符号相反的增量，此增量正比于被测加速度。<br> 　电容式加速度传感器的主要特点是频率响应快和量程范围大。</strong></p><h5 id="应用：（差动）电容式测厚传感器"><a href="#应用：（差动）电容式测厚传感器" class="headerlink" title="应用：（差动）电容式测厚传感器"></a><strong>应用：（差动）电容式测厚传感器</strong></h5><p>　　<strong>电容测厚传感器是用来对金属带材在轧制过程中厚度的检测。</strong></p><p><strong>其工作原理是在被测带材的上下两侧各置放一块面积相等，与带材距离相等的极板，这样极板与带材就构成了两个电容器C1、C2。</strong></p><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-3-%E4%BC%A0%E6%84%9F%E5%99%A8/image-20231030092527456.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="测厚"></p><p><strong>把两块极板用导线连接起来成为一个极，而带材就是电容的另一个极，其总电容为</strong> <strong>C1</strong> <strong>+</strong> <strong>C2。</strong></p><p><strong>如果带材的厚度发生变化，将引起电容量的变化。</strong></p><p><strong>用交流电桥将电容的变化测出来，经过放大即可由电表指示测量结果。</strong></p><h3 id="热电式传感器"><a href="#热电式传感器" class="headerlink" title="热电式传感器"></a><strong>热电式传感器</strong></h3><h4 id="热电式传感器的分类"><a href="#热电式传感器的分类" class="headerlink" title="热电式传感器的分类"></a><strong>热电式传感器的分类</strong></h4><p><strong>热电式传感器是一种将温度变化转换为电量变化的转换装置。它利用敏感元件的电参数随温度变化的特性，对温度和温度相关的参数进行测量，</strong></p><p><strong>其中将温度转换为电势的热电式传感器叫热电偶</strong></p><p><strong>将温度变化转换为电阻值的热电式传感器叫热电阻</strong></p><ul><li><strong>用金属作为感温元件的热电阻，称为金属热电阻</strong></li><li><strong>用半导体材料作为感温元件的热电阻，称为热敏电阻</strong></li></ul><h4 id="热电偶的测温原理"><a href="#热电偶的测温原理" class="headerlink" title="热电偶的测温原理"></a><strong>热电偶的测温原理</strong></h4><p><strong>热电偶是利用热电效应制成的温度传感器。</strong></p><p><strong>热电效应： 当不同材料的导体或半导体组成一个闭合回路时，若两个接点的温度不同，那么在回路中将会产生电动势的现象。</strong></p><p><strong>这种闭合回路组合被称为热电偶，不同的导体或半导体称为热电极，温度高的接点称为热端（或工作端、测量端），温度低的接点称为冷端（或自由端、补偿端）。</strong></p><p><strong>两点间的温差越大，产生的电动势就越大。引入适当的测量电路测量电动势的大小，就可测得温度的大小。</strong></p><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-3-%E4%BC%A0%E6%84%9F%E5%99%A8/image-20231030092644770.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="1"></p><p><strong>热电动势的组成</strong></p><ul><li><strong>接触电动势：是由两种不同导体的自由电子，其密度不同而在接触处形成的热电势。它的大小取决于两导体的性质及接触点的温度，而与导体的形状和尺寸无关。</strong></li><li><strong>温差电动势：是在同一根导体中，由于两端温度不同而产生的一种电势。</strong></li></ul><h4 id="热电偶的特点"><a href="#热电偶的特点" class="headerlink" title="热电偶的特点"></a><strong>热电偶的特点</strong></h4><p>热电偶作为热电式传感器，凭借其简单的结构，便捷的操作，稳定的性能，广阔的测温范围，较小的热惯性和热容量，便于检测和控制的输出信号，在温度测量中占有重要地位。所以常被用作测量炉子、管道内的气体或液体的温度及固体的表面温度。</p><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-3-%E4%BC%A0%E6%84%9F%E5%99%A8/image-20231030092729412.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="1"></p><h4 id="金属热电阻"><a href="#金属热电阻" class="headerlink" title="金属热电阻"></a><strong>金属热电阻</strong></h4><p><strong>金属热电阻传感器是利用导体的电阻值随温度变化的原理，将温度的变化量转换成与之有一定函数关系的电阻值的变化量，通过对电阻值的测量实现对温度的测量。</strong></p><p><strong>大多数金属导体的电阻随温度变化而变化，当温度升高时，金属内部自由电子的动能增加，在电场作用下，这些杂乱无章的电子作定向移动会遇到更大的阻力，导致金属电阻值随温度的升高而增加。</strong></p><p><strong>材料：温度系数大、线性度好、热容量小、电阻率大、易提纯等</strong></p><table><thead><tr><th><strong>材料</strong></th><th><strong>使用温度范围&#x2F;℃</strong></th><th><strong>（0～100）℃间电阻温度系数α（平均值）（1&#x2F;C）</strong></th><th><strong>化学稳定性</strong></th><th><strong>特性</strong></th><th><strong>应用</strong></th></tr></thead><tbody><tr><td><strong>铂</strong></td><td><strong>-200～850</strong></td><td><strong>0.00385</strong></td><td><strong>在氧化性介质中较稳定，不能在还原性介质中使用，尤其在高温情况下</strong></td><td><strong>特性近于线性、性能稳定、精度高</strong></td><td><strong>适于较高温度的测量，可作标准测温装置</strong></td></tr><tr><td><strong>铜</strong></td><td><strong>-50～150</strong></td><td><strong>0.00428</strong></td><td><strong>超过100℃易氧化</strong></td><td><strong>线性较好、价格低廉、体积大</strong></td><td><strong>适于测量低温、无水分、无腐蚀性介质的温度</strong></td></tr></tbody></table><h4 id="热敏电阻"><a href="#热敏电阻" class="headerlink" title="热敏电阻"></a><strong>热敏电阻</strong></h4><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-3-%E4%BC%A0%E6%84%9F%E5%99%A8/image-20231030092947212.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="1"></p><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-3-%E4%BC%A0%E6%84%9F%E5%99%A8/image-20231030092953595.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="2"></p><ul><li><strong>热敏电阻属于半导体器件，对温度敏感，不同的温度下表现出不同的电阻值。正温度系数热敏电阻在温度越高时电阻值越大，负温度系数热敏电阻在温度越高时电阻值越低。</strong></li><li><strong>热敏电阻具有结构简单、温度系数大、灵敏度高、电阻率高、热惯性小等特点，比较适合动态测量。</strong></li><li><strong>热敏电阻线性度较差，只在某一较窄温度范围内有较好的线性度，且由于是半导体材料其互换性差。</strong></li><li><strong>热敏电阻两大用途</strong></li></ul><p><strong>作为检测元件</strong></p><p><strong>作为电路元件</strong></p><h3 id="光电式传感器"><a href="#光电式传感器" class="headerlink" title="光电式传感器"></a><strong>光电式传感器</strong></h3><ul><li><strong>光电式传感器也称为光电器件，是将光信号转换为电信号的一种装置。</strong></li><li><strong>光电式传感器工作时，先将被测量的变化转换为光量的变化，然后通过光电器件再把光量的变化转换为相应的电量变化，从而实现非电量的测量。</strong></li><li><strong>其原理为光电效应，是指物体吸收了光能后，光能转化为该物体中某些电子的能量，从而产生电效应。</strong></li><li><strong>光电效应分类</strong><ul><li><strong>外光电效应：</strong> <strong>在光线作用下，电子逸出物体表面而产生光电子发射的现象。</strong></li><li><strong>内光电效应：</strong> <strong>在光线作用下，物体的电阻率改变的现象。</strong></li><li><strong>光生伏特效应：</strong> <strong>在光线作用下，物体内部产生一定方向电动势。</strong></li><li><strong>热释电现象：</strong> <strong>热电材料受红外线等照射时，若其表面温度发生变化，则该表面产生电荷的现象。</strong></li></ul></li></ul><h4 id="光电式传感器的工作原理"><a href="#光电式传感器的工作原理" class="headerlink" title="光电式传感器的工作原理"></a><strong>光电式传感器的工作原理</strong></h4><ul><li><strong>光电式传感器也称为光电器件，是将光信号转换为电信号的一种装置。</strong></li><li>光敏电阻作为被广泛使用的光电器件，工作原理基于内光电效应，其核心器件为光电导体，由半导体制成。<ul><li>在室温条件下，没有光照射时，阻值变大，电流变弱，流过回路的电流称为暗电流；有光照射时，阻值变小，电流变强。</li><li>能产生光电效应的器件称为光电效应器件，常用的制作材料为硫化镉，另外还有硒、硫化铝、硫化铅和硫化铋等材料。</li></ul></li><li><strong>光电池，即太阳能电池，也是光电器件的一种，其物理基础是光生伏特效应，将光量转换为电动势，它能够接收不同强度的光照射，产生不同大小的电流。</strong></li><li><strong>光电检测方法具有精度高、响应快、非接触、结构简单、形式多样等优点，因此在自动控制系统中得到了广泛应用。</strong></li></ul><h3 id="MEMS-传感器"><a href="#MEMS-传感器" class="headerlink" title="MEMS 传感器"></a><strong>MEMS</strong> 传感器</h3><p> <strong>（MEMS：微机电系统）</strong></p><p>•<strong>MEMS</strong> <strong>全称为</strong> <strong>Microelectro Mechanical Systems，中文名称为微机电系统，是利用微纳加工技术将机械零件、电子电路、传感与执行机构高度集成的高附加值半导体器件。</strong></p><p>•<strong>利用</strong> <strong>MEMS</strong> <strong>技术构建的器件具有体积小、重量轻、功耗低、集成度高、易于使用等特点，适于大批量生产，广泛应用于汽车、消费电子、工业、医疗、国防、航空航天等领域。</strong></p><p>•<strong>常见的产品包括</strong> <strong>MEMS</strong> <strong>加速度计、MEMS</strong> <strong>麦克风、微马达、微泵、微振子、MEMS</strong> <strong>光学传感器、MEMS</strong> <strong>压力传感器、MEMS陀螺仪、MEMS</strong> <strong>气体传感器等等，以及它们的集成产品。</strong></p><p>•<strong>MEMS技术的目标是通过系统的微型化、集成化、智能化来探索具有新原理、新功能的元件和系统。</strong></p><h4 id="MEMS-概况"><a href="#MEMS-概况" class="headerlink" title="MEMS 概况"></a><strong>MEMS</strong> <strong>概况</strong></h4><p><strong>微机电系统（MEMS, Micro-Electro-Mechanical System），也叫做微电子机械系统、微系统、微机械等，指尺寸在几毫米乃至更小的高科技装置。</strong></p><p><strong>微机电系统其内部结构一般在微米甚至纳米量级，是一个独立的智能系统。</strong> </p><p><strong>微机电系统是在微电子技术（半导体制造技术）基础上发展起来的，融合了光刻、腐蚀、薄膜、LIGA、硅微加工、非硅微加工和精密机械加工等技术制作的高科技电子机械器件。</strong></p><p><strong>微机电系统是集微传感器、微执行器、微机械结构、微电源微能源、信号处理和控制电路、高性能电子集成器件、接口、通信等于一体的微型器件或系统。MEMS是一项革命性的新技术，广泛应用于高新技术产业，是一项关系到国家的科技发展、经济繁荣和国防安全的关键技术。</strong> </p><p><strong>MEMS侧重于超精密机械加工，涉及微电子、材料、力学、化学、机械学诸多学科领域。它的学科面涵盖微尺度下的力、电、光、磁、声、表面等物理、化学、机械学的各分支。</strong> </p><h4 id="MEMS-主要研究方面"><a href="#MEMS-主要研究方面" class="headerlink" title="MEMS 主要研究方面"></a><strong>MEMS</strong> <strong>主要研究方面</strong></h4><p><strong>MEMS技术是一种典型的多学科交叉的前沿性研究领域，几乎涉及到自然及工程科学的所有领域，如电子技术、机械技术、物理学、化学、生物医学、材料科学、能源科学等。其研究内容一般可以归纳为以下三个基本方面：</strong><br> <strong>1．理论基础： 在当前MEMS所能达到的尺度下，宏观世界基本的物理规律仍然起作用，但由于尺寸缩小带来的影响（Scaling Effects），许多物理现象与宏观世界有很大区别，因此许多原来的理论基础都会发生变化，如力的尺寸效应、微结构的表面效应、微观摩擦机理等，因此有必要对微动力学、微流体力学、微热力学、微摩擦学、微光学和微结构学进行深入的研究。这一方面的研究虽然受到重视，但难度较大，往往需要多学科的学者进行基础研究。</strong></p><p><strong>2．技术基础研究：主要包括微机械设计、微机械材料、微细加工、微装配与封装、集成技术、微测量等技术基础研究。</strong></p><p><strong>3．微机械在各学科领域的应用研究。</strong></p><h4 id="MEMS主要应用分类"><a href="#MEMS主要应用分类" class="headerlink" title="MEMS主要应用分类"></a>MEMS主要应用分类</h4><p><strong>传感</strong>： 传感 MEMS 技术是指用微电子微机械加工出来的、用敏感元件如电容、压电、压阻、热电耦、谐振、隧道电流等来感受转换电信号的器件和系统。它包括速度、压力、湿度、加速度、气体、磁、光、声、生物、化学等各种传感器，按种类分主要有：面阵触觉传感器、谐振力敏感传感器、微型加速度传感器、真空微电子传感器等。传感器的发展方向是阵列化、集成化、智能化。由于传感器是人类探索自然界的触角，是各种自动化装置的神经元，且应用领域广泛，未来将备受世界各国的重视。</p><p><strong>生物</strong>： 生物 MEMS 技术是用 MEMS 技术制造的化学&#x2F;生物微型分析和检测芯片或仪器，有一种在衬底上制造出的微型驱动泵、微控制阀、通道网络、样品处理器、混合池、计量、增扩器、反应器、分离器以及检测器等元器件并集成为多功能芯片。可以实现样品的进样、稀释、加试剂、混合、增扩、反应、分离、检测和后处理等分析全过程。它把传统的分析实验室功能微缩在一个芯片上。生物 MEMS 系统具有微型化、集成化、智能化、成本低的特点。功能上有获取信息量大、分析效率高、系统与外部连接少、实时通信、连续检测的特点。国际上生物 MEMS 的研究已成为热点，不久将为生物、化学分析系统带来一场重大的革新。</p><p><strong>光学</strong>：随着信息技术、光通信技术的迅猛发展，MEMS 发展的又一领域是与光学相结合，即综合微电子、微机械、光电子技术等基础技术，开发新型光器件，称为微光机电系统 (MOEMS)。它能把各种 MEMS 结构件与微光学器件、光波导器件、半导体激光器件、光电检测器件等完整地集成在一起。形成一种全新的功能系统。MOEMS 具有体积小、成本低、可批量生产、可精确驱动和控制等特点。较成功的应用研究：</p><p> 一是基于 MOEMS 的新型显示、投影设备，主要研究如何通过反射面的物理运动来进行光的空间调制，典型代表为数字微镜阵列芯片和光栅光阀。</p><p>二是通信系统，主要研究通过微镜的物理运动来控制光路发生预期的改变，较成功的有光开关调制器、光滤波器及复用器等光通信器件。</p><p><strong>射频</strong>：射频 MEMS 技术传统上分为固定的和可动的两类。固定的 MEMS 器件包括本体微机械加工传输线、滤波器和耦合器，可动的 MEMS 器件包括开关、调谐器和可变电容。按技术层面又分为由微机械开关、可变电容器和电感谐振器组成的基本器件层面；由移相器、滤波器和 VCO 等组成的组件层面；由单片接收机、变波束雷达、相控阵雷达天线组成的应用系统层面。</p><h4 id="MEMS-加速度计"><a href="#MEMS-加速度计" class="headerlink" title="MEMS 加速度计"></a><strong>MEMS</strong> <strong>加速度计</strong></h4><p>ADXL203是完整的高精度、低功耗、单轴&#x2F;双轴加速度计，提供经过信号调理的电压输出，所有功能（MEMS &amp; IC）均集成于一个单芯片中。这些器件的满量程加速度测量范围为±1.7 g，既可以测量动态加速度（例如振动），也可以测量静态加速度（例如重力）。</p><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-3-%E4%BC%A0%E6%84%9F%E5%99%A8/image-20231030203302148.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="图： ADXL203（单片集成了MEMS与IC）"></p><p>  <strong>加速度传感器是最早广泛应用的</strong> <strong>MEMS</strong> <strong>之一。MEMS</strong> <strong>作为一个机械结构为主的技术，可以通过设计使一个部件（图中橙色部件）相对底座</strong> <strong>substrate</strong> <strong>产生位移（这也是绝大部分</strong> <strong>MEMS</strong> <strong>的工作原理），这个部件称为质量块（proof mass）。质量块通过锚</strong> <strong>anchor，铰链</strong> <strong>hinge，或弹簧</strong> <strong>spring与底座连接。绿色部分固定在底座。当感应到加速度时，质量块相对底座产生位移。通过一些换能技术可以将位移转换为电能，如果采用电容式传感结构（电容的大小受到两极板重叠面积或间距影响），电容大小的变化可以产生电流信号供其信号处理单元采样。通过梳齿结构可以极大地扩大传感面积，提高测量精度，降低信号处理难度。加速度计还可以通过压阻式、力平衡式和谐振式等方式实现。</strong></p><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-3-%E4%BC%A0%E6%84%9F%E5%99%A8/image-20231030203335697.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="ex"></p><h4 id="NEMS（Nanoelectromechanical-systems，纳机电系统）"><a href="#NEMS（Nanoelectromechanical-systems，纳机电系统）" class="headerlink" title="NEMS（Nanoelectromechanical systems，纳机电系统）"></a><strong>NEMS（Nanoelectromechanical systems，纳机电系统）</strong></h4><p>   首个 NEMS 器件由 IBM 在2000年展示。器件为一个 32×32的二维悬臂梁（2D cantilever array）。该器件采用表面微加工技术加工而成。该器件设计用来进行超高密度，快速数据存储，基于热机械读写技术（thermomechanical writing and readout），高聚物薄膜作为存储介质。该数据存储技术来源于AFM (原子力显微镜) 技术，相比磁存储技术，基于AFM的存储技术具有更大潜力。</p><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-3-%E4%BC%A0%E6%84%9F%E5%99%A8/image-20231030203836796.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="1"></p><h4 id="S-PPA-仿生水凝胶压力传感器"><a href="#S-PPA-仿生水凝胶压力传感器" class="headerlink" title="S-PPA 仿生水凝胶压力传感器"></a><strong>S-PPA</strong> <strong>仿生水凝胶压力传感器</strong></h4><p><strong>2023年，东北大学田野课题组受芦荟的启发，成功地制备一种特殊结构的水凝胶（名为皮肤-聚乙烯醇-聚苯胺-AgNWs，S-PPA）。相关研究成果发表在</strong> <strong>Advanced Functional Materials</strong> <strong>期刊。</strong></p><p><strong>S-PPA水凝胶具有很强的抗损伤能力（拉伸强度为5 MPa，是无皮肤水凝胶的11倍），具有双重电导率（内皮肤为0.8 S&#x2F;m，外皮肤为0.33 S&#x2F;m），具有保水能力、抗菌性能（对金黄色葡萄球菌的抑制率为89.4%）和对金属电极的最小腐蚀。</strong></p><p><strong>S-PPA水凝胶不仅具有优异的抗损伤性，而且还表现出高压缩性能。并且可以在多个加载循环中保持稳定的性能，而不会出现明显的变形或损坏。</strong></p><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-3-%E4%BC%A0%E6%84%9F%E5%99%A8/image-20231030203859300.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="1"></p><p><strong>S-PPA 水凝胶表现出高压缩性和可变形性，内部微观结构在施加压力时发生变化，导致电荷传输路径和阻抗发生变化，这些变化可以通过电气测量来测量和量化，从而实现压力信号的传感和测量。</strong></p><p><strong>具有良好的压敏稳定性，能够抵抗多次压缩的疲劳影响，表现出更高的压力灵敏度。</strong></p><p><strong>可用于评估肌肉力量、控制力和耐力。</strong></p><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-3-%E4%BC%A0%E6%84%9F%E5%99%A8/image-20231030203918572.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="2"></p><h4 id="基于-PMUT-的液体密度测量传感器"><a href="#基于-PMUT-的液体密度测量传感器" class="headerlink" title="基于 PMUT 的液体密度测量传感器"></a><strong>基于</strong> <strong>PMUT</strong> <strong>的液体密度测量传感器</strong></h4><ul><li><strong>2023年，中国科学院苏州纳米技术与纳米仿生研究所轻量化实验室、长春理工大学合作，开发了一种基于压电式微机械超声换能器（PMUT）的液体密度测量传感器。</strong></li><li><strong>解决当前传统密度测量装置体积大、功耗高、不易在线测量的问题，</strong></li><li><strong>由两个</strong> <strong>PMUT（半径</strong> <strong>500 μm，空气中的谐振频率</strong> <strong>136 kHz）组成，作为发射、接收端。</strong></li><li><strong>基于虚拟质量增加效应，即当一个机械结构在不同密度的介质中振动时，其固有频率会发生不同程度的变化。介质密度越大，机械结构的谐振频率变化越大。</strong></li><li><strong>通过对该传感器在不同密度介质中所产生的时域信号与频域信号的分析，得出液体密度与PMUT谐振频率的关系，可应用于微型化可在线测量液体密度传感器。</strong></li></ul><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-3-%E4%BC%A0%E6%84%9F%E5%99%A8/image-20231030203944904.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="1"></p><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-3-%E4%BC%A0%E6%84%9F%E5%99%A8/image-20231030203950595.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="2"></p><h4 id="微流控技术"><a href="#微流控技术" class="headerlink" title="微流控技术"></a><strong>微流控技术</strong></h4><p><strong>微流控（Microfluidics）指的是使用微管道（尺寸为数十到数百微米）处理或操纵微小流体（纳升到阿升）的系统所涉及的科学和技术，是一门涉及化学、流体物理、微电子、新材料、生物学和生物医学工程的新兴交叉学科。</strong></p><p><strong>微流控的重要特征之一是微尺度环境下具有独特的流体性质，如层流和液滴等。借助这些独特的流体现象，微流控可以实现一系列常规方法所难以完成的微加工和微操作。</strong></p><p><strong>过去十年，通过将最多达数千个阀门和泵集成到单个芯片平台上，实现高度多路复用的自动化复杂性液滴控制系统的研究爆炸式增长。</strong></p><p><strong>传统的方法大多使用串行控制来处理单个液滴，不能高效和稳定地控制微流体的存储路径或运动方位。其次，作为流体逻辑元件的微阀，通常需要通过施加包括外部压力、加热、电场或磁场来实现功能。在此背景下，缩小阀门及其驱动系统非常困难，对制造工艺提出了巨大的挑战。</strong></p><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-3-%E4%BC%A0%E6%84%9F%E5%99%A8/image-20231030204216577.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="总让我想起水冷头一类的东西"></p><p><strong>离心微流控系统：多进程控制的实现</strong></p><p><strong>依靠偏转角和偏转速度实现多进程</strong></p><p><strong>可变位姿微流控芯片在工作过程中能不断进行顺时针和逆时针的偏转，类似于提供时钟信号；离心力与电源十分相似同样为系统提供动力。</strong></p><p><strong>研究团队从逻辑电路角度去构思芯片设计，称之为逻辑水路。通过对偏转脉冲的控制，研究团队实现了逻辑液滴的加法器。证明在离心微流控平台实现液滴逻辑控制的可行性。</strong></p><p><strong>构建了一种由逻辑开关单元组成的液体混合器，ABCD端口代表四种携带生物信息的液体输入，其能排列组合合成所有混合产物，共计16种组合方式。能快速实现对生物信息的匹配，可应用于核酸大规模自动筛查。</strong></p><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-3-%E4%BC%A0%E6%84%9F%E5%99%A8/image-20231030204258688.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="1"></p><h4 id="中国首款商用可重构5G射频芯片“破风”"><a href="#中国首款商用可重构5G射频芯片“破风”" class="headerlink" title="中国首款商用可重构5G射频芯片“破风”"></a><strong>中国首款商用可重构5G射频芯片“破风”</strong></h4><p><strong>2023年8月30日，中国移动核心自主创新成果“破风8676” 可重构5G射频收发芯片首次亮相。</strong></p><p><strong>射频收发芯片是无线电波和数字信号之间的转换器，是</strong> <strong>5G</strong> <strong>网络设备中的关键器件，被称为</strong> <strong>5G</strong> <strong>基站上的“明珠”。</strong></p><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-3-%E4%BC%A0%E6%84%9F%E5%99%A8/image-20231030204322058.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="明珠+1"></p><p><strong>国内首款基于可重构架构设计，可广泛商业应用于</strong> <strong>5G</strong> <strong>云基站、皮基站、家庭基站等</strong> <strong>5G</strong> <strong>网络核心设备中的关键芯片，实现从零到一的关键性突破，填补了该领域的国内空白，有效提升了我国</strong> <strong>5G</strong> <strong>网络核心设备的自主可控度。</strong></p><h4 id="移动式高效率超导单光子探测系统"><a href="#移动式高效率超导单光子探测系统" class="headerlink" title="移动式高效率超导单光子探测系统"></a><strong>移动式高效率超导单光子探测系统</strong></h4><p><strong>2023年，中国科学院上海微系统所李浩、尤立星团队和赋同量子科技（浙江）有限公司合作，成功研制了基于小型液氦杜瓦（工作温度4.2K）、在1550nm波段系统探测效率超过70%的移动式超导单光子探测系统。</strong></p><p><strong>为未来开展基于移动平台（机载、车载等）的高性能单光子探应用铺平了道路。获得</strong> <strong>2023年上海工业博览会金奖。</strong></p><p><strong>超导条带光子探测器（SSPD：Superconducting strip photon detector）作为高性能的单光子探测器，广泛地应用于量子信息和弱光探测等领域。</strong></p><p><strong>迄今为止，高效率的</strong> <strong>SSPD</strong> <strong>系统通常需要使用</strong> <strong>GM</strong> <strong>制冷机</strong> <strong>(T≤2.5 K)、吸附式制冷机</strong> <strong>(T≤0.85 K)甚至更低温度的制冷机，这些系统的质量、体积、功耗等成为了限制</strong> <strong>SSPD</strong> <strong>在机载等移动平台应用的关键原因。</strong></p><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-3-%E4%BC%A0%E6%84%9F%E5%99%A8/image-20231030204410466.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="IF"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;第二章-物联网感知识别&quot;&gt;&lt;a href=&quot;#第二章-物联网感知识别&quot; class=&quot;headerlink&quot; title=&quot;第二章 物联网感知识别&quot;&gt;&lt;/a&gt;&lt;strong&gt;第二章 物联网感知识别&lt;/strong&gt;&lt;/h1&gt;&lt;h2 id=&quot;2-3-传感器技术&quot;&gt;&lt;</summary>
      
    
    
    
    <category term="学习资料" scheme="https://www.emokable.top/categories/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/"/>
    
    
    <category term="课件笔记" scheme="https://www.emokable.top/tags/%E8%AF%BE%E4%BB%B6%E7%AC%94%E8%AE%B0/"/>
    
    <category term="物联网技术与应用" scheme="https://www.emokable.top/tags/%E7%89%A9%E8%81%94%E7%BD%91%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%BA%94%E7%94%A8/"/>
    
    <category term="IoT" scheme="https://www.emokable.top/tags/IoT/"/>
    
  </entry>
  
  <entry>
    <title>正则化直接构造DFA思路</title>
    <link href="https://www.emokable.top/%E6%AD%A3%E5%88%99%E5%8C%96%E7%9B%B4%E6%8E%A5%E6%9E%84%E9%80%A0DFA%E6%80%9D%E8%B7%AF/"/>
    <id>https://www.emokable.top/%E6%AD%A3%E5%88%99%E5%8C%96%E7%9B%B4%E6%8E%A5%E6%9E%84%E9%80%A0DFA%E6%80%9D%E8%B7%AF/</id>
    <published>2023-10-25T08:18:11.000Z</published>
    <updated>2023-10-25T08:19:51.740Z</updated>
    
    <content type="html"><![CDATA[<p>关于正则化直接构造法DFA的记录：</p><p>①构造firstpos，lastpos，nullable，followpos</p><p>②节点类型：|（或），*（闭包），·（连接）</p><p>③语法树：添加’#‘号作为接收状态标志</p><p>④最小化DFA</p><p><img src="/%E6%AD%A3%E5%88%99%E5%8C%96%E7%9B%B4%E6%8E%A5%E6%9E%84%E9%80%A0DFA%E6%80%9D%E8%B7%AF/image-20231018232957777.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="图"></p><p>最简单的nullable，如果空字符串是由以n为根的子表达式生成的字符串的成员，则为true。看节点是否可能为空：比如ɛ，*节点以及对应的组合</p><p>firstpos，定义了以结点n为根的子树中的位置集合。这些位置对应于以结点n为根推导出的某个句子的第一个符号：大多数情况都i是叶子前结点的并。在连接的情况下，如果前结点不为空就只有前结点，否则也是并</p><p>lastpos，和firstpos的前后节点情况对调</p><p>followpos：</p><ul><li><p>当n是一个连接结点，且其左右子树分别为c1、c2，那么对于lastpos(c1)中的所有位置i，firstpos(c2)中的所有位置都在followpos(i)中。  </p><p>​followpos（lastpos（c1））&#x3D;firstpos（c2）</p></li><li><p>当n是一个星结点，且i是lastpos(n)中的一个位置，那么firstpos(n)中的所有位置都在followpos(i)中。</p></li><li><p>followpos(lastpos（i）)&#x3D;firstpos（i）</p></li></ul><p>盯准两种结点，从下往上扫一遍并记录</p><p>最小化DFA：</p><p>第一步，写出firstpos(root)&#x3D;{1,2,3}&#x3D;A意思就是根节点的firstpos用来构建第一个状态（怎么找？别被迷惑，就是语法树顶的左边的几个数字）</p><p>第二步，A闭包，接a，b等东西(例如接a，那么就并上A中为a标号的followpos)。。。。和</p><p>具体可看：<a href="https://blog.nowcoder.net/n/a9bd25e694e547189bc691824ebc0d50">https://blog.nowcoder.net/n/a9bd25e694e547189bc691824ebc0d50</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;关于正则化直接构造法DFA的记录：&lt;/p&gt;
&lt;p&gt;①构造firstpos，lastpos，nullable，followpos&lt;/p&gt;
&lt;p&gt;②节点类型：|（或），*（闭包），·（连接）&lt;/p&gt;
&lt;p&gt;③语法树：添加’#‘号作为接收状态标志&lt;/p&gt;
&lt;p&gt;④最小化DFA&lt;/</summary>
      
    
    
    
    <category term="笔记" scheme="https://www.emokable.top/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="笔记" scheme="https://www.emokable.top/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="编译原理" scheme="https://www.emokable.top/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>第1.1章-机器学习基础</title>
    <link href="https://www.emokable.top/%E7%AC%AC1-1%E7%AB%A0-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/"/>
    <id>https://www.emokable.top/%E7%AC%AC1-1%E7%AB%A0-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/</id>
    <published>2023-09-24T11:48:45.000Z</published>
    <updated>2023-09-24T16:31:57.798Z</updated>
    
    <content type="html"><![CDATA[<h1 id="机器学习基础（见PDF栏）"><a href="#机器学习基础（见PDF栏）" class="headerlink" title="机器学习基础（见PDF栏）"></a>机器学习基础（见PDF栏）</h1><p>突然发现老师给的ppt全是图片。。。实际上就是用pdf转的</p><p>于是参考了这篇博客<a href="https://blog.csdn.net/m0_59464010/article/details/123361053?spm=1001.2101.3001.6661.1&utm_medium=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~Rate-1-123361053-blog-104574959.235%5Ev38%5Epc_relevant_sort_base2&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~Rate-1-123361053-blog-104574959.235%5Ev38%5Epc_relevant_sort_base2&utm_relevant_index=1">如何在hexo博客中在线阅读pdf</a></p><p>点击PDF就可以阅读了</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;机器学习基础（见PDF栏）&quot;&gt;&lt;a href=&quot;#机器学习基础（见PDF栏）&quot; class=&quot;headerlink&quot; title=&quot;机器学习基础（见PDF栏）&quot;&gt;&lt;/a&gt;机器学习基础（见PDF栏）&lt;/h1&gt;&lt;p&gt;突然发现老师给的ppt全是图片。。。实际上就是用pd</summary>
      
    
    
    
    <category term="学习资料" scheme="https://www.emokable.top/categories/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/"/>
    
    
    <category term="机器学习" scheme="https://www.emokable.top/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="PDF" scheme="https://www.emokable.top/tags/PDF/"/>
    
  </entry>
  
  <entry>
    <title>IoT__第2章__感知识别__2.2_RFID</title>
    <link href="https://www.emokable.top/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-2-RFID/"/>
    <id>https://www.emokable.top/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-2-RFID/</id>
    <published>2023-09-24T11:48:29.000Z</published>
    <updated>2023-09-24T12:45:18.841Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第二章-物联网感知识别"><a href="#第二章-物联网感知识别" class="headerlink" title="第二章 物联网感知识别"></a><strong>第二章 物联网感知识别</strong></h1><h2 id="2-2-RFID"><a href="#2-2-RFID" class="headerlink" title="2.2 RFID"></a><strong>2.2</strong> <strong>RFID</strong></h2><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-2-RFID/image-20230924195032140.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="RFID"></p><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-2-RFID/image-20230924195042841.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="process"></p><p>RFID是射频识别技术（Radio Frequency Identification）的英文缩写，利用射频信号通过空间耦合（交变磁场或电磁场）实现无接触信息传递并通过所传递的信息达到识别目的。</p><p>它是上世纪90年代兴起的自动识别技术，首先在欧洲市场上得以使用，随后在世界范围内普及。</p><p>RFID较其它技术明显的优点是电子标签和阅读器无需接触便可完成识别。射频识别技术改变了条形码依靠“有形”的一维或二维几何图案来提供信息的方式，通过芯片来提供存储在其中的数量巨大的“无形”信息。</p><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-2-RFID/image-20230924195124630.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="some logos"></p><h3 id="RFID-系统组成"><a href="#RFID-系统组成" class="headerlink" title="RFID 系统组成"></a><strong>RFID</strong> <strong>系统组成</strong></h3><p>RFID系统主要由电子标签、阅读器、中间件和位于后台的中央信息系统组成 </p><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-2-RFID/image-20230924195203568.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="RFID系统组成框图"></p><h3 id="RFID系统工作原理"><a href="#RFID系统工作原理" class="headerlink" title="RFID系统工作原理"></a><strong>RFID系统工作原理</strong></h3><p>RFID系统工作原理</p><p>标签进入磁场后，只要接收到阅读器发出的射频信号，就能产生感应电流获得能量，然后发送出存储在芯片中的信息，或者是主动发送信号（限于有源标签），阅读器读取标签信息，进行解码后送至后台的中央信息系统进行数据处理。</p><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-2-RFID/image-20230924195236669.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="扫描"></p><p>RFID 的两种耦合方式：电感耦合、电磁反向散射耦合</p><p>电子标签与阅读器之间通过耦合元件实现射频信号的非接触的空间耦合，从而根据时序关系，实现能量、数据的交换</p><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-2-RFID/image-20230924195307181.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="2-ways"></p><h3 id="RFID-设备基本组件"><a href="#RFID-设备基本组件" class="headerlink" title="RFID 设备基本组件"></a><strong>RFID</strong> <strong>设备基本组件</strong></h3><p>RFID 设备的基本组件构成</p><ul><li>阅读器 (Reader)</li><li>天线 (Antenna)</li><li>标签 (Tag)</li></ul><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-2-RFID/image-20230924195432353.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="basic parts"></p><h4 id="RFID-组件：阅读器"><a href="#RFID-组件：阅读器" class="headerlink" title="RFID 组件：阅读器"></a><strong>RFID</strong> <strong>组件：阅读器</strong></h4><p>阅读器：读取或读写电子标签信息的设备。主要任务是控制射频模块向标签发射信号，并接收标签的应答，对标签的对象识别信息及其它信息进行解码，传输到后台主机以供处理。</p><p>因其工作模式一般是主动向标签询问标识信息，所以又被称为询问器（Interrogator）。</p><p>固定式阅读器通过有线接口、手持式阅读器通过无线接口，同后台主机相连。</p><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-2-RFID/image-20230924195527917.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="reader"></p><h4 id="RFID-组件：天线"><a href="#RFID-组件：天线" class="headerlink" title="RFID 组件：天线"></a><strong>RFID</strong> <strong>组件：天线</strong></h4><p>天线：在标签和阅读器之间传递射频信号。阅读器可以连接一个或多个天线。</p><p>RFID系统的工作频率从低频到微波，这使得天线与标签芯片之间的匹配问题变得很复杂。</p><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-2-RFID/image-20230924195558007.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="天线"></p><h4 id="RFID-组件：标签"><a href="#RFID-组件：标签" class="headerlink" title="RFID 组件：标签"></a><strong>RFID</strong> <strong>组件：标签</strong></h4><p>标签（Tag）：由微型天线、耦合元件、芯片组成。芯片内保存有一定格式的电子数据，每个标签内部存有唯一的电子编码，作为标识性信息的数据载体，可附着在物体上用于标识目标对象。</p><p>标签进入 RFID 阅读器扫描场以后，接收到阅读器发出的射频信号，凭借感应电流获得的能量发送出存储在芯片中的电子编码（被动式标签），或者主动发送某一频率的信号（主动式标签）。</p><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-2-RFID/image-20230924195644611.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="tags"></p><h5 id="标签分类："><a href="#标签分类：" class="headerlink" title="标签分类："></a><strong>标签分类</strong>：</h5><ul><li>被动式标签（Passive Tag）：因内部没有电源设备又被称为无源标签。被动式标签内部的集成电路通过接收由阅读器发出的电磁波进行驱动，向阅读器发送数据。</li><li>主动标签（Active Tag）：因标签内部携带电源又被称为有源标签。主动式标签要比被动式标签体积大、价格昂贵。但主动标签通信距离更远，可达数十米。</li><li>半主动标签（Semi-active Tag）：兼有被动标签和主动标签的所有优点，内部携带电池，能够为标签内部计算提供电源。<ul><li>这种标签可以携带传感器，可用于检测环境参数，如温度、湿度、是否移动等。</li><li>然而与主动式标签不同的是它们的通信并不需要电池提供能量，而是像被动式标签一样通过阅读器发射的电磁波获取通信能量</li></ul></li></ul><h3 id="RFID技术分析：频率"><a href="#RFID技术分析：频率" class="headerlink" title="RFID技术分析：频率"></a><strong>RFID技术分析：频率</strong></h3><p>频率是RFID系统的一个很重要的参数，它决定了系统工作原理、通信距离、成本、天线形状和应用领域等因素。</p><p>RFID典型的工作频率有125KHz、133KHz、13.56MHz、27.12MHz、433MHz、860-960MHz、2.45GHz、5.8GHz等。按照工作频率的不同，RFID系统集中在低频、高频和超高频三个区域。</p><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-2-RFID/image-20230924195904377.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="f"></p><h4 id="标签分类：按-RFID-频率"><a href="#标签分类：按-RFID-频率" class="headerlink" title="标签分类：按 RFID 频率"></a><strong>标签分类：按</strong> <strong>RFID</strong> <strong>频率</strong></h4><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-2-RFID/image-20230924195927999.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="分类"></p><h4 id="阅读器及标签分类"><a href="#阅读器及标签分类" class="headerlink" title="阅读器及标签分类"></a><strong>阅读器及标签分类</strong></h4><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-2-RFID/image-20230924200008558.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="分类"></p><h3 id="阅读器操作规范"><a href="#阅读器操作规范" class="headerlink" title="阅读器操作规范"></a>阅读器操作规范</h3><p><strong>为保证阅读器的性能满足应用需求，在阅读器的使用过程中通常要遵循相应的操作规范。</strong></p><p><strong>在操作规范中，下面几点是选择使用阅读器时需要重点考虑的方面：</strong></p><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-2-RFID/image-20230924200047669.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="思维图"></p><h4 id="阅读器组成"><a href="#阅读器组成" class="headerlink" title="阅读器组成"></a>阅读器组成</h4><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-2-RFID/image-20230924200134811.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="reader"></p><h3 id="标签操作规范"><a href="#标签操作规范" class="headerlink" title="标签操作规范"></a>标签操作规范</h3><p><strong>与阅读器类似，在实际系统中，标签的操作规范也要考虑很多因素，下面几个是需要重点考虑的：</strong></p><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-2-RFID/image-20230924200216741.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="10"></p><h4 id="标签组成"><a href="#标签组成" class="headerlink" title="标签组成"></a>标签组成</h4><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-2-RFID/image-20230924200254153.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="标签"></p><h3 id="标签天线"><a href="#标签天线" class="headerlink" title="标签天线"></a>标签天线</h3><p><strong>天线是一种专门设计用来耦合、辐射电磁能量的导体结构。</strong></p><p><strong>通常标签天线尺寸越小，天线辐射阻抗越小，标签工作距离越短，工作效率越低。</strong></p><p><strong>天线性能包括方向特性、天线效率、天线增益等。</strong></p><p><strong>根据工作原理不同，可以将标签天线分为三类：</strong></p><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-2-RFID/image-20230924200325340.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="三类"></p><h3 id="标签芯片"><a href="#标签芯片" class="headerlink" title="标签芯片"></a>标签芯片</h3><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-2-RFID/image-20230924200410164.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="三"></p><p><strong>可分为：模拟前端、控制部件和存储部件</strong></p><p><strong>模拟前端：整流天线输入信号提供稳定电压、将天线输入检波得到数字信号、调制控制部件发送信号给天线发送、为控制模块提供时钟。</strong></p><p><strong>控制部件：数据解码、数据校验、数据编码、加密解密、防碰撞、读写控制。</strong></p><p><strong>存储部件：标签数据载体。</strong></p><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-2-RFID/image-20230924200401821.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="结构"></p><h3 id="标签制造"><a href="#标签制造" class="headerlink" title="标签制造"></a>标签制造</h3><p><strong>标签的制作工艺主要有：</strong></p><p><strong>线圈绕制法、化学蚀刻法和印刷法</strong></p><p><strong>制造过程分为：</strong></p><p><strong>天线制造和芯片组装</strong></p><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-2-RFID/image-20230924200448443.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="流程"></p><h4 id="声表面波电子标签结构"><a href="#声表面波电子标签结构" class="headerlink" title="声表面波电子标签结构"></a><strong>声表面波电子标签结构</strong></h4><p><strong>声表面波</strong></p><p>–<strong>Surface Acoustic Wave</strong></p><p>–<strong>SAW</strong></p><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-2-RFID/image-20230924200509030.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="结构"></p><h4 id="RFID-中间件"><a href="#RFID-中间件" class="headerlink" title="RFID 中间件"></a><strong>RFID</strong> <strong>中间件</strong></h4><p>RFID 中间件的主要功能</p><ul><li>对读写器或数据采集设备的管理、协同、控制</li><li>数据过滤与数据处理</li><li>事件数据报告生成与发送</li><li>访问安全控制</li><li>发布&#x2F;订阅模型</li><li>提供符合标准的接口、集中统一的管理界面</li><li>进程管理与负载均衡</li><li>数据路由与集成</li></ul><h4 id="RFID-标签的存储结构"><a href="#RFID-标签的存储结构" class="headerlink" title="RFID 标签的存储结构"></a><strong>RFID</strong> <strong>标签的存储结构</strong></h4><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-2-RFID/image-20230924200552864.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="EPC Class1 Generation 标签存储区示意图"></p><h4 id="RFID系统组件原理小结"><a href="#RFID系统组件原理小结" class="headerlink" title="RFID系统组件原理小结"></a><strong>RFID系统组件原理小结</strong></h4><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-2-RFID/image-20230924200610188.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="总结"></p><h3 id="EPCglobal-的-RFID-体系架构"><a href="#EPCglobal-的-RFID-体系架构" class="headerlink" title="EPCglobal 的 RFID 体系架构"></a>EPCglobal 的 RFID 体系架构</h3><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-2-RFID/image-20230924200647960.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="图"></p><h3 id="RFID标签与条形码相比的优点"><a href="#RFID标签与条形码相比的优点" class="headerlink" title="RFID标签与条形码相比的优点"></a><strong>RFID标签与条形码相比的优点</strong></h3><p><strong>体积小且形状多样：RFID标签在读取上并不受尺寸大小与形状限制，不需要为了读取精度而配合纸张的固定尺寸和印刷品质。</strong></p><p><strong>环境适应性：纸张容易被污染而影响识别。但RFID对水、油等物质却有极强的抗污性。另外，即使在黑暗的环境中，RFID标签也能够被读取。</strong></p><p><strong>可重复使用：标签具有读写功能，电子数据可被反复覆盖，因此可以被回收而重复使用。</strong></p><p><strong>穿透性强：标签在被纸张、木材和塑料等非金属或非透明的材质包裹的情况下也可以进行穿透性通讯。</strong></p><p><strong>数据安全性：标签内的数据通过循环冗余校验的方法来保证标签发送的数据准确性。</strong></p><h3 id="RFID和物联网"><a href="#RFID和物联网" class="headerlink" title="RFID和物联网"></a><strong>RFID和物联网</strong></h3><p>基于RFID标签对物体的唯一标识特性，引发了物联网初期的应用场景和热潮。</p><p>通过给物品贴上RFID标签，在现有互联网基础之上构建所有参与流通的物品信息网络。</p><p>通过RFID接入物联网，世界上任何物品都可以随时随地按需被标识、追踪和监控。</p><p>RFID和物联网的建立将对生产制造、销售、运输、使用、回收等物品流通的各个环节以及政府、企业和个人行为带来深刻影响。</p><h3 id="RFID的标签识别协议"><a href="#RFID的标签识别协议" class="headerlink" title="RFID的标签识别协议"></a><strong>RFID的标签识别协议</strong></h3><p><strong>RFID系统支持多目标识别，在多个阅读器和多个电子标签同时工作的情况下，会造成阅读器和电子标签之间的相互干扰，无法读取信息，这种现象称为冲突（或碰撞、干扰）。</strong></p><p><strong>RFID系统中，主要存在以下两种类型的信号干扰：</strong>标签冲突、阅读器冲突</p><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-2-RFID/image-20230924200758115.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="冲突"></p><p><strong>因此，需要降低阅读器之间以及标签之间的冲突来提高对标签的识别效率。</strong></p><h4 id="RFID系统的防冲突（防碰撞）技术"><a href="#RFID系统的防冲突（防碰撞）技术" class="headerlink" title="RFID系统的防冲突（防碰撞）技术"></a><strong>RFID系统的防冲突（防碰撞）技术</strong></h4><ul><li><strong>空分多址法</strong><ul><li><strong>按空间区域进行划分</strong><ul><li><strong>读写器和天线的作用距离</strong></li></ul></li><li><strong>相控阵天线</strong><ul><li><strong>天线的方向</strong></li></ul></li></ul></li><li><strong>频分多址法</strong><ul><li><strong>不同载波频率</strong><ul><li><strong>副载波</strong></li></ul></li></ul></li><li><strong>时分多址法</strong><ul><li><strong>ALOHA算法</strong></li><li><strong>基于二进制算法（确定性算法）</strong></li></ul></li></ul><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-2-RFID/image-20230924200937055.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="1"></p><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-2-RFID/image-20230924200941942.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="2"></p><p><strong>针对阅读器之间的冲突问题，存在一些典型的防冲突协议：</strong></p><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-2-RFID/image-20230924201001726.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="协议"></p><p><strong>与阅读器相比，标签受硬件资源限制，存储能力和计算能力很有限。这使得标签没有冲突检测功能，标签之间不能相互的通信，所有的冲突检测都需要借助于阅读器完成。从系统的复杂度以及成本方面考虑，TDMA</strong> <strong>可用于检测</strong> <strong>RFID</strong> <strong>标签之间的冲突。</strong></p><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-2-RFID/image-20230924201014569.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="算法"></p><h4 id="基于纯-ALOHA-的防冲突算法"><a href="#基于纯-ALOHA-的防冲突算法" class="headerlink" title="基于纯 ALOHA 的防冲突算法"></a><strong>基于纯</strong> <strong>ALOHA</strong> <strong>的防冲突算法</strong></h4><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-2-RFID/image-20230924201045878.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="aloha"></p><p><strong>算法简单，易于实现，但信道利用率仅为</strong> <strong>18.4%，性能差。</strong></p><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-2-RFID/image-20230924201104839.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="性能"></p><h4 id="基于时隙-ALOHA-的防冲突算法"><a href="#基于时隙-ALOHA-的防冲突算法" class="headerlink" title="基于时隙 ALOHA 的防冲突算法"></a><strong>基于时隙</strong> <strong>ALOHA</strong> <strong>的防冲突算法</strong></h4><p><strong>S-ALOHA</strong> <strong>算法将纯</strong> <strong>ALOHA</strong> <strong>的时间分为若干时隙，每个时隙大于或等于标签标识符发送的时间长度，并且每个标签只能在时隙开始时刻发送标识符。由于系统进行了时间同步，S‐ALOHA</strong> <strong>协议的信道利用率达到36.8%，是纯</strong> <strong>ALOHA</strong> <strong>的两倍。</strong></p><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-2-RFID/image-20230924201137601.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="性能"></p><h4 id="基于帧的时隙-ALOHA-FSA-防冲突算法"><a href="#基于帧的时隙-ALOHA-FSA-防冲突算法" class="headerlink" title="基于帧的时隙 ALOHA (FSA) 防冲突算法"></a><strong>基于帧的时隙</strong> <strong>ALOHA</strong> <strong>(FSA)</strong> <strong>防冲突算法</strong></h4><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-2-RFID/image-20230924201206242.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="帧"></p><p><strong>1、每一帧开始时，阅读器广播帧长度</strong> <strong>f（时隙个数），并激活所有标签。</strong></p><p><strong>各个标签在接收 f 以后随机在0 ~ ( f – 1 ) 中选择一个整数，作为其发送标识符的时隙序号 SN，并存于其寄存器内。</strong></p><p><strong>2、阅读器通过时隙开始命令启动一个新时隙。对每个标签而言：</strong></p><p><strong>如果 SN &#x3D; 0 则立即发送标识符；否则就不发送并且设 SN &#x3D; SN – 1 。</strong></p><p><strong>若标签发送成功即无冲突发生，则立即休眠即不再活动；否则，该标签进入等待，在下一帧中再选择一个时隙重新发送标识符。</strong></p><p><strong>3、重复此过程，直到阅读器在某一帧中没有收到标签信号，即标签均被识别</strong></p><p><strong>例：帧长</strong> <strong>f &#x3D; 3，每个标签产生</strong> <strong>0 ~ 2</strong> <strong>的随机数</strong></p><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-2-RFID/image-20230924201241930.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="例"></p><p><strong>冲突时隙：不止一个标签响应</strong>  <strong>（响应标签#</strong> <strong>&gt; 1）</strong></p><p><strong>单 时 隙：只有一个标签响应</strong>    <strong>（响应标签#</strong>  <strong>&#x3D; 1）</strong></p><p><strong>空 时 隙：没有标签响应</strong>           <strong>（响应标签#</strong>  <strong>&#x3D; 0）</strong></p><blockquote><p><strong>FSA</strong> <strong>算法的优点在于逻辑简单，电路设计简单，所需内存少，且在帧内只随机发送一次，这样能够更进一步降低了冲突的概率。</strong></p><p><strong>FSA</strong> <strong>成为</strong> <strong>RFID</strong> <strong>系统中最常用的一种基于</strong> <strong>ALOHA</strong> <strong>的防冲突算法</strong></p></blockquote><p><strong>FSA</strong> <strong>算法局限性：</strong></p><p>   <strong>帧的长度</strong> <strong>L</strong> <strong>固定（标签数</strong> <strong>n</strong> <strong>动态变化）</strong></p><ul><li><strong>当标签数远小于帧长度：时隙会巨大浪费，识别时间也会增加</strong></li><li><strong>当标签数远大于帧长度：标签冲突概率增大，识别标签的时间会极大地增加</strong></li><li><strong>当帧长度等于标签的数目（L &#x3D; n）时，FSA</strong> <strong>才能获得最佳的识别性能。</strong></li></ul><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-2-RFID/image-20230924201404261.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="性能计算"></p><h4 id="FSA-帧长调整-gt-Q-算法"><a href="#FSA-帧长调整-gt-Q-算法" class="headerlink" title="FSA + 帧长调整    -&gt;Q 算法"></a><strong>FSA +</strong> <strong>帧长调整</strong>    -&gt;<strong>Q</strong> <strong>算法</strong></h4><p><strong>实际中标签的数量是未知的，并且动态变化。</strong></p><p><strong>动态自适应设置帧长度的算法可以解决</strong> <strong>FSA</strong> <strong>的局限性。</strong></p><p><strong>常见的帧长调整方法：</strong></p><p><strong>方法一：根据前一帧通信获取的空时隙数目，发生碰撞的时隙数目、成功识别标签的时隙数目，来估计当前的标签数并设置下一帧的最优长度；</strong> <strong>（ISO&#x2F;IEC 18000-6</strong> <strong>中</strong> <strong>Type A</strong> <strong>标准）</strong></p><p><strong>方法二：根据前一时隙的反馈，动态调整帧长为</strong> <strong>2</strong> <strong>的整数倍，最具代表性的是</strong> <strong>EPCglobalGen2</strong> <strong>标准中的</strong> <strong>Q</strong> <strong>算法</strong> <strong>（ISO&#x2F;IEC 18000-6</strong> <strong>中</strong> <strong>Type C</strong> <strong>标准）</strong></p><ul><li><strong>当一个帧出现过多的冲突时隙时，阅读器会提前结束该帧，并重新启动一个更长的帧；</strong></li><li><strong>当一个帧出现过多的空闲时隙时，阅读器也会提前结束帧，并重新启动一个更短的帧</strong></li></ul><blockquote><p><strong>Q</strong> <strong>算法过程</strong>：</p><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-2-RFID/image-20230924202810104.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="图"></p><ul><li><strong>用</strong> <strong>Q</strong> <strong>值标记</strong> <strong>FSA</strong> <strong>中帧长</strong> <strong>2Q</strong> <strong>，Q</strong> <strong>值取值范围</strong> <strong>0 ~ 15，作为</strong> <strong>Query</strong> <strong>命令参数。</strong></li><li><strong>Qfp</strong> <strong>作为</strong> <strong>Q</strong> <strong>的浮点表示形式，初始值为</strong> <strong>4.0。</strong></li><li><strong>常量</strong> <strong>c</strong> <strong>是</strong> <strong>Q</strong> <strong>的浮动因子，取值为</strong> <strong>0.1 ~ 0.5。</strong></li><li><strong>reader</strong> <strong>广播帧长：</strong> <strong>帧开始命令Query</strong> <strong>中包含了</strong> <strong>Q值</strong> <strong>(帧长</strong> <strong>2Q</strong> <strong>)。</strong></li><li><strong>tag</strong> <strong>选时隙：非休眠的标签收到</strong> <strong>Query</strong> <strong>时，随机产生</strong> <strong>0 ~ 2Q-1</strong> <strong>并存入寄存器SN</strong> <strong>，每过一时隙减一。</strong></li><li><strong>当</strong> <strong>SN</strong> <strong>减至</strong> <strong>0</strong> <strong>则向阅读器回复。</strong></li><li><strong>reader</strong> <strong>根据前一个时隙的回复情况来更改</strong> <strong>Qfp</strong> <ul><li><strong>如没有标签回复：Qfp</strong> <strong>减去</strong> <strong>c</strong>  </li><li><strong>如多个标签回复：Qfp</strong> <strong>加上</strong> <strong>c</strong> </li><li><strong>如一个标签回复：Qfp</strong> <strong>不变</strong></li></ul></li><li><strong>根据</strong> <strong>Q &#x3D; round(Qfp)</strong> <strong>是否变化，决定是继续该帧还是重新开启新帧。</strong></li></ul><p><strong>Q</strong> <strong>算法自适应地调整帧长为</strong> <strong>2Q</strong> <strong>，识别效率高，该算法以及改进算法在超高频射频识别系统中得到广泛的应用。</strong></p></blockquote><h4 id="基于-ALOHA-算法的不足"><a href="#基于-ALOHA-算法的不足" class="headerlink" title="基于 ALOHA 算法的不足"></a><strong>基于</strong> <strong>ALOHA</strong> <strong>算法的不足</strong></h4><ul><li><h5 id="基于-ALOHA-的防冲突算法简单，并且兼顾了公平性。"><a href="#基于-ALOHA-的防冲突算法简单，并且兼顾了公平性。" class="headerlink" title="基于 ALOHA 的防冲突算法简单，并且兼顾了公平性。"></a><strong>基于</strong> <strong>ALOHA</strong> <strong>的防冲突算法简单，并且兼顾了公平性。</strong></h5></li><li><p><strong>但是，标签存在饿死的问题。当一个标签选择的时隙总是冲突时隙，则该标签可能永远无法被识别。</strong></p></li></ul><p><strong>确定性算法可解决上述问题。</strong></p><p><strong>基于确定性二进制的防冲突算法</strong></p><ul><li><strong>BSA</strong> <strong>二进制搜索算法、FBSA</strong> <strong>动态二进制搜索算法、基于查询二进制树</strong></li><li><strong>特点：</strong><ul><li><strong>无状态协议，标签只需要根据阅读器广播的标示符作比较，可用于无可写存储区的标签</strong></li><li><strong>不存在标签饿死</strong></li><li><strong>识别时延受标签ID分布及长度影响</strong></li></ul></li></ul><p><strong>基于随机二进制树的防冲突算法</strong></p><ul><li><strong>自适应</strong> <strong>B</strong> <strong>树算法</strong><ul><li><strong>状态协议，标签需要可写存储区</strong></li><li><strong>仍有可能存在标签饿死</strong></li><li><strong>识别时延受标签ID分布及长度影响</strong></li></ul></li></ul><h4 id="二进制搜索算法-BSA"><a href="#二进制搜索算法-BSA" class="headerlink" title="二进制搜索算法  BSA"></a><strong>二进制搜索算法</strong>  <strong>BSA</strong></h4><p><strong>算法原理</strong></p><ul><li><strong>标签</strong> <strong>SN：每个标签具有自身唯一的序号SN（假设序号长度一致）。</strong></li><li><strong>每一轮选择：阅读器多次向标签群发送命令，每次命令都会把标签群分成两组，多次分组，最后得到此轮唯一的一个标签。</strong></li><li><strong>对剩余的标签群继续上述操作。每轮选中一个标签，直至选完所有标签。</strong></li></ul><p><strong>算法基本命令</strong></p><ul><li><strong>请求</strong> <strong>Request (SN)：携带一个参数</strong> <strong>SN，当标签收到该命令时，将自身的</strong> <strong>SN</strong> <strong>与收到的</strong> <strong>SN</strong> <strong>对比，若自身</strong> <strong>SN</strong> <strong>小于或等于收到的</strong> <strong>SN，则向阅读器回复标签SN。</strong></li><li><strong>休眠</strong> <strong>Sleep (SN)：携带一个参数</strong> <strong>SN，若标签自身的</strong> <strong>SN</strong> <strong>与收到的</strong> <strong>SN</strong> <strong>相等，则被阅读器选中，完成数据传送后，进入休眠状态。</strong></li></ul><h5 id="BSA-算法步骤："><a href="#BSA-算法步骤：" class="headerlink" title="BSA 算法步骤："></a><strong>BSA</strong> <strong>算法步骤</strong>：</h5><p><strong>阅读器发出请求序列号</strong> <strong>SN，属于</strong> <strong>{ tag |</strong> <strong>SNtag</strong> <strong>&lt;&#x3D; SN}</strong> <strong>的标签回复自身序列号</strong></p><p>1.<strong>阅读器第一次发送请求Request命令；参数设为最大序列号（11 … 11），因此所有标签向阅读器回复自身。</strong></p><p>2.<strong>当存在两个以上的标签同时回复阅读器时，必然发生碰撞，设这些标签序列号出现不一致的最高位为</strong> <strong>C（碰撞位），阅读器更新自身序列号：第</strong> <strong>C</strong> <strong>位置0，高于该位的置为这些标签序列号相同的前</strong> <strong>C - 1</strong> <strong>位，低于该位的置</strong> <strong>1。阅读器发送Request命令，参数采用新序列号。</strong></p><p>3.<strong>标签接收到新一轮的请求序列号， 只有序列号小于或等于此序列号的标签，才向阅读器回复自身序列号。</strong></p><p>4.<strong>循环执行</strong> <strong>2 - 3，依次排除序列号较大的标签，选出一个序列号最小的标签；阅读器与此标签通信，结束后发送休眠</strong> <strong>Sleep</strong> <strong>命令使其休眠，即对阅读器发送的请求命令不进行响应。</strong></p><p><strong>重复上述过程，可以按照序列号从小到大的次序，完成所有标签的识别和读取。</strong></p><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-2-RFID/image-20230924203147938.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="BAS"></p><h4 id="动态二进制搜索算法-FBSA"><a href="#动态二进制搜索算法-FBSA" class="headerlink" title="动态二进制搜索算法 FBSA"></a><strong>动态二进制搜索算法</strong> <strong>FBSA</strong></h4><p>传统二进制搜索算法，每次传输的数据是全部长度的序列号，造成了识别所需时间和所消耗功率的浪费。</p><p>动态二进制树搜索算法FBSA，其改进思路是把数据分成两部分，阅读器和标签双方各自传送其中的一部分数据，阅读器只发送前面一致部分，标签只发送其余的比特位（阅读传送部分+ 标签传送部分&#x3D;** 序列号总长度）。因此总的传输量减小一半，缩短防碰撞执行时间</p><p>FBSA的主要命令和传统BSA算法一样，只是传输策略上有所不同。</p><h5 id="FBSA-算法步骤"><a href="#FBSA-算法步骤" class="headerlink" title="FBSA 算法步骤"></a><strong>FBSA</strong> <strong>算法步骤</strong></h5><p>1.<strong>阅读器第一次发送请求</strong> <strong>Request</strong> <strong>命令；参数设为最大序列号（11 … 11），所有标签回复其自身的序列号。</strong></p><p>2.<strong>阅读器检测到碰撞位，将最高碰撞位（C）置</strong> <strong>0。阅读器发送Request命令，只传输</strong> <strong>C</strong> <strong>~</strong> <strong>N</strong> <strong>的位作为下一次的请求序列号。</strong></p><p>3.<strong>标签接收到新一轮的请求序列号，只有序列号与</strong> <strong>C</strong> <strong>~</strong> <strong>N</strong> <strong>位相同（序列号 ≤ 请求序列号）的标签，才会把其剩余的序列号（1</strong> <strong>~</strong> <strong>C-1）回复给阅读器。</strong></p><p>4.<strong>循环执行</strong> <strong>2 - 3，选出一个序列号最小的标签；阅读器与此标签通信，结束后发送休眠</strong> <strong>Sleep</strong> <strong>命令使其休眠，即对阅读器发送的请求命令不进行响应。</strong></p><p>5.<strong>重复上述过程，可以按照序列号从小到大的次序，完成所有标签的识别和读取。</strong></p><h5 id="图例：-BSA-算法及-FBSA算法"><a href="#图例：-BSA-算法及-FBSA算法" class="headerlink" title="图例： BSA 算法及 FBSA算法"></a><strong>图例：</strong> <strong>BSA</strong> <strong>算法及</strong> <strong>FBSA算法</strong></h5><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-2-RFID/image-20230924203234633.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="TU"></p><h4 id="基于随机二进制树的防冲突算法"><a href="#基于随机二进制树的防冲突算法" class="headerlink" title="基于随机二进制树的防冲突算法"></a><strong>基于随机二进制树的防冲突算法</strong></h4><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-2-RFID/image-20230924203414081.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="TU"></p><ul><li><strong>基于</strong> <strong>B</strong> <strong>树算法</strong> <strong>（ISO&#x2F;IEC 18000-6</strong> <strong>中</strong> <strong>Type B</strong> <strong>标准）</strong></li><li><strong>需要每个标签维持一个计数器（初始值为</strong> <strong>0）。</strong></li><li><strong>标签在每一个时隙开始时，检查计数器值，决定是否响应：</strong><ul><li><strong>如果计数器为</strong> <strong>0</strong> <strong>则立即响应发送自己的标识符号，</strong></li><li><strong>否则，标签在该时隙不响应。</strong></li><li><strong>标签被成功识别后将进入沉默状态，对以后时隙的阅读器命令均不响应。</strong></li></ul></li><li><strong>如果阅读器收到有冲突响应，则广播</strong> <strong>FAIL</strong> <strong>命令。</strong></li><li><strong>当标签收到</strong> <strong>FAIL</strong> <strong>命令后，查看并调整自己的计数器</strong><ul><li><strong>如果计数器不为</strong> <strong>0，则把计数器加</strong> <strong>1，推后发送时间</strong></li><li><strong>反之，生成</strong> <strong>1</strong> <strong>或</strong> <strong>0</strong> <strong>的随机数，并加到计数器（产生1的标签退出下一个时隙的竞争，产生</strong> <strong>0</strong> <strong>的标签继续下一时隙的竞争）</strong></li></ul></li><li><strong>如果阅读器收到的响应数为</strong> <strong>0，则广播</strong> <strong>Success</strong> <strong>命令。</strong></li><li><strong>如果只有一个标签的计数器为</strong> <strong>0，则阅读器感知到无冲突，于是发送</strong> <strong>Read</strong> <strong>命令（包含</strong> <strong>ID），与该标签完成数据交换后，阅读器广播</strong> <strong>Success</strong> <strong>命令。</strong></li><li><strong>收到</strong> <strong>Success</strong> <strong>命令的所有标签将计数器减</strong> <strong>1</strong> <strong>。</strong></li><li><strong>如果全部标签都成功发送数据，则结束算法。</strong></li></ul><p><strong>B</strong> <strong>树算法示例</strong>:</p><table><thead><tr><th><strong>角色</strong></th><th><strong>命令</strong></th><th>时隙<strong>1</strong></th><th>时隙  2</th><th>时隙3</th><th>时隙 4</th><th>时隙5</th><th>时隙5</th><th>时隙 <strong>7</strong></th><th>时隙5</th><th>时隙5</th></tr></thead><tbody><tr><td><strong>阅读器</strong></td><td><strong>Group_Select</strong></td><td></td><td></td><td><strong>Read</strong></td><td></td><td><strong>Read</strong></td><td><strong>Read</strong></td><td></td><td><strong>Read</strong></td><td><strong>Read</strong></td></tr><tr><td><strong>标签1</strong></td><td></td><td><strong>0</strong></td><td><strong>0</strong></td><td><strong>0</strong></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td><strong>标签2</strong></td><td></td><td><strong>0</strong></td><td><strong>1</strong></td><td><strong>2</strong></td><td><strong>1</strong></td><td><strong>2</strong></td><td><strong>1</strong></td><td><strong>0</strong></td><td><strong>1</strong></td><td><strong>0</strong></td></tr><tr><td><strong>标签3</strong></td><td></td><td><strong>0</strong></td><td><strong>0</strong>  <strong>( 1 ? )</strong></td><td><strong>1</strong></td><td><strong>0</strong></td><td><strong>1</strong></td><td><strong>0</strong></td><td></td><td></td><td></td></tr><tr><td><strong>标签4</strong></td><td></td><td><strong>0</strong></td><td><strong>0</strong>  <strong>( 1 ? )</strong></td><td><strong>1</strong></td><td><strong>0</strong></td><td><strong>0</strong></td><td></td><td></td><td></td><td></td></tr><tr><td><strong>标签5</strong></td><td></td><td><strong>0</strong></td><td><strong>1</strong></td><td><strong>2</strong></td><td><strong>1</strong></td><td><strong>2</strong></td><td><strong>1</strong></td><td><strong>0</strong></td><td><strong>0</strong></td><td></td></tr><tr><td></td><td></td><td><strong>冲突</strong></td><td><strong>冲突</strong></td><td><strong>发送1</strong></td><td><strong>冲突</strong></td><td><strong>发送4</strong></td><td><strong>发送3</strong></td><td><strong>冲突</strong></td><td><strong>发送5</strong></td><td><strong>发送2</strong></td></tr></tbody></table><h3 id="防冲突算法的性能对比"><a href="#防冲突算法的性能对比" class="headerlink" title="防冲突算法的性能对比"></a><strong>防冲突算法的性能对比</strong></h3><p><strong>基于ALOHA的防冲突算法</strong></p><ul><li><strong>标签“饿死”</strong></li><li><strong>最坏情况，识别时延趋于+∞</strong></li><li><strong>低负载情况，识别时延小</strong></li><li><strong>结果可进行统计性分析</strong></li><li><strong>标签需要可写存储区</strong></li></ul><p><strong>基于确定性二进制（BSA、FBSA、查询二进制树）的防冲突算法</strong></p><ul><li><strong>标签在确定时间内可识别，不存在“饿死”</strong></li><li><strong>识别时延受标签ID分布及长度影响</strong></li><li><strong>标签不需要可写存储区</strong></li></ul><p><strong>基于随机二进制树的防冲突算法</strong></p><ul><li><strong>存在标签“饿死”</strong></li><li><strong>识别时延受标签ID分布及长度影响</strong></li><li><strong>标签需要可写存储区</strong></li></ul><h3 id="RFID分类及应用"><a href="#RFID分类及应用" class="headerlink" title="RFID分类及应用"></a><strong>RFID分类及应用</strong></h3><p><strong>无源RFID的有效识别距离通常较短，一般用于近距离的接触式识别。无源RFID主要工作在较低频段125KHz、13.56MKHz等，其典型应用包括：公交卡、二代身份证（高频频段，通讯协议</strong> <strong>ISO14443B）、校园卡、食堂餐卡等。</strong></p><p><strong>有源RFID的远距性、高效性，使得它在一些需要高性能、大范围的射频识别应用场合里必不可少。一个典型的有源RFID标签能在百米之外主动与射频识别阅读器建立联系，读取率可达1,700read&#x2F;sec。有源RFID主要工作在900MHz、2.45GHz、5.8GHz等较高频段，且具有可以同时识别多个标签的功能。其典型应用包括：高速公路电子不停车收费系统等。</strong></p><p><strong>半有源RFID，又称作低频激活触发技术。无源RFID自身不供电，但有效识别距离太短。有源RFID识别距离足够长，但需外接电源，体积较大。而半有源RFID就是为这一矛盾而妥协的产物。在通常情况下，半有源RFID产品处于休眠状态，仅对标签中保持数据的部分进行供电，因此耗电量较小，可维持较长时间。当标签进入射频识别阅读器识别范围后，阅读器先以125KHz低频信号在小范围内精确激活标签使之进入工作状态，再通过2.4GHz微波与其进行信息传递。也即是说，先利用低频信号精确定位，再利用高频信号快速传输数据。其通常应用场景为：在一个高频信号所能所覆盖的大范围中，在不同位置安置多个低频阅读器用于激活半有源RFID产品。这样既完成了定位，又实现了信息的采集与传递。</strong></p><h3 id="RFID的通信协议"><a href="#RFID的通信协议" class="headerlink" title="RFID的通信协议"></a><strong>RFID的通信协议</strong></h3><p><strong>RFID</strong> <strong>空中接口</strong></p><p><strong>规范阅读器与标签之间的信息交互，实现不同厂商设备之间的互联互通。</strong></p><table><thead><tr><th><strong>协议</strong></th><th><strong>内容及适用范围</strong></th></tr></thead><tbody><tr><td><strong>ISO&#x2F;IEC</strong> <strong>18000-1</strong></td><td><strong>参考结构和标准化的参数定义。规范协议中应共同遵守的阅读器与标签的通信参数表、知识产权基本规则等</strong></td></tr><tr><td><strong>ISO&#x2F;IEC</strong> <strong>18000-2</strong></td><td><strong>适用于</strong> <strong>125 – 134 KHz</strong></td></tr><tr><td><strong>ISO&#x2F;IEC</strong> <strong>18000-3</strong></td><td><strong>适用于</strong> <strong>13.56 MHz</strong></td></tr><tr><td><strong>ISO&#x2F;IEC</strong> <strong>18000-4</strong></td><td><strong>适用于</strong> <strong>2.45 GHz</strong></td></tr><tr><td><strong>ISO&#x2F;IEC</strong>  <strong>18000-6</strong></td><td><strong>适用于</strong> <strong>860 – 930 MHz</strong></td></tr><tr><td><strong>ISO&#x2F;IEC</strong> <strong>18000-7</strong></td><td><strong>适用于</strong>  <strong>433.92</strong>  <strong>MHz</strong></td></tr></tbody></table><p><strong>RFID</strong> <strong>数据标准</strong></p><ul><li><strong>主要规定数据的表示形式。</strong></li><li><strong>ISO&#x2F;IEC 15961</strong> <strong>规定阅读器与应用软件之间的接口，侧重于交换数据的标准方式，这样应用软件可以完成对标签数据的读取、写入、修改、删除等操作。</strong></li><li><strong>ISO&#x2F;IEC 15962</strong> <strong>规定数据的编码、压缩、逻辑内存映射格式，以及如何将标签中的数据转化为对应用软件有意义的形式。</strong></li></ul><h4 id="ISO-x2F-IEC-18000-6-协议"><a href="#ISO-x2F-IEC-18000-6-协议" class="headerlink" title="ISO&#x2F;IEC 18000-6 协议"></a><strong>ISO&#x2F;IEC 18000-6</strong> <strong>协议</strong></h4><p><strong>规定了阅读器与标签之间的物理接口、协议和命令，以及防冲突仲裁机制等</strong></p><ul><li><strong>物理层：</strong> <strong>RFID</strong> <strong>频率。数据编码方式、调制格式、数据传输速率等</strong></li><li><strong>标签标识层： 阅读器读写标签的各种指令</strong></li></ul><table><thead><tr><th><strong>参数</strong></th><th><strong>Type</strong> <strong>B</strong></th><th><strong>Type C</strong></th></tr></thead><tbody><tr><td><strong>调制方式</strong></td><td><strong>ASK</strong></td><td><strong>SSB-ASK, DSB-ASK, PR-ASK</strong></td></tr><tr><td><strong>前向链路编码</strong></td><td><strong>曼切斯特编码</strong></td><td><strong>PIE</strong> <strong>编码</strong></td></tr><tr><td><strong>返向链路编码</strong></td><td><strong>FM0</strong></td><td><strong>FM0</strong> <strong>或</strong> <strong>Miller</strong>  <strong>子载波</strong></td></tr><tr><td><strong>标签唯一标识号长度</strong></td><td><strong>64</strong> <strong>位</strong></td><td><strong>16 – 496</strong> <strong>位</strong></td></tr><tr><td><strong>数据速率</strong></td><td><strong>10</strong> <strong>kbps</strong> <strong>或</strong>  <strong>40 kbps</strong></td><td><strong>26.7 kbps – 128 kbps</strong></td></tr><tr><td><strong>标签容量</strong></td><td><strong>2048</strong> <strong>位</strong></td><td><strong>最大</strong> <strong>512</strong> <strong>位</strong></td></tr><tr><td><strong>防冲突算法</strong></td><td><strong>自适应二进制树（B树）</strong></td><td><strong>随机时隙反碰撞（Q算法）</strong></td></tr></tbody></table><h5 id="部分-ISO-x2F-IEC-18000-6B-命令表"><a href="#部分-ISO-x2F-IEC-18000-6B-命令表" class="headerlink" title="部分 ISO&#x2F;IEC 18000-6B 命令表"></a><strong>部分</strong> <strong>ISO&#x2F;IEC 18000-6B</strong> <strong>命令表</strong></h5><table><thead><tr><th><strong>命令码</strong></th><th><strong>类型</strong></th><th><strong>命令名称</strong></th><th><strong>备注</strong></th></tr></thead><tbody><tr><td><strong>00</strong></td><td><strong>强制</strong></td><td><strong>GROUP_SELECT_EQ</strong></td><td><strong>选择标签作为识别对象</strong></td></tr><tr><td><strong>08</strong></td><td><strong>强制</strong></td><td><strong>FAIL</strong></td><td><strong>失败命令</strong></td></tr><tr><td><strong>09</strong></td><td><strong>强制</strong></td><td><strong>SUCCESS</strong></td><td><strong>成功命令</strong></td></tr><tr><td><strong>0A</strong></td><td><strong>强制</strong></td><td><strong>INT</strong></td><td><strong>初始化</strong></td></tr><tr><td><strong>0C</strong></td><td><strong>强制</strong></td><td><strong>READ</strong></td><td><strong>从标签读数据</strong></td></tr><tr><td><strong>0D</strong></td><td><strong>可选</strong></td><td><strong>WRITE</strong></td><td><strong>向标签写数据</strong></td></tr><tr><td><strong>0F</strong></td><td><strong>可选</strong></td><td><strong>LOCK</strong></td><td></td></tr></tbody></table><h3 id="RFID-典型应用领域"><a href="#RFID-典型应用领域" class="headerlink" title="RFID 典型应用领域"></a><strong>RFID</strong> <strong>典型应用领域</strong></h3><p><strong>1、物流</strong></p><p><strong>物流仓储是RFID最有潜力的应用领域之一，可应用的过程包括：物流过程中的货物追踪、信息自动采集、仓储管理应用、港口应用、邮政包裹、快递等。</strong></p><p><strong>2、交通</strong></p><p><strong>出租车管理、公交车枢纽管理、铁路机车识别等。</strong></p><p><strong>3、身份识别</strong></p><p><strong>RFID技术由于具有快速读取与难伪造性，所以被广泛应用于个人的身份识别证件中。如电子护照、我国第二代身份证、学生证等其他各种电子证件。</strong></p><p><strong>4、防伪</strong></p><p><strong>RFID具有很难伪造的特性，但是如何应用于防伪还需要政府和企业的积极推广。可以应用的领域包括贵重物品（烟、酒、药品）的防伪和票证的防伪等。</strong></p><p><strong>5、资产管理</strong></p><p><strong>可应用于各类资产的管理，包括贵重物品、数量大相似性高的物品或危险品等。随着标签价格的降低，RFID几乎可以管理所有的物品。</strong></p><p><strong>6、食品</strong></p><p><strong>可应用于水果、蔬菜、生鲜、食品等管理。需要在标签的设计及应用模式上有所创新。</strong></p><h2 id="NFC-近场通讯"><a href="#NFC-近场通讯" class="headerlink" title="NFC 近场通讯"></a><strong>NFC</strong> <strong>近场通讯</strong></h2><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-2-RFID/image-20230924204155131.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="图"></p><p><strong>NFC</strong> <strong>（Near Field Communication）即近场无线通讯，是一种非接触式识别和互联技术，可以在移动设备、消费类电子产品、PC和智能控件工具间进行近距离无线通信。</strong></p><p><strong>NFC</strong> <strong>技术起源于</strong> <strong>RFID，但是与</strong> <strong>RFID</strong> <strong>相比有一定的区别</strong></p><p>–<strong>NFC</strong> <strong>将非接触读卡器、非接触卡和点对点功能整合进一块单芯片，而</strong> <strong>RFID</strong> <strong>必须由阅读器和标签组成</strong></p><p>–<strong>NFC</strong> <strong>技术则强调的是信息交互，而</strong> <strong>RFID</strong> <strong>只能实现信息的读取以及判定</strong></p><p><strong>NFC设备的功能定位</strong></p><p>–<strong>NFC</strong> <strong>设备内置</strong> <strong>NFC</strong> <strong>芯片，组成</strong> <strong>RFID</strong> <strong>模块的一部分，可以当作</strong> <strong>RFID</strong> <strong>无源标签使用进行支付费用；</strong></p><p>–<strong>也可以当作</strong> <strong>RFID</strong> <strong>读写器，用作数据交换与采集，还可以进行</strong> <strong>NFC</strong> <strong>设备之间的数据通信。</strong></p><h3 id="NFC-与-RFID-的区别"><a href="#NFC-与-RFID-的区别" class="headerlink" title="NFC 与 RFID 的区别"></a><strong>NFC</strong> <strong>与</strong> <strong>RFID</strong> <strong>的区别</strong></h3><ul><li><strong>工作频段</strong><ul><li><strong>NFC</strong> <strong>的工作频段为</strong> <strong>13.56MHz，而</strong> <strong>RFID</strong> <strong>有低频，高频（13.56MHz）及超高频。</strong></li></ul></li><li><strong>工作有效距离</strong><ul><li><strong>NFC</strong> <strong>的工作距离理论上为</strong> <strong>0</strong> <strong>~</strong> <strong>20 cm，但是在产品实现上，由于采用了特殊功率抑制技术，使其工作距离只有</strong> <strong>0</strong> <strong>~</strong> <strong>10 cm</strong> <strong>，业务更具有安全性。</strong></li><li><strong>相对于</strong> <strong>RFID</strong> <strong>来说</strong> <strong>NFC</strong> <strong>具有距离近、带宽高、能耗低等特点。</strong></li><li><strong>RFID</strong> <strong>具有不同的频率，其工作距离在几厘米到几十米不等。</strong></li></ul></li><li><strong>工作模式</strong><ul><li><strong>NFC</strong> <strong>同时支持读写模式和卡模式；支持点对点</strong> <strong>P2P</strong> <strong>模式。</strong></li><li><strong>RFID</strong> <strong>的读卡器和非接触卡是独立的两个实体，模式不能切换&#x2F;并存，不支持</strong> <strong>P2P。</strong></li></ul></li><li><strong>兼容性</strong><ul><li><strong>NFC设备都工作于13.56MHz，并与现有非接触智能卡技术兼容，NFC兼容性更好 。</strong></li><li><strong>RFID</strong> <strong>标准较多，统一较为复杂。</strong></li></ul></li><li><strong>应用领域</strong><ul><li><strong>RFID</strong> <strong>更多的应用在生产，物流，跟踪和资产管理上，更擅长在长距离识别、批量识别</strong></li><li><strong>NFC</strong> <strong>工作在门禁，公交卡，手机支付等领域，更多应用于消费类电子设备相互通讯。</strong></li></ul></li><li><strong>标准协议</strong><ul><li><strong>NFC</strong> <strong>的底层通讯协议兼容高频</strong> <strong>RFID</strong> <strong>的底层通信标准，即兼容</strong> <strong>ISO14443&#x2F;ISO15693</strong> <strong>。</strong></li><li><strong>NFC</strong> <strong>技术还定义了比较完整的上层协议，如</strong> <strong>LLCP，NDEF</strong> <strong>和</strong> <strong>RTD</strong> <strong>等。</strong></li></ul></li></ul><h4 id="RFID、NFC-相关标准"><a href="#RFID、NFC-相关标准" class="headerlink" title="RFID、NFC 相关标准"></a><strong>RFID、NFC</strong> <strong>相关标准</strong></h4><p>1.<strong>ISO&#x2F;IEC</strong></p><p><strong>RFID</strong> <strong>技术符合</strong> <strong>ISO14443、ISO15693</strong> <strong>标准</strong></p><ul><li><strong>ISO14443</strong> <strong>和</strong> <strong>ISO 15693</strong> <strong>二者皆以</strong> <strong>13.56MHz</strong> <strong>交变信号为载波频率；</strong></li><li><strong>ISO15693</strong> <strong>读写距离较远，与应用系统的天线形状和发射功率有关；</strong></li><li><strong>ISO14443</strong> <strong>读写距离稍近，应用较广泛，第二代电子身份证采用</strong> <strong>ISO14443 TYPE B</strong> <strong>；</strong></li><li><strong>传输速率为</strong> <strong>106kbits&#x2F;s，它们的不同主要在于载波的调制深度及位的编码方式。</strong></li></ul><p><strong>NFC</strong> <strong>技术符合</strong> <strong>ISO18092、ISO21481</strong> <strong>标准，兼容</strong> <strong>ISO14443、ISO15693</strong> <strong>等射频标准</strong></p><ul><li><strong>ISO18092</strong> <strong>标准定义了13.56MHz</strong> <strong>的</strong> <strong>NFC</strong> <strong>相关协议内容；</strong></li><li><strong>ISO18092</strong> <strong>后来增加了对</strong> <strong>ISO15693</strong> <strong>的兼容，形成新的</strong> <strong>NFC</strong> <strong>标准 即</strong> <strong>ISO21481；</strong></li><li><strong>NFC</strong> <strong>的传输速率有</strong> <strong>106kbps、212kbps、424kbps。</strong></li></ul><p><strong>ISO7816</strong> <strong>是接触式智能卡的标准。</strong></p><p>2.<strong>ECMA340、ECMA352</strong></p><ul><li><strong>ECMA（European Computer Manufacturers Association）是欧洲的标准组织</strong></li><li><strong>ECMA340</strong> <strong>是</strong> <strong>ISO18092</strong> <strong>的前身，它被</strong> <strong>ISO</strong> <strong>接收后成为了</strong> <strong>ISO18092；</strong></li><li><strong>ECMA352</strong> <strong>是</strong> <strong>ISO21481</strong> <strong>的前身。</strong></li></ul><p>3.<strong>NFC Forum</strong></p><ul><li><strong>行业标准，将</strong> <strong>ISO14443、ISO18092</strong> <strong>及</strong> <strong>JIS X6319-4（Felica）融合用于支持</strong> <strong>NFC-A&#x2F;B&#x2F;F</strong> <strong>。</strong></li><li><strong>其中</strong> <strong>NFC</strong> <strong>的模式有读写模式、卡模拟模式以及点对点模式</strong></li></ul><h4 id="NFC-技术架构"><a href="#NFC-技术架构" class="headerlink" title="NFC 技术架构"></a><strong>NFC</strong> <strong>技术架构</strong></h4><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-2-RFID/image-20230924204451446.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="架构"></p><h4 id="NFC-各种标签类型的属性"><a href="#NFC-各种标签类型的属性" class="headerlink" title="NFC 各种标签类型的属性"></a><strong>NFC</strong> <strong>各种标签类型的属性</strong></h4><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-2-RFID/image-20230924204507055.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="属性"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;第二章-物联网感知识别&quot;&gt;&lt;a href=&quot;#第二章-物联网感知识别&quot; class=&quot;headerlink&quot; title=&quot;第二章 物联网感知识别&quot;&gt;&lt;/a&gt;&lt;strong&gt;第二章 物联网感知识别&lt;/strong&gt;&lt;/h1&gt;&lt;h2 id=&quot;2-2-RFID&quot;&gt;&lt;a</summary>
      
    
    
    
    <category term="学习资料" scheme="https://www.emokable.top/categories/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/"/>
    
    
    <category term="课件笔记" scheme="https://www.emokable.top/tags/%E8%AF%BE%E4%BB%B6%E7%AC%94%E8%AE%B0/"/>
    
    <category term="物联网技术与应用" scheme="https://www.emokable.top/tags/%E7%89%A9%E8%81%94%E7%BD%91%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%BA%94%E7%94%A8/"/>
    
    <category term="IoT" scheme="https://www.emokable.top/tags/IoT/"/>
    
  </entry>
  
  <entry>
    <title>IoT__第2章__感知识别__2.1_自动识别技术</title>
    <link href="https://www.emokable.top/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-1-%E8%87%AA%E5%8A%A8%E8%AF%86%E5%88%AB%E6%8A%80%E6%9C%AF/"/>
    <id>https://www.emokable.top/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-1-%E8%87%AA%E5%8A%A8%E8%AF%86%E5%88%AB%E6%8A%80%E6%9C%AF/</id>
    <published>2023-09-23T15:55:45.000Z</published>
    <updated>2023-09-24T11:46:53.156Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第二章-物联网感知识别"><a href="#第二章-物联网感知识别" class="headerlink" title="第二章 物联网感知识别"></a><strong>第二章 物联网感知识别</strong></h1><h2 id="2-1-自动识别"><a href="#2-1-自动识别" class="headerlink" title="2.1  自动识别"></a><strong>2.1</strong>  <strong>自动识别</strong></h2><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-1-%E8%87%AA%E5%8A%A8%E8%AF%86%E5%88%AB%E6%8A%80%E6%9C%AF/image-20230924003613516.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="auto"></p><h3 id="2-1-1-自动识别技术概述"><a href="#2-1-1-自动识别技术概述" class="headerlink" title="2.1.1 自动识别技术概述"></a><strong>2.1.1</strong> <strong>自动识别技术概述</strong></h3><p><strong>识别：对有关事务进行归类和定性</strong></p><p><strong>自动识别技术是一种机器自动数据采集技术</strong></p><ul><li><strong>应用一定的识别装置，自动地获取被识别物品的相关信息，并传递给后台进行数据处理</strong></li><li><strong>自动识别是用机器来实现类似人对各种事物或现象的检测与分析，并做出辨识的过程</strong></li><li><strong>需要：经验、标准、规则</strong></li></ul><p><strong>自动识别技术标准组织</strong></p><ul><li><strong>国际自动识别制造商协会</strong> <strong>Association for Automatic Identification and Mobility,  AIM Global</strong></li><li><strong>中国自动识别技术协会</strong>  <strong>AIM China</strong></li></ul><h4 id="自动识别技术的分类"><a href="#自动识别技术的分类" class="headerlink" title="自动识别技术的分类"></a>自动识别技术的分类</h4><p>•<strong>数据采集技术</strong></p><ul><li><strong>特点：需要特定的载体存放信息</strong></li><li><strong>光存储识别 （条码识别、二维码识别、答题卡识别）</strong></li><li><strong>磁存储识别（磁条、非接触磁卡、磁光存储识别）</strong></li><li><strong>电存储识别（射频识别、IC卡识别）</strong></li></ul><p>•<strong>特征提取技术</strong></p><ul><li><strong>特点：根据事物本身的行为特征来判决信息</strong></li><li><strong>静态特征 （指纹、虹膜、面部、光学字符识别</strong> <strong>OCR</strong> <strong>）</strong></li><li><strong>动态特征 （语音、步态、表情）</strong></li><li><strong>属性特征 （化学、物理、生物、联合感觉）</strong></li></ul><h4 id="自动识别系统的构成"><a href="#自动识别系统的构成" class="headerlink" title="自动识别系统的构成"></a>自动识别系统的构成</h4><p>一般自动识别系统模型:</p><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-1-%E8%87%AA%E5%8A%A8%E8%AF%86%E5%88%AB%E6%8A%80%E6%9C%AF/image-20230924003806842.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="normal"></p><p>基于特征提取的自动识别系统模型</p><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-1-%E8%87%AA%E5%8A%A8%E8%AF%86%E5%88%AB%E6%8A%80%E6%9C%AF/image-20230924005709203.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="特征"></p><h3 id="2-1-2-条形码识别"><a href="#2-1-2-条形码识别" class="headerlink" title="2.1.2 条形码识别"></a><strong>2.1.2</strong> <strong>条形码识别</strong></h3><p><strong>最“古老”的自动识别技术</strong></p><p><strong>条形码是由一组规则排列的条、空以及对应的字符组成的标记。普通的条形码在使用过程中仅作为识别信息。</strong></p><p><strong>一个完整的条码的组成次序依次为：</strong></p><p><strong>左侧空白区（静区）、起始符、数据符、（中间分割符，主要用于EAN码）、（校验符）、终止符、右侧空白区（静区）</strong></p><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-1-%E8%87%AA%E5%8A%A8%E8%AF%86%E5%88%AB%E6%8A%80%E6%9C%AF/image-20230924005830237.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="条形码"></p><h4 id="条形码的分类"><a href="#条形码的分类" class="headerlink" title="条形码的分类"></a><strong>条形码的分类</strong></h4><p>按照长度： 定长、非定长条形码</p><p>依据排列方式： 连续型、非连续型条形码</p><p>按照扫描方式： 双向、单向条形码</p><p>按照单元模块方式： 宽窄调节码、模块组合码</p><p>一维条形码（条形码）、二维条形码（二维码）</p><h4 id="条形码：基本概念"><a href="#条形码：基本概念" class="headerlink" title="条形码：基本概念"></a><strong>条形码：基本概念</strong></h4><ul><li><strong>模块：构成条码的基本单位是模块，模块是指条码中最窄的条或空，模块的宽度通常以</strong> <strong>mm</strong> <strong>或</strong> <strong>mil（千分之一英寸）为单位。</strong></li><li><strong>单元：构成条码的一个条或空称为一个单元，一个单元包含的模块数是由编码方式决定的，有些码制中，如</strong> <strong>EAN</strong> <strong>码，所有单元由一个或多个模块组成（模块组合法）；而另一些码制，如</strong> <strong>39</strong> <strong>码中，所有单元只有两种宽度，即宽单元和窄单元，其中的窄单元即为一个模块（宽度调节法）。</strong> </li><li><strong>密度：单位长度的条码所表示的字符个数。模块尺寸越小，密度越大，所以密度值通常以模块尺寸的值来表示（如</strong> <strong>5 mil）。通常</strong> <strong>7.5 mil</strong> <strong>以下的条码称为高密度条码，15 mil</strong> <strong>以上的条码称为低密度条码。</strong></li><li><strong>宽窄比：对于只有两种宽度单元的码制，宽单元与窄单元的比值称为宽窄比，一般为2-3左右（常用的有2：1，3：1）。宽窄比较大时，阅读设备更容易分辨宽单元和窄单元，因此比较容易阅读。</strong></li></ul><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-1-%E8%87%AA%E5%8A%A8%E8%AF%86%E5%88%AB%E6%8A%80%E6%9C%AF/image-20230924005959213.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="例子"></p><ul><li><strong>对比度（PCS）：条码符号的光学指标，PCS值越大则条码的光学特性越好。</strong><ul><li><strong>PCS＝(RL - RD) &#x2F; RL</strong> <strong>× 100%</strong> <strong>（RL:条形码反射率，RD:空气反射率）</strong></li></ul></li><li><strong>条码长度：从条码起始符前缘到终止符后缘的长度。</strong></li><li><strong>条码密度：单位长度的条码所表示的字符个数。</strong></li><li><strong>双向条码：条码的两端都可以作为扫描起点的。</strong></li><li><strong>中间分隔符：在条码符号中，位于两个相邻的条码符号之间且不代表任何信息的空。</strong></li><li><strong>连续性条码：在条码字符中，两个相邻的条码字符之间没有中间分隔符的条码。</strong></li><li><strong>非连续性条码：在条码字符中，两个相邻的条码字符之间存在中间分隔符的条码。</strong></li></ul><h4 id="条形码的编码方法"><a href="#条形码的编码方法" class="headerlink" title="条形码的编码方法"></a><strong>条形码的编码方法</strong></h4><p><strong>宽度调节法</strong></p><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-1-%E8%87%AA%E5%8A%A8%E8%AF%86%E5%88%AB%E6%8A%80%E6%9C%AF/image-20230924011055121.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="width"></p><p>条形码中条与空的宽窄设置不同，用宽单元表示二进制的“1”，而用窄单元表示二进制的“0”，宽窄单元之比控制在2～3之间。印刷精度要求低。</p><p><strong>模块组合法 &#x2F; 色度调节法</strong></p><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-1-%E8%87%AA%E5%8A%A8%E8%AF%86%E5%88%AB%E6%8A%80%E6%9C%AF/image-20230924011119214.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="c"></p><p>条形码符号中，条与空是由标准宽度的模块组成的。一个标准宽度的条模块表示二进制的“1”，而一个标准宽度的空模块表示二进制的“0”。印刷精度要求高。</p><h5 id="EAN-13-条形码-（模块组合法、非连续）"><a href="#EAN-13-条形码-（模块组合法、非连续）" class="headerlink" title="EAN-13 条形码  （模块组合法、非连续）"></a><strong>EAN-13</strong> <strong>条形码</strong>  <strong>（模块组合法、非连续）</strong></h5><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-1-%E8%87%AA%E5%8A%A8%E8%AF%86%E5%88%AB%E6%8A%80%E6%9C%AF/image-20230924011149094.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="example"></p><p>起始部分: 由11条线组成，从左到右依次为8条白线、1条黑线、1条白线、1条黑线</p><p>第一数据部分: 由42条线组成，按照一定算法形成，包含了左侧数据符（d1～d6）的信息</p><p>中间部分: 由5条线组成，从左到右依次为1条白线、1条黑线、1条白线、1条黑线、1条白线</p><p>第二数据部分: 由42条线组成，和第一数据部分一样由一定算法形成，包含右侧数据符（d7～d12）数字的信息</p><p>结尾部分: 由11条线组成，从左至右分别是1条黑线、1条白线、1条黑线、8条白线</p><h5 id="25码-（宽度调节法、连续）"><a href="#25码-（宽度调节法、连续）" class="headerlink" title="25码 （宽度调节法、连续）"></a>25码 （宽度调节法、连续）</h5><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-1-%E8%87%AA%E5%8A%A8%E8%AF%86%E5%88%AB%E6%8A%80%E6%9C%AF/image-20230924011221938.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="25"></p><h5 id="39码-（宽度调节法、连续）"><a href="#39码-（宽度调节法、连续）" class="headerlink" title="39码 （宽度调节法、连续）"></a>39码 （宽度调节法、连续）</h5><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-1-%E8%87%AA%E5%8A%A8%E8%AF%86%E5%88%AB%E6%8A%80%E6%9C%AF/image-20230924011233551.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="39"></p><h5 id="UPC-条形码"><a href="#UPC-条形码" class="headerlink" title="UPC 条形码"></a><strong>UPC</strong> <strong>条形码</strong></h5><p>Universal Product Code</p><p>UPC-A 码 </p><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-1-%E8%87%AA%E5%8A%A8%E8%AF%86%E5%88%AB%E6%8A%80%E6%9C%AF/image-20230924011259843.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="UPC-A"></p><p>UPC-E 码</p><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-1-%E8%87%AA%E5%8A%A8%E8%AF%86%E5%88%AB%E6%8A%80%E6%9C%AF/image-20230924011313444.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="UPC-E"></p><h5 id="ISBN-x2F-ISSN"><a href="#ISBN-x2F-ISSN" class="headerlink" title="ISBN &#x2F; ISSN"></a><strong>ISBN &#x2F; ISSN</strong></h5><p>国际标准书号  International Standard Book Number</p><p>国际标准连续出版物号 International Standard Serial Number</p><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-1-%E8%87%AA%E5%8A%A8%E8%AF%86%E5%88%AB%E6%8A%80%E6%9C%AF/image-20230924011347429.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="ex"></p><p><strong>ISBN</strong> <strong>号包含的信息</strong>:</p><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-1-%E8%87%AA%E5%8A%A8%E8%AF%86%E5%88%AB%E6%8A%80%E6%9C%AF/image-20230924012525848.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="实例"></p><p>978 表示用于 ISBN 国家 &#x2F; 语言  出版商   图书编号   检查码</p><h5 id="EAN（欧洲商品编号）条形码"><a href="#EAN（欧洲商品编号）条形码" class="headerlink" title="EAN（欧洲商品编号）条形码"></a><strong>EAN（欧洲商品编号）条形码</strong></h5><p>UPC超集</p><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-1-%E8%87%AA%E5%8A%A8%E8%AF%86%E5%88%AB%E6%8A%80%E6%9C%AF/image-20230924012644704.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="EAN-13 码"></p><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-1-%E8%87%AA%E5%8A%A8%E8%AF%86%E5%88%AB%E6%8A%80%E6%9C%AF/image-20230924012653021.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="EAN-8 码"></p><p>UCC&#x2F;EAN-128码（连续型、非定长）</p><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-1-%E8%87%AA%E5%8A%A8%E8%AF%86%E5%88%AB%E6%8A%80%E6%9C%AF/image-20230924012706785.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="long"></p><h4 id="条形码阅读器工作原理：-扫描-译码"><a href="#条形码阅读器工作原理：-扫描-译码" class="headerlink" title="条形码阅读器工作原理： 扫描 + 译码"></a><strong>条形码阅读器工作原理：</strong> <strong>扫描</strong> <strong>+</strong> <strong>译码</strong></h4><p><strong>激光扫描仪通过一个激光二极管发出一束光线，照射到一个旋转的棱镜或来回摆动的镜子上，反射后的光线穿过阅读窗照射到条码表面，光线经过条或空的反射后返回阅读器，由一个镜子进行采集、聚焦，通过光电转换器转换成电信号，该信号将通过扫描期或终端上的译码软件进行译码。</strong></p><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-1-%E8%87%AA%E5%8A%A8%E8%AF%86%E5%88%AB%E6%8A%80%E6%9C%AF/image-20230924012815063.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="过程"></p><h5 id="条形码阅读器产品和应用"><a href="#条形码阅读器产品和应用" class="headerlink" title="条形码阅读器产品和应用"></a><strong>条形码阅读器产品和应用</strong></h5><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-1-%E8%87%AA%E5%8A%A8%E8%AF%86%E5%88%AB%E6%8A%80%E6%9C%AF/image-20230924012845779.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="应用"></p><h4 id="典型条形码制比较"><a href="#典型条形码制比较" class="headerlink" title="典型条形码制比较"></a><strong>典型条形码制比较</strong></h4><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-1-%E8%87%AA%E5%8A%A8%E8%AF%86%E5%88%AB%E6%8A%80%E6%9C%AF/image-20230924013022584.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="table"></p><h3 id="2-1-3-二维码"><a href="#2-1-3-二维码" class="headerlink" title="2.1.3 二维码"></a><strong>2.1.3</strong> <strong>二维码</strong></h3><ul><li><strong>二维码利用某种特定的几何图形按一定规律在平面（二维方向上）分布的黑白相间的图形记录数据符号信息；</strong></li><li><strong>在代码编制上，使用若干个与</strong> <strong>0、1</strong> <strong>二进制相对应的几何形体来表示文字数值信息，通过图象输入设备或光电扫描设备自动识读以实现信息自动处理。</strong></li><li><strong>二维码具有条码技术的一些共性：</strong><ul><li><strong>每种码制有其特定的字符集</strong></li><li><strong>每个字符占有一定的宽度</strong></li><li><strong>具有一定的校验功能等</strong></li></ul></li><li><strong>同时还具有对不同行的信息自动识别功能、以及处理图形旋转变化等特点。</strong></li></ul><h4 id="二维码符号"><a href="#二维码符号" class="headerlink" title="二维码符号"></a><strong>二维码符号</strong></h4><p>•<strong>目前，世界上应用最多的二维码符号有Aztec Code、PDF147、Data Matrix、QR Code、Code16K</strong> <strong>等。</strong></p><p><strong>国际自动识别制造商协会（AIM）</strong></p><p><strong>美国标准化协会（ANSI）</strong></p><p><strong>ISO&#x2F;IEC</strong></p><p><strong>中国物品编码中心</strong></p><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-1-%E8%87%AA%E5%8A%A8%E8%AF%86%E5%88%AB%E6%8A%80%E6%9C%AF/image-20230924013203695.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="aztec"></p><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-1-%E8%87%AA%E5%8A%A8%E8%AF%86%E5%88%AB%E6%8A%80%E6%9C%AF/image-20230924013211603.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="pdf147"></p><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-1-%E8%87%AA%E5%8A%A8%E8%AF%86%E5%88%AB%E6%8A%80%E6%9C%AF/image-20230924013219950.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="data matrix"></p><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-1-%E8%87%AA%E5%8A%A8%E8%AF%86%E5%88%AB%E6%8A%80%E6%9C%AF/image-20230924013228419.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="code16k"></p><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-1-%E8%87%AA%E5%8A%A8%E8%AF%86%E5%88%AB%E6%8A%80%E6%9C%AF/image-20230924013235410.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="qrcode"></p><h4 id="二维码的分类"><a href="#二维码的分类" class="headerlink" title="二维码的分类"></a><strong>二维码的分类</strong></h4><p>§<strong>行排式</strong></p><ul><li><strong>又称堆积式或层叠式二维码，是在一维条形码的基础上按需要将其堆积成多行而成</strong></li><li><strong>PDF417、49码、Code 16K</strong> <strong>条码</strong></li></ul><p>§<strong>矩阵式</strong></p><ul><li><strong>用点阵表示二进制</strong> <strong>0&#x2F;1</strong> <strong>的序列</strong></li><li><strong>Code One、QR码、Data Matrix、Vericode、田字码、汉信码、龙贝码</strong></li></ul><p>§<strong>邮政码</strong></p><ul><li><strong>通过不同高度的条进行编码，主要用于邮政编码</strong></li><li><strong>Postnet、BPO 4-State</strong></li></ul><p>§<strong>彩码</strong></p><ul><li><strong>在传统二维码的基础上添加色彩元素而形成，也称为三维码</strong></li></ul><p>§<strong>复合码</strong></p><ul><li><strong>各种条码类型的组合</strong></li><li><strong>EAN.UCC：一维码对主要标识、二维码对附加数据如批号、有效期等编码</strong></li></ul><h5 id="PDF417码：行排式二维码-Portable-Data-File"><a href="#PDF417码：行排式二维码-Portable-Data-File" class="headerlink" title="PDF417码：行排式二维码 Portable Data File"></a><strong>PDF417码：行排式二维码</strong> <strong>Portable Data</strong> <strong>File</strong></h5><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-1-%E8%87%AA%E5%8A%A8%E8%AF%86%E5%88%AB%E6%8A%80%E6%9C%AF/image-20230924013350837.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="pdf417"></p><p>PDF417条形码中每个数据字符包括4个条和4个空，每个条或空由1～6个模块组成，一个数据字符中，4个条和4个空的总模块数为17，故名PDF417</p><h5 id="QR-码：矩阵式二维码"><a href="#QR-码：矩阵式二维码" class="headerlink" title="QR 码：矩阵式二维码"></a><strong>QR</strong> <strong>码：矩阵式二维码</strong></h5><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-1-%E8%87%AA%E5%8A%A8%E8%AF%86%E5%88%AB%E6%8A%80%E6%9C%AF/image-20230924013703762.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="ex"></p><ul><li><strong>快速响应矩阵（Quick Response Code, QR）</strong></li><li><strong>国标：GB&#x2F;T 18284 - 2000</strong></li><li><strong>使用最为广泛的二维码</strong></li><li><strong>超高速识读、全方位识读、高效表示汉字</strong></li></ul><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-1-%E8%87%AA%E5%8A%A8%E8%AF%86%E5%88%AB%E6%8A%80%E6%9C%AF/image-20230924013421175.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="ex"></p><h5 id="QR-码符号版本"><a href="#QR-码符号版本" class="headerlink" title="QR 码符号版本"></a><strong>QR</strong> <strong>码符号版本</strong></h5><p><strong>QR</strong> <strong>码符号共有40种版本</strong></p><ul><li><strong>版本1：21 x 21</strong></li><li><strong>版本2：25 x 25</strong></li><li><strong>每个版本增加4个模块</strong></li><li><strong>版本40：177 x</strong> <strong>177</strong></li></ul><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-1-%E8%87%AA%E5%8A%A8%E8%AF%86%E5%88%AB%E6%8A%80%E6%9C%AF/image-20230924013738095.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="QR"></p><h5 id="汉信码：矩阵式二维码"><a href="#汉信码：矩阵式二维码" class="headerlink" title="汉信码：矩阵式二维码"></a><strong>汉信码：矩阵式二维码</strong></h5><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-1-%E8%87%AA%E5%8A%A8%E8%AF%86%E5%88%AB%E6%8A%80%E6%9C%AF/image-20230924124831416.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="汉信"></p><h5 id="彩码"><a href="#彩码" class="headerlink" title="彩码"></a><strong>彩码</strong></h5><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-1-%E8%87%AA%E5%8A%A8%E8%AF%86%E5%88%AB%E6%8A%80%E6%9C%AF/image-20230924192715046.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="color"></p><h4 id="二维码的生成过程"><a href="#二维码的生成过程" class="headerlink" title="二维码的生成过程"></a><strong>二维码的生成过程</strong></h4><ul><li><strong>数据分析</strong></li><li><strong>数据编码</strong></li><li><strong>纠错</strong></li><li><strong>构造最终信息</strong></li><li><strong>在矩阵中布置模块</strong></li><li><strong>掩模</strong></li><li><strong>添加格式信息和版本信息</strong></li></ul><h4 id="一维条形码与二维码的比较"><a href="#一维条形码与二维码的比较" class="headerlink" title="一维条形码与二维码的比较"></a><strong>一维条形码与二维码的比较</strong></h4><ul><li><strong>一维条形码特点：</strong><ul><li><strong>可直接显示内容为英文、数字、简单符号；</strong></li><li><strong>贮存数据不多，主要依靠计算机中的关联数据库；</strong></li><li><strong>保密性能不高；</strong></li><li><strong>损污后可读性差。</strong></li></ul></li><li><strong>二维码特点：</strong><ul><li><strong>可直接显示英文、中文、数字、符号、图形；</strong></li><li><strong>贮存数据量大，可存放1K字符，可用扫描仪直接读取内容，无需另接数据库；</strong></li><li><strong>保密性高（可加密）；</strong></li><li><strong>安全级别最高时，损污50%仍可读取完整信息。</strong></li></ul></li></ul><h4 id="QR-码结构图"><a href="#QR-码结构图" class="headerlink" title="QR 码结构图"></a><strong>QR 码结构图</strong></h4><p><strong>QR 码由编码区域和包括寻像图形、分隔符、定位图形和校正图形在内的功能图形组成。</strong></p><p><strong>QR 码结构图如下图所示：</strong> </p><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-1-%E8%87%AA%E5%8A%A8%E8%AF%86%E5%88%AB%E6%8A%80%E6%9C%AF/image-20230924192853645.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="st"></p><blockquote><p><strong>二维码的特点：</strong></p><ul><li><strong>存储大容量信息</strong></li><li><strong>在小空间内打印</strong></li><li><strong>有效表现各种字母</strong></li><li><strong>对变脏和破损的纠错能力强</strong></li><li><strong>从任意方向读取</strong></li><li><strong>可以数据分割与合并</strong></li></ul></blockquote><h4 id="二维码识别原理"><a href="#二维码识别原理" class="headerlink" title="二维码识别原理"></a><strong>二维码识别原理</strong></h4><p><strong>定位校正图形：</strong></p><p><strong>根据 3 个位置探测图像估计右下角校正符，共同定位该图形。</strong></p><p><strong>透视变换：</strong></p><p><strong>根据 3 个定位中心点和校正符中心点，和理想 4 个点的坐标，获取单应性矩阵，再通过透视变换获取标准正方形图像。</strong></p><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-1-%E8%87%AA%E5%8A%A8%E8%AF%86%E5%88%AB%E6%8A%80%E6%9C%AF/image-20230924192956842.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="定位"></p><p><strong>译码和纠错</strong>：<strong>译码是对二维码版本信息、格式信息、数据和纠错码进行解码和对比。将数据区转为0和1的比特流，并用Reed-Solomon纠错算法对比特流校验和纠错。判断QR码编码格式后译码，这样得到了二维码包含的数据。</strong></p><p><strong>常规的QR码识别过程容易受到环境影响而难以识别，往往需要一些预处理改善图像质量和识别环境。</strong></p><p><strong>图像灰度化</strong></p><p><strong>去噪</strong></p><p><strong>畸变矫正</strong></p><p><strong>二值化</strong></p><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-1-%E8%87%AA%E5%8A%A8%E8%AF%86%E5%88%AB%E6%8A%80%E6%9C%AF/image-20230924193024754.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="工业"></p><h4 id="常见的工业领域应用问题"><a href="#常见的工业领域应用问题" class="headerlink" title="常见的工业领域应用问题"></a><strong>常见的工业领域应用问题</strong></h4><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-1-%E8%87%AA%E5%8A%A8%E8%AF%86%E5%88%AB%E6%8A%80%E6%9C%AF/image-20230924193044564.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="平衡"></p><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-1-%E8%87%AA%E5%8A%A8%E8%AF%86%E5%88%AB%E6%8A%80%E6%9C%AF/image-20230924193052570.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="问题"></p><h4 id="二维码检测定位技术（例）"><a href="#二维码检测定位技术（例）" class="headerlink" title="二维码检测定位技术（例）"></a><strong>二维码检测定位技术（例）</strong></h4><p><strong>更高的检测精度、复杂环境应用、防止图像失真、具有鲁棒性</strong></p><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-1-%E8%87%AA%E5%8A%A8%E8%AF%86%E5%88%AB%E6%8A%80%E6%9C%AF/image-20230924193120160.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="photo"></p><h3 id="2-1-3-IC卡识别"><a href="#2-1-3-IC卡识别" class="headerlink" title="2.1.3  IC卡识别"></a><strong>2.1.3  IC卡识别</strong></h3><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-1-%E8%87%AA%E5%8A%A8%E8%AF%86%E5%88%AB%E6%8A%80%E6%9C%AF/image-20230924193147038.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="IC"></p><h4 id="CPU卡：-按与外界数据交换界面"><a href="#CPU卡：-按与外界数据交换界面" class="headerlink" title="CPU卡： 按与外界数据交换界面"></a><strong>CPU卡： 按与外界数据交换界面</strong></h4><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-1-%E8%87%AA%E5%8A%A8%E8%AF%86%E5%88%AB%E6%8A%80%E6%9C%AF/image-20230924193259076.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="分类"></p><p>接触式IC卡的多个金属触点为卡芯片与外界的信息传输媒介，成本低，实施相对简便；非接触式IC卡则不用触点，而是借助无线收发传送信息，因此在前者难以胜任的交通运输等诸多场合有较多应用。</p><h3 id="2-1-4-光学字符识别"><a href="#2-1-4-光学字符识别" class="headerlink" title="2.1.4  光学字符识别"></a><strong>2.1.4</strong>  <strong>光学字符识别</strong></h3><p>光学字符识别（optical character recognition，OCR）： 采用电子设备（如扫描仪或数码相机）检查纸上打印的字符，通过检测暗亮的模式确定其形状，然后用字符识别方法将形状翻译成计算机文字的过程，即对文本资料进行扫描，然后对图像文件进行分析处理，获取文字及版面信息的过程。</p><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-1-%E8%87%AA%E5%8A%A8%E8%AF%86%E5%88%AB%E6%8A%80%E6%9C%AF/image-20230924193340804.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="光学字符识别流程图"></p><h3 id="2-1-5-语音识别"><a href="#2-1-5-语音识别" class="headerlink" title="2.1.5 语音识别"></a><strong>2.1.5</strong> <strong>语音识别</strong></h3><p>语音识别：采用数字信号处理技术自动提取及决定语言信号中最基本有意义的信息，同时也包括利用音律特征等个人特征识别说话人。</p><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-1-%E8%87%AA%E5%8A%A8%E8%AF%86%E5%88%AB%E6%8A%80%E6%9C%AF/image-20230924193403444.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="voice"></p><h3 id="2-1-6-生物特征识别"><a href="#2-1-6-生物特征识别" class="headerlink" title="2.1.6 生物特征识别"></a><strong>2.1.6</strong> <strong>生物特征识别</strong></h3><p>概念：</p><p> 通过计算机与光学、声学、生物传感器和生物统计学原理等高科技手段密切结合，利用人体固有的生理特性（如指纹、指静脉、人脸、虹膜等）和行为特征（如笔迹、声音、步态等）来进行个人身份的鉴定</p><p>分类：</p><ul><li>指纹识别</li><li>掌纹识别</li><li>静脉识别</li><li>虹膜识别</li><li>人脸识别</li><li>声音识别</li></ul><h4 id="指纹识别"><a href="#指纹识别" class="headerlink" title="指纹识别"></a><strong>指纹识别</strong></h4><p>从实用角度看，指纹识别是优于其他生物识别技术的身份鉴别方法。因为指纹具有各不相同、终生基本不变的特点，且目前的指纹识别系统已达到操作方便、准确可靠、价格适中的阶段，正逐步应用于民用市场。</p><p>指纹识别的处理流程：</p><p>–通过特殊的光电转换设备和计算机图像处理技术，对活体指纹进行采集、分析和比对，可以迅速、准确地鉴别出个人身份。系统一般主要包括对指纹图像采集、指纹图像处理、特征提取、特征值的比对与匹配等过程。</p><h5 id="指纹的总体特征"><a href="#指纹的总体特征" class="headerlink" title="指纹的总体特征"></a><strong>指纹的总体特征</strong></h5><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-1-%E8%87%AA%E5%8A%A8%E8%AF%86%E5%88%AB%E6%8A%80%E6%9C%AF/image-20230924193526268.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="特征"></p><h4 id="静脉识别"><a href="#静脉识别" class="headerlink" title="静脉识别"></a><strong>静脉识别</strong></h4><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-1-%E8%87%AA%E5%8A%A8%E8%AF%86%E5%88%AB%E6%8A%80%E6%9C%AF/image-20230924193557136.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="静脉"></p><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-1-%E8%87%AA%E5%8A%A8%E8%AF%86%E5%88%AB%E6%8A%80%E6%9C%AF/image-20230924193612708.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="静脉"></p><h4 id="虹膜识别"><a href="#虹膜识别" class="headerlink" title="虹膜识别"></a><strong>虹膜识别</strong></h4><p>•<strong>虹膜识别是当前应用最方便精确的生物识别技术，虹膜的高度独特性和稳定性是其用于身份鉴别的基础。</strong></p><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-1-%E8%87%AA%E5%8A%A8%E8%AF%86%E5%88%AB%E6%8A%80%E6%9C%AF/image-20230924193637586.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="虹膜"></p><h5 id="虹膜识别的高识别率"><a href="#虹膜识别的高识别率" class="headerlink" title="虹膜识别的高识别率"></a><strong>虹膜识别的高识别率</strong></h5><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-1-%E8%87%AA%E5%8A%A8%E8%AF%86%E5%88%AB%E6%8A%80%E6%9C%AF/image-20230924193718196.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="识别率对比"></p><p><strong>虹膜识别的特点：</strong></p><ul><li><strong>生物活性:</strong> <strong>虹膜处在巩膜的保护下，生物活性强。</strong></li><li><strong>非接触性:</strong> <strong>无需用户接触设备，对人身没有侵犯。</strong></li><li><strong>唯一性:</strong>  <strong>形态完全相同虹膜的可能性低于其他组织。</strong></li><li><strong>稳定性:</strong>  <strong>虹膜定型后终身不变，一般疾病不会对虹膜组织造成损伤。</strong></li><li><strong>防伪性:</strong> <strong>不可能在对视觉无严重影响的情况下用外科手术改变虹膜特征。</strong></li><li><strong>识别率极高，仅次于DNA识别。</strong></li></ul><h4 id="人脸识别"><a href="#人脸识别" class="headerlink" title="人脸识别"></a><strong>人脸识别</strong></h4><p>人脸识别（human face recognition）是基于人的面部特征信息进行身份识别。其准确性要低于虹膜、指纹识别，但它具有非强制性、非接触性、操作简单、隐蔽性好等特点，因此成为最容易被接受的生物特征识别方式。</p><p>人脸识别过程：</p><ul><li>建立人脸的面像档案：制作面像文件，并生成面纹编码进行存储</li><li>获取当前的人体面像，并以此生成面纹编码</li><li>用当前的面纹编码与档案库存中的面纹编码进行检索对比</li></ul><h5 id="人脸识别涉及到的技术模块"><a href="#人脸识别涉及到的技术模块" class="headerlink" title="人脸识别涉及到的技术模块"></a><strong>人脸识别涉及到的技术模块</strong></h5><p><strong>人脸检测</strong></p><p>在动态场景、复杂背景中判断是否存在面像，并分离出面像。</p><ul><li>参考模板法、人脸规则法、样品学习法、肤色模型法、特征脸法</li></ul><p><strong>人脸跟踪</strong></p><p>在检测之后，在后续帧中继续捕获人脸的运动轨迹及大小变化。</p><ul><li>基于模型跟踪、运动信息跟踪、人脸局部特征跟踪、神经网络跟踪</li></ul><p><strong>人脸比对</strong> </p><p>对被检测到的面像进行身份确认，即在面像库中进行目标检索，找出最佳匹配。面像的描述决定了面像识别的具体方法与性能。</p><ul><li>特征向量、面纹模板</li></ul><h5 id="人脸识别的特征提取"><a href="#人脸识别的特征提取" class="headerlink" title="人脸识别的特征提取"></a><strong>人脸识别的特征提取</strong></h5><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-1-%E8%87%AA%E5%8A%A8%E8%AF%86%E5%88%AB%E6%8A%80%E6%9C%AF/image-20230924193856486.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="难点"></p><h4 id="声音识别"><a href="#声音识别" class="headerlink" title="声音识别"></a><strong>声音识别</strong></h4><p>通过对采集到的语音信号进行分析和处理，提取相应的特征以识别说话人的身份。</p><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-1-%E8%87%AA%E5%8A%A8%E8%AF%86%E5%88%AB%E6%8A%80%E6%9C%AF/image-20230924193923197.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="流程"></p><h3 id="2-1-7-图像识别、机器视觉"><a href="#2-1-7-图像识别、机器视觉" class="headerlink" title="2.1.7 图像识别、机器视觉"></a><strong>2.1.7</strong> <strong>图像识别、机器视觉</strong></h3><p><img src="/IoT-%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E8%AF%86%E5%88%AB-2-1-%E8%87%AA%E5%8A%A8%E8%AF%86%E5%88%AB%E6%8A%80%E6%9C%AF/image-20230924193956563.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="无其它内容"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;第二章-物联网感知识别&quot;&gt;&lt;a href=&quot;#第二章-物联网感知识别&quot; class=&quot;headerlink&quot; title=&quot;第二章 物联网感知识别&quot;&gt;&lt;/a&gt;&lt;strong&gt;第二章 物联网感知识别&lt;/strong&gt;&lt;/h1&gt;&lt;h2 id=&quot;2-1-自动识别&quot;&gt;&lt;a</summary>
      
    
    
    
    <category term="学习资料" scheme="https://www.emokable.top/categories/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/"/>
    
    
    <category term="课件笔记" scheme="https://www.emokable.top/tags/%E8%AF%BE%E4%BB%B6%E7%AC%94%E8%AE%B0/"/>
    
    <category term="物联网技术与应用" scheme="https://www.emokable.top/tags/%E7%89%A9%E8%81%94%E7%BD%91%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%BA%94%E7%94%A8/"/>
    
    <category term="IoT" scheme="https://www.emokable.top/tags/IoT/"/>
    
  </entry>
  
  <entry>
    <title>IoT__第1章__物联网概述</title>
    <link href="https://www.emokable.top/IoT-%E7%AC%AC1%E7%AB%A0-%E7%89%A9%E8%81%94%E7%BD%91%E6%A6%82%E8%BF%B0/"/>
    <id>https://www.emokable.top/IoT-%E7%AC%AC1%E7%AB%A0-%E7%89%A9%E8%81%94%E7%BD%91%E6%A6%82%E8%BF%B0/</id>
    <published>2023-09-23T14:10:48.000Z</published>
    <updated>2023-09-24T11:47:17.306Z</updated>
    
    <content type="html"><![CDATA[<h1 id="物联网技术与应用"><a href="#物联网技术与应用" class="headerlink" title="物联网技术与应用"></a>物联网技术与应用</h1><h3 id="物物互联"><a href="#物物互联" class="headerlink" title="物物互联"></a><strong>物物互联</strong></h3><p>•物联网概念在2005年国际电信联盟（ITU）发布的《ITU互联网报告2005：物联网》中被正式提出：</p><p>”它通过泛在网络，借助物体识别技术（如射频识别）、传感技术、嵌入式智能技术、小型化技术（如纳米结构），将世界万物连接在一起，通过感知世界、认识世界、改造世界，进而推动整个世界发展。</p><p><img src="/IoT-%E7%AC%AC1%E7%AB%A0-%E7%89%A9%E8%81%94%E7%BD%91%E6%A6%82%E8%BF%B0/image-20230923223303067.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="物物互联：连接物理世界与虚拟世界"></p><h3 id="物联网是一项技术吗-……"><a href="#物联网是一项技术吗-……" class="headerlink" title="物联网是一项技术吗 ……"></a>物联网是一项技术吗 ……</h3><p><img src="/IoT-%E7%AC%AC1%E7%AB%A0-%E7%89%A9%E8%81%94%E7%BD%91%E6%A6%82%E8%BF%B0/image-20230923223334523.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="image-20230923223334523"></p><p><strong>来源多样，主线复杂</strong></p><p>物联网不是某项具体的技术，而是很多推动万物互联趋势的支撑技术的有机集合。</p><p><img src="/IoT-%E7%AC%AC1%E7%AB%A0-%E7%89%A9%E8%81%94%E7%BD%91%E6%A6%82%E8%BF%B0/image-20230923223401700.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="本科专业"></p><blockquote><p>虽然这里是软工。。。</p></blockquote><p><img src="/IoT-%E7%AC%AC1%E7%AB%A0-%E7%89%A9%E8%81%94%E7%BD%91%E6%A6%82%E8%BF%B0/image-20230923223447346.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="应避免“盲人摸象”现象"></p><h1 id="物联网-IoT-Internet-of-Things"><a href="#物联网-IoT-Internet-of-Things" class="headerlink" title="物联网  IoT (Internet of Things)"></a>物联网  IoT (Internet of Things)</h1><ul><li>概述</li><li>感知识别</li><li>传感网络</li><li>支撑管理</li><li>广域连接</li><li>综合应用</li></ul><h2 id="第一章-物联网概述"><a href="#第一章-物联网概述" class="headerlink" title="第一章 物联网概述"></a><strong>第一章 物联网概述</strong></h2><h3 id="1-1发展起源和背景"><a href="#1-1发展起源和背景" class="headerlink" title="1.1发展起源和背景"></a>1.1<strong>发展起源和背景</strong></h3><p><img src="/IoT-%E7%AC%AC1%E7%AB%A0-%E7%89%A9%E8%81%94%E7%BD%91%E6%A6%82%E8%BF%B0/image-20230923223637490.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="直接截取的课件。。。"></p><h4 id="IoT-起源：-普适计算"><a href="#IoT-起源：-普适计算" class="headerlink" title="IoT 起源： 普适计算"></a><strong>IoT</strong> <strong>起源： 普适计算</strong></h4><p>•1988年，Xerox PARC 研究中心的 Mark Weiser 提出普适计算的概念。</p><p>–1991年，在  <em>Scientific American</em> 上发表 “The Computer for the 21st Century” ，正式提出了普适计算 Ubiquitous Computing</p><p>–”The most profound technologies are those that disappear. They weave themselves into the fabric of everyday life until they are indistinguishable from it.”</p><p>•1999年，IBM也提出 Pervasive Computing的概念，即为无所不在的、随时随地可以进行计算的一种方式。强调计算资源普存于环境当中，人们可以随时随地获得需要的信息和服务。</p><p>•1999年，欧洲 ISTAG 提出了环境智能（Ambient Intelligence）的概念。提法不同，但是含义一致。</p><h5 id="普适计算的特点："><a href="#普适计算的特点：" class="headerlink" title="普适计算的特点："></a><strong>普适计算的特点</strong>：</h5><ul><li>当时的计算领域新浪潮，是多技术的融合，突破桌面计算的模式，将计算和互联技术普及到日常生活中</li><li>倡导发展可以广泛部署的微小计算设备，并与已有的互联网技术结合，实现移动、无缝、透明、泛在的计算服务，又称为不可见计算（Invisible Computing）</li><li>强调和环境融为一体的计算概念，计算机本身从人们的视线里消失。 能够在任何时间、任何地点、以任何方式进行信息的获取与处理</li><li>模式转变：（互联网）让人围绕着网络运行 à 让微小系统形成的网络围绕着人运转</li><li>然而，普适设备大多是已有计算系统的延伸和拓展，集聚化、智能化程度较低，而且服务对象主要是个体，缺乏突破性应用场景，未能大规模推广</li><li>将互联网推广到物理世界的一种初步尝试</li></ul><h4 id="IoT-起源：无线传感网（WSN-Wireless-Sensor-Network）"><a href="#IoT-起源：无线传感网（WSN-Wireless-Sensor-Network）" class="headerlink" title="IoT 起源：无线传感网（WSN: Wireless Sensor Network）"></a><strong>IoT</strong> <strong>起源：无线传感网（WSN: Wireless Sensor Network）</strong></h4><p><img src="/IoT-%E7%AC%AC1%E7%AB%A0-%E7%89%A9%E8%81%94%E7%BD%91%E6%A6%82%E8%BF%B0/image-20230923223804215.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="智能化"></p><p><img src="/IoT-%E7%AC%AC1%E7%AB%A0-%E7%89%A9%E8%81%94%E7%BD%91%E6%A6%82%E8%BF%B0/image-20230923223809626.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="点到网"></p><p><img src="/IoT-%E7%AC%AC1%E7%AB%A0-%E7%89%A9%E8%81%94%E7%BD%91%E6%A6%82%E8%BF%B0/image-20230923223837109.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="sys"></p><h4 id="物联网的起源和发展"><a href="#物联网的起源和发展" class="headerlink" title="物联网的起源和发展"></a><strong>物联网的起源和发展</strong></h4><ul><li>本世纪初，泛在网络 Ubiquitous Networks: 互联网和移动通信的融合与拓展</li><li>2006年，Cyber-Physical Systems (CPS) ：相比传感网系统，注重实现开放、可控、闭环的计算支持</li><li>2009年，美国工商业领袖“圆桌会议”，IBM提出“智慧地球”概念</li><li>2009年，“感知中国”战略启动<ul><li>–前期：中科院、科工委、高校、中电等预研攻关</li><li>–传感器网络被列入国家重大科技计划三“新一代移动通信网络”</li><li>–初期行业应用，与运营商合作探讨三步走</li><li>–2019年被视为中国物联网元年，收到全社会关注</li><li>–物联网被正式列入国家五大新兴战略性产业之一</li></ul></li><li>2016年，十三五规划建议提出实施“互联网+”行动计划</li><li>…… ……</li></ul><h5 id="物联网发展并提升至战略高度"><a href="#物联网发展并提升至战略高度" class="headerlink" title="物联网发展并提升至战略高度"></a><strong>物联网发展并提升至战略高度</strong></h5><p>•《中华人民共和国国民经济和社会发展第十四个五年规划和2035年远景目标纲要》（2021年）要求，在信息领域重点发展云计算、大数据、物联网、工业互联网、区块链、人工智能（AI）、虚拟现实（VR） &#x2F; 增强现实（AR）等七大产业。</p><p>•《物联网新型基础设施建设三年行动计划（2021—2023）》（2021年）提出，到2023年国内主要城市初步建成物联网新型基础设施。</p><p>物联网是一个<strong>动态的全球网络化基础设施</strong>，它具有基于标准和互操作通信协议的自组织能力，其中物理的和虚拟的“物”具有身份标识、物理属性、虚拟的特性和智能的接口，并与信息网络无缝整合。物联网将与媒体互联网、服务互联网和企业互联网一起，构成未来互联网。</p><h4 id="物联网过去、现在与发展"><a href="#物联网过去、现在与发展" class="headerlink" title="物联网过去、现在与发展"></a><strong>物联网过去、现在与发展</strong></h4><p><img src="/IoT-%E7%AC%AC1%E7%AB%A0-%E7%89%A9%E8%81%94%E7%BD%91%E6%A6%82%E8%BF%B0/image-20230923224405341.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="历史"></p><h3 id="1-2概念和特点"><a href="#1-2概念和特点" class="headerlink" title="1.2概念和特点"></a>1.2<strong>概念和特点</strong></h3><h4 id="物联网概念"><a href="#物联网概念" class="headerlink" title="物联网概念"></a><strong>物联网概念</strong></h4><ul><li>1998，MIT的Kevin Ashton首次提及 Internet of Things<ul><li>将RFID技术与传感器技术应用于日常物品中将会创建一个“物联网”，这项技术将带来人们对机器理解的新纪</li></ul></li><li>2003年，美国&lt;技术评论&gt;：传感网技术将是未来改变人们生活的十大技术之首。</li><li>2005,ITU发布《ITU互联网报告2005：物联网》<ul><li>物联网是通过RFID和智能计算等技术实现全世界设备互连的</li></ul></li><li>2008，欧委会的CERP-IOT工程给出新的物联网定<ul><li>物联网是物理和数字世界融合的网络，每个物理实体都有一个数字的身份；物体具有上下文感知能力―他们可以感知、沟通与互动。他们对待物理事件进行即时反映，对物理实体的信息进行即时传送；使得实时作出决定成为可能</li></ul></li><li>早期的维基百科<ul><li>所谓“物联网”（Internet of Things），指的是将各种信息传感设备，如射频识别（RFID）装置、红外感应器、全球定位系统、激光扫描器等种种装置与互联网结合起来而形成的一个巨大网络。</li></ul></li></ul><h5 id="物联网的其他定义"><a href="#物联网的其他定义" class="headerlink" title="物联网的其他定义"></a>物联网的其他定义</h5><p><img src="/IoT-%E7%AC%AC1%E7%AB%A0-%E7%89%A9%E8%81%94%E7%BD%91%E6%A6%82%E8%BF%B0/image-20230923225159018.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="p"></p><h4 id="物联网的系统化概念"><a href="#物联网的系统化概念" class="headerlink" title="物联网的系统化概念"></a><strong>物联网的系统化概念</strong></h4><p>物联网的系统化概念由中国提出，整合了美国CPS (Cyber-Physical Systems)、欧盟 IoT（Internet of Things) 和 日本 U-Japan 等概念。是一个基于互联网、传统电信网等信息载体，让所有（能被独立寻址的）普通物理对象实现被感知和互联互通的网络。物理环境感知化、普通对象设备化、自治终端互联化和普适服务智能化是其重要特征。</p><h4 id="IoT-Internet-of-Things-物联网"><a href="#IoT-Internet-of-Things-物联网" class="headerlink" title="IoT (Internet-of-Things)  物联网"></a>IoT (Internet-of-Things)  物联网</h4><p><strong>全面感知：利用传感器、RFID、卫星、微波，及其它各种感知设备随时随地采集各种动态对象，全面感知世界。</strong></p><p><strong>可靠传送：利用无线网、移动网、工控网等网络将感知的信息进行实时传送。</strong></p><p><strong>协同处理：对多维、多源信息进行融合处理，协同决策。</strong></p><p><strong>智能控制：对物体实现智能化的控制和管理，达到人与物的沟通。</strong></p><p><img src="/IoT-%E7%AC%AC1%E7%AB%A0-%E7%89%A9%E8%81%94%E7%BD%91%E6%A6%82%E8%BF%B0/image-20230923225428059.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="IoT"></p><h4 id="物联网应用-vs-互联网应用"><a href="#物联网应用-vs-互联网应用" class="headerlink" title="物联网应用 vs. 互联网应用"></a>物联网应用 vs. 互联网应用</h4><p><strong>互联网应用：</strong>人们想要在互联网上了解某种信息，需要有人去收集、发布这个信息到互联网上，才可供人们浏览。人需要在环路中做大量工作，并难以动态了解其变化。</p><p><strong>物联网应用</strong>：物联网通过各种感知设备，如射频识别、传感器、红外等，将信息传送到接收器，再通过互联网传送，通过高层应用进行信息处理，以实现远程监视、自动报警、控制、诊断和维护，进而实现“管理、控制、营运”的一体化。</p><p><img src="/IoT-%E7%AC%AC1%E7%AB%A0-%E7%89%A9%E8%81%94%E7%BD%91%E6%A6%82%E8%BF%B0/image-20230923225735601.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="HOME"></p><h4 id="几种网络概念之间的关系"><a href="#几种网络概念之间的关系" class="headerlink" title="几种网络概念之间的关系"></a><strong>几种网络概念之间的关系</strong></h4><p><img src="/IoT-%E7%AC%AC1%E7%AB%A0-%E7%89%A9%E8%81%94%E7%BD%91%E6%A6%82%E8%BF%B0/image-20230923225749817.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="包含和侧重"></p><h3 id="1-3体系结构"><a href="#1-3体系结构" class="headerlink" title="1.3体系结构"></a>1.3<strong>体系结构</strong></h3><p>传感网（物联网）三层体系架构 （2007-2009）</p><p><img src="/IoT-%E7%AC%AC1%E7%AB%A0-%E7%89%A9%E8%81%94%E7%BD%91%E6%A6%82%E8%BF%B0/image-20230923225943098.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="3F"></p><p><strong>物联网四层模型（例）</strong></p><p><img src="/IoT-%E7%AC%AC1%E7%AB%A0-%E7%89%A9%E8%81%94%E7%BD%91%E6%A6%82%E8%BF%B0/image-20230923230007346.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="4F"></p><p>• <strong>To be continued …</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;物联网技术与应用&quot;&gt;&lt;a href=&quot;#物联网技术与应用&quot; class=&quot;headerlink&quot; title=&quot;物联网技术与应用&quot;&gt;&lt;/a&gt;物联网技术与应用&lt;/h1&gt;&lt;h3 id=&quot;物物互联&quot;&gt;&lt;a href=&quot;#物物互联&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    <category term="学习资料" scheme="https://www.emokable.top/categories/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/"/>
    
    
    <category term="课件笔记" scheme="https://www.emokable.top/tags/%E8%AF%BE%E4%BB%B6%E7%AC%94%E8%AE%B0/"/>
    
    <category term="物联网技术与应用" scheme="https://www.emokable.top/tags/%E7%89%A9%E8%81%94%E7%BD%91%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%BA%94%E7%94%A8/"/>
    
    <category term="IoT" scheme="https://www.emokable.top/tags/IoT/"/>
    
  </entry>
  
  <entry>
    <title>大三开学，感觉时间好快e</title>
    <link href="https://www.emokable.top/%E5%A4%A7%E4%B8%89%E5%BC%80%E5%AD%A6%EF%BC%8C%E6%84%9F%E8%A7%89%E6%97%B6%E9%97%B4%E5%A5%BD%E5%BF%ABe/"/>
    <id>https://www.emokable.top/%E5%A4%A7%E4%B8%89%E5%BC%80%E5%AD%A6%EF%BC%8C%E6%84%9F%E8%A7%89%E6%97%B6%E9%97%B4%E5%A5%BD%E5%BF%ABe/</id>
    <published>2023-09-17T04:15:35.000Z</published>
    <updated>2023-09-17T06:11:36.133Z</updated>
    
    <content type="html"><![CDATA[<h3 id="牢骚"><a href="#牢骚" class="headerlink" title="牢骚"></a>牢骚</h3><p>2021年入学，有时候还觉得疫情如在昨天（第一波是在高二的时候了），结果一转眼都大三了，工作考研什么的都挺急了，自己进入大学以来还是感觉学到的太少了，特别是现在是学的嵌入式方向和互联网就业的学生比前后端一窍不通，和硬件学生比也不会画板子设计电路，什么白银卡住了。我的同学舍友有自己开发游戏的，有b站做up百万播放量的，还有准备北欧留学的，还有卷acm的，总之和他们相比总有一种自己没做什么实事的感觉。自己总该找点什么东西来做，可能才有点用。</p><h3 id="学习计划"><a href="#学习计划" class="headerlink" title="学习计划"></a>学习计划</h3><p>目前计划自学一下python，配合这学期的课程做点什么东西，还有教资考试也得提上日程，毕竟父母都是教师，又在师范学校，多拿一个证以后混不下去了，回老家躺平摆烂也有用。</p><p>其他的，这学期应该还是会在博客做笔记整理，上学期部分专业课成绩还是有提升的，对我这种人来说知识还得靠重复记忆才行，还有这学期有建模和算法课，要是脑袋转不过来就惨了，上课摸鱼还得戒掉才行，课上课后都得发力。</p><p>还计划这个大三参加一些学科竞赛刷点奖，不然可能真就保不了研了，如果已经既定保不了研，按就业形势来看，如果实习不顺利到大四还得准备考。。。</p><h3 id="Others"><a href="#Others" class="headerlink" title="Others"></a>Others</h3><p>这个博客的评论区崩了，有时间还得修修</p><p>暑假忙着做暑期课程的项目和摸鱼，鸽了好久，也没更新，寄</p><p>github上的<a href="https://github.com/Emokable/ADEwatch">项目地址</a>，只是作了个存档</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;牢骚&quot;&gt;&lt;a href=&quot;#牢骚&quot; class=&quot;headerlink&quot; title=&quot;牢骚&quot;&gt;&lt;/a&gt;牢骚&lt;/h3&gt;&lt;p&gt;2021年入学，有时候还觉得疫情如在昨天（第一波是在高二的时候了），结果一转眼都大三了，工作考研什么的都挺急了，自己进入大学以来还是感觉学到</summary>
      
    
    
    
    <category term="杂谈" scheme="https://www.emokable.top/categories/%E6%9D%82%E8%B0%88/"/>
    
    
    <category term="总结" scheme="https://www.emokable.top/tags/%E6%80%BB%E7%BB%93/"/>
    
    <category term="学习" scheme="https://www.emokable.top/tags/%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="生活" scheme="https://www.emokable.top/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>计算机组成原理-L012-Mcore</title>
    <link href="https://www.emokable.top/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L012-Mcore/"/>
    <id>https://www.emokable.top/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L012-Mcore/</id>
    <published>2023-06-06T16:12:19.000Z</published>
    <updated>2023-06-06T16:52:17.776Z</updated>
    
    <content type="html"><![CDATA[<h1 id="计算机组成与实践-多核处理器"><a href="#计算机组成与实践-多核处理器" class="headerlink" title="计算机组成与实践 -多核处理器"></a><strong>计算机组成与实践</strong> -<strong>多核处理器</strong></h1><h1 id="一-简介"><a href="#一-简介" class="headerlink" title="一.简介"></a>一.简介</h1><h3 id="指令级并行的局限"><a href="#指令级并行的局限" class="headerlink" title="指令级并行的局限"></a><strong>指令级并行的局限</strong></h3><p>将每个时钟周期处理3<del>6条指令的处理器提升一倍的性能，即每个时钟周期处理6</del>12条指令，需要该处理器每个时钟周期完成：</p><ul><li>处理3~4个存储访问</li><li>决策2~3个分支指令</li><li>重命名并访问20多个寄存器</li><li>提取12~24条指令</li></ul><blockquote><p>实现上述性能的复杂度可能意味着牺牲最高时钟频率</p></blockquote><h1 id="二-Amdahl定律"><a href="#二-Amdahl定律" class="headerlink" title="二.Amdahl定律"></a>二.Amdahl定律</h1><table><thead><tr><th>Amdahl定律</th></tr></thead><tbody><tr><td>加速比 S  &#x3D; 1&#x2F;(1 –  a + a&#x2F;n)</td></tr></tbody></table><p>a：可并行计算部分的占比</p><p>n：并行处理节点个数</p><p>加速之前的执行时间 To</p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L012-Mcore/image-20230607002814617.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="时间占比图"></p><p>加速之后的执行时间 Tp &#x3D; To  * （1 – a + a&#x2F;n）</p><p><strong>例子1</strong></p><p>如果希望在100个处理器上获得90的加速比，请问在原始计算负载中顺序执行部分最多占多少？</p><blockquote><p>答：假设可并行执行部分占比为a，根据加速比公式</p><p>​    s &#x3D; 1 &#x2F; (1 – a + a&#x2F;n)</p><p>​    90 &#x3D; 1 &#x2F; (1 – a + a&#x2F;100)</p><p>​    a &#x3D; 0.999</p><p>​    因此，顺序执行部分最多占0.1%</p></blockquote><h3 id="标量v-s-向量"><a href="#标量v-s-向量" class="headerlink" title="标量v.s 向量"></a><strong>标量v.s 向量</strong></h3><ul><li>标量处理器一次只能处理一个数据</li><li>向量处理器能够处理向量型并行计算<ul><li>如果希望在100个处理器上获得90的加速比，标量在原始程序中的占比要少于0.1%</li><li>由Amdahl定律可知，要在100个处理器上获得线性加速比，原始计算不能包含标量</li></ul></li></ul><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L012-Mcore/image-20230607002934659.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="左标量，计算只能一次处理一个数据"></p><p><strong>例子2</strong></p><p>执行两个加法：一个加法是10个标量的求和，另一个加法是一对10×10二维矩阵的求和。假设目前只有矩阵求和可以并行，使用10个和40个处理器达到的加速比分别是多少？</p><p>答：</p><p>​10个处理器加速比是110t&#x2F;20t&#x3D;5.5</p><p>​    40个处理器加速比是110t&#x2F;12.5t&#x3D;8.8</p><blockquote><p>这里的t是周期的意思，加速比是没加速花费的总时间和加速后的时间之比</p></blockquote><h1 id="三-线程级并行"><a href="#三-线程级并行" class="headerlink" title="三.线程级并行"></a><strong>三.线程级并行</strong></h1><h3 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a><strong>多线程</strong></h3><p>继续进行指令级并行（ILP）变得越来越复杂和困难</p><p>探索线程级并行（Thread-level parallelism，TLP）</p><blockquote><p>多道程序间的TLP（独立运行的串行程序）</p><p>多线程应用的TLP（程序运行采用多线程）</p></blockquote><p>多线程利用线程级并行提高单个处理器的效率</p><h4 id="线程例子"><a href="#线程例子" class="headerlink" title="线程例子"></a><strong>线程例子</strong></h4><ul><li>浏览器软件<ul><li>一个线程显示图片</li><li>一个线程从网络中检索数据</li></ul></li><li>文字处理软件<ul><li>一个线程显示图形</li><li>一个线程读取键盘输入</li><li>一个线程进行拼写检查</li></ul></li><li>web服务器<ul><li>一个线程接收访问请求</li><li>接收到请求后，创建一个线程提供服务</li><li>多个线程处理成千上万的用户请求</li></ul></li></ul><h4 id="硬件多线程"><a href="#硬件多线程" class="headerlink" title="硬件多线程"></a><strong>硬件多线程</strong></h4><table><thead><tr><th><strong>硬件多线程</strong></th></tr></thead><tbody><tr><td>在线程阻塞时处理器可以切换到另一个线程的实现</td></tr></tbody></table><ul><li>通过执行与造成阻塞的指令不相关的指令来隐藏阻塞开销的方法</li><li>处理器必须为每个线程复制独立的状态<ul><li>寄存器文件、PC、指令缓存等</li></ul></li><li>缓存、TLBs、BHT、BTB等可以共享</li><li>存储器自身可以通过虚拟存储器机制实现共享</li><li>硬件必须支持高效的线程切换</li></ul><table><thead><tr><th>细粒度多线程（fine-grained multithreading)</th></tr></thead><tbody><tr><td>每条指令之后都进行线程切换</td></tr></tbody></table><ul><li>多线程直接交叉执行，交叉以循环方式进行</li><li>处理器能够在每个时钟周期进行切换</li><li>☺可同时隐藏由短阻塞和长阻塞引起的吞吐量损失</li><li>☹降低了单个线程的执行速度</li></ul><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L012-Mcore/image-20230607003421004.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="sun"></p><h5 id="Niagara整数流水线"><a href="#Niagara整数流水线" class="headerlink" title="Niagara整数流水线"></a>Niagara整数流水线</h5><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L012-Mcore/image-20230607003514006.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="8细粒"></p><table><thead><tr><th>**粗粒度多线程（coarse-grained **multithreading</th></tr></thead><tbody><tr><td>仅在高开销阻塞时进行线程切换，如最后一级缓存缺失</td></tr></tbody></table><ul><li>☺几乎不会降低单个线程的执行速度</li><li>☹隐藏吞吐量损失能力受限，特别是短阻塞</li><li>☹线程切换时，必须清空流水线，并填充流水线</li><li>适合用来降低高开销阻塞带来的性能损失</li></ul><h4 id="同时多线程（SMT）"><a href="#同时多线程（SMT）" class="headerlink" title="同时多线程（SMT）"></a><strong>同时多线程（SMT）</strong></h4><table><thead><tr><th><strong>同时多线程（simultaneous  multithreading，SMT）</strong></th></tr></thead><tbody><tr><td>硬件多线程的变种，使用多发射动态调度流水线处理器的资源来挖掘线程级并行，并同时保持指令级并行</td></tr></tbody></table><ul><li>多发射处理器中通常有单线程难以充分利用的多个并行功能单元</li><li>借助于寄存器重命名和动态调度，不需要考虑相关性，即可以发射来自不同线程的多条指令</li><li>每个线程需要单独的重命名表（RUUs），或者需要指明一个表项属于哪个线程</li><li>Intel Pentium 4的SMT称为超线程（hyperthreading）：支持两个线程</li></ul><h4 id="4个线程运行在超标量处理器（4路）"><a href="#4个线程运行在超标量处理器（4路）" class="headerlink" title="4个线程运行在超标量处理器（4路）"></a><strong>4个线程运行在超标量处理器（4路）</strong></h4><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L012-Mcore/image-20230607004021046.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="chu"></p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L012-Mcore/image-20230607004033109.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="粗粒度/细粒度/同时多线程"></p><blockquote><p>粗的就是到高阻塞才调度，细是每条指令，smt是不需要开销的每条指令轮换</p></blockquote><h1 id="四-多核"><a href="#四-多核" class="headerlink" title="四.多核"></a><strong>四.多核</strong></h1><table><thead><tr><th><strong>多处理器</strong></th></tr></thead><tbody><tr><td>至少两个处理器的计算机系统</td></tr></tbody></table><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L012-Mcore/image-20230607004340664.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="多核"></p><p>通过任务级并行（task-level parallelism）或进程级并行实现高吞吐量（process-level parallelism）</p><p>将单个程序运行在多个处理器上实现性能的提升，并行处理程序（parallel processing program）</p><h3 id="多核处理器"><a href="#多核处理器" class="headerlink" title="多核处理器"></a><strong>多核处理器</strong></h3><ul><li>很多科学问题需要更快速的计算机，可以通过集群（cluster）完成</li><li>集群：通过局域网连接的一组计算机，其作用等同于一个大型的多处理器</li><li>例如搜索引擎、web服务器、电子邮件服务器和数据库</li></ul><table><thead><tr><th><strong>主要挑战</strong></th></tr></thead><tbody><tr><td>如何构建易于正确编写并行处理程序的软硬件系统</td></tr></tbody></table><h4 id="需要解决的关键问题"><a href="#需要解决的关键问题" class="headerlink" title="需要解决的关键问题"></a><strong>需要解决的关键问题</strong></h4><table><thead><tr><th>1、如何共享数据？</th></tr></thead><tbody><tr><td>多处理器共享一个物理地址空间</td></tr></tbody></table><table><thead><tr><th>2、如何合作处理任务？</th></tr></thead><tbody><tr><td>处理器通过存储器中的共享变量进行通信（load、store）</td></tr></tbody></table><p>通过同步机制访问共享数据，最多一个处理器进行访问</p><table><thead><tr><th><strong>两种类型</strong></th></tr></thead><tbody><tr><td>统一存储访问（Uniform Memory  Access, UMA）</td></tr><tr><td>非统一存储访问（Non-uniform Memory Access, NUMA）</td></tr></tbody></table><h4 id="简单并行处理程序"><a href="#简单并行处理程序" class="headerlink" title="简单并行处理程序"></a><strong>简单并行处理程序</strong></h4><p>10个处理器求和</p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L012-Mcore/image-20230607004538519.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="需要每层同步"></p><h4 id="进程同步"><a href="#进程同步" class="headerlink" title="进程同步"></a><strong>进程同步</strong></h4><ul><li>通过多进程合作完成一项任务</li><li>使用锁变量（信号量）实现进程合作与同步，需要架构提供仲裁机制</li><li>仲裁机制决定哪个处理器获得锁变量的访问权</li><li>单总线提供仲裁机制，只能通过单总线访问存储器</li><li>处理器获得总线，共享数据需要加锁，可以通过原子交换实现</li></ul><h4 id="自旋锁同步"><a href="#自旋锁同步" class="headerlink" title="自旋锁同步"></a><strong>自旋锁同步</strong></h4><p>一个处理器成功获得锁变量表示成功将1写入锁变量，其他处理器获得返回值0</p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L012-Mcore/image-20230607004642755.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="自旋"></p><p><strong>例子</strong></p><p>假设对100000个数字进行求和，运行在100个处理器上</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs prolog">sum[<span class="hljs-symbol">Pn</span>] = <span class="hljs-number">0</span>;<br>for (i = <span class="hljs-number">1000</span>*<span class="hljs-symbol">Pn</span>; i&lt;<span class="hljs-number">1000</span>*(<span class="hljs-symbol">Pn</span>+<span class="hljs-number">1</span>); i = i + <span class="hljs-number">1</span>)<br>sum[<span class="hljs-symbol">Pn</span>] = sum[<span class="hljs-symbol">Pn</span>] + <span class="hljs-symbol">A</span>[i];<br><span class="hljs-symbol">Repeat</span><br>   synch(); //synchronize first <br>   if (half<span class="hljs-comment">%2 != 0 &amp;&amp; Pn == 0) &#123; </span><br>        sum[<span class="hljs-number">0</span>] = sum[<span class="hljs-number">0</span>] + sum[half<span class="hljs-number">-1</span>]; <br>   &#125; <br>   half = half/<span class="hljs-number">2</span> <br>   if (<span class="hljs-symbol">Pn</span>&lt;half) &#123; <br>        sum[<span class="hljs-symbol">Pn</span>] = sum[<span class="hljs-symbol">Pn</span>] + sum[<span class="hljs-symbol">Pn</span>+half] <br>   &#125; <br>until (half == <span class="hljs-number">1</span>); //final sum in sum[<span class="hljs-number">0</span>]<br><br></code></pre></td></tr></table></figure><h4 id="Synch-例子"><a href="#Synch-例子" class="headerlink" title="Synch()例子"></a><strong>Synch()例子</strong></h4><p>Synch()：生产者-消费者模型下，消费者处理器在提取数据之前必须先同步</p><p>路障同步（Barrier）：处理器需要在路障处等待，直到满足条件</p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L012-Mcore/image-20230607004746635.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="路障捏"></p><h4 id="自旋锁实现路障"><a href="#自旋锁实现路障" class="headerlink" title="自旋锁实现路障"></a><strong>自旋锁实现路障</strong></h4><p>arrive、depart是自旋锁，arrive初始化未锁定，depart初始化锁定</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs delphi"><span class="hljs-function"><span class="hljs-keyword">procedure</span> <span class="hljs-title">synch</span><span class="hljs-params">()</span> <span class="hljs-comment">&#123; </span></span><br><span class="hljs-comment"><span class="hljs-function">    lock(arrive); </span></span><br><span class="hljs-comment"><span class="hljs-function">    count = count + 1; // count the processors as</span></span><br><span class="hljs-comment"><span class="hljs-function">    if (count &lt; n) &#123; // they arrive at barrier </span></span><br><span class="hljs-comment"><span class="hljs-function">           unlock(arrive) </span></span><br><span class="hljs-comment"><span class="hljs-function">    &#125;</span> <span class="hljs-title">else</span> <span class="hljs-comment">&#123;</span></span><br><span class="hljs-comment"><span class="hljs-function">           unlock(depart);</span></span><br><span class="hljs-comment"><span class="hljs-function">    &#125;</span> </span><br><span class="hljs-function">    <span class="hljs-title">lock</span><span class="hljs-params">(depart)</span>;</span> <br>    count = count - <span class="hljs-number">1</span>; <span class="hljs-comment">// count the processors as </span><br>    <span class="hljs-keyword">if</span> (count &gt; <span class="hljs-number">0</span>) <span class="hljs-comment">&#123; // they leave barrier </span><br><span class="hljs-comment">          unlock(depart) </span><br><span class="hljs-comment">    &#125;</span> <span class="hljs-keyword">else</span> <span class="hljs-comment">&#123; </span><br><span class="hljs-comment">          unlock(arrive); </span><br><span class="hljs-comment">    &#125;</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="消息传递多核处理器（MPP）"><a href="#消息传递多核处理器（MPP）" class="headerlink" title="消息传递多核处理器（MPP）"></a><strong>消息传递多核处理器（MPP）</strong></h3><table><thead><tr><th>1、如何共享数据？</th></tr></thead><tbody><tr><td>多处理器通过相互传递消息实现数据共享</td></tr></tbody></table><table><thead><tr><th>2、如何合作处理任务？</th></tr></thead><tbody><tr><td>通过消息传递（send和receive）实现处理器间合作</td></tr></tbody></table><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L012-Mcore/image-20230607004901229.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="多核-不共享内存"></p><p><strong>例子</strong></p><p>给每个处理器分配1000个数据进行求和</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash">Sum = 0;<br><span class="hljs-keyword">for</span> (i = 0; i&lt;1000; i = i + 1)<br><span class="hljs-built_in">sum</span> = <span class="hljs-built_in">sum</span> + A[i];<br>//将所有处理器计算结果相加 ，send(x,y)将数据y发送给处理器x<br><br>half = 100; l<br>imit = 100; <br>repeat &#123; <br>    half = (half+1)/2; //dividing line <br>    <span class="hljs-keyword">if</span> (Pn&gt;= half &amp;&amp; Pn&lt;<span class="hljs-built_in">limit</span>) send(Pn-half,<span class="hljs-built_in">sum</span>);<br>    <span class="hljs-keyword">if</span> (Pn&lt;(<span class="hljs-built_in">limit</span>/2)) <span class="hljs-built_in">sum</span> = <span class="hljs-built_in">sum</span> + receive(); <br>    <span class="hljs-built_in">limit</span> = half; <br>&#125; until (half == 1); //final <span class="hljs-built_in">sum</span> <span class="hljs-keyword">in</span> P0’s <span class="hljs-built_in">sum</span><br><br></code></pre></td></tr></table></figure><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L012-Mcore/image-20230607005019757.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="消息传递"></p><h1 id="五-小结"><a href="#五-小结" class="headerlink" title="五.小结"></a><strong>五.小结</strong></h1><p>多核处理器基础</p><ol><li>如何共享数据？</li><li>如何合作处理任务？</li><li>架构的可扩展性如何？</li></ol><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L012-Mcore/image-20230607005121724.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="m"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;计算机组成与实践-多核处理器&quot;&gt;&lt;a href=&quot;#计算机组成与实践-多核处理器&quot; class=&quot;headerlink&quot; title=&quot;计算机组成与实践 -多核处理器&quot;&gt;&lt;/a&gt;&lt;strong&gt;计算机组成与实践&lt;/strong&gt; -&lt;strong&gt;多核处理器&lt;/s</summary>
      
    
    
    
    <category term="学习资料" scheme="https://www.emokable.top/categories/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/"/>
    
    
    <category term="课件笔记" scheme="https://www.emokable.top/tags/%E8%AF%BE%E4%BB%B6%E7%AC%94%E8%AE%B0/"/>
    
    <category term="计算机组成原理" scheme="https://www.emokable.top/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>计算机组成原理-L011-vm</title>
    <link href="https://www.emokable.top/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L011-vm/"/>
    <id>https://www.emokable.top/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L011-vm/</id>
    <published>2023-06-06T16:12:08.000Z</published>
    <updated>2023-06-06T16:25:11.349Z</updated>
    
    <content type="html"><![CDATA[<h1 id="计算机组成与实践-虚拟存储器（Virtual-Memory）"><a href="#计算机组成与实践-虚拟存储器（Virtual-Memory）" class="headerlink" title="计算机组成与实践 -虚拟存储器（Virtual Memory）"></a><strong>计算机组成与实践</strong> -<strong>虚拟存储器（Virtual Memory）</strong></h1><h2 id="一-简介"><a href="#一-简介" class="headerlink" title="一.简介"></a>一.简介</h2><p>存储器的存储容量可能小于可寻址空间</p><ul><li>32-bit地址可以寻址4GB空间</li><li>内存地址可能只有1GB</li></ul><blockquote><p>系统可以同时运行多个程序，如果这些程序运行所需的存储空间大于实际内存容量，系统该如何运行？</p></blockquote><p>术语：</p><ul><li>运行的程序称为一个进程（process）或线程（thread）</li><li>操作系统控制进程</li></ul><h3 id="虚拟存储器（Virtual-Memory）"><a href="#虚拟存储器（Virtual-Memory）" class="headerlink" title="虚拟存储器（Virtual Memory）"></a><strong>虚拟存储器（Virtual Memory）</strong></h3><ul><li>将主存用作辅助存储器的高速缓存的技术</li><li>程序拥有自己的虚拟地址空间，存储频繁访问的代码与数据</li><li>根据局部性原理而设计</li></ul><blockquote><p>虚拟存储器优势：</p><p>​运行时，CPU和OS将虚拟地址（Virtual Address）转换成物理地址（Physical Address）</p><p>​实现多个程序共享存储器</p><p>​允许运行超过主存容量的程序</p><p>​代码重定位（Code Relocation）：代码可以加载进内存的任何地方</p></blockquote><h3 id="例子：从存储层次结构来看"><a href="#例子：从存储层次结构来看" class="headerlink" title="例子：从存储层次结构来看"></a><strong>例子：从存储层次结构来看</strong></h3><ul><li>假设内存容量为1GB，此时已经使用了1GB容量，在程序运行时需要额外的存储空间</li><li>把内存中的一块数据（100MB）移出到硬盘</li><li>此时，内存有100MB的空闲（free）存储空间</li><li>如果稍后，需要使用被替换出去那块数据</li><li>需要把内存中其他的数据块移出到硬盘，以获得100MB的空闲存储空间将原来的数据载入</li></ul><h3 id="两个程序共享物理存储"><a href="#两个程序共享物理存储" class="headerlink" title="两个程序共享物理存储"></a><strong>两个程序共享物理存储</strong></h3><p>程序的地址空间被划分成页（pages）或片段（segments）</p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L011-vm/image-20230607001556446.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="共享"></p><h3 id="虚拟存储器架构"><a href="#虚拟存储器架构" class="headerlink" title="虚拟存储器架构"></a><strong>虚拟存储器架构</strong></h3><p>部分进程临时存放在硬盘，一旦需要运行就载入内存</p><p>载入由操作系统执行，应用程序不需要知道虚拟存储器的存在</p><p>存储管理单元（MMU）将虚拟地址转换成物理地址</p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L011-vm/image-20230607001627575.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="存储器架构"></p><h1 id="二-虚拟存储器"><a href="#二-虚拟存储器" class="headerlink" title="二.虚拟存储器"></a>二.<strong>虚拟存储器</strong></h1><h3 id="地址转换"><a href="#地址转换" class="headerlink" title="地址转换"></a><strong>地址转换</strong></h3><p>存储器的数据传输单元为页（page）</p><ul><li>页大小：4KB ~ 16 KB</li><li>与缓存块大小设计类似</li><li>页太小：花费较长时间在磁盘寻址页</li><li>页太大：页中部分存储空间空闲</li></ul><p>在磁盘中寻址数据需要花费较长时间，一旦找到数据，能以每秒几MB的速度进行数据传输</p><p>如果页太大，页中部分存储空间空闲，造成内存中很大一部分存储空间的浪费</p><ul><li>虚拟地址到物理地址的转换由软硬件协同完成</li><li>存储访问请求首先需要进行地址转换</li><li>处理器请求的虚拟地址：<ul><li>高位字段代表虚拟页号（virtual page number）</li><li>低位字段代表页偏移（page offset）</li></ul></li></ul><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L011-vm/image-20230607001744207.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="va-pa"></p><h3 id="页表映射"><a href="#页表映射" class="headerlink" title="页表映射"></a><strong>页表映射</strong></h3><table><thead><tr><th><strong>页表（Page Table）</strong></th></tr></thead><tbody><tr><td>保存着虚拟地址和物理地址之间转换关系的表  Ø以虚拟页号为索引  Ø指向页表首地址的寄存器：页表寄存器（  page table register ）  页在内存中：页表中的对应项将包含虚页对应的物理页号及状态信息  页不在内存中：页表可以指向磁盘的交换区（swap space）中的地址</td></tr></tbody></table><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L011-vm/image-20230607001826178.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="页表"></p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L011-vm/image-20230607001839671.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="页表地址转换"></p><h4 id="缺页（page-fault）代价"><a href="#缺页（page-fault）代价" class="headerlink" title="缺页（page fault）代价"></a><strong>缺页（page fault）代价</strong></h4><ul><li>缺页时需要从磁盘提取页到内存<ul><li>一次缺页处理将花费数百万个时钟周期</li><li>由OS代码处理</li></ul></li><li>缺页处理<ul><li>用发生缺页的虚拟地址找到PTE</li><li>在磁盘中定位该页的位置</li><li>在页表中选择一页进行替换<ul><li>如果选择的页为脏页，则先写回磁盘</li></ul></li><li>将该页读入内存，并更新页表</li><li>恢复程序运行</li></ul></li><li>最小化缺页率<ul><li>采用全相联映射</li><li>优化的替换算法</li></ul></li></ul><h4 id="页替换与写"><a href="#页替换与写" class="headerlink" title="页替换与写"></a><strong>页替换与写</strong></h4><ul><li>降低缺页率，可以采用LRU替换策略<ul><li>采用引用位（Reference bit）或者使用位（use bit）表示对某一页的访问</li><li>引用位由OS周期性的置0</li><li>引用位为0表示该页最近没有使用</li></ul></li><li>写磁盘需要百万个时钟周期<ul><li>采用写回机制</li><li>页被写后脏页位置1</li></ul></li></ul><h3 id="虚拟存储下的数据访问"><a href="#虚拟存储下的数据访问" class="headerlink" title="虚拟存储下的数据访问"></a><strong>虚拟存储下的数据访问</strong></h3><p>程序每次访存至少需要两次</p><ul><li>获得物理地址</li><li>获得数据</li></ul><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L011-vm/image-20230607002029325.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="虚存访问"></p><h4 id="加快地址转换：TLB"><a href="#加快地址转换：TLB" class="headerlink" title="加快地址转换：TLB"></a><strong>加快地址转换：TLB</strong></h4><ul><li>CPU中特殊的地址转换Cache：快表（Translation Look-aside Buffer，TLB）</li><li>减少页表访问</li></ul><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L011-vm/image-20230607002101466.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="加上TLB的流程"></p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L011-vm/image-20230607002122018.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="映射机制"></p><h3 id="TLB"><a href="#TLB" class="headerlink" title="TLB"></a><strong>TLB</strong></h3><ul><li>与cache设计类似，可以是全相联、组相联、直接映射</li><li>容量比cache小，因此访问速度比cache 块</li><li>一般不超过512表项</li><li>TLB缺失<ul><li>如果页在内存中，缺失可以处理<ul><li>从内存中提取PTE到TLB</li><li>可以由硬件处理<ul><li>更复杂的页表结构</li></ul></li><li>或者由软件处理<ul><li>采用特殊的异常处理程序</li></ul></li></ul></li><li>如果页不在内存中，发生缺页（page fault）</li></ul></li></ul><h4 id="TLB与Cache"><a href="#TLB与Cache" class="headerlink" title="TLB与Cache"></a><strong>TLB与Cache</strong></h4><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L011-vm/image-20230607002304350.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="再加上cache"></p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L011-vm/image-20230607002314817.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="流程图"></p><h4 id="结合TLB的事件组合"><a href="#结合TLB的事件组合" class="headerlink" title="结合TLB的事件组合"></a><strong>结合TLB的事件组合</strong></h4><p>TLB&#x2F;Cache缺失：页&#x2F;块不在“缓存”中</p><p>缺页：页不在内存中</p><table><thead><tr><th><strong>TLB</strong></th><th><strong>Page  Table</strong></th><th><strong>Cache</strong></th><th><strong>是否可能发生？何种情况下发生？</strong></th></tr></thead><tbody><tr><td>Hit</td><td>Hit</td><td>Hit</td><td>是，全部命中是最好的情况</td></tr><tr><td>Hit</td><td>Hit</td><td>Miss</td><td>是，查找TLB找到物理地址后，缓存缺失</td></tr><tr><td>Miss</td><td>Hit</td><td>Hit</td><td>是，TLB缺失但能从页表找到物理地址</td></tr><tr><td>Miss</td><td>Hit</td><td>Miss</td><td>是，TLB缺失但能从页表找到物理地址，缓存缺失</td></tr><tr><td>Miss</td><td>Miss</td><td>Miss</td><td>是，缺页</td></tr><tr><td>Hit</td><td>Miss</td><td>Miss&#x2F;  Hit</td><td>否，TLB保存了页表的部分表项，不存在表项在TLB而不在页表的情况</td></tr><tr><td>Miss</td><td>Miss</td><td>Hit</td><td>否，如果缺页，数据不在内存，因此不可能在缓存</td></tr></tbody></table><h1 id="四-小结"><a href="#四-小结" class="headerlink" title="四.小结"></a>四.小结</h1><h4 id="存储器层次结构"><a href="#存储器层次结构" class="headerlink" title="存储器层次结构"></a><strong>存储器层次结构</strong></h4><ul><li>存储器层次结构共用许多原理</li><li>每个存储层次需要解决以下问题：<ul><li>数据放置问题</li><li>如何查找数据</li><li>发生缺失时的替换策略</li><li>写操作机制</li></ul></li></ul><h4 id="虚拟地址保护"><a href="#虚拟地址保护" class="headerlink" title="虚拟地址保护"></a><strong>虚拟地址保护</strong></h4><ul><li>程序可以共享部分虚拟地址空间<ul><li>需要防止非法修改和访问</li><li>需要OS支撑</li></ul></li><li>需要硬件支撑<ul><li>支撑两种模式：用户态和内核态</li><li>内核态指令</li><li>页表和其他状态信息只能在内核态访问</li><li>系统调用提供两种模式间的切换</li></ul></li></ul><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a><strong>小结</strong></h4><p>虚拟存储器是管理主存和磁盘之间数据缓存的一级存储器层次</p><p>允许单个程序在主存有限的容量内扩展地址空间</p><p>支持多个活跃的进程共享主存</p><p>需要将虚拟地址转换成物理地址</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;计算机组成与实践-虚拟存储器（Virtual-Memory）&quot;&gt;&lt;a href=&quot;#计算机组成与实践-虚拟存储器（Virtual-Memory）&quot; class=&quot;headerlink&quot; title=&quot;计算机组成与实践 -虚拟存储器（Virtual Memory）&quot;</summary>
      
    
    
    
    <category term="学习资料" scheme="https://www.emokable.top/categories/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/"/>
    
    
    <category term="课件笔记" scheme="https://www.emokable.top/tags/%E8%AF%BE%E4%BB%B6%E7%AC%94%E8%AE%B0/"/>
    
    <category term="计算机组成原理" scheme="https://www.emokable.top/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>嵌入式系统设计ch6-程序设计与分析</title>
    <link href="https://www.emokable.top/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1ch6-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/"/>
    <id>https://www.emokable.top/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1ch6-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/</id>
    <published>2023-05-28T13:38:24.000Z</published>
    <updated>2023-05-29T16:52:35.791Z</updated>
    
    <content type="html"><![CDATA[<h1 id="嵌入式系统设计-程序设计与分析"><a href="#嵌入式系统设计-程序设计与分析" class="headerlink" title="嵌入式系统设计-程序设计与分析"></a>嵌入式系统设计-程序设计与分析</h1><h2 id="一-嵌入式程序设计"><a href="#一-嵌入式程序设计" class="headerlink" title="一.嵌入式程序设计"></a>一.嵌入式程序设计</h2><h3 id="自然语言描述"><a href="#自然语言描述" class="headerlink" title="自然语言描述"></a>自然语言描述</h3><ul><li>直接使用语言文字描述设计过程</li><li>一般会结合其他方法使用</li></ul><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1ch6-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/image-20230528214238378.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="tu"></p><h3 id="形式化描述"><a href="#形式化描述" class="headerlink" title="形式化描述"></a>形式化描述</h3><p>通过严谨的数学语言、逻辑和公式描述</p><p>对开发工程师的知识背景要求严格</p><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1ch6-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/image-20230528214332855.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="形式化描述"></p><h3 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a>伪代码</h3><ul><li>伪代码是一种常用的描述程序设计方法</li><li>能够较为清晰地描述思路</li><li>通常使用伪代码设计核心部分</li></ul><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1ch6-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/image-20230528214407610.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="伪代码"></p><h3 id="结构图"><a href="#结构图" class="headerlink" title="结构图"></a>结构图</h3><ul><li>结构图<ul><li>结构图( structure chart)是一种自顶向下的模块化设计工具</li><li>系统由不同模块和线组成，用小方块表示模块，线表示模块之间的关系。</li><li>结构图用于高层设计或体系结构设计</li><li>帮助程序员划分大型软件，递归地将问题分解成可以理解的小问题</li></ul></li></ul><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1ch6-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/image-20230528214501986.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="树状"></p><p>结构图</p><ul><li>树状结构图</li><li>非树状结构图</li></ul><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1ch6-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/image-20230528214535525.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="非树状"></p><h3 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h3><p>流程图( flow chart)</p><ul><li>流程图是描述一个程序的工作流程或过程</li><li>使用方框表示步骤、菱形表示判断、带箭头的线表示执行流程</li><li>流程图表示对给定问题的解决方案</li><li>常用于分析、设计、记录或者管理的流程中</li></ul><p>例：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">for</span><span class="hljs-params">( A ; B ; C)</span></span><br><br>D<br></code></pre></td></tr></table></figure><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1ch6-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/image-20230528214946481.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="流程图"></p><h3 id="状态图-States-diagram"><a href="#状态图-States-diagram" class="headerlink" title="状态图( States diagram)"></a>状态图( States diagram)</h3><ul><li>状态图关注系统某一对象在生命周期内的特性和特性的变化，以及引起特性变化的时间和动作等</li><li>状态（state）是指在生命周期中某个特性，具有一定的时间稳定性，即会在一段时间内保持相对稳定。</li><li>转移( transition) 两个状态之间的变迁，表示在指定事件发生后，在特定的条件下，对象执行特定的动作从源状态转移到目标状态</li><li>转移由源状态、目标状态、触发事件、警戒条件和转移动作组成</li></ul><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1ch6-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/image-20230528215818235.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="状态图"></p><p>例：给定一个电话座机，打电话包含哪几种状态？并画出状态图</p><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1ch6-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/image-20230528215839235.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="是状态自动机吗？"></p><h4 id="控制-x2F-数据流图（CDFG）"><a href="#控制-x2F-数据流图（CDFG）" class="headerlink" title="控制&#x2F;数据流图（CDFG）"></a>控制&#x2F;数据流图（CDFG）</h4><p>数据流图（Data flow graph, DFG）</p><p>无条件程序模型，不能表示控制</p><p>基本语句块：</p><ul><li>无条件代码段</li><li>只有一个入口和出口</li><li>可操作的最大顺序语句序列</li></ul><p>单赋值形式：一个变量只能在赋值运算符左边出现一次</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">x</span> = a + b<span class="hljs-comment">;</span><br><span class="hljs-attr">y</span> = c - d<span class="hljs-comment">;</span><br><span class="hljs-attr">z</span> = x * y<span class="hljs-comment">;</span><br><span class="hljs-attr">y</span> = b + d<span class="hljs-comment">;</span><br><br></code></pre></td></tr></table></figure><p>两类结点</p><p>◼圆形结点：表示操作</p><p>◼方形结点：表示值</p><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1ch6-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/image-20230528220529867.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="DFG"></p><p>部分序：</p><p>▪<strong>a+b, c-d; b+d, x*y</strong></p><p>▪操作<strong>a+b</strong>和 <strong>c-d</strong>可以用任何顺序执行</p><p>▪操作<strong>b+d</strong>和<strong>x*y</strong>可以用任何顺序执行</p><h4 id="CDFG"><a href="#CDFG" class="headerlink" title="CDFG"></a>CDFG</h4><p>CDFG: 表示控制与数据的图</p><p>用数据流图表示组件，添加控制部分</p><p>CDFG有两种类型的节点</p><p>判断节点：描述的全部控制类型</p><p>数据流节点：一个完整的表示基本语句块的数据流图</p><p><strong>数据流节点</strong></p><ul><li>封装一个数据流图</li><li>在节点中完成写操作</li></ul><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1ch6-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/image-20230528220704006.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="DATA"></p><p><strong>判断节点</strong></p><p>◼ 描述控制类型</p><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1ch6-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/image-20230528220731093.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="CONTROL"></p><p>EX:</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs scss">if (cond1) <span class="hljs-built_in">bb1</span>();<br>else <span class="hljs-built_in">bb2</span>();<br><span class="hljs-built_in">bb3</span>();<br>switch (test1) &#123;<br>case c1: <span class="hljs-built_in">bb4</span>(); break;<br>case c2: <span class="hljs-built_in">bb5</span>(); break;<br>case c3: <span class="hljs-built_in">bb6</span>(); break;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1ch6-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/image-20230528220757073.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="SWITCH"></p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs gcode">for <span class="hljs-comment">(i=0; i&lt;N; i++)</span><br>loop_body<span class="hljs-comment">()</span>;<br>等价=&gt;<br>i=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span> <span class="hljs-comment">(i&lt;N)</span> &#123;<br>loop_body<span class="hljs-comment">()</span>; <br>i++; <br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1ch6-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/image-20230528220842074.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="for"></p><h3 id="嵌入式程序模型"><a href="#嵌入式程序模型" class="headerlink" title="嵌入式程序模型"></a>嵌入式程序模型</h3><p>有限状态机：响应系统</p><p>循环缓冲区：数字信号处理</p><p>队列：数字信号处理</p><h4 id="有限状态机（FSM）"><a href="#有限状态机（FSM）" class="headerlink" title="有限状态机（FSM）"></a>有限状态机（FSM）</h4><p>状态机具有离散动态的系统模型</p><ul><li>一种常用的状态机叫做有限状态机，表示状态数目是有限的</li><li>状态机建模适用于对时间驱动的系统，给定不同输入信号，系统根据这些输入信号做出不同响应</li><li>状态来表示系统的内部特性，状态的变化是基于输入的变化</li></ul><p>状态图是对状态机的一种图形表示</p><p>MOORE机、MEALY机 ???</p><p>应用:</p><ul><li>面向控制的代码</li><li>响应式系统</li><li>非周期性采样作为输入</li></ul><h5 id="EX-座位安全带控制器"><a href="#EX-座位安全带控制器" class="headerlink" title="EX:座位安全带控制器"></a>EX:座位安全带控制器</h5><blockquote><p>需求：</p><p>有人坐到座椅上，在规定时间内若没有系好安全带，就启动蜂鸣器</p><p>输入：</p><p>◼ seat: 是否有人坐；</p><p>◼ belt: 是否系安全带；</p><p>◼ timer: 定长计时器；</p><p>输出：</p><p>◼ 蜂鸣器</p><p>◼ 定时器</p><p>状态：</p><p>◼ state: 机器当前状态 </p></blockquote><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1ch6-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/image-20230528221226990.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="座位"></p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs pf"><span class="hljs-comment">#define IDLE 0</span><br><span class="hljs-comment">#define SEATED 1</span><br><span class="hljs-comment">#define BELTED 2</span><br><span class="hljs-comment">#define BUZZER 3</span><br>switch (<span class="hljs-keyword">state</span>) &#123;<br>case IDLE: <br>if (seat) &#123; <span class="hljs-keyword">state</span> = SEATED; <br>timer_on = TRUE; &#125;<br>break;<br>case SEATED: <br>if (belt) <span class="hljs-keyword">state</span> = BELTED;<br>else if (timer) <span class="hljs-keyword">state</span> = BUZZER;<br>break;<br>…<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="循环缓冲区"><a href="#循环缓冲区" class="headerlink" title="循环缓冲区"></a>循环缓冲区</h4><p>面向流的程序设计</p><p>数据流：按规律到达并需要在限定时间内处理</p><ul><li>FIR滤波器：面向流处理</li><li>有限脉冲响应（FIR）滤波器</li><li>乘积求和</li></ul><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1ch6-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/image-20230528222011572.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="累乘"></p><p>循环缓冲区</p><ul><li>固定数目</li><li>处理流数据的一种数据结构</li></ul><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1ch6-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/image-20230528222134158.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="什么滑动窗口"></p><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1ch6-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/image-20230528222254919.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="循环"></p><p>▪pos:当前采样的位置；</p><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1ch6-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/image-20230528222312124.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="移动"></p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-meta">#<span class="hljs-keyword">define</span> CMAX 6 <span class="hljs-comment">/* filter order */</span> </span><br><span class="hljs-type">int</span> circ[<span class="hljs-built_in">CMAX</span>]; <span class="hljs-comment">/* circular buffer */</span> <br><span class="hljs-type">int</span> pos; <span class="hljs-comment">/* position of current sample */</span> <br><br><span class="hljs-type">void</span> circ_init() &#123; <br><span class="hljs-type">int</span> i; <br><span class="hljs-keyword">for</span> (i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-built_in">CMAX</span>; i++) <span class="hljs-comment">/* set values to 0 */</span> <br>circ[i] = <span class="hljs-number">0</span>; <br>pos=<span class="hljs-built_in">CMAX</span><span class="hljs-number">-1</span>; <span class="hljs-comment">/* start at tail so first element at 0 */</span> <br>&#125;<br><span class="hljs-type">void</span> circ_update(<span class="hljs-type">int</span> xnew) &#123; <br><span class="hljs-comment">/* compute the new head value with wrap around; the pos </span><br><span class="hljs-comment">pointer moves from 0 to CMAX-1 */</span> <br>pos = ((pos == <span class="hljs-built_in">CMAX</span><span class="hljs-number">-1</span>) ? <span class="hljs-number">0</span> : (pos+<span class="hljs-number">1</span>)); <br><span class="hljs-comment">/* insert the new value at the new head */</span> <br>circ[pos] = xnew; <br>&#125;<br><span class="hljs-type">int</span> circ_get(<span class="hljs-type">int</span> i) &#123; <br><span class="hljs-type">int</span> ii; <br><span class="hljs-comment">/* compute the buffer position */</span> <br>ii = ((pos+<span class="hljs-number">1</span>)% <span class="hljs-built_in">CMAX</span> + (i<span class="hljs-number">-1</span>)) % <span class="hljs-built_in">CMAX</span>; <br><span class="hljs-keyword">return</span> circ[ii]; <span class="hljs-comment">/* return the value */</span> <br>&#125;<br></code></pre></td></tr></table></figure><h4 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h4><ul><li>生产者&#x2F;消费者</li><li>弹性缓冲区<ul><li>数据无法预料到达或离开的时间</li><li>构建队列的方法：<ul><li>链表</li><li>数组</li></ul></li></ul></li></ul><p><strong>生产者-消费者系统</strong></p><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1ch6-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/image-20230528222441589.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="队列法"></p><p>p1,p2是两个算法处理块</p><p>数据从单行缓存区的队列中发送到处理块中</p><p>数据q12是p1产生的数据，p2消费的数据</p><h2 id="二-嵌入式C语言编程"><a href="#二-嵌入式C语言编程" class="headerlink" title="二.嵌入式C语言编程"></a>二.嵌入式C语言编程</h2><p>C语言开发的嵌入式程序，其有如下优点：</p><p>◼表现能力和处理能力极强。它具有丰富的运算符和数据类型，便于实现各类复杂的数据结构</p><p>◼可读性强，易于调试和维护。采用自顶向下的设计方法，层次清晰，便于按模块方式组织程序</p><p>◼可移植性强。具有非处理器特定代码的特点</p><p>◼运算速度快，编译效率高。具有功能丰富的库函数，而且可以直接实现对系统硬件的控制</p><h3 id="嵌入式C语言编程方法"><a href="#嵌入式C语言编程方法" class="headerlink" title="嵌入式C语言编程方法"></a>嵌入式C语言编程方法</h3><p>嵌入式程序开发是硬件实现与软件编程相结合的开发过程。其开发的过程包括</p><p>◼了解开发板上的硬件属性</p><p>◼考察I&#x2F;O等外设的连线</p><p>◼采用模块化编程的思想。将整个系统分解成许多小模块，针对每个小模块进行编程</p><p>◼设计程序流程框架，根据流程框架整合各个模块形成完整系统</p><p>◼整合模块进行编译，若无问题，编译后生成的hex文件，下载到开发板中调试，排查其软硬件的问题</p><h3 id="嵌入式C语言元素"><a href="#嵌入式C语言元素" class="headerlink" title="嵌入式C语言元素"></a>嵌入式C语言元素</h3><p>嵌入式C语言编程通常具有三个方面的结构化元素</p><ul><li>预处理声明、定义和 include语句</li><li>主函数</li></ul><p><strong>While(TURE)</strong></p><p><strong>{</strong></p><p><strong>……</strong></p><p><strong>}</strong></p><ul><li>函数、异常和中断服务函数<ul><li>外设的访问通常基于忙等、中断、DMA的访问</li></ul></li></ul><h4 id="预处理声明、定义和-include语句"><a href="#预处理声明、定义和-include语句" class="headerlink" title="预处理声明、定义和 include语句"></a>预处理声明、定义和 include语句</h4><ol><li>用于包含文件的 include语句：include是一个用于包含某个文件内容的预处理语句，将给定文件的代码导</li></ol><p>入（粘贴）到当前文件中</p><ul><li>系统定义：#include <em>&lt;*filename*&gt;</em></li><li>用户定义：#include “filename”</li><li>以头文件(.h文件)的形式</li><li>可为后期的调试带来便利</li></ul><ol start="2"><li>预处理语句</li></ol><p>◼给编译器传达指示，提高程序的可读性</p><p>◼预处理语句 #define</p><p>​◼ 预处理全局变量</p><p><strong>#define GPLOH-MODER *(unsigned int*(GPIOH_BASE+0x00)</strong></p><p>​◼ 预处理常量</p><p><strong>#define TRUE</strong></p><ol start="3"><li>条件编译语句：</li></ol><p>◼#ifdef 说明当满足某条件时对一组语句编译，条件不满足时编译另一组语句的功能</p><p>◼采用条件编译指令，可以减少被编译的语句，从而减少目标代码的长度</p><p>◼在一个文件中，给出芯片不同系列的代码，使用不同编译器，…</p><p><strong>#ifdef</strong> <strong>标识符</strong></p><p>​<strong>程序段1</strong> </p><p><strong>#else</strong> </p><p>​<strong>程序段2</strong> </p><p><strong>#endif</strong></p><p>◼ 它的作用是当“标识符”已经被定义(一般是用#define定义)，则对#ifdef 下的程序段进行编译，否则编译#else下的程序段</p><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1ch6-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/image-20230528222925991.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="条件编译"></p><ol start="4"><li>import, extern, export声明</li></ol><p>◼C语言混合编程中</p><p>◼ extern，import表明变量或者函数是定义在其他文件中</p><p>◼ 表示本程序用到变量提供给其他模块调用</p><p>◼常用在多个源文件编译的程序中</p><p>◼在一个文件中定义全局变量，而在另一文件中用 extern对全局变量引用。编译器知道是在别处定义的外部变量</p><p>◼通过extern定义外部函数，其中extern可以省略，若函数不能被其他文件引用，在函数定义前加static</p><p>◼在程序连接时从其他文件中找此外部变量</p><p><strong>extern int value1;</strong></p><p><strong>extern int p(void);</strong> </p><ol start="5"><li>typedef 类型别名</li></ol><p>◼ 定义一种类型的别名，用 typedef 来定义与平台无关的类型</p><p>◼ 提高可移植性。当跨平台时，只要改 typedef 本身就行，不用对其他源码做任何修改</p><p>◼例，定义一个叫REAL 的浮点类型，表示最高精度的类型</p><p>◼在支持双精度的目标平台一上</p><p><strong>typedef long double REAL;</strong></p><p>◼在不支持 long double 的目标平台二上，改为：</p><p><strong>typedef double REAL;</strong></p><p>◼在连 double 都不支持的目标平台三上，改为：</p><p><strong>typedef float REAL;</strong></p><p>◼typedef 定义一种类型的新别名，在结构体、枚举类型中非常常见</p><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1ch6-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/image-20230528223106699.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="typedef"></p><ol start="6"><li>结构体：</li></ol><p>◼结构体是由具有相同或不同类型的数据项构成的数据集合</p><p>◼结构体可以被声明为变量、指针或数组等，以实现较复杂的数据结构</p><p>◼结构体指针作为函数的参数，可提高程序的可扩展性。</p><p>​◼例，串口，它的初始化由几个属性決定，若不使用结构体，一般的方法如下：</p><p><strong>void USART_Init(u16 usart, u32 Baudrate, u16 wordlengh,</strong> </p><p><strong>u16 stopbites, u16 parity, u8 mode)</strong></p><p>​◼将串口有关的参数组合到一个结构体里面</p><p><strong>void USART_Init(u16 usart,USART_InitTypeDef uart_initdef)</strong></p><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1ch6-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/image-20230528223601644.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="struct"></p><ol start="7"><li>位运算操作</li></ol><p>◼在嵌入式系统编程中，位运算比其他运算更常用</p><p>◼嵌入式系统涉及到很多有关硬件寄存器的操作</p><p>◼硬件寄存器由若干位组成，对配置、读写等属性控制</p><p>◼C语言没有专门对指定位操作的语法，在进行位操作的时候，需要对指令进行简单的组合来完成此功能</p><p>◼C语言位运算操作符有6个：&amp;, |, ~, ^, &lt;&lt;, &gt;&gt;</p><p>◼例：</p><p>​◼判断 x 第 n 位是否为1；</p><p><strong>if x &amp; (1 &lt;&lt; n)</strong></p><p>​◼对于单个或多个位置 0 或置 1 的操作</p><p><strong>GPIOH_MODER&amp; &#x3D;~(0x03 &lt;&lt; (2*10));</strong> </p><p><strong>GPIOH_MODER |&#x3D; (01 &lt;&lt; 2*10);</strong></p><p>​◼获取寄存器 x 的第 3∼7 位的值</p><p><strong>x &#x3D; (x &amp; (0x1f &lt;&lt; 3)) &gt;&gt; 3;</strong></p><p>​◼给寄存器 a 的 bit3∼bit7 赋值 0xc</p><p><strong>a &#x3D; (a &amp; (~(0x1f &lt;&lt; 3)))| (0xc &lt;&lt; 3);</strong></p><p>​◼给寄存器 a 的 bit3 ∼ bit7 加上 0xd</p><p><strong>tmp &#x3D; (a &amp; (0x1f &lt;&lt; 3)) &gt;&gt; 3;</strong></p><p><strong>tmp +&#x3D; 0xd;</strong></p><p><strong>a &#x3D; a &amp; (~(0x1f &lt;&lt; 3));</strong></p><p><strong>a |&#x3D; tmp &lt;&lt; 3;</strong></p><p>◼给寄存器 a 的 bit3 ∼ bit7 赋值 4 和 bit8 ∼ bit12 赋值 7</p><p><strong>a &#x3D; (a &amp; (~0x1f &lt;&lt; 3)) | (4 &lt;&lt; 3);</strong></p><p><strong>a &#x3D; (a &amp; (~0x1f &lt;&lt; 8)) | (7 &lt;&lt; 8)；</strong></p><h2 id="三-编译及优化技术"><a href="#三-编译及优化技术" class="headerlink" title="三.编译及优化技术"></a>三.编译及优化技术</h2><ul><li>编译是将一种语言转换成另一种语言的过程</li><li>翻译和优化两个阶段<ul><li>翻译即将高级语言解释为机器识别的语言</li><li>优化是指将机器识别的语言进行修改以提升其执行性能的过程</li></ul></li></ul><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1ch6-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/image-20230528223827928.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="编译优化"></p><h3 id="代码翻译："><a href="#代码翻译：" class="headerlink" title="代码翻译："></a>代码翻译：</h3><ul><li>词法分析：将字符流分组为一个词（token）</li><li>语法分析：根据语法规则形成语法树</li><li>语义分析：确保组成部分有意义</li><li>中间代码：显式中间抽象表示</li><li>符号表的生成：记录使用的标识符及其各种属性信息的一个数据结构</li><li>代码生成：生成目标代码</li></ul><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1ch6-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/image-20230528223927611.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="translate"></p><h4 id="代码优化"><a href="#代码优化" class="headerlink" title="代码优化"></a>代码优化</h4><ul><li>代码优化过程改进中间代码，产生执行速度更快的机器代码</li><li>优化阶段包括机器无关的优化和与具体机器特征相关的指令集优化<ul><li>机器无关的优化涉及程序的逻辑结构、数据表示以及变量计算等方面</li><li>指令集优化是和CPU的流水线以及高速缓存相关的优化</li></ul></li></ul><p>代码翻译</p><ul><li>源程序翻译过程包括词法分析、语法分析和语义分析。</li><li>在典型应用中，大量代码都是由算术表达式和逻辑表达式构成。</li><li>在词法分析中，表达式扫描后的空格被删除。经过词法分析，几组分类的记号被生成，这些分组的字符将被存储到一个字符表中。</li><li>语法分析也叫层次分析，各个记号被进一步分组，根据语法规则产生记号之间的依赖，形成语法树，相当于代码生成的层次结构。</li><li>表达式x&#x3D;4 *a+5 *(b-c)的语法树如图所示。</li></ul><blockquote><p>例：表达式x&#x3D;4 *a+5 *(b-c)经过词法分析，得到的单词和记号有：</p><p>◼ 标识符：x </p><p>◼ 赋值符号：&#x3D; </p><p>◼ 数字：4 </p><p>◼ 乘号操作符：* </p><p>◼ 标识符：a </p><p>◼ 加法操作符：+ </p><p>◼ 数字：5 </p><p>◼ 乘法操作符：* </p><p>◼ 标识符：（</p><p>◼ 标识符：b </p><p>◼ 减法操作符：− </p><p>◼ 标识符：c </p><p>◼ 标识符：）</p></blockquote><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1ch6-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/image-20230528224537160.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="语法树"></p><p>▪表达式x&#x3D;4* a+5*(b-c)代码生成，采用的数据流模型</p><p>若是ARM</p><ul><li>寄存器选择</li><li>变量放入寄存器</li><li>存放中间结果的寄存器</li></ul><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1ch6-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/image-20230528224644879.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="数据流"></p><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1ch6-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/image-20230528224700914.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="汇编"></p><h4 id="控制结构的翻译"><a href="#控制结构的翻译" class="headerlink" title="控制结构的翻译"></a>控制结构的翻译</h4><ul><li>控制语句除了有表达式，还存在大量的控制流程<ul><li>如if语句中包含布尔表达式。</li></ul></li><li>控制流本身翻译成中间代码也是必不可缺的。</li><li>通过CDFG图表示控制结构并进行翻译<ul><li>遍历条件表达式。根据数据流图方式生成该表达式中变量加载等信息的代码</li><li>测试判定表达式。编译器会为判定表达式创建能够在分支中测试的条件代码和标记</li><li>在各个分支指令中运用表达式翻译方法生成相应代码</li><li>通过遍历，得到汇编代码</li></ul></li></ul><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs abnf">if (a &gt; b)<br>x <span class="hljs-operator">=</span> a<span class="hljs-comment">;</span><br>else<br>x <span class="hljs-operator">=</span> b<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1ch6-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/image-20230528224853537.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="控制代码"></p><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1ch6-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/image-20230528224910289.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="1"></p><h4 id="过程的翻译"><a href="#过程的翻译" class="headerlink" title="过程的翻译"></a>过程的翻译</h4><ul><li><p>每次过程调用，将建立过程参数并执行调用，之后还要返回到原来代码位置。</p></li><li><p>过程调用包括保存现场、运行过程及恢复现场，使用过程栈</p><ul><li>过程栈从高位地址到低位地址建立。</li><li>栈指针(sp)定义了当前栈帧在内存中的结束地址，</li><li>帧指针(fp)定义了当前栈帧在内存中的起始地址。</li><li>过程通过栈指针将相关数据保存在栈中，运行过程结束后，从栈中取出数据恢复原代码的环境</li></ul></li><li><p>需要代码做</p><ul><li>调用和返回</li><li>传递参数和返回结果</li></ul></li><li><p>参数和结果被返回到堆栈中</p></li><li><p>对ARM</p><ul><li>R0-R3用来传递程序的前4个参数</li><li>R0 用来保存返回值</li></ul></li></ul><blockquote><p>APCS（ARM过程调用标准）</p><p>▪ r0-r3传递参数给过程，额外的参数放到栈中；</p><p>▪ r0 保持返回的值</p><p>▪ r4-r7保留寄存器的值</p><p>▪ r11是帧指针fp，指向栈底；r13是栈指针sp</p><p>▪ r10是指示栈界限的寄存器，以判断栈是否溢出</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">int <span class="hljs-function"><span class="hljs-title">fun</span> <span class="hljs-params">(int i)</span></span> <br>&#123; int a = <span class="hljs-number">2</span>; <br><span class="hljs-keyword">return</span> a * i;&#125;<br>int main (void) <br>&#123;int i = <span class="hljs-number">25</span>; <br><span class="hljs-function"><span class="hljs-title">fun</span><span class="hljs-params">(i)</span></span>; <br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<br></code></pre></td></tr></table></figure><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs armasm">; fun <span class="hljs-meta">function</span> &lt; fun &gt; <br><span class="hljs-keyword">PUSH</span> &#123; <span class="hljs-built_in">fp</span> &#125; <br><span class="hljs-keyword">ADD</span> <span class="hljs-built_in">FP</span>, <span class="hljs-built_in">SP</span>, # <span class="hljs-number">0</span> <br><span class="hljs-keyword">STR</span> <span class="hljs-built_in">R0</span>, [ <span class="hljs-built_in">FP</span>, #− <span class="hljs-number">16</span> ] <br><span class="hljs-keyword">MOV</span> <span class="hljs-built_in">R3</span>, # <span class="hljs-number">2</span> <br><span class="hljs-keyword">STR</span> <span class="hljs-built_in">R3</span>, [ <span class="hljs-built_in">FP</span>, #−<span class="hljs-number">8</span> ] <br><span class="hljs-keyword">LDR</span> <span class="hljs-built_in">R3</span>, [ <span class="hljs-built_in">FP</span>, #−<span class="hljs-number">8</span> ] <br><span class="hljs-keyword">LDR</span> <span class="hljs-built_in">R2</span>, [ <span class="hljs-built_in">FP</span>, #− <span class="hljs-number">16</span> ] <br><span class="hljs-keyword">MUL</span> R <span class="hljs-number">3</span>,R <span class="hljs-number">2</span>, <span class="hljs-built_in">R3</span> <br><span class="hljs-keyword">MOV</span> <span class="hljs-built_in">R0</span>, <span class="hljs-built_in">R3</span> <br><span class="hljs-keyword">SUB</span> <span class="hljs-built_in">SP</span>, <span class="hljs-built_in">FP</span>, # <span class="hljs-number">0</span> <br><span class="hljs-keyword">POP</span> &#123;<span class="hljs-built_in">FP</span>&#125; <br><span class="hljs-keyword">BX</span> <span class="hljs-built_in">LR</span> <br>; main <span class="hljs-meta">function</span> &lt;main &gt; <br><span class="hljs-keyword">PUSH</span> &#123; <span class="hljs-built_in">FP</span>, <span class="hljs-built_in">LR</span>&#125; <br><span class="hljs-keyword">ADD</span> <span class="hljs-built_in">FP</span>, <span class="hljs-built_in">SP</span>, <span class="hljs-number">#4</span> <br><span class="hljs-keyword">SUB</span> <span class="hljs-built_in">SP</span>, <span class="hljs-built_in">SP</span>, <span class="hljs-number">#8</span> <br><span class="hljs-keyword">MOV</span> <span class="hljs-built_in">R3</span>, # <span class="hljs-number">25</span> <br><span class="hljs-keyword">STR</span> <span class="hljs-built_in">R3</span>, [ <span class="hljs-built_in">FP</span>, #−<span class="hljs-number">8</span> ]<br><span class="hljs-keyword">LDR</span> <span class="hljs-built_in">R0</span>, [ <span class="hljs-built_in">FP</span>, #−<span class="hljs-number">8</span> ]<br><span class="hljs-keyword">BL</span> <span class="hljs-number">822</span>c &lt; fun &gt;<br><span class="hljs-keyword">MOV</span> <span class="hljs-built_in">R3</span>, # <span class="hljs-number">0</span><br><span class="hljs-keyword">MOV</span> <span class="hljs-built_in">R0</span>, <span class="hljs-built_in">R3</span><br><span class="hljs-keyword">SUB</span> <span class="hljs-built_in">SP</span>, <span class="hljs-built_in">FP</span>, <span class="hljs-number">#4</span><br><span class="hljs-keyword">POP</span> &#123;<span class="hljs-built_in">FP</span>, <span class="hljs-built_in">PC</span>&#125;<br></code></pre></td></tr></table></figure><h4 id="编译过程的代码优化"><a href="#编译过程的代码优化" class="headerlink" title="编译过程的代码优化"></a>编译过程的代码优化</h4><p>机器无关的优化，主要是软件方面的优化，修改源程序从而提高代码的性能</p><p>机器相关的优化，如指令集的选择，寄存器的分配，高速缓存优化，流水线的优化等</p><h5 id="指令选择与调度"><a href="#指令选择与调度" class="headerlink" title="指令选择与调度"></a>指令选择与调度</h5><ul><li>对语法树生成的指令代码进行优化<ul><li>效率更高的指令替换中间代码生成指令</li><li>指令重排来改变流水线的性能。</li></ul></li><li>指令集的丰富程度决定了可选指令的范围，要求指令集的一</li><li>致性和完整性</li><li>指令调度就是选择指令的过程<ul><li>本地调度是不能跨基本块边界移动</li><li>全局调度则可跨越基本块的指令调度</li><li>模调度对内循环不同迭代次数来消除流水线气泡的一种技术</li><li>跟踪调度跟踪最常执行的控制流路径实现优化<ul><li>超级块调度则是跟踪调度的一种简化版本。</li></ul></li></ul></li></ul><h5 id="寄存器分配"><a href="#寄存器分配" class="headerlink" title="寄存器分配"></a>寄存器分配</h5><ul><li>CPU的寄存器是有限的<ul><li>若无可用寄存器，续借助内存完成计算</li></ul></li><li>最优的寄存器分配方案是一个NP完全问题<ul><li>某些寄存器有特殊用途或者其使用必须遵循一定约束</li><li>寄存器数目是有限的，这又增加了问题的复杂度</li></ul></li></ul><h5 id="计算次序的选择"><a href="#计算次序的选择" class="headerlink" title="计算次序的选择"></a>计算次序的选择</h5><p>计算执行的次序也会影响目标代码的效率</p><ul><li>计算次序的选择所影响的是寄存器分配问题</li><li>计算次序是更上层的改进</li></ul><p><strong>a&#x3D;b+c ;</strong> </p><p><strong>y&#x3D;d + 2;</strong> </p><p><strong>z&#x3D;c + 3;</strong> </p><p><strong>x&#x3D;a+b ;</strong></p><p>◼ <strong>需要5个寄存器</strong></p><p><strong>a&#x3D;b+c ;</strong> </p><p><strong>x&#x3D;a+b ;</strong> </p><p><strong>y&#x3D;d + 2;</strong> </p><p><strong>z&#x3D;c + 3;</strong></p><p>◼ <strong>需要4个寄存器</strong></p><h5 id="窥孔优化"><a href="#窥孔优化" class="headerlink" title="窥孔优化"></a>窥孔优化</h5><ul><li>窥孔优化是一种局部优化方法，通过检査目标指令的短序列（称为窥孔），用更小更短的指令序列代替这些指令以提高目标程序的性能</li><li>窥孔优化的特征是每次改进可能又为进一步的改进带来机会，且由于占用内存较小而执行速度很快</li><li>窥孔优化常用方法包括冗余加载和保存、删除死代码、控制流优化、强度削弱以及机器语言的使用</li></ul><p>冗余加载和保存</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-keyword">ADR</span> <span class="hljs-built_in">r4</span> , a <br><span class="hljs-keyword">LDR</span> <span class="hljs-built_in">r0</span> , [<span class="hljs-built_in">r4</span>] <br><span class="hljs-keyword">STR</span> <span class="hljs-built_in">r0</span> , [<span class="hljs-built_in">r4</span>]<br></code></pre></td></tr></table></figure><p>▪删除死代码</p><p>删除死代码</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs gauss"><span class="hljs-meta"># <span class="hljs-keyword">define</span> DEBUG 0</span><br><br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">DEBUG</span>)<br><br><span class="hljs-built_in">dbg</span>(p1) ;<br></code></pre></td></tr></table></figure><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1ch6-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/image-20230528225716536.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="窥孔优化-删除"></p><p>控制流优化</p><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1ch6-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/image-20230528225909363.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="控制流"></p><p>强度削弱：目标机器上用时间开销小的等价操作代替时间开销大的操作</p><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1ch6-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/image-20230528225938957.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="左移"></p><p>机器语言的使用</p><ul><li>内嵌的汇编代码，是很典型机器语言的使用<ul><li>有些场合纯 C 语言无法实现<ul><li>例如，协处理器指令、软中断指令、特殊定制指令</li></ul></li><li>提高效率</li></ul></li></ul><h2 id="四-程序性能分析与优化"><a href="#四-程序性能分析与优化" class="headerlink" title="四.程序性能分析与优化"></a>四.程序性能分析与优化</h2><ul><li>程序执行时间<ul><li>程序的执行时间是最重要的嵌入式系统性能评价指标，尤其是对时间关键的实时嵌入式系统。</li></ul></li><li>软件分析方法<ul><li>软件分析的方法通常采用插桩技术，在程序关键代码处插入一段能采集当前程序执行性能的代码。</li><li>当程序执行时，可实际测量出程序的性能信息</li><li>问题：在源程序中插入一段代码尽管不影响源程序的执行结果，但这使得测试环境不够真实，同时在数据导入和导出时会产生额外的开销</li></ul></li><li>硬件分析方式</li><li>在总线上的计时器监控程序运行时的总线信息，采样或者实时检测的方式，测量程序的真实执行时间采用硬件测量的方式在速度上是有优势的</li><li>问题：<ul><li>通用性差，程序在不同的硬件环境中执行可能得到差别较大的执行时间</li><li>数据完备性和准确性无法得到保证</li><li>会造成系统长时间的负载，导致资源的浪费</li></ul></li></ul><h3 id="程序执行时间–静态动态分析"><a href="#程序执行时间–静态动态分析" class="headerlink" title="程序执行时间–静态动态分析"></a>程序执行时间–静态动态分析</h3><ul><li><p>静态分析方法指在不通过程序执行的情况下，静态分析程序的结构和语句，获得程序执行时间的方法</p></li><li><p>平均执行时间( Average Case Execution Time,ACET)</p><ul><li>典型数据期望的典型执行时间</li></ul></li><li><p>最坏执行时间( Best Case Execution Time,BCET)</p><ul><li>程序花费在任何输入序列中的最长运行时间</li><li>对有时限要求的系统是非常重要的</li></ul></li><li><p>最好执行时间( Worst Case Execution Time,WCET)</p><ul><li>程序花费在任何输入序列中的最短运行时间</li><li>测量多速率实时系统时非常重要</li></ul></li><li><p>动态分析方法是收集程序运行时的性能信息，以找到具有性能优化潜力的热点代码</p></li><li><p>动态分析需要大量运行时的信息以确保数据的准确性</p></li><li><p>在一定的阈值内，同时需要额外的测量开销，最常用的动态分析方法是软件测试</p></li></ul><h4 id="代码级分析方法"><a href="#代码级分析方法" class="headerlink" title="代码级分析方法"></a>代码级分析方法</h4><ul><li>代码级分析方法就是针对源程序结构本身的性能分析方法，是编译器最常用的优化技术</li><li>通过对程序本身的控制结构、数据流等关系进行分析，分析程序本身的执行路径，通过程序路径的指令周期来共同计算程序的执行时间</li><li>程序路径分析使用整数线性规划(ILP)的方法来隐式的解决路径问题，使用一个约束条件集合描述程序的结构及其行为的某些方面</li></ul><p>枚举法用于简单具有有限确定执行路径的方法</p><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1ch6-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/image-20230528230843421.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="枚举"></p><p>控制&#x2F;数据流图(CDFG)：</p><p>循环结构程序路径的确定</p><ul><li>循环初始模块执行一次</li><li>判断执行了N+1次</li><li>循环体和循环变量各执行了N次</li></ul><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">for (i<span class="hljs-operator">=</span><span class="hljs-number">0</span><span class="hljs-comment">; i&lt;N; i++) </span><br>&#123;a[i]<span class="hljs-operator">=</span> b[i]*c[i]<span class="hljs-comment">; &#125;</span><br></code></pre></td></tr></table></figure><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1ch6-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/image-20230528230943058.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="代码级"></p><h3 id="程序执行时间"><a href="#程序执行时间" class="headerlink" title="程序执行时间"></a>程序执行时间</h3><ul><li>指令的执行时间<ul><li>CPU厂商通常提供了某些操作指令的CPU周期数表</li></ul></li><li>高速缓存的影响</li><li>流水线技术对执行时间的影响</li><li>执行时间的分析有很多方法，关键是分析程序的哪个部分比较耗时，优化就从这里开始</li></ul><h3 id="性能优化–与机器无关的性能优化"><a href="#性能优化–与机器无关的性能优化" class="headerlink" title="性能优化–与机器无关的性能优化"></a>性能优化–与机器无关的性能优化</h3><h4 id="循环优化"><a href="#循环优化" class="headerlink" title="循环优化"></a>循环优化</h4><p>代码移出</p><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1ch6-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/image-20230528231121940.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="移出"></p><p>归纳变量共享和强度削减</p><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1ch6-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/image-20230528231140898.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="归纳"></p><p>循环展开</p><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1ch6-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/image-20230528231158598.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="一次当两次"></p><p>循环合并</p><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1ch6-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/image-20230528231219388.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="二合一"></p><h4 id="算法与数据结构的优化"><a href="#算法与数据结构的优化" class="headerlink" title="算法与数据结构的优化"></a>算法与数据结构的优化</h4><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1ch6-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/image-20230528231240119.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="直接换成数组可还行"></p><h4 id="过程调用的优化"><a href="#过程调用的优化" class="headerlink" title="过程调用的优化"></a>过程调用的优化</h4><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1ch6-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/image-20230528231538412.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="过程"></p><h3 id="性能优化–与机器相关的性能优化"><a href="#性能优化–与机器相关的性能优化" class="headerlink" title="性能优化–与机器相关的性能优化"></a>性能优化–与机器相关的性能优化</h3><h4 id="寄存器调度"><a href="#寄存器调度" class="headerlink" title="寄存器调度"></a>寄存器调度</h4><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk">w=a*b; <span class="hljs-regexp">/*阶 段1*/</span> <br>x=c+d; <span class="hljs-regexp">/*阶 段2*/</span> <br>y=w+e ; <span class="hljs-regexp">/*阶 段3*/</span> <br>z=a<span class="hljs-regexp">/b ; /</span>* 阶 段<span class="hljs-number">4</span>*/<br></code></pre></td></tr></table></figure><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1ch6-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/image-20230528231632770.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="周期"></p><p>生命周期图↑</p><p>每个变量的生命周期为</p><p>a 持续第 1<em>∼</em>4 阶段； d 持续第 2 阶段； x 持续第 2 阶段；</p><p>b 持续第 1<em>∼</em>4 阶段； e 持续第 3 阶段； y 持续第 3 阶段；</p><p>c 持续第 2 阶段； w 持续第 1<em>∼</em>3 阶段； z 持续第 4 阶段。</p><p> 需要6个寄存器</p><p>优化后： </p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk">w=a*b; <span class="hljs-regexp">/*阶 段1*/</span> <br>x=a<span class="hljs-regexp">/b; /</span>*阶 段<span class="hljs-number">2</span>*/ <br>y=w+e; <span class="hljs-regexp">/*阶 段3*/</span> <br>z=c+d; <span class="hljs-regexp">/*阶 段4*/</span><br></code></pre></td></tr></table></figure><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1ch6-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/image-20230528231710076.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="优化后"></p><p>需要4个寄存器</p><h4 id="高速缓存优化"><a href="#高速缓存优化" class="headerlink" title="高速缓存优化"></a>高速缓存优化</h4><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1ch6-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/image-20230528231856410.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="图"></p><h3 id="程序功耗分析与优化"><a href="#程序功耗分析与优化" class="headerlink" title="程序功耗分析与优化"></a>程序功耗分析与优化</h3><ul><li>功耗是嵌入式系统性能的另一个重要指标，是基于电池供电的最重要性能指标之一。</li><li>功耗的优化<ul><li>时钟控制、使用功耗敏感的处理器、低电压以及无用电路子部件的关闭</li></ul></li><li>软件控制功耗<ul><li>对系统设置不同的模式，如空闲时的休眠状态、运行时的运行状态等。</li><li>改变处理器的时钟频率（降频）</li><li>采用动态功耗管理的策略降低非关键任务的功耗</li></ul></li></ul><h4 id="功耗的测量评估"><a href="#功耗的测量评估" class="headerlink" title="功耗的测量评估"></a>功耗的测量评估</h4><p>通过循环体测量</p><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1ch6-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/image-20230528232037019.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="循环"></p><p>从指令级的角度对程序的功耗进行评估</p><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1ch6-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/image-20230528232118191.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="指令集"></p><h4 id="程序功耗分析与优化-1"><a href="#程序功耗分析与优化-1" class="headerlink" title="程序功耗分析与优化"></a>程序功耗分析与优化</h4><ul><li>硬件相关的功耗优化<ul><li>有效使用寄存器</li><li>分析高速缓存的行为来避免或减少缓存冲突</li><li>存储模式中采用页模式访问</li></ul></li><li>轮询机制优化<ul><li>程序在等待访问外设时可能会采用轮询的方法，轮询会让处理器重复地执行几条指令，会带来大量的能量浪费。通常的做法是使用一些替代的方法，如对外设的访问使用中断的方式替代</li><li>客户服务器协作模型中，将客户端不停地査询服务，改为服务器主动推服务给客户端，这是一种很有用的机制，能大大降低功耗</li></ul></li></ul><h4 id="程序尺寸分析与优化"><a href="#程序尺寸分析与优化" class="headerlink" title="程序尺寸分析与优化"></a>程序尺寸分析与优化</h4><ul><li>程序尺寸是指编译后生成的二进制代码的大小</li><li>优化程序尺寸通常从两方面来考虑：指令和数据<ul><li>指令正确高效的调度，是缩小代码尺寸的基本措施。</li></ul></li><li>方法–模板匹配<ul><li>模板匹配是指令集映射的核心</li><li>对于一个给定的指令序列，通过模板匹配将该序列进行最优的覆盖</li></ul></li></ul><p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1ch6-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/image-20230528233207025.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="模板匹配"></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul><li>嵌入式程序的设计方法</li><li>程序模型</li><li>汇编语言和C语言编程技术</li><li>编译及优化技术</li><li>嵌入式软件的性能分析</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;嵌入式系统设计-程序设计与分析&quot;&gt;&lt;a href=&quot;#嵌入式系统设计-程序设计与分析&quot; class=&quot;headerlink&quot; title=&quot;嵌入式系统设计-程序设计与分析&quot;&gt;&lt;/a&gt;嵌入式系统设计-程序设计与分析&lt;/h1&gt;&lt;h2 id=&quot;一-嵌入式程序设计&quot;&gt;&lt;a</summary>
      
    
    
    
    <category term="学习资料" scheme="https://www.emokable.top/categories/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/"/>
    
    
    <category term="课件笔记" scheme="https://www.emokable.top/tags/%E8%AF%BE%E4%BB%B6%E7%AC%94%E8%AE%B0/"/>
    
    <category term="嵌入式程序设计" scheme="https://www.emokable.top/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>计算机组成原理-L010-cache</title>
    <link href="https://www.emokable.top/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L010-cache/"/>
    <id>https://www.emokable.top/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L010-cache/</id>
    <published>2023-05-23T01:55:14.000Z</published>
    <updated>2023-05-24T17:55:46.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="计算机组成与实践-缓存（Cache）"><a href="#计算机组成与实践-缓存（Cache）" class="headerlink" title="计算机组成与实践 -缓存（Cache）"></a><strong>计算机组成与实践</strong> -<strong>缓存（Cache）</strong></h1><h2 id="一-简介"><a href="#一-简介" class="headerlink" title="一.简介"></a>一.<strong>简介</strong></h2><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L010-cache/image-20230523100509867.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="示意图"></p><p>缓存是基于局部性原理设计的存储器体系层次，能够有效的提升数据访问速度</p><h4 id="麒麟990-5G芯片"><a href="#麒麟990-5G芯片" class="headerlink" title="麒麟990 5G芯片"></a>麒麟990 5G芯片</h4><p>8核：2个Cortex-A76（2.86GHz），2个Cortex-A76（2.36GHz），4个Cortex-A55（1.95GHz）</p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L010-cache/image-20230523095910296.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="huawei"></p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L010-cache/image-20230523095921416.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="990"></p><h3 id="缓存-内存映射"><a href="#缓存-内存映射" class="headerlink" title="缓存-内存映射"></a>缓存-内存映射</h3><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L010-cache/image-20230523100554128.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="映射"></p><ul><li>内存单元到缓存行间的对于关系</li><li>缓存行（Cache line）&#x3D;缓存块（Cache block）</li><li>设计点：<ul><li>可以快速判断缓存命中或缺失</li><li>充分利用容量有限的缓存，提高命中率</li></ul></li></ul><table><thead><tr><th align="left"><strong>硬件设计需要解决的问题</strong></th></tr></thead><tbody><tr><td align="left">1、如何判断数据是否在缓存中</td></tr><tr><td align="left">2、如果在缓存中，如何找到该数据</td></tr></tbody></table><h3 id="缓存行"><a href="#缓存行" class="headerlink" title="缓存行"></a><strong>缓存行</strong></h3><p>缓存容量远小于内存容量</p><p>多对一映射</p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L010-cache/image-20230523100729681.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="多对一"></p><h2 id="二-直接映射（Direct-Mapping）"><a href="#二-直接映射（Direct-Mapping）" class="headerlink" title="二.直接映射（Direct Mapping）"></a>二.<strong>直接映射（Direct Mapping）</strong></h2><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L010-cache/image-20230523100856419.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="存储形式"></p><ul><li>每个缓存块中有2^4&#x3D;16 bytes</li><li>2^7&#x3D;128个缓存块</li><li>2^(7+5）&#x3D;4096个内存块</li></ul><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L010-cache/image-20230523100927956.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="memory to cache"></p><ul><li>缓存块号&#x3D;（内存块地址）mod（缓存中块总数）<ul><li>内存块j映射到 （j mod 128）缓存块</li></ul></li><li>如果标签相同，则缓存命中</li></ul><table><thead><tr><th><strong>地址分为3个字段</strong></th></tr></thead><tbody><tr><td>块号字段决定存储在内存的哪个块</td></tr><tr><td>标签字段用于区分不同的内存块（内存块到缓存块是多对一的关系）</td></tr><tr><td>字节偏移字段用于选择需要访问的数据（字或字节等）</td></tr></tbody></table><p><strong>例如：给出地址（t,b,w）(16-bit)</strong></p><p>1、用t与缓存块b中的tag作比较，确定该数据是否在缓存中</p><p>2、如果不相同，缓存缺失（Cache miss），用内存块（t,b）(12-bit)替换缓存块b</p><p><strong>CPU需要访问数据，其地址为[A7B4]&#x3D;1010011110110100</strong></p><p>1、检索缓存块1111011，查看其tag是否为10100</p><p>2、如果是，命中</p><p>3、如果不是，从内存读取该块到缓存块1111011中，并更新tag为10100</p><h4 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h4><p>假设缓存有4个块，每个缓存块大小为1 word，初始时为空，给出以下内存块地址：0,1,2,3,4,3,4,15，计算缓存命中率</p><table><thead><tr><th>INDEX</th><th>TAG</th><th>DATA</th></tr></thead><tbody><tr><td>00</td><td></td><td></td></tr><tr><td>01</td><td></td><td></td></tr><tr><td>10</td><td></td><td></td></tr><tr><td>11</td><td></td><td></td></tr></tbody></table><p>块地址有16个，需要4bit，index占2bit，那么tag位也占4-2&#x3D;2bit，index&#x3D;n%4, tag&#x3D;n&#x2F;4</p><p>0-index00-tag00      4-index00-tag014hit</p><p>1-index01-tag00</p><p>2-index10-tag00</p><p>3-index11-tag00  3hit15-index11-tag11   总共hit 2次命中率25%</p><h3 id="MIP中的直接映射缓存"><a href="#MIP中的直接映射缓存" class="headerlink" title="MIP中的直接映射缓存"></a><strong>MIP中的直接映射缓存</strong></h3><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L010-cache/image-20230523101414345.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="DIR"></p><p>缓存块大小为1 word（4 bytes）</p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L010-cache/image-20230523101436520.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="DIR2"></p><p>缓存块大小为4 word（16 bytes）</p><h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a><strong>例子</strong></h4><p>假设缓存有2个块，每个缓存块大小为2-word，初始时为空，给出以下内存块地址：0,1,2,3,4,3,4,15，计算缓存命中率</p><table><thead><tr><th>INDEX</th><th>TAG</th><th>DATA(1)</th><th>DATA(2)</th></tr></thead><tbody><tr><td>00</td><td></td><td></td><td></td></tr><tr><td>01</td><td></td><td></td><td></td></tr></tbody></table><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L010-cache/image-20230523101654410.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="ANS"></p><p>16&#x3D;2^4,index占了2bit，tag也是2bit，不过是一次取2word比如0-1，2-3，4-5,index就是（n&#x2F;2）%2，tag就是(n&#x2F;2)&#x2F;2</p><p> 8次访问，4次命中，命中率为50%</p><h3 id="MIPS缓存设计"><a href="#MIPS缓存设计" class="headerlink" title="MIPS缓存设计"></a><strong>MIPS缓存设计</strong></h3><p>缓存需要存储数据以及与其对应的标签</p><ul><li>2^n个块的直接映射缓存，n个bit用于索引</li><li>大小为2^m个字（ 2^(m+2) 个字节）的缓存块，m个bit用于寻址块中的字</li><li>2 bit用于寻址一个字中的字节</li></ul><table><thead><tr><th><strong>标签字段的大小</strong></th></tr></thead><tbody><tr><td>32  -（n  + m + 2）</td></tr></tbody></table><table><thead><tr><th><strong>直接映射缓存中存储的总的bit</strong></th></tr></thead><tbody><tr><td>2^n ×（块大小 + 标签字段大小 + 有效位大小）</td></tr></tbody></table><h4 id="练习-1"><a href="#练习-1" class="headerlink" title="练习"></a>练习</h4><blockquote><p>假设一个直接映射的cache，有16 KB的数据，块大小为4 words，地址为32 bits，那么该cache总共需要多少位？</p><p>4word&#x3D;16Bytes ，字节寻址块偏移位4bits，块数目16KB&#x2F;16Bytes&#x3D;1024&#x3D;2^10 ,直接用10bit来索引,tag&#x3D;32-10-4&#x3D;18bits</p><p>CacheSize&#x3D;Number*(1 valid bit +tag + Blocksize)&#x3D;2^10 *（1bits+18bits +32bits * 4）&#x3D; 147Kb</p><p>思考了一下：这里的16KB都是缓存块存的数据部分大小，因此求出的块数目2^10，就是index&#x3D;10，通过32bits地址和2bits块内偏移可以直接得出tag&#x3D;18，那么顺势也能得到总共有2^(18+10)个内存块，对这2^28个内存块求tag和index也是÷和%得到（这样就和前面的串起来了）</p></blockquote><p>老师的版本：16KB&#x3D;4096words，根据块大小有4096&#x2F;4&#x3D;1024个块</p><p>每个块存有是4*32&#x3D;128bits数据</p><p>标签字大小：32-（10+2+2）&#x3D;18bits</p><p>每个块有1bit有效位，总cache大小2^10(128+18+1)&#x3D;147Kb</p><h2 id="三-组相联映射（Associative-Mappin）"><a href="#三-组相联映射（Associative-Mappin）" class="headerlink" title="三.组相联映射（Associative Mappin）"></a>三.<strong>组相联映射（Associative Mappin）</strong></h2><h3 id="全相联映射"><a href="#全相联映射" class="headerlink" title="全相联映射"></a><strong>全相联映射</strong></h3><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L010-cache/image-20230523103331651.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="全相连"></p><ul><li>每个缓存块中有2^4&#x3D;16 bytes</li><li>128个缓存块</li><li>2^12&#x3D;4096个内存块</li></ul><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L010-cache/image-20230523103431604.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="全"></p><p><strong>内存块可以映射到任意的缓存块</strong>（没有对应吧关系）</p><p>128个缓存块的标签需要与地址的标签位进行并行的比较（硬件实现）</p><p><strong>CPU需要访问数据，其地址为[A7B4]&#x3D;1010011110110100</strong></p><p>1、查看其tag是否为101001111011</p><p>2、如果是，命中</p><p>3、如果不是，从内存读取该块到任意空闲缓存块（如果没有空闲缓存块，就采用缓存替换策略进行替换），并更新tag为101001111011</p><h3 id="组相联映射"><a href="#组相联映射" class="headerlink" title="组相联映射"></a><strong>组相联映射</strong></h3><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L010-cache/image-20230523103515048.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="组相联"></p><p>每个缓存块中有2^4&#x3D;16 bytes</p><p>128个缓存块分为2^6&#x3D;64个组</p><p>2^12&#x3D;4096个内存块</p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L010-cache/image-20230523103613077.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="组相联"></p><p>结合了直接映射与全相联映射的特点</p><p>缓存组号&#x3D;（内存块地址）mod（缓存中组总数）；内存块j映射到 （j mod 64）缓存组</p><p>每组有K个块称为<strong>K路组相联缓存</strong></p><h4 id="2路相联映射（每组两个块-是两个块而不是每组两个数据，数据是和字节偏移对应的）"><a href="#2路相联映射（每组两个块-是两个块而不是每组两个数据，数据是和字节偏移对应的）" class="headerlink" title="2路相联映射（每组两个块-是两个块而不是每组两个数据，数据是和字节偏移对应的）"></a><strong>2路相联映射</strong>（每组两个块-是两个块而不是每组两个数据，数据是和字节偏移对应的）</h4><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L010-cache/image-20230523103657398.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="2way"></p><p>2路组相联（2-way set associative）：</p><p>CPU需要访问数据，其地址为[A7B4]&#x3D;1010011110110100</p><p>1、检测缓存组111011</p><ul><li>缓存块1110110</li><li>缓存块1110111</li></ul><p>2、检测缓存组中是否其中一个缓存块的标签为101001</p><p>3、如果是，命中</p><p>4、如果不是，从内存读取该块到缓存组111011中空闲的缓存块（如果没有空闲缓存块，就采用缓存替换策略进行替换），并更新tag为101001</p><h4 id="MIPS中的组相联映射缓存"><a href="#MIPS中的组相联映射缓存" class="headerlink" title="MIPS中的组相联映射缓存"></a><strong>MIPS中的组相联映射缓存</strong></h4><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L010-cache/image-20230523103738074.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="组相联"></p><h2 id="四-替换策略"><a href="#四-替换策略" class="headerlink" title="四.替换策略"></a>四.<strong>替换策略</strong></h2><h3 id="处理缓存的读请求"><a href="#处理缓存的读请求" class="headerlink" title="处理缓存的读请求"></a><strong>处理缓存的读请求</strong></h3><ul><li>适用于I cache和D cache</li><li>命中<ul><li>顺利读取数据</li></ul></li><li>缺失<ul><li>阻塞流水线</li><li>从下层存储层级获取请求的数据</li><li>数据保存至缓存，读取请求的字</li><li>恢复流水线运行</li></ul></li></ul><h3 id="处理缓存写命中"><a href="#处理缓存写命中" class="headerlink" title="处理缓存写命中"></a><strong>处理缓存写命中</strong></h3><p>D cache</p><table><thead><tr><th><strong>策略1：写直达（Write-Through）</strong></th></tr></thead><tbody><tr><td>保持缓存和内存数据的一致性</td></tr><tr><td>将数据同时写回到缓存和下层存储层级</td></tr><tr><td>加入写缓缓冲（write  buffer），只有写缓冲满时才停止写回缓存</td></tr></tbody></table><table><thead><tr><th><strong>策略2：写回(Write-Back）</strong></th></tr></thead><tbody><tr><td>只将数据写回到缓存</td></tr><tr><td>只有需要将缓存块驱逐（evicted）时，才写回到下层存储层级</td></tr><tr><td>每个缓存块需要1  bit 脏块（dirty）标记</td></tr></tbody></table><h3 id="处理缓存写缺失"><a href="#处理缓存写缺失" class="headerlink" title="处理缓存写缺失"></a><strong>处理缓存写缺失</strong></h3><table><thead><tr><th><strong>策略1：带写缓冲的写直达缓存</strong></th></tr></thead><tbody><tr><td>没有写分配（No-write  allocate）：内存块更新后，不重新载入缓存</td></tr><tr><td>跳过缓存更新，但是需要将该缓存块置位无效</td></tr><tr><td>将写回数据写入写缓冲</td></tr></tbody></table><table><thead><tr><th><strong>策略2：写回缓存</strong></th></tr></thead><tbody><tr><td>写分配</td></tr><tr><td>更新缓存中的数据，包括标签和数据</td></tr><tr><td>不需要写命中检测</td></tr></tbody></table><h3 id="没有写分配的写直达缓存"><a href="#没有写分配的写直达缓存" class="headerlink" title="没有写分配的写直达缓存"></a><strong>没有写分配的写直达缓存</strong></h3><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L010-cache/image-20230523104254506.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="没有写分配"></p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L010-cache/image-20230523104314788.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="2"></p><h3 id="替换算法"><a href="#替换算法" class="headerlink" title="替换算法"></a><strong>替换算法</strong></h3><ul><li>直接映射：不需要选择替换的块</li><li>组相联映射：<ul><li>首先映射到有效位为0的项</li><li>如果没有，在该组的项中挑选一个项替换</li></ul></li><li>最近最少使用（Least-recently used，LRU）<ul><li>替换很长时间没有使用的块</li><li>不适用于超过4路的组相联映射</li></ul></li><li>随机替换<ul><li>当相联度较高时，与LRU性能类似</li></ul></li></ul><p><strong>缓存例子</strong></p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-built_in">short</span> A[<span class="hljs-number">10</span>][<span class="hljs-number">4</span>];<br><span class="hljs-built_in">int</span>   <span class="hljs-keyword">sum</span>=<span class="hljs-number">0</span>;<br><span class="hljs-built_in">int</span>   j,i;<br><span class="hljs-built_in">double</span> mean;<br><br><span class="hljs-comment">//forward loop</span><br><span class="hljs-keyword">for</span> (j=<span class="hljs-number">0</span>;j&lt;=<span class="hljs-number">9</span>;j++)<br>     <span class="hljs-keyword">sum</span> +=A[j][<span class="hljs-number">0</span>];<br><span class="hljs-comment">//backward loop</span><br><span class="hljs-keyword">for</span> (i=<span class="hljs-number">9</span>;i&gt;=<span class="hljs-number">0</span>;i--)<br>     A[i][<span class="hljs-number">0</span>]=A[i][<span class="hljs-number">0</span>]/mean;<br></code></pre></td></tr></table></figure><p>数据缓存大小为8 块</p><p>A [ 10 ] [4]存储地址空间为7A00-7A27</p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L010-cache/image-20230523104605859.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="tu"></p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L010-cache/image-20230523104644075.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="table"></p><p>假设采用16 bit地址，并且1 字大小为1 byte（也就是说没有字节偏移位）</p><ul><li>直接映射：13 bits 标签，3 bits 块号</li><li>全相联：16 bits标签</li><li>2路组相联：15 bits 标签，1 bit组号</li></ul><h3 id="直接映射"><a href="#直接映射" class="headerlink" title="直接映射"></a><strong>直接映射</strong></h3><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L010-cache/image-20230523104721334.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="direct"></p><ul><li>只有两个缓存块被使用（注意看，都是A[X] [0],只看上面标红的地址7A00&amp;7A04）,读图以列为状态单位，从左往右读，比如j&#x3D;0时，cache里块0装A00;j&#x3D;1时，块0还是A00，块4新写入A10</li><li>缓存利用率低</li></ul><h3 id="全相联映射-1"><a href="#全相联映射-1" class="headerlink" title="全相联映射"></a><strong>全相联映射</strong></h3><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L010-cache/image-20230523104817036.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="all"></p><p>使用LRU替换策略</p><h3 id="2路组相联"><a href="#2路组相联" class="headerlink" title="2路组相联"></a><strong>2路组相联</strong></h3><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L010-cache/image-20230523104855835.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="2way"></p><p>只有一半的缓存块被使用</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a><strong>分析</strong></h3><ul><li>全相联映射缓存最好，组相联缓存次之，直接映射缓存最差</li><li>通常情况使用组相联映射，并采用LRU替换策略</li><li>较大的cache 块能更好地利用空间局部性以降低缺失率</li><li>在固定块大小的cache中<ul><li>较大块-&gt;块的数量减少</li><li>地址映射的竞争增大-&gt;增加缺失率(用直接映射来思考，块数量少了，一个缓存块需要对应的内存块就更多了，竞争大)</li><li>较大块-&gt;空间局部性降低</li></ul></li></ul><h2 id="五-小结"><a href="#五-小结" class="headerlink" title="五.小结"></a><strong>五.小结</strong></h2><ul><li>缓存结构<ul><li>直接映射、全相联映射、组相联映射</li></ul></li><li>替换策略<ul><li>随机替换、LRU</li></ul></li><li>缓存命中与缺失代价</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;计算机组成与实践-缓存（Cache）&quot;&gt;&lt;a href=&quot;#计算机组成与实践-缓存（Cache）&quot; class=&quot;headerlink&quot; title=&quot;计算机组成与实践 -缓存（Cache）&quot;&gt;&lt;/a&gt;&lt;strong&gt;计算机组成与实践&lt;/strong&gt; -&lt;str</summary>
      
    
    
    
    <category term="学习资料" scheme="https://www.emokable.top/categories/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/"/>
    
    
    <category term="课件笔记" scheme="https://www.emokable.top/tags/%E8%AF%BE%E4%BB%B6%E7%AC%94%E8%AE%B0/"/>
    
    <category term="计算机组成原理" scheme="https://www.emokable.top/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>ARM体系结构与编程-第4章-ARM程序设计基础-伪指令2</title>
    <link href="https://www.emokable.top/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC4%E7%AB%A0-ARM%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%80-%E4%BC%AA%E6%8C%87%E4%BB%A42/"/>
    <id>https://www.emokable.top/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC4%E7%AB%A0-ARM%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%80-%E4%BC%AA%E6%8C%87%E4%BB%A42/</id>
    <published>2023-05-21T14:07:29.000Z</published>
    <updated>2023-05-21T14:37:51.601Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ARM体系结构与编程"><a href="#ARM体系结构与编程" class="headerlink" title="ARM体系结构与编程"></a>ARM体系结构与编程</h1><h2 id="第4章-ARM程序设计基础"><a href="#第4章-ARM程序设计基础" class="headerlink" title="第4章 ARM程序设计基础"></a><strong>第4章</strong> ARM程序设计基础</h2><h2 id="4-2-汇编语言的语句格式"><a href="#4-2-汇编语言的语句格式" class="headerlink" title="4.2 汇编语言的语句格式"></a>4.2 汇编语言的语句格式</h2><ul><li>ARM（Thumb）汇编语言的语句格式为：</li><li><strong>{标号}  {指令或伪指令}  {；注释}</strong></li><li>标号必须从一行的行头开始，并且符号中不能包含空格。</li><li>指令不能从一行的行头开始，即在一行语句中，指令的前面必须有空格或者标号。</li><li>在汇编语言程序设计中，每一条指令的助记符可以全部用大写、或全部用小写，但不允许在一条指令中大、小写混用。</li><li>寄存器可以大写或小写。</li><li>伪指令有些必须在一行的开头顶格书写，另外一些必须留有空格。</li><li>注释以分号“；”开头，到行末结束。</li><li>如果一条语句太长，可将该长语句分为若干行来书写，在行的末尾用“****”表示下一行与本行为同一条语句。</li><li>在源程序中，语句之间可以插入空行，增强可读性。</li></ul><p><strong>常数：数值、布尔值、字符或字符串</strong></p><ul><li>数字：十进制数、十六进制数</li><li>布尔值：{TRUE&#x2F;FALSE}</li><li>字符：由左右单引号组成</li><li>字符串：由左右双引号括住多个字符或空格组成</li></ul><p><img src="/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC4%E7%AB%A0-ARM%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%80-%E4%BC%AA%E6%8C%87%E4%BB%A42/image-20230521221151411.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="主视图"></p><p><strong>汇编语言的源程序主要由指令、伪指令、语句标号和注释组成。</strong></p><ul><li>指令：一条指令一般是一个简短的汇编语句行，由指令助记符和操作数、操作寄存器或语句标号组成。</li><li>伪指令：<ul><li>通过伪指令把设计意图表达给编译器，编译器依据这些伪指令，组织、编译和连接程序；</li><li>大多数伪指令在编译后都不留痕迹。</li></ul></li><li>语句标号：语句标号的主要作用有两个：<ul><li>一是表达地址；</li><li>二是为一段语句命名，以方便记忆和阅读。</li></ul></li><li>注释：注释是为了方便阅读和记忆。</li></ul><h3 id="4-2-1-在汇编语言程序中常用的符号"><a href="#4-2-1-在汇编语言程序中常用的符号" class="headerlink" title="4.2.1 在汇编语言程序中常用的符号"></a><strong>4.2.1</strong> <strong>在汇编语言程序中常用的符号</strong></h3><ul><li>在汇编语言程序设计中，经常使用各种符号代替地址、变量和常量等，以增加程序的可读性。</li><li>尽管符号的命名由编程者决定，但并不是任意的，必须遵循以下的约定：<ul><li><strong>符号由大小写字母、数字以及下划线组成；</strong></li><li><strong>局部标号以数字开头，其他的符号都不能以数字开头；</strong></li><li><strong>符号区分大小写，同名的大、小写符号会被编译器认为是两个不同的符号；</strong></li><li><strong>符号在其作用范围内必须唯一；</strong></li><li><strong>自定义的符号名不能与系统的保留字相同；</strong></li><li><strong>符号名不应与指令或伪指令同名。</strong></li></ul></li></ul><h4 id="1、-程序中的变量"><a href="#1、-程序中的变量" class="headerlink" title="1、 程序中的变量"></a>1、 程序中的变量</h4><ul><li>程序中的变量是指其值在程序的运行过程中可以改变的量。ARM（Thumb）汇编程序所支持的变量有数字变量、逻辑变量和字符串变量。</li><li>数字变量用于在程序的运行中保存数字值，但注意数字值的大小不应超出数字变量所能表示的范围。</li><li>逻辑变量用于在程序的运行中保存逻辑值，逻辑值只有两种取值情况：真{true}或假{false}。</li><li>字符串变量用于在程序的运行中保存一个字符串，但注意字符串的长度不应超出字符串变量所能表示的范围。</li><li>在ARM（Thumb）汇编语言程序设计中，可使用GBLA、GBLL、GBLS伪指令声明全局变量；使用LCLA、LCLL、LCLS伪指令声明局部变量；并可使用SETA、SETL和SETS对其进行初始化。</li></ul><h4 id="2、-程序中的常量"><a href="#2、-程序中的常量" class="headerlink" title="2、 程序中的常量"></a>2、 程序中的常量</h4><ul><li>程序中的常量是指其值在程序的运行过程中不能被改变的量。ARM（Thumb）汇编程序所支持的常量有数字常量、逻辑常量和字符串常量。<ul><li>数字常量一般为32位的整数，当作为无符号数时，其取值范围为0～232-1；当作为有符号数时，其取值范围为-2^31～2^31-1。</li><li>逻辑常量只有两种取值情况：真或假。</li><li>字符串常量为一个固定的字符串，一般用于程序运行时的信息提示。</li></ul></li><li>使用EQU来定义数字常量。</li></ul><h4 id="3、-程序中的变量替换"><a href="#3、-程序中的变量替换" class="headerlink" title="3、 程序中的变量替换"></a>3、 程序中的变量替换</h4><ul><li>程序中的变量可通过替换操作取得一个常量。</li><li>替换操作符为“**$**”。<ul><li>如果在数字变量前面有一个代换操作符“$”，编译器会将该数字变量的值转换为十六进制的字符串，并将该十六进制的字符串替换“$”后的数字变量。</li><li>如果在逻辑变量前面有一个替换操作符“$”，编译器会将该逻辑变量替换为它的取值（真或假）。</li><li>如果在字符串变量前面有一个替换操作符“$”，编译器会将该字符串变量的值替换“$”后的字符串变量。</li></ul></li><li>使用示例：</li></ul><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs armasm"> <span class="hljs-meta">LCLS</span> <span class="hljs-built_in">S1</span> ；定义局部字符串变量<span class="hljs-built_in">S1</span>和<span class="hljs-built_in">S2</span><br><br> <span class="hljs-meta">LCLS</span> <span class="hljs-built_in">S2</span> <br><br> <span class="hljs-built_in">S1</span> <span class="hljs-meta">SETS</span> “Test！”<br><br> <span class="hljs-built_in">S2</span> <span class="hljs-meta">SETS</span> “This is a $<span class="hljs-built_in">S1</span>” <br><br>；字符串变量<span class="hljs-built_in">S2</span>的值为“This is a Test！”<br></code></pre></td></tr></table></figure><ul><li><p>变量替换的特殊情况：</p><ul><li>如果需要字符$，则用$$来表示。</li><li>包含在两个竖线（|）之间的$不进行变量替换，但如果竖线是在双引号内，则将进行变量替换。</li><li>使用“**.**”来表示变量名称的结束。</li><li></li><li></li><li></li></ul><p>例如</p></li><li><p>&#96;&#96;&#96;<br> STR1  SETS  “STRING”<br> STR2  SETS  “THISISA$STR1.INSETENCE”</p><figure class="highlight nestedtext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs nestedtext"><br>  <span class="hljs-comment">#### 4、标号</span><br><br>标号是表示程序中的指令或数据地址的符号，主要有三种：<br><br><span class="hljs-bullet">-</span> <span class="hljs-string">基于PC的标号</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">是位于目标指令前或者程序中数据定义伪操作前的标号。</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">被处理成PC值加上或减去一个数字常量。</span><br><span class="hljs-bullet">-</span> <span class="hljs-string">基于寄存器的标号</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">通常用MAP和FIELD伪操作定义，或用EQU伪操作定义。</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">被处理成寄存器的值加上或减去一个数字常量。</span><br><span class="hljs-bullet">-</span> <span class="hljs-string">绝对地址</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">绝对地址是一个32位的数字量。</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">寻址范围为0～231-1，即可以寻址整个内存空间。</span><br><br><span class="hljs-comment">#### 5、局部标号</span><br><br>局部标号主要在局部范围使用。<br><br>局部标号定义的语法格式：<br><br></code></pre></td></tr></table></figure></li></ul><p>N{routname}</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs excel"><br><span class="hljs-built_in">N</span>为<span class="hljs-number">0</span>－<span class="hljs-number">99</span>的数字,routname为当前作用范围的名称。<br><br>局部变量引用的语法格式：<br><br></code></pre></td></tr></table></figure><pre><code class="hljs">    %&#123;F|B&#125;&#123;A|T&#125;   N&#123;routname&#125;</code></pre><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs clean"><br>### **<span class="hljs-number">4.2</span><span class="hljs-number">.2</span>** **汇编语言程序中的表达式和运算符**<br><br>在汇编语言程序设计中，也经常使用各种表达式，表达式一般由变量、常量、运算符和括号构成。<br><br>常用的表达式有数字表达式、逻辑表达式和字符串表达式，其运算次序遵循如下的优先级：<br><br>- 优先级相同的双目运算符的运算顺序为从左到右。<br>- 相邻的单目运算符的运算顺序为从右到左，且单目运算符的优先级高于其他运算符。<br>- 括号运算符的优先级最高。<br><br>#### <span class="hljs-number">1</span>、 数字表达式及运算符<br><br>数字表达式一般由数字常量、数字变量、数字运算符和括号构成。与数字表达式相关的运算符如下：<br><br> “＋”、“－”、“×”、“/” 及“MOD”算术运算符<br><br> 以上的算术运算符分别代表加、减、乘、除和取余数运算。例如，以X和Y表示两个数字表达式，则：<br><br></code></pre></td></tr></table></figure><p>X＋Y;表示X与Y的和<br>X－Y;表示X与Y的差<br>X×Y;表示X与Y的乘积<br>X&#x2F;Y;表示X除以Y的商<br>X：MOD：Y;表示X除以Y的余数</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><br>“<span class="hljs-keyword">ROL</span>”、“<span class="hljs-keyword">ROR</span>”、“<span class="hljs-keyword">SHL</span>”及“<span class="hljs-keyword">SHR</span>”移位运算符<br><br> 以X和Y表示两个数字表达式，以上的移位运算符代表的运算如下：<br><br></code></pre></td></tr></table></figure><pre><code class="hljs">X：ROL：Y;表示将X循环左移Y位X：ROR：Y;表示将X循环右移Y位X：SHL：Y;表示将X左移Y位X：SHR：Y;表示将X右移Y位</code></pre><figure class="highlight tp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs tp"><br>“<span class="hljs-keyword">AND</span>”、“<span class="hljs-keyword">OR</span>”、“NOT”及“EOR”按位逻辑运算符<br><br> 以<span class="hljs-keyword">X</span>和<span class="hljs-keyword">Y</span>表示两个数字表达式，以上的**按位**逻辑运算符代表的运算如下：<br><br></code></pre></td></tr></table></figure><p>X：AND：Y;表示将X和Y按位作逻辑与的操作<br>X：OR：Y;表示将X和Y按位作逻辑或的操作<br>：NOT：Y;表示将Y按位作逻辑非的操作<br>X：EOR：Y;表示将X和Y按位作逻辑异或的操作</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs clean"><br>#### <span class="hljs-number">2</span>、 逻辑表达式及运算符<br><br>逻辑表达式一般由逻辑量、逻辑运算符和括号构成，其表达式的运算结果为真或假。与逻辑表达式相关的运算符如下：<br><br> “=”、“&gt;”、“&lt;”、“&gt;=”、“&lt;= ”、“/=”、“ &lt;&gt;” 运算符<br><br>以X和Y表示两个逻辑表达式，以上的运算符代表的运算如下<br><br></code></pre></td></tr></table></figure><pre><code class="hljs">X = Y;表示X等于YX &gt; Y;表示X大于YX &lt; Y;表示X小于YX &gt;= Y;表示X大于等于YX &lt;= Y;表示X小于等于YX /= Y;表示X不等于YX &lt;&gt; Y;表示X不等于Y</code></pre><figure class="highlight tp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs tp"><br>“LAND”、“LOR”、“LNOT”及“LEOR”运算符<br><br> 以<span class="hljs-keyword">X</span>和<span class="hljs-keyword">Y</span>表示两个逻辑表达式，以上的逻辑运算符代表的运算如下：<br><br></code></pre></td></tr></table></figure><p>X：LAND：Y;表示将X和Y作逻辑与的操作<br>X：LOR：Y;表示将X和Y作逻辑或的操作<br>：LNOT：Y;表示将Y作逻辑非的操作<br>X：LEOR：Y;表示将X和Y作逻辑异或的操作</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs clean"><br>操作结果为&#123;FALSE&#125;或&#123;TRUE&#125;<br><br>#### <span class="hljs-number">3</span>、 字符串表达式及运算符<br><br>字符串表达式一般由字符串常量、字符串变量、运算符和括号构成。编译器所支持的字符串最大长度为<span class="hljs-number">512</span>字节。常用的与字符串表达式相关的运算符如下：<br><br>**LEN运算符**<br><br> LEN运算符返回字符串的长度（字符数），以X表示字符串表达式，其语法格式如下：<br><br></code></pre></td></tr></table></figure><pre><code class="hljs">：LEN：X</code></pre><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs autoit"><br>**<span class="hljs-built_in">CHR</span>运算符**<br><br><span class="hljs-built_in">CHR</span>运算符将<span class="hljs-number">0</span>～<span class="hljs-number">255</span>之间的整数转换为一个ASCII字符，以M表示某一个整数，其语法格式如下：<br><br></code></pre></td></tr></table></figure><pre><code class="hljs">：CHR：M</code></pre><figure class="highlight hsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs hsp"><br>**<span class="hljs-keyword">STR</span>运算符**<br><br><span class="hljs-keyword">STR</span>运算符将将一个数字表达式或逻辑表达式转换为一个字符串。对于数字表达式，<span class="hljs-keyword">STR</span>运算符将其转换为一个以十六进制组成的字符串；对于逻辑表达式，<span class="hljs-keyword">STR</span>运算符将其转换为字符串T或F，其语法格式如下：<br><br></code></pre></td></tr></table></figure><pre><code class="hljs">：STR：X</code></pre><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css"><br> 其中，X为一个数字表达式或逻辑表达式。<br><br>**<span class="hljs-attribute">LEFT</span>运算符**<br><br> <span class="hljs-attribute">LEFT</span>运算符返回某个字符串左端的一个子串，其语法格式如下：<br><br></code></pre></td></tr></table></figure><pre><code class="hljs">X：LEFT：Y</code></pre><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css"><br> 其中：X为源字符串，Y为一个整数，表示要返回的字符个数。<br><br>**<span class="hljs-attribute">RIGHT</span>运算符**<br><br> 与<span class="hljs-attribute">LEFT</span>运算符相对应，<span class="hljs-attribute">RIGHT</span>运算符返回某个字符串右端的一个子串，其语法格式如下：<br><br></code></pre></td></tr></table></figure><pre><code class="hljs">X：RIGHT：Y</code></pre><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs stata"><br> 其中：X为源字符串，Y为一个整数，表示要返回的字符个数。<br><br><span class="hljs-comment">**CC运算符**</span><br><br> <span class="hljs-keyword">CC</span>运算符用于将两个字符串连接成一个字符串，其语法格式如下：<br><br></code></pre></td></tr></table></figure><pre><code class="hljs">X：CC：Y</code></pre><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs clean"><br> 其中：X为源字符串<span class="hljs-number">1</span>，Y为源字符串<span class="hljs-number">2</span>，CC运算符将Y连接到X的后面。<br><br>#### <span class="hljs-number">4</span>、 与寄存器和程序计数器（PC）相关的表达式及运算符<br><br> 常用的与寄存器和程序计数器（PC）相关的表达式及运算符如下：<br><br> **BASE运算符**<br><br>BASE运算符返回基于寄存器的表达式中寄存器的编号，其语法格式如下：<br><br></code></pre></td></tr></table></figure><p> ：BASE：X</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs delphi"><br> 其中，X为与寄存器相关的表达式。<br><br>**<span class="hljs-keyword">INDEX</span>运算符**<br><br> <span class="hljs-keyword">INDEX</span>运算符返回基于寄存器的表达式中相对于其基址寄存器的偏移量，其语法格式如下：<br><br></code></pre></td></tr></table></figure><p> ：INDEX：X</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs clean"><br> 其中，X为与寄存器相关的表达式。<br><br>####  <span class="hljs-number">5</span>、 其他常用运算符<br><br>**？运算符**<br><br> ？运算符返回某代码行所生成的可执行代码的长度，例如：<br><br></code></pre></td></tr></table></figure><pre><code class="hljs">?X</code></pre><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><br> 返回定义符号X的代码行所生成的可执行代码的字节数。<br><br>**<span class="hljs-keyword">DEF</span>运算符**<br><br> <span class="hljs-keyword">DEF</span>运算符判断是否定义某个符号，例如：<br><br></code></pre></td></tr></table></figure><pre><code class="hljs">：DEF：X</code></pre><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs gherkin"><br> 如果符号X已经定义，则结果为真，否则为假。<br><br>操作符运算顺序<br><br>|<span class="hljs-string">      </span>|<span class="hljs-string"> 单目操作                 </span>|<span class="hljs-string"> 备注           </span>|<br>|<span class="hljs-string"> ---- </span>|<span class="hljs-string"> ------------------------ </span>|<span class="hljs-string"> -------------- </span>|<br>|<span class="hljs-string"> 1    </span>|<span class="hljs-string"> *、/、MOD                </span>|<span class="hljs-string"> 乘除和取模     </span>|<br>|<span class="hljs-string"> 2    </span>|<span class="hljs-string"> SHL、SHR、ROR、ROL       </span>|<span class="hljs-string"> 移位运算       </span>|<br>|<span class="hljs-string"> 3    </span>|<span class="hljs-string"> +、-、AND、OR、EOR       </span>|<span class="hljs-string"> 加减和逻辑运算 </span>|<br>|<span class="hljs-string"> 4    </span>|<span class="hljs-string"> ==、&gt;、&gt;=、&lt;、&lt;=、/=、&lt;&gt; </span>|<span class="hljs-string"> 各种逻辑运算   </span>|<br>|<span class="hljs-string"> 5    </span>|<span class="hljs-string"> LAND、LOR、LEOR          </span>|<span class="hljs-string"> 逻辑运算       </span>|<br><br><span class="hljs-comment">## 4.3 汇编语言的程序结构</span><br><br><span class="hljs-comment">### **4.3.1** **汇编语言的程序结构**</span><br><br>在ARM（Thumb）汇编语言程序中，以程序<span class="hljs-symbol">*</span><span class="hljs-symbol">*</span>段<span class="hljs-symbol">*</span><span class="hljs-symbol">*</span>为单位组织代码。段是相对独立的指令或数据序列，具有特定的名称。<br><br>段可以分为代码段和数据段，代码段的内容为执行代码，数据段存放代码运行时需要用到的数据。<br><br>一个汇编程序至少应该有一个代码段，当程序较长时，可以分割为多个代码段和数据段，多个段在程序编译链接时最终形成一个可执行的映象文件。<br><br>可执行映象文件通常由以下几部分构成：<br><br>- <span class="hljs-symbol">*</span><span class="hljs-symbol">*</span>一个或多个代码段，代码段的属性为只读。<span class="hljs-symbol">*</span><span class="hljs-symbol">*</span><br>- <span class="hljs-symbol">*</span><span class="hljs-symbol">*</span>零个或多个包含初始化数据的数据段，数据段的属性为可读写。<span class="hljs-symbol">*</span><span class="hljs-symbol">*</span><br>- <span class="hljs-symbol">*</span><span class="hljs-symbol">*</span>零个或多个不包含初始化数据的数据段，数据段的属性为可读写<span class="hljs-symbol">*</span><span class="hljs-symbol">*</span><br><br>链接器根据系统默认或用户设定的规则，将各个段安排在存储器中的相应位置。因此源程序中段之间的相对位置与可执行的映象文件中段的相对位置一般不会相同。<br><br>文件应该按功能构成，尽可能把一个功能完整地编辑在同一个文件中，这样便于调试和修改。<br><br>尽量减少一个文件与其他文件之间的关联，尽量减少文件的入口和出口，这样使程序条理更加清晰。<br><br>一个文件中代码段和数据段地设立不要过多，应该把夹在代码段中的数据缓冲区尽可能的集中在一起。<br><br>最好把Thumb指令设计为单独的段，并把ARM指令段和Thumb指令段分开存储。<br><br>数据存储区也要按功能划分，特权模式和用户模式程序使用不同的存储区块，以便对这些存储区块进行属性定义。<br><br>以下是一个汇编语言源程序的基本结构：<br><br></code></pre></td></tr></table></figure><pre><code class="hljs">    AREAInit，CODE，READONLY</code></pre><p>     ENTRY<br>start<br>     LDRR0，&#x3D;0x3FF5000<br>     LDRR1，0xFF<br>     STRR1，[R0]<br>     LDRR0，&#x3D;0x3FF5008<br>     LDRR1，0x01<br>     STRR1，[R0]<br>     ………<br>     END</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><br>&gt; 在汇编语言程序中，用<span class="hljs-meta">AREA</span>伪指令定义一个段，并说明所定义段的相关属性，本例定义一个名为Init的代码段，属性为只读。<span class="hljs-meta">ENTRY</span>伪指令标识程序的入口点，接下来为指令序列，程序的末尾为<span class="hljs-meta">END</span>伪指令，该伪指令告诉编译器源文件的结束，每一个汇编源程序都必须有一条<span class="hljs-meta">END</span>伪指令，指示源程序的结束。<br><br><span class="hljs-comment">### **4.3.2** **汇编语言的子程序调用**</span><br><br>在<span class="hljs-meta">ARM</span>汇编语言程序中，子程序的调用一般是通过**BL**指令来实现的。在程序中，使用指令：<br><br></code></pre></td></tr></table></figure><p> BL 子程序名</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><br> 即可完成子程序的调用。<br><br>该指令在执行时完成如下操作：<br><br>- 将子程序的返回地址存放在连接寄存器<span class="hljs-built_in">LR</span>中，同时将程序计数器<span class="hljs-built_in">PC</span>指向子程序的入口点。<br>- 当子程序执行完毕需要返回调用处时，只需要将存放在<span class="hljs-built_in">LR</span>中的返回地址重新拷贝给程序计数器<span class="hljs-built_in">PC</span>即可。<br><br>在调用子程序的同时，也可以完成参数的传递和从子程序返回运算的结果，通常可以使用寄存器<span class="hljs-built_in">R0</span>～<span class="hljs-built_in">R3</span>完成。<br><br><br><br>以下是使用BL指令调用子程序的汇编语言源程序的基本结构：<br><br></code></pre></td></tr></table></figure><pre><code class="hljs">AREAInit，CODE，READONLENTRY</code></pre><p>  start<br>     LDRR0，&#x3D;0x3FF5000<br>     LDRR1，0xFF<br>     STRR1，[R0]<br>     LDRR0，&#x3D;0x3FF5008<br>     LDRR1，0x01<br>     STRR1，[R0]<br>     BLPRINT_TEXT<br>     ;………<br>  PRINT_TEXT<br>     ;………<br>     ;………</p><pre><code class="hljs"> MOVPC，LR</code></pre><p>         <br>   END</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs clean"><br>### **<span class="hljs-number">4.3</span><span class="hljs-number">.3</span>** **汇编语言程序示例**<br><br>以下是一个基于S3C4510B的串行通讯程序，在此仅说明一个完整汇编语言程序的基本结构：<br><br></code></pre></td></tr></table></figure><pre><code class="hljs">; *********************************************************************;   Software Engineering Institute East China Normal University;    Description:  This example shows the UART communication！;    Author:   BBsitman;    Date:;**********************************************************************UARTLCON0EQU0x3FFD000</code></pre><p>    UARTCONT0EQU0x3FFD004<br>    UARTSTAT0EQU 0x3FFD008<br>    UTXBUF0EQU0x3FFD00C<br>    UARTBRD0EQU0x3FFD014<br>        AREA Init,CODE,READONLY<br>        ENTRY<br>    ;   **************************************************<br>    ;   LED Display<br>    ;   **************************************************<br>        LDRR1,&#x3D;0x3FF5000<br>        LDRR0,&#x3D;&amp;ff<br>        STRR0,[R1]<br>        LDRR1,&#x3D;0x3FF5008<br>        LDRR0,&#x3D;&amp;ff<br>        STRR0,[R1]<br>    ;   *************************************************<br>    ;   UART0 line control register<br>    ;   *************************************************<br>        LDRR1,&#x3D;UARTLCON0<br>        LDRR0,&#x3D;0x03<br>        STRR0,[R1]<br>    ;   **************************************************<br>    ;   UART0 control regiser<br>    ;   **************************************************<br>        LDRR1,&#x3D;UARTCONT0<br>        LDRR0,&#x3D;0x9<br>        STRR0,[R1]<br>    ;   **************************************************<br>    ;   UART0 baud rate divisor regiser<br>    ;   Baudrate&#x3D;19200，对应于50MHz的系统工作频率<br>    ;  ***************************************************<br>        LDRR1,&#x3D;UARTBRD0<br>        LDRR0,&#x3D;0x500<br>        STRR0,[R1]<br>    ;  ***************************************************<br>    ;  Print the messages!<br>    ;  ***************************************************<br>    LOOP<br>        LDRR0,&#x3D;Line1<br>        BLPrintLine<br>        LDRR0,&#x3D;Line2<br>        BLPrintLine<br>        LDRR0,&#x3D;Line3<br>        BLPrintLine<br>        LDRR0,&#x3D;Line4<br>        BLPrintLine<br>        LDRR1,&#x3D;0x7FFFFF<br>    LOOP1<br>        SUBSR1,R1,#1<br>        BNELOOP1<br>        BLOOP<br>    ;  ***************************************************<br>    ; Print line<br>    ; ***************************************************<br>    PrintLine<br>        MOVR4,LR<br>        MOVR5,R0<br>    Line<br>        LDRBR1,[R5],#1<br>        ANDR0,R1,#&amp;FF<br>        TSTR0,#&amp;FF<br>        MOVEQPC,R4<br>        BLPutByte<br>        BLine<br>    PutByte<br>        LDRR3,&#x3D;UARTSTAT0<br>        LDRR2,[R3]<br>        TSTR2,#&amp;40<br>        BEQPutByte<br>        LDRR3,&#x3D;UTXBUF0<br>        STRR0,[R3]<br>        MOVPC,LR<br>    Line1 DCB  &amp;A,&amp;D,”******************************************************************”,0<br>    Line2 DCB&amp;A,&amp;D,”Chinese Academy of Sciences,Institute of Automation,Complex System Lab.”,0<br>    Line3 DCB&amp;A,&amp;D,”ARM Development Board Based on Samsung ARM S3C4510B.”,0<br>    Line4 DCB  &amp;A,&amp;D,&amp;A,&amp;D,&amp;A,&amp;D,&amp;A,&amp;D,&amp;A,&amp;D,&amp;A,&amp;D,&amp;A,&amp;D,&amp;A,&amp;D,&amp;A,&amp;D,&amp;A,&amp;D,&amp;A,&amp;D,&amp;A,&amp;D,&amp;A<br>     DCB&amp;D,&amp;A,&amp;D,&amp;A,&amp;D,0<br>    END</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><br><span class="hljs-comment">## 4.4 本章小节</span><br><br>本章介绍了<span class="hljs-meta">ARM</span>程序设计的一些基本概念，以及在汇编语言程序设计中常见的伪指令、汇编语言的基本语句格式等，汇编语言程序的基本结构等，这些问题均为程序设计中的基本问题，要求理解并掌握。<br><br>练习:<br><br><span class="hljs-number">1</span>、用LDM/STM实现一块连续内存单元之间的数据传输（块复制）。<br><br>- <span class="hljs-built_in">R12</span>指向数据块的起始地址，<span class="hljs-built_in">r14</span>指向数据块的结束地址，<span class="hljs-built_in">r13</span>指向目的处的起始地址。<br><br><span class="hljs-number">2</span>、函数的调用与返回<br><br>- 以题<span class="hljs-number">1</span>块拷贝的功能模块作为函数体，写出该函数原型；<br>- 写出函数blockcopy调用的相关代码。<br><br><span class="hljs-number">3</span>、利用<span class="hljs-meta">ARM</span>指令具有条件执行的功能写出下列C代码对应的汇编代码。要求按照<span class="hljs-meta">ARM</span>汇编程序语法书写。<br><br></code></pre></td></tr></table></figure><p>int a&#x3D;1,b&#x3D;4;<br>if (a&gt;b)<br>   a&#x3D;b+1;<br>else<br>   b&#x3D;a+1;<br>return a-b;</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs"><br></code></pre></td></tr></table></figure><p>int i,a[10]&#x3D;{0,1,2,3,4,5,6,7,8,9};<br>for (i&#x3D;0;i&lt;10;i++)<br>   a[i]&#x3D;a[i]+i;</p><pre><code class="hljs"></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;ARM体系结构与编程&quot;&gt;&lt;a href=&quot;#ARM体系结构与编程&quot; class=&quot;headerlink&quot; title=&quot;ARM体系结构与编程&quot;&gt;&lt;/a&gt;ARM体系结构与编程&lt;/h1&gt;&lt;h2 id=&quot;第4章-ARM程序设计基础&quot;&gt;&lt;a href=&quot;#第4章-ARM程</summary>
      
    
    
    
    <category term="学习资料" scheme="https://www.emokable.top/categories/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/"/>
    
    
    <category term="ARM体系结构与编程" scheme="https://www.emokable.top/tags/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B/"/>
    
    <category term="课件笔记" scheme="https://www.emokable.top/tags/%E8%AF%BE%E4%BB%B6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>计算机组成原理-L09-memory</title>
    <link href="https://www.emokable.top/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L09-memory/"/>
    <id>https://www.emokable.top/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L09-memory/</id>
    <published>2023-05-08T16:30:43.000Z</published>
    <updated>2023-05-20T15:10:18.138Z</updated>
    
    <content type="html"><![CDATA[<h1 id="计算机组成与实践-存储体系结构"><a href="#计算机组成与实践-存储体系结构" class="headerlink" title="计算机组成与实践 -存储体系结构"></a><strong>计算机组成与实践</strong> -<strong>存储体系结构</strong></h1><h2 id="一-简介"><a href="#一-简介" class="headerlink" title="一.简介"></a>一.<strong>简介</strong></h2><h3 id="计算机主要组成部件"><a href="#计算机主要组成部件" class="headerlink" title="计算机主要组成部件"></a><strong>计算机主要组成部件</strong></h3><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L09-memory/image-20230509224246838.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="组件"></p><h3 id="存储“墙”问题"><a href="#存储“墙”问题" class="headerlink" title="存储“墙”问题"></a><strong>存储“墙”问题</strong></h3><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L09-memory/image-20230509224627637.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="发展限制"></p><h4 id="存储器发展"><a href="#存储器发展" class="headerlink" title="存储器发展"></a><strong>存储器发展</strong></h4><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L09-memory/image-20230509224648379.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="发展"></p><h4 id="存储系统"><a href="#存储系统" class="headerlink" title="存储系统"></a><strong>存储系统</strong></h4><p>存储器容量由寻址策略决定</p><table><thead><tr><th><strong>例如：</strong></th></tr></thead><tbody><tr><td>采用16位地址，寻址空间大小为2^16&#x3D;65536存储单元</td></tr></tbody></table><p>大多数存储器是字节可寻址（byte-addressable）</p><p>每个存储单元的大小为1字节</p><p>大多数计算机以字为单位（word）检索或存储数据</p><p>常用缩写：</p><blockquote><p>1K ≈ 2^10（Kilo）</p><p>1M ≈ 2^20（Mega）</p><p>1G ≈ 2^30（Giga）</p><p>1T ≈ 2^40（Tera）</p></blockquote><h4 id="主存访问模式"><a href="#主存访问模式" class="headerlink" title="主存访问模式"></a><strong>主存访问模式</strong></h4><p>数据传输通过</p><ul><li>MAR：地址寄存器</li><li>MDR：数据寄存器</li></ul><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L09-memory/image-20230509225449676.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="交互"></p><h4 id="主存的基本结构"><a href="#主存的基本结构" class="headerlink" title="主存的基本结构"></a><strong>主存的基本结构</strong></h4><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L09-memory/image-20230509225512428.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="贮存结构"></p><h4 id="存储系统设计"><a href="#存储系统设计" class="headerlink" title="存储系统设计"></a><strong>存储系统设计</strong></h4><p>处理器的运行速度远快于存储访问速度</p><ul><li>小容量访问速度快，大容量访问速度慢</li><li>设计缓存存储常用数据加速存储访问速度</li></ul><p>内存容量有限：</p><ul><li>使用虚拟存储器增加内存容量</li><li>内存管理单元（memory management unit，MMU）进行虚拟地址与物理地址之间的转换</li></ul><h4 id="局部性原理"><a href="#局部性原理" class="headerlink" title="局部性原理"></a><strong>局部性原理</strong></h4><p>程序局部性的访问地址空间</p><table><thead><tr><th><strong>时间局部性（Temporal locality）</strong></th></tr></thead><tbody><tr><td>如果某个数据项被访问，那么在不久的将来它可能再次被访问</td></tr></tbody></table><p>例如，loop循环中的指令</p><table><thead><tr><th><strong>空间局部性（Spatial locality）</strong></th></tr></thead><tbody><tr><td>如果某个数据项被询问，与它地址相邻的数据项可能很快也将被访问</td></tr></tbody></table><p>例如，顺序的指令执行，数组数据等</p><h5 id="利用局部性原理"><a href="#利用局部性原理" class="headerlink" title="利用局部性原理"></a><strong>利用局部性原理</strong></h5><ul><li>存储层次结构（Memory hierarchy）</li><li>所有数据存储在磁盘</li><li>最近访问的数据（相邻数据）从磁盘拷贝到较小的DRAM存储器<ul><li>主存（Main memory）</li></ul></li><li>最近经常访问的数据（相邻数据）从DRAM拷贝到更小的SRAM存储器<ul><li>缓存（Cache）</li></ul></li></ul><h4 id="存储体系结构"><a href="#存储体系结构" class="headerlink" title="存储体系结构"></a><strong>存储体系结构</strong></h4><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L09-memory/image-20230509230258739.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="tu"></p><h4 id="计算机的存储器是如何运作的"><a href="#计算机的存储器是如何运作的" class="headerlink" title="计算机的存储器是如何运作的"></a><strong>计算机的存储器是如何运作的</strong></h4><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L09-memory/image-20230509230312003.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="tt"></p><p><a href="https://www.bilibili.com/video/av19939336/">https://www.bilibili.com/video/av19939336/</a></p><h4 id="相关术语"><a href="#相关术语" class="headerlink" title="相关术语"></a><strong>相关术语</strong></h4><table><thead><tr><th><strong>随机访问存储器（Random Access Memory, RAM）</strong></th></tr></thead><tbody><tr><td>根据地址访问存储空间中的单元  Ø存储空间中的任意地址的访问时间相同</td></tr></tbody></table><table><thead><tr><th><strong>块（Block）</strong></th></tr></thead><tbody><tr><td>缓存中数据交换的最小单元</td></tr></tbody></table><p>命中率（Hit Rate）：在高层存储器中找到目标数据的存储访问比例</p><p>缺失率（Miss Rate）：在高层存储器中不能找到目标数据的存储访问比例，Miss Rate &#x3D; 1 - Hit Rate</p><table><thead><tr><th><strong>命中时间（Hit Time）</strong></th></tr></thead><tbody><tr><td>访问某存储器层次结构所需的时间，包括了判断当前访问是命中还是缺失所需的时间</td></tr></tbody></table><table><thead><tr><th><strong>缺失代价（Miss Penalty）</strong></th></tr></thead><tbody><tr><td>将相应的块从低层存储器器替换到高层存储器所需的时间，包括访问块、将数据逐层传输、将数据插入缺失的层和将目标块传递给请求者的时间</td></tr></tbody></table><p>命中时间 &lt;&lt; 缺失代价</p><h4 id="带宽和延迟"><a href="#带宽和延迟" class="headerlink" title="带宽和延迟"></a><strong>带宽和延迟</strong></h4><ul><li>带宽（Bandwidth）<ul><li>描述数据传输时每秒传输的数据量（bits or bytes）</li></ul></li><li>延迟（Latency）<ul><li>发出访问信号到开始传输第一个字的时间</li><li>以时钟周期为单位</li></ul></li></ul><h2 id="二-寄存器"><a href="#二-寄存器" class="headerlink" title="二.寄存器"></a>二.<strong>寄存器</strong></h2><h3 id="基于反馈的存储"><a href="#基于反馈的存储" class="headerlink" title="基于反馈的存储"></a><strong>基于反馈的存储</strong></h3><p>给两个反相器加上反馈信号</p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L09-memory/image-20230509230512552.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="中间可以稳定输出1信号"></p><p>通常称为交叉耦合反相器（Cross-coupled Inverter）</p><p>稳定存储1 bit数据的方式</p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L09-memory/image-20230509230537433.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="0/1"></p><h3 id="S-R锁存器（latch）"><a href="#S-R锁存器（latch）" class="headerlink" title="S-R锁存器（latch）"></a><strong>S-R锁存器（latch）</strong></h3><ul><li><p>用或非门替换反相器</p></li><li><p><strong>S-R锁存器（set-reset Latch）</strong></p><blockquote><p>这个是数电讲过的东西吧</p></blockquote></li></ul><table><thead><tr><th><strong>锁存器（latch）</strong></th></tr></thead><tbody><tr><td>一种存储元件，它的输出与内部存储的状态一致，并且当时钟有效时，只要输入发生变化，存储状态就会随之发生变化。</td></tr></tbody></table><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L09-memory/image-20230509230624503.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="锁存器"></p><table><thead><tr><th>input</th><th></th><th>output</th></tr></thead><tbody><tr><td>A</td><td>B</td><td>(A+B) ̅</td></tr><tr><td>0</td><td>0</td><td>1</td></tr><tr><td>1</td><td>0</td><td>0</td></tr><tr><td>0</td><td>1</td><td>0</td></tr><tr><td>1</td><td>1</td><td>0</td></tr></tbody></table><p>根据不同的R，S输入，Q的值</p><ul><li>R&#x3D;S&#x3D;0：Q&#x3D;1(其实是保持上次信号，Q不一定是1)</li><li>S&#x3D;0，R&#x3D;1：Q&#x3D;0</li><li>S&#x3D;1，R&#x3D;0：Q&#x3D;1</li><li>R&#x3D;S&#x3D;1：亚稳定状态</li></ul><blockquote><p>S是set，置位1</p><p>R是reset，复位0</p></blockquote><h3 id="D锁存器"><a href="#D锁存器" class="headerlink" title="D锁存器"></a>D锁存器</h3><p>D锁存器：</p><ul><li>两个输入：要存储的数据D，时钟信号C</li><li>两个输出：输出信号Q，其反向信号Q ̅</li><li>当输入时钟C有效时，锁存器称为打开状态，此时输出信号Q 的值为输入信号D 的值。</li><li>当输入时钟无效时，锁存器处于关闭状态，输出信号Q 等于锁存器最后一次打开时所存储的数据。</li></ul><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L09-memory/image-20230509231108004.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="D锁存器"></p><h3 id="D触发器（flip-flop）"><a href="#D触发器（flip-flop）" class="headerlink" title="D触发器（flip-flop）"></a><strong>D触发器（flip-flop）</strong></h3><table><thead><tr><th><strong>触发器（flip-flop）</strong></th></tr></thead><tbody><tr><td>一种存储元件，它的输出与内部存储的状态一致，并且内部状态只在时钟的边沿发生变化。</td></tr></tbody></table><ul><li>下降沿触发的D触发器<ul><li>第一个锁存器称为主锁存器，第二个锁存器称为从锁存器</li><li>当输入时钟C有效时，主锁存器打开，输入数据D。</li><li>当输入时钟C被拉低时，主锁存器关闭，但第二个锁存器打开，并且主锁存器的输出作为第二个锁存器的输入信号。</li></ul></li></ul><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L09-memory/image-20230509231211938.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="D"></p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L09-memory/image-20230509231230264.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="Q"></p><h3 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a><strong>寄存器</strong></h3><p>D触发器构造寄存器</p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L09-memory/image-20230509231254101.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="寄存器构造"></p><h2 id="三-随机访问存储器（RAM）"><a href="#三-随机访问存储器（RAM）" class="headerlink" title="三.随机访问存储器（RAM）"></a>三.<strong>随机访问存储器（RAM）</strong></h2><h3 id="静态随机存储器（SRAM）"><a href="#静态随机存储器（SRAM）" class="headerlink" title="静态随机存储器（SRAM）"></a><strong>静态随机存储器（SRAM）</strong></h3><ul><li>存储1 bit数据需要6个晶体管</li><li>大多数芯片使用SRAM</li><li>一对弱交叉耦合反相器</li><li>数据存储在交叉耦合反相器</li></ul><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L09-memory/image-20230509231428108.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="SRAM"></p><blockquote><p>X地址译码线（行选通）</p><p>Y地址译码线（列选通）</p><p>T1、T2保存数据；<br>T3、T4补充电荷；</p><p>T5、T6、T7、T8开关作用</p></blockquote><h4 id="静态存储器结构"><a href="#静态存储器结构" class="headerlink" title="静态存储器结构"></a><strong>静态存储器结构</strong></h4><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L09-memory/image-20230509231506116.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="结构"></p><ul><li>N位地址，寻址2n个存储单元，2n&#x2F;2+1根译码线</li><li>一行存储1 block数据（word line），列地址（bit line）选择请求访问的字节或字</li></ul><blockquote><p>按块存取，而非字节（具体取字节在内存中）</p></blockquote><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L09-memory/image-20230509231623323.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="配套"></p><h3 id="动态随机存储器（DRAM）"><a href="#动态随机存储器（DRAM）" class="headerlink" title="动态随机存储器（DRAM）"></a><strong>动态随机存储器（DRAM）</strong></h3><h4 id="1-T-DRAM存储单元"><a href="#1-T-DRAM存储单元" class="headerlink" title="1-T DRAM存储单元"></a><strong>1-T DRAM存储单元</strong></h4><ul><li>1个晶体管</li><li>需要一个存储电容（Capacitor）</li><li>提高存储密度</li><li>电容存储数据，有电荷为1，否则是0</li></ul><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L09-memory/image-20230509231818691.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="1-T"></p><h4 id="动态存储器结构"><a href="#动态存储器结构" class="headerlink" title="动态存储器结构"></a><strong>动态存储器结构</strong></h4><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L09-memory/image-20230509231851657.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="block"></p><h4 id="DRAM技术"><a href="#DRAM技术" class="headerlink" title="DRAM技术"></a><strong>DRAM技术</strong></h4><ul><li>存储单元使用电容保存电荷的方式来存储数据<ul><li>使用一个晶体管对电容进行访问</li><li>必须周期性的刷新才能保持数据<ul><li>读出内容再写回</li><li>对一整行数据进行刷新</li></ul></li></ul></li></ul><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L09-memory/image-20230509232024945.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="dram"></p><h4 id="DRAM的优化"><a href="#DRAM的优化" class="headerlink" title="DRAM的优化"></a><strong>DRAM的优化</strong></h4><ul><li>DRAM中的bit以矩形数组的结构组织排列<ul><li>DRAM访问一整行数据</li><li>突发模式（burst mode）：减少从行中连续访问字的开销</li></ul></li><li>双倍数据速率（Double data rate, DDR）DRAM<ul><li>在时钟的上升沿和下降沿传输数据，以获得双倍的数据带宽</li></ul></li><li>四倍数据速率（Quad data rate, QDR）DRAM<ul><li>将DDR的传输数据线路分为输入和输出，以获得四倍的数据带宽</li></ul></li></ul><h4 id="影响DRAM性能的因素"><a href="#影响DRAM性能的因素" class="headerlink" title="影响DRAM性能的因素"></a><strong>影响DRAM性能的因素</strong></h4><ul><li>行缓冲器（Row buffer）<ul><li>允许同时访问和刷新多个字的数据</li></ul></li><li>同步DRAM（Synchronous DRAM）<ul><li>以突发方式连续访问数据时，不需要发送所有字的地址</li><li>增加带宽</li></ul></li><li>DRAM划分存储块（banking）<ul><li>支持多个存储块的并发访问</li><li>增加带宽</li></ul></li></ul><h3 id="1到4代内存规格变化"><a href="#1到4代内存规格变化" class="headerlink" title="1到4代内存规格变化"></a><strong>1到4代内存规格变化</strong></h3><table><thead><tr><th><strong>内存规格</strong></th><th><strong>时钟频率</strong></th><th><strong>数据传输率</strong></th><th><strong>数据传输带宽</strong></th></tr></thead><tbody><tr><td>SDRAM-133</td><td>133MHz</td><td>133MT&#x2F;s</td><td>1.06GB&#x2F;s</td></tr><tr><td>DDR-266</td><td>133MHz</td><td>266MT&#x2F;s</td><td>2.1GB&#x2F;s</td></tr><tr><td>DDR2-533</td><td>133MHz</td><td>533MT&#x2F;s</td><td>4.2GB&#x2F;s</td></tr><tr><td>DDR3-1066</td><td>133MHz</td><td>1066MT&#x2F;s</td><td>8.5GB&#x2F;s</td></tr><tr><td>DDR3-1600</td><td>200MHz</td><td>1600MT&#x2F;s</td><td>12.8GB&#x2F;s</td></tr><tr><td>DDR4-2133</td><td>133MHz</td><td>2133MT&#x2F;s</td><td>21.3GB&#x2F;s</td></tr><tr><td>DDR4-3200</td><td>200MHz</td><td>3200MT&#x2F;s</td><td>25.6GB&#x2F;s</td></tr></tbody></table><h2 id="四-交叉存取（Interleaving）"><a href="#四-交叉存取（Interleaving）" class="headerlink" title="四.交叉存取（Interleaving）"></a>四.<strong>交叉存取（Interleaving）</strong></h2><h3 id="存储控制器（Memory-Controller）"><a href="#存储控制器（Memory-Controller）" class="headerlink" title="存储控制器（Memory Controller）"></a><strong>存储控制器（Memory Controller）</strong></h3><ul><li>控制处理器与存储器间交互</li><li>DRAM需要频繁刷新， 并且使用时分复用信号减少引脚数</li><li>SRAM管理简单，通常不需要存储控制器</li></ul><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L09-memory/image-20230509233656913.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="控制器"></p><p>RAS（CAS）：行（列）地址选通，CS：片选信号</p><h3 id="存储控制器"><a href="#存储控制器" class="headerlink" title="存储控制器"></a><strong>存储控制器</strong></h3><ul><li>存储控制器接收处理器发送的访问地址和R&#x2F;W信号</li><li>生成RAS和CAS信号</li><li>在RAS信号的控制下，部分高位地址作为行地址，选通存储结构中的某一行</li><li>在CAS信号的控制下，部分低位地址作为列地址，在选通的某一行存储结构中的选通某一列</li><li>根据地址选中相应的存储模块后，建立处理器与存储器间的数据线路</li><li>DRAM需要频繁刷新，但是刷新开销少于总存储访问时间的1%</li></ul><h3 id="存储模块交叉"><a href="#存储模块交叉" class="headerlink" title="存储模块交叉"></a><strong>存储模块交叉</strong></h3><ul><li>处理器和缓存访问速度快，内存访问慢</li><li>可以通过交叉访问几个存储模块来隐藏访问延迟</li><li>每个存储模块都有自己的地址缓冲寄存器（Address Buffer Register，ABR）和数据缓冲寄存器（Data Buffer Register，DBR）</li></ul><h4 id="存储模块交叉存取"><a href="#存储模块交叉存取" class="headerlink" title="存储模块交叉存取"></a><strong>存储模块交叉存取</strong></h4><p>处理器和缓存访问速度快，内存访问慢</p><p>可以通过交叉访问几个存储模块来隐藏访问延迟</p><p>每个存储模块都有自己的地址缓冲寄存器（Address Buffer Register，ABR）和数据缓冲寄存器（Data Buffer Register，DBR）</p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L09-memory/image-20230509233830558.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="2"></p><p><strong>哪种策略更好？</strong></p><p>两个或多个兼容的存储模块</p><p>在一个存储模块中，采用多个并行访问的片</p><table><thead><tr><th><strong>例如：</strong></th></tr></thead><tbody><tr><td>8个存储模块，每个模块有8个片，实现8×8&#x3D;64 bit的存储器总线</td></tr></tbody></table><p>交叉存储可以在类似双通道内存架构中实现</p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L09-memory/image-20230509233907811.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="2"></p><h3 id="非交叉存储V-S-交叉存储"><a href="#非交叉存储V-S-交叉存储" class="headerlink" title="非交叉存储V.S.交叉存储"></a><strong>非交叉存储V.S.交叉存储</strong></h3><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L09-memory/image-20230509233923890.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="vs"></p><h4 id="交叉存取例子"><a href="#交叉存取例子" class="headerlink" title="交叉存取例子"></a><strong>交叉存取例子</strong></h4><p>假设指令访问数据缓存发生read miss，需要从内存将数据读入缓存</p><p>缓存块大小为8 bytes</p><p>假设发送地址到内存花费1 个时钟周期，从内存发送数据花费1个时钟周期</p><p>此外，内存的访问延迟为6个时钟周期，即从接收到地址到发送第一个字节需要6个时钟周期</p><p>访问相同行的字节的延迟为4个时钟周期</p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L09-memory/image-20230509233958395.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="读取"></p><h4 id="非交叉存取"><a href="#非交叉存取" class="headerlink" title="非交叉存取"></a><strong>非交叉存取</strong></h4><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L09-memory/image-20230509234019380.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="非"></p><p>访问第一个字节需要6 cycles</p><p>假设所有随后的字节都在同一行，每个需要4 cycles</p><table><thead><tr><th><strong>非交叉存取</strong></th></tr></thead><tbody><tr><td>1+6+7×4+1&#x3D;  36 cycles</td></tr></tbody></table><h4 id="4个模块交叉存取"><a href="#4个模块交叉存取" class="headerlink" title="4个模块交叉存取"></a><strong>4个模块交叉存取</strong></h4><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L09-memory/image-20230509234104125.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="4"></p><table><thead><tr><th><strong>交叉存取</strong></th></tr></thead><tbody><tr><td>1+6+1×8&#x3D;  15 cycles</td></tr></tbody></table><h4 id="课题练习"><a href="#课题练习" class="headerlink" title="课题练习"></a><strong>课题练习</strong></h4><p>如果只有2个模块交叉存取，传输8 bytes数据，需要多少个时钟周期？</p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L09-memory/image-20230509234129094.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="4-8"></p><table><thead><tr><th><strong>交叉存取</strong></th></tr></thead><tbody><tr><td>1+6+2×3+1×8&#x3D;  21 cycles</td></tr></tbody></table><h2 id="五-二级存取器"><a href="#五-二级存取器" class="headerlink" title="五.二级存取器"></a>五.<strong>二级存取器</strong></h2><ul><li>长期的非易失性存储</li><li>存储体系结构的底层：访问速度慢、容量大、便宜</li><li>带有磁性图层的可旋转的圆盘</li><li>通过可移动的读&#x2F;写头来访问数据</li></ul><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L09-memory/image-20230509235235024.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="磁盘"></p><h3 id="闪存（Flash-Storage）"><a href="#闪存（Flash-Storage）" class="headerlink" title="闪存（Flash Storage）"></a><strong>闪存（Flash Storage）</strong></h3><p>磁盘替代者</p><p>固态硬盘（SSD）：基于闪存</p><p>非易失性，比磁盘快100~1000倍</p><p>磨损问题：采用磨损均衡技术</p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-L09-memory/image-20230509235345912.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="flash"></p><h2 id="六-小结"><a href="#六-小结" class="headerlink" title="六.小结"></a>六.<strong>小结</strong></h2><ul><li>处理器速度与存储器的访问速度间不匹配问题——存储墙</li><li>通用RAM类型：<ul><li>SRAM、DRAM、SDRAM、DDR SDRAM</li></ul></li><li>局部性原理：时间局部性和空间局部性</li><li>存储体系结构：<ul><li>寄存器-&gt;缓存-&gt;内存-&gt;磁盘-&gt;磁带</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;计算机组成与实践-存储体系结构&quot;&gt;&lt;a href=&quot;#计算机组成与实践-存储体系结构&quot; class=&quot;headerlink&quot; title=&quot;计算机组成与实践 -存储体系结构&quot;&gt;&lt;/a&gt;&lt;strong&gt;计算机组成与实践&lt;/strong&gt; -&lt;strong&gt;存储体系结</summary>
      
    
    
    
    <category term="学习资料" scheme="https://www.emokable.top/categories/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/"/>
    
    
    <category term="课件笔记" scheme="https://www.emokable.top/tags/%E8%AF%BE%E4%BB%B6%E7%AC%94%E8%AE%B0/"/>
    
    <category term="计算机组成原理" scheme="https://www.emokable.top/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>ARM体系结构与编程-第4章-ARM程序设计基础-伪指令1</title>
    <link href="https://www.emokable.top/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC4%E7%AB%A0-ARM%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%80-%E4%BC%AA%E6%8C%87%E4%BB%A41/"/>
    <id>https://www.emokable.top/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC4%E7%AB%A0-ARM%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%80-%E4%BC%AA%E6%8C%87%E4%BB%A41/</id>
    <published>2023-05-08T13:30:18.000Z</published>
    <updated>2023-05-08T14:32:00.721Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ARM体系结构与编程"><a href="#ARM体系结构与编程" class="headerlink" title="ARM体系结构与编程"></a>ARM体系结构与编程</h1><h2 id="第4章-ARM程序设计基础"><a href="#第4章-ARM程序设计基础" class="headerlink" title="第4章 ARM程序设计基础"></a><strong>第4章</strong> ARM程序设计基础</h2><p>ARM编译器一般都支持汇编语言的程序设计和C&#x2F;C++语言的程序设计，以及两者的混合编程。本章介绍ARM程序设计的一些基本概念，如ARM汇编语言的伪指令、汇编语言的语句格式和汇编语言的程序结构等。</p><p>本章的主要内容：</p><ul><li>ARM编译器所支持的伪指令</li><li>汇编语言的语句格式</li><li>汇编语言的程序结构</li><li>相关的程序示例</li></ul><h2 id="4-1-ARM汇编器所支持的伪指令"><a href="#4-1-ARM汇编器所支持的伪指令" class="headerlink" title="4.1 ARM汇编器所支持的伪指令"></a>4.1 ARM汇编器所支持的伪指令</h2><p>在ARM汇编语言程序里，有一些特殊指令助记符，这些助记符与指令系统的助记符不同，没有相对应的操作码，通常称这些特殊指令助记符为<strong>伪指令</strong>，他们所完成的操作称为<strong>伪操作</strong>。</p><p>伪指令在源程序中的作用是为完成汇编程序作各种准备工作的，这些伪指令仅在汇编过程中起作用，一旦汇编结束，伪指令的使命就完成。</p><p>伪指令的两个基本特征：</p><ul><li>伪指令是一条指令；</li><li>伪指令不是一条真正的指令，通常没有指令代码。</li></ul><p>在ARM的汇编程序中，有如下几种伪指令：</p><ul><li>符号定义伪指令</li><li>数据定义伪指令</li><li>汇编控制伪指令</li><li>宏指令</li><li>其他伪指令</li></ul><h3 id="4-1-1-符号定义（Symbol-Definition）伪指令"><a href="#4-1-1-符号定义（Symbol-Definition）伪指令" class="headerlink" title="4.1.1 符号定义（Symbol Definition）伪指令"></a>4.1.1 符号定义（Symbol Definition）伪指令</h3><p>符号定义伪指令用于定义ARM汇编程序中的变量、对变量赋值以及定义寄存器的别名等操作。常见的符号定义伪指令有如下几种：</p><ul><li>用于定义全局变量的GBLA、GBLL和GBLS。</li><li>用于定义局部变量的LCLA、LCLL和LCLS。</li><li>用于对变量赋值的SETA、SETL、SETS。</li><li>为通用寄存器列表定义名称的RLIST。</li></ul><ol><li><h4 id="GBLA、GBLL和GBLS"><a href="#GBLA、GBLL和GBLS" class="headerlink" title="GBLA、GBLL和GBLS"></a>GBLA、GBLL和GBLS</h4></li></ol><p>语法格式：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-symbol">GBLA</span>（<span class="hljs-meta">GBLL</span>或<span class="hljs-meta">GBLS</span>） 全局变量名<br></code></pre></td></tr></table></figure><p>GBLA、GBLL和GBLS伪指令用于定义一个ARM程序中的全局变量，并将其初始化。其中：</p><ul><li>GBLA伪指令用于定义一个全局的数字变量，并初始化为0；</li><li>GBLL伪指令用于定义一个全局的逻辑变量，并初始化为F（假）；</li><li>GBLS伪指令用于定义一个全局的字符串变量，并初始化为空；</li></ul><p>由于以上三条伪指令用于定义全局变量，因此在整个程序范围内变量名必须唯一。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs abnf">使用示例：<br>GBLATest1<span class="hljs-comment">;定义一个全局的数字变量，</span><br><span class="hljs-comment">;变量名为Test1</span><br>Test1SETA<span class="hljs-number">0</span>xaa<span class="hljs-comment">;将该变量赋值为0xaa</span><br>GBLLTest2<span class="hljs-comment">;定义一个全局的逻辑变量，</span><br><span class="hljs-comment">;变量名为Test2</span><br>Test2SETL&#123;TRUE&#125;<span class="hljs-comment">;将该变量赋值为真</span><br>GBLSTest3<span class="hljs-comment">;定义一个全局的字符串变量，</span><br><span class="hljs-comment">;变量名为Test3</span><br>Test3SETS“Testing”   <span class="hljs-comment">;将该变量赋值为“Testing”</span><br><br></code></pre></td></tr></table></figure><ol start="2"><li><h4 id="LCLA、LCLL和LCLS"><a href="#LCLA、LCLL和LCLS" class="headerlink" title="LCLA、LCLL和LCLS"></a>LCLA、LCLL和LCLS</h4></li></ol><p>语法格式：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-symbol">LCLA</span>（<span class="hljs-meta">LCLL</span>或<span class="hljs-meta">LCLS</span>） 局部变量名<br></code></pre></td></tr></table></figure><p>LCLA、LCLL和LCLS伪指令用于定义一个ARM程序中的局部变量，并将其初始化。其中：</p><ul><li>LCLA伪指令用于定义一个局部的数字变量，并初始化为0；</li><li>LCLL伪指令用于定义一个局部的逻辑变量，并初始化为F（假）；</li><li>LCLS伪指令用于定义一个局部的字符串变量，并初始化为空；</li></ul><p>以上三条伪指令用于声明局部变量，在其作用范围内变量名必须唯一。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs abnf">使用示例：<br>LCLATest4<span class="hljs-comment">;声明一个局部的数字变量，</span><br><span class="hljs-comment">;变量名为Test4</span><br>Test3SETA<span class="hljs-number">0</span>xaa<span class="hljs-comment">;将该变量赋值为0xaa</span><br>LCLLTest5<span class="hljs-comment">;声明一个局部的逻辑变量，</span><br><span class="hljs-comment">;变量名为Test5</span><br>Test4SETL&#123;TRUE&#125; <span class="hljs-comment">;将该变量赋值为真</span><br>LCLSTest6<span class="hljs-comment">;定义一个局部的字符串变量，</span><br><span class="hljs-comment">;变量名为Test6</span><br>Test6SETS“Testing” <span class="hljs-comment">;将该变量赋值为“Testing”</span><br><br></code></pre></td></tr></table></figure><ol start="3"><li><h4 id="SETA、SETL和SETS"><a href="#SETA、SETL和SETS" class="headerlink" title="SETA、SETL和SETS"></a>SETA、SETL和SETS</h4></li></ol><p>语法格式：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs armasm">变量名 <span class="hljs-meta">SETA</span>（<span class="hljs-meta">SETL</span>或<span class="hljs-meta">SETS</span>） 表达式<br></code></pre></td></tr></table></figure><p>伪指令SETA、SETL、SETS用于给一个已经定义的全局变量或局部变量赋值。</p><ul><li>SETA伪指令用于给一个数学变量赋值；</li><li>SETL伪指令用于给一个逻辑变量赋值；</li><li>SETS伪指令用于给一个字符串变量赋值；</li><li>其中，变量名为已经定义过的全局变量或局部变量，表达式为将要赋给变量的值。</li></ul><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs abnf">使用示例：<br>LCLATest3 <span class="hljs-comment">;声明一个局部的数字变量，</span><br><span class="hljs-comment">;变量名为Test3</span><br>Test3SETA<span class="hljs-number">0</span>xaa <span class="hljs-comment">;将该变量赋值为0xaa</span><br>LCLLTest4 <span class="hljs-comment">;声明一个局部的逻辑变量，</span><br><span class="hljs-comment">;变量名为Test4</span><br>Test4SETL&#123;TRUE&#125; <span class="hljs-comment">;将该变量赋值为真</span><br>LCLSTest6 <span class="hljs-comment">;定义一个局部的字符串变量， ;变量名为Test6</span><br>Test5SETS“Testing” <span class="hljs-comment">;将该变量赋值为“Testing”</span><br><br></code></pre></td></tr></table></figure><ol start="4"><li><h4 id="RLIST"><a href="#RLIST" class="headerlink" title="RLIST"></a>RLIST</h4></li></ol><p>语法格式：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs armasm">名称 <span class="hljs-meta">RLIST</span>   &#123;寄存器列表&#125;<br></code></pre></td></tr></table></figure><p>RLIST伪指令可用于对一个通用寄存器列表定义名称，使用该伪指令定义的名称可在ARM指令LDM&#x2F;STM中使用。</p><p><strong>在LDM&#x2F;STM</strong>指令中，列表中的寄存器访问次序为根据寄存器的编号由低到高，而与列表中的寄存器排列次序无关。</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs armasm">使用示例：<br>RegList  <span class="hljs-meta">RLIST</span>   &#123;<span class="hljs-built_in">R0</span>-<span class="hljs-built_in">R5</span>，<span class="hljs-built_in">R8</span>，<span class="hljs-built_in">R10</span>&#125;<br><span class="hljs-comment">;将寄存器列表名称定义为RegList，</span><br><span class="hljs-comment">;可在ARM指令LDM/STM中通过</span><br><span class="hljs-comment">;该名称访问寄存器列表。</span><br></code></pre></td></tr></table></figure><h3 id="4-1-2-数据定义（Data-Definition）伪指令"><a href="#4-1-2-数据定义（Data-Definition）伪指令" class="headerlink" title="4.1.2 数据定义（Data Definition）伪指令"></a>4.1.2 数据定义（Data Definition）伪指令</h3><p>数据定义伪指令一般用于为特定的数据分配存储单元，同时可完成已分配存储单元的初始化。常见的数据定义伪指令有如下几种：</p><ul><li>DCB       用于分配一片连续的<strong>字节</strong>存储单元并用指定 的数据初始化。</li><li>DCW（DCWU）用于分配一片连续的<strong>半字</strong>存储单元并用指定的 数据初始化。</li><li>DCD（DCDU） 用于分配一片连续的<strong>字</strong>存储单元并用指定的数 据初始化。</li><li>DCFD（DCFDU） 用于为双精度的浮点数分配一片连续的字存 储单元并用指定的数据初始化。</li><li>DCFS（DCFSU）用于为单精度的浮点数分配一片连续的字存 储单元并用指定的数据初始化。</li><li>DCQ（DCQU）用于分配一片以8字节为单位的连续的存储单元 并用指定的数据初始化。</li><li>SPACE 用于分配一片连续的存储单元</li><li>MAP 用于定义一个结构化的内存表首地址</li><li>FIELD 用于定义一个结构化的内存表的数据域</li></ul><ol><li><h4 id="DCB"><a href="#DCB" class="headerlink" title="DCB"></a>DCB</h4></li></ol><p>语法格式：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs armasm">标号 <span class="hljs-meta">DCB</span> 表达式&#123;,表达式&#125;……<br></code></pre></td></tr></table></figure><p>DCB伪指令用于分配一片连续的字节存储单元并用伪指令中指定的表达式初始化。其中，表达式可以为0～255的数字或字符串。</p><p>DCB也可用“&#x3D;”代替。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">使用示例：<br><span class="hljs-built_in">string</span>DCB“This <span class="hljs-keyword">is</span> a test！”<br><span class="hljs-built_in">string</span>=“This <span class="hljs-keyword">is</span> a test！”<br>;分配一片连续的字节存储单元并初始化。<br></code></pre></td></tr></table></figure><ol start="2"><li><h4 id="DCW（或DCWU）"><a href="#DCW（或DCWU）" class="headerlink" title="DCW（或DCWU）"></a>DCW（或DCWU）</h4></li></ol><p>语法格式：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs armasm">标号 <span class="hljs-meta">DCW</span>（或<span class="hljs-meta">DCWU</span>） 表达式&#123;,表达式&#125;…..<br></code></pre></td></tr></table></figure><p>DCW（或DCWU）伪指令用于分配一片连续的半字存储单元并用伪指令中指定的表达式初始化。其中，表达式可以为程序标号或数字表达式。</p><p>用DCW分配的字存储单元是半字对齐的，而用DCWU分配的字存储单元并不严格半字对齐。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">使用示例：<br> DataTest DCW <span class="hljs-number">1</span>，<span class="hljs-number">2</span>，<span class="hljs-number">3</span><br> <span class="hljs-comment">;分配一片连续的半字存储单元并初始化</span><br></code></pre></td></tr></table></figure><ol start="3"><li><h4 id="DCD（或DCDU）"><a href="#DCD（或DCDU）" class="headerlink" title="DCD（或DCDU）"></a>DCD（或DCDU）</h4></li></ol><p>语法格式：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs armasm">标号  <span class="hljs-meta">DCD</span>（或<span class="hljs-meta">DCDU</span>） 表达式&#123;,表达式&#125;…..<br></code></pre></td></tr></table></figure><p>DCD（或DCDU）伪指令用于分配一片连续的字存储单元并用伪指令中指定的表达式初始化。其中，表达式可以为程序标号或数字表达式。</p><p>DCD也可用“&amp;”代替。</p><p>用DCD分配的字存储单元是字对齐的，而用DCDU分配的字存储单元并不严格字对齐。</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs 1c">使用示例：<br><br> DataTest DCD   <span class="hljs-number">4</span>，<span class="hljs-number">5</span>，<span class="hljs-number">6</span> <br><br> DataTest <span class="hljs-meta">&amp;   4，5，6 </span><br><br> ;分配一片连续的字存储单元并初始化。<br></code></pre></td></tr></table></figure><ol start="4"><li><h4 id="DCFD（或DCFDU）"><a href="#DCFD（或DCFDU）" class="headerlink" title="DCFD（或DCFDU）"></a>DCFD（或DCFDU）</h4></li></ol><p>语法格式：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs armasm">标号 <span class="hljs-meta">DCFD</span>（或<span class="hljs-meta">DCFDU</span>） 表达式&#123;,表达式&#125;…..<br></code></pre></td></tr></table></figure><p>DCFD（或DCFDU）伪指令用于为双精度的浮点数分配一片连续的字存储单元并用伪指令中指定的表达式初始化。每个双精度的浮点数占据两个字单元。</p><p>用DCFD分配的字存储单元是字对齐的，而用DCFDU分配的字存储单元并不严格字对齐。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">使用示例：<br> FDataTest   DCFD <span class="hljs-number">2</span>E115，-<span class="hljs-number">5</span>E7 <br>  <span class="hljs-comment">;分配一片连续的字存储单元并初始化为指定的双精度数。</span><br></code></pre></td></tr></table></figure><ol start="5"><li><h4 id="DCFS（或DCFSU）"><a href="#DCFS（或DCFSU）" class="headerlink" title="DCFS（或DCFSU）"></a>DCFS（或DCFSU）</h4></li></ol><p>语法格式：</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml">标号 DCFS（或DCFSU）表达式</span><span class="hljs-template-variable">&#123;,表达式&#125;</span><span class="language-xml">…..</span><br></code></pre></td></tr></table></figure><p>DCFS（或DCFSU）伪指令用于为单精度的浮点数分配一片连续的字存储单元并用伪指令中指定的表达式初始化。每个单精度的浮点数占据一个字单元。</p><p>用DCFS分配的字存储单元是字对齐的，而用DCFSU分配的字存储单元并不严格字对齐。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">使用示例：<br> FDataTest  DCFS <span class="hljs-number">2</span>E5，-<span class="hljs-number">5</span>E－<span class="hljs-number">7</span> <br><span class="hljs-comment">;分配一片连续的字存储单元并初始化为指定的单精度数。</span><br></code></pre></td></tr></table></figure><ol start="6"><li><h4 id="DCQ-或DCQU）"><a href="#DCQ-或DCQU）" class="headerlink" title="DCQ(或DCQU）"></a>DCQ(或DCQU）</h4></li></ol><p>语法格式：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs armasm">标号 <span class="hljs-meta">DCQ</span>（或<span class="hljs-meta">DCQU</span>） 表达式&#123;,表达式&#125;…..<br></code></pre></td></tr></table></figure><p>DCQ（或DCQU）伪指令用于分配一片以8个字节为单位的连续存储区域并用伪指令中指定的表达式初始化。</p><p>用DCQ分配的存储单元是字对齐的，而用DCQU分配的存储单元并不严格字对齐。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">使用示例：<br> DataTest   DCQ <span class="hljs-number">100</span> <br> <span class="hljs-comment">;分配一片连续的存储单元并初始化为指定的值。</span><br></code></pre></td></tr></table></figure><ol start="7"><li><h4 id="SPACE"><a href="#SPACE" class="headerlink" title="SPACE"></a>SPACE</h4></li></ol><p>语法格式：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs armasm">标号 <span class="hljs-meta">SPACE</span> 表达式<br></code></pre></td></tr></table></figure><p>SPACE伪指令用于分配一片连续的存储区域并初始化为0。其中，表达式为要分配的字节数。</p><p>SPACE也可用“％”代替。</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tap">使用示例：<br>DataSpace SPACE<span class="hljs-number"> 100 </span><br>DataSpace %<span class="hljs-number"> 100 </span> <br>;分配连续100字节的存储单元并初始化为0。<br></code></pre></td></tr></table></figure><ol start="8"><li><h4 id="MAP"><a href="#MAP" class="headerlink" title="MAP"></a>MAP</h4></li></ol><p>语法格式：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-built_in">MAP</span> 表达式&#123;，基址寄存器&#125;<br></code></pre></td></tr></table></figure><p>MAP伪指令用于定义一个结构化的内存表的首地址。</p><p>MAP也可用“＾”代替。</p><p>表达式可以为程序中的标号或数学表达式，基址寄存器为可选项。</p><p>当基址寄存器选项不存在时，表达式的值即为内存表的首地址；</p><p>当该选项存在时，内存表的首地址为表达式的值与基址寄存器的和。</p><p>MAP伪指令通常与FIELD伪指令配合使用来定义结构化的内存表。</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs armasm">使用示例：<br> <span class="hljs-meta">MAP</span> <span class="hljs-number">0x100</span>，<span class="hljs-built_in">R0</span> <br> ^ <span class="hljs-number">0x100</span>，<span class="hljs-built_in">R0</span>  <br> <span class="hljs-comment">;定义结构化内存表首地址的值为0x100＋R0。</span><br></code></pre></td></tr></table></figure><ol start="9"><li><h4 id="FILED"><a href="#FILED" class="headerlink" title="FILED"></a>FILED</h4></li></ol><p>语法格式：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs armasm">标号 <span class="hljs-meta">FIELD</span> 表达式<br></code></pre></td></tr></table></figure><p>FIELD伪指令用于定义一个结构化内存表中的数据域。</p><p>FILED也可用“#”代替。</p><p>表达式的值为当前数据域在内存表中所占的字节数。</p><p>FIELD伪指令常与MAP伪指令配合使用来定义结构化的内存表。MAP伪指令定义内存表的首地址，FIELD伪指令定义内存表中的各个数据域，并可以为每个数据域指定一个标号供其他的指令引用。</p><p>注意MAP和FIELD伪指令仅用于定义数据结构，并不实际分配存储单元。</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">使用示例：<br> MAP <span class="hljs-number">0x100</span> <span class="hljs-comment">;定义结构化内存表首地址的值为0x100。</span><br> A FIELD <span class="hljs-number">16</span> <span class="hljs-comment">;定义A的长度为16字节，位置为0x100</span><br> <span class="hljs-keyword">B </span><span class="hljs-comment"># 32 ;定义B的长度为32字节，位置为0x110</span><br> S FIELD <span class="hljs-number">256</span> <span class="hljs-comment">;定义S的长度为256字节，位置为0x130</span><br></code></pre></td></tr></table></figure><h3 id="4-1-3-汇编控制（Assembly-Control）伪指令"><a href="#4-1-3-汇编控制（Assembly-Control）伪指令" class="headerlink" title="4.1.3 汇编控制（Assembly Control）伪指令"></a>4.1.3 汇编控制（Assembly Control）伪指令</h3><p>汇编控制伪指令用于控制汇编程序的执行流程，常用的汇编控制伪指令包括以下几条：</p><ul><li>IF、ELSE、ENDIF</li><li>WHILE、WEND</li><li>MACRO、MEND</li><li>MEXIT</li></ul><ol><li><h4 id="IF、ELSE、ENDIF"><a href="#IF、ELSE、ENDIF" class="headerlink" title="IF、ELSE、ENDIF"></a>IF、ELSE、ENDIF</h4></li></ol><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs armasm">语法格式：<br><span class="hljs-meta">IF</span>逻辑表达式<br>指令序列<span class="hljs-number">1</span><br><span class="hljs-meta">ELSE</span><br>指令序列<span class="hljs-number">2</span><br><span class="hljs-meta">ENDIF</span><br></code></pre></td></tr></table></figure><ul><li>IF、ELSE、ENDIF伪指令能根据条件的成立与否决定是否执行某个指令序列。当IF后面的逻辑表达式为真，则执行指令序列1，否则执行指令序列2。其中，ELSE及指令序列2可以没有，此时，当IF后面的逻辑表达式为真，则执行指令序列1，否则继续执行后面的指令。</li><li>IF、ELSE、ENDIF伪指令可以嵌套使用。</li></ul><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cmake">使用示例：<br>    GBLL<span class="hljs-keyword">Test</span>;声明一个全局的逻辑变量，变量名为<span class="hljs-keyword">Test</span><br>    ……<br>    <span class="hljs-keyword">IF</span><span class="hljs-keyword">Test</span> = <span class="hljs-keyword">TRUE</span><br>  指令序列<span class="hljs-number">1</span><br>    <span class="hljs-keyword">ELSE</span><br> 指令序列<span class="hljs-number">2</span><br>    <span class="hljs-keyword">ENDIF</span><br></code></pre></td></tr></table></figure><ol start="2"><li><h4 id="WHILE、WEND"><a href="#WHILE、WEND" class="headerlink" title="WHILE、WEND"></a>WHILE、WEND</h4></li></ol><p>语法格式：</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs autoit"><span class="hljs-keyword">WHILE</span> 逻辑表达式<br>指令序列<br><span class="hljs-keyword">WEND</span><br></code></pre></td></tr></table></figure><p>WHILE、WEND伪指令能根据条件的成立与否决定是否循环执行某个指令序列。当WHILE后面的逻辑表达式为真，则执行指令序列，该指令序列执行完毕后，再判断逻辑表达式的值，若为真则继续执行，一直到逻辑表达式的值为假。</p><p>WHILE、WEND伪指令可以嵌套使用。</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs armasm">使用示例：<br>    <span class="hljs-meta">GBLA</span>  counter <span class="hljs-comment">;声明一个全局的数学变量，变量名为;counter</span><br><span class="hljs-symbol">counter</span><span class="hljs-meta">SETA</span>   <span class="hljs-number">1</span> <span class="hljs-comment">;初始化循环控制计数器</span><br>    ……<br>    <span class="hljs-meta">WHILE</span>  counter &lt; <span class="hljs-number">10</span><br>  指令序列<br><span class="hljs-symbol">counter</span> <span class="hljs-meta">SETA</span>   counter +<span class="hljs-number">1</span><br>    <span class="hljs-meta">WEND</span><br></code></pre></td></tr></table></figure><ol start="3"><li><h4 id="MACRO、MEND-CF-P-129"><a href="#MACRO、MEND-CF-P-129" class="headerlink" title="MACRO、MEND (CF.P.129)"></a>MACRO、MEND (CF.P.129)</h4></li></ol><p>语法格式：</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs crystal">MACRO<br><span class="hljs-variable">$标</span>号宏名<span class="hljs-variable">$参</span>数<span class="hljs-number">1</span>，<span class="hljs-variable">$参</span>数<span class="hljs-number">2</span>，……<br>指令序列<br>MEND<br></code></pre></td></tr></table></figure><p>MACRO、MEND伪指令可以将一段代码定义为一个整体，称为宏指令，然后就可以在程序中通过宏指令多次调用该段代码。其中，$标号在宏指令被展开时，标号会被替换为用户定义的符号，</p><p>宏指令可以使用一个或多个参数，当宏指令被展开时，这些参数被相应的值替换。</p><p>宏指令的使用方式和功能与子程序有些相似，子程序可以提供模块化的程序设计、节省存储空间并提高运行速度。但在使用子程序结构时需要保护现场，从而增加了系统的开销，因此，在代码较短且需要传递的参数较多时，可以使用宏指令代替子程序。</p><p>包含在MACRO和MEND之间的指令序列称为<strong>宏定义体</strong>，在宏定义体的第一行应声明宏的原型（包含宏名、所需的参数），然后就可以在汇编程序中通过宏名来调用该指令序列。在源程序被编译时，汇编器将宏调用展开，用宏定义中的指令序列代替程序中的宏调用，并将实际参数的值传递给宏定义中的形式参数。</p><p>MACRO、MEND伪指令可以嵌套使用。</p><ol start="4"><li><h4 id="MEXIT"><a href="#MEXIT" class="headerlink" title="MEXIT"></a>MEXIT</h4></li></ol><p>语法格式：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">MEXIT</span><br></code></pre></td></tr></table></figure><p>MEXIT用于从宏定义中跳转出去</p><p><img src="/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC4%E7%AB%A0-ARM%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%80-%E4%BC%AA%E6%8C%87%E4%BB%A41/image-20230508215635871.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="图"></p><h3 id="4-1-4-其他常用的伪指令"><a href="#4-1-4-其他常用的伪指令" class="headerlink" title="4.1.4 其他常用的伪指令"></a>4.1.4 其他常用的伪指令</h3><p>还有一些其他的伪指令，在汇编程序中经常会被使用，包括以下几条：</p><ul><li>AREA</li><li>ALIGN</li><li>CODE16、CODE32</li><li>ENTRY</li><li>END</li><li>EQU</li><li>EXPORT（或GLOBAL）</li><li>IMPORT</li><li>EXTERN</li><li>GET（或INCLUDE）</li><li>INCBIN</li><li>RN</li><li>ROUT</li></ul><ol><li><h4 id="AREA"><a href="#AREA" class="headerlink" title="AREA"></a>AREA</h4></li></ol><p>语法格式：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">AREA</span>段名属性<span class="hljs-number">1</span>，属性<span class="hljs-number">2</span>，……<br></code></pre></td></tr></table></figure><p>AREA伪指令用于定义一个代码段或数据段。其中，段名若以数字开头，则该段名需用“|”括起来，如|1_test|。</p><p>属性字段表示该代码段（或数据段）的相关属性，多个属性用逗号分隔。常用的属性如下：</p><ul><li>CODE属性：用于定义代码段，默认为READONLY。</li><li>DATA属性：用于定义数据段，默认为READWRITE。</li><li>READONLY属性：指定本段为只读，代码段默认为READONLY。</li><li>READWRITE属性：指定本段为可读可写，数据段的默认属性为READWRITE。</li><li>ALIGN属性：使用方式为ALIGN&#x3D;expression。在默认时，ELF（可执行连接文件）的代码段和数据段是按字对齐的，表达式的取值范围为0～31，相应的对齐方式为<strong>2<strong><strong>expression</strong></strong>次方</strong>。</li><li>COMMON属性：该属性定义一个通用的段，不包含任何的用户代码和数据。各源文件中同名的COMMON段共享同一段存储单元。</li></ul><p>一个汇编语言程序至少要包含一个段，当程序太长时，也可以将程序分为多个代码段和数据段。</p><p>段的常用属性：</p><ul><li>每个段都有一个名字，段名字可以重复使用，编译器将同名段作为一个段的不同部分；</li><li>指令（代码）段定义为CODE，数据段定义为DATA，这个属性一般不能忽略。<ul><li>代码段可以存放数据，如数据缓区LTORG或分配内存单元DCD等，但数据段不能存放指令；</li></ul></li><li>代码段的属性通常是READONLY， 数据段的属性通常是READWRITE。</li></ul><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs armasm">使用示例：<br>  <span class="hljs-meta">AREA</span> Init，<span class="hljs-meta">CODE</span>，<span class="hljs-meta">READONLY</span><br>  指令序列<br>  ；该伪指令定义了一个代码段，段名为Init，属性为只读<br></code></pre></td></tr></table></figure><ol start="2"><li><h4 id="ALIGN"><a href="#ALIGN" class="headerlink" title="ALIGN"></a>ALIGN</h4></li></ol><p>语法格式：</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml">ALIGN</span><span class="hljs-template-variable">&#123;表达式&#123;，偏移量&#125;</span><span class="language-xml">&#125;</span><br></code></pre></td></tr></table></figure><p>ALIGN伪指令可通过添加填充字节的方式，使当前位置满足一定的对其方式。其中，表达式的值用于指定对齐方式，可能的取值为2的幂，如1、2、4、8、16等。若未指定表达式，则将当前位置对齐到下一个字的位置。偏移量也为一个数字表达式，若使用该字段，则当前位置的对齐方式为：2的表达式次幂＋偏移量。</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs armasm">使用示例：<br>   <span class="hljs-meta">AREA</span> Init，<span class="hljs-meta">CODE</span>，<span class="hljs-meta">READONLY</span>，<span class="hljs-meta">ALIGN</span>＝<span class="hljs-number">3</span> <br> <span class="hljs-comment">;指定后面的指令为8字节对齐。</span><br>   指令序列<br>   <span class="hljs-meta">ALIGN</span> <span class="hljs-number">4</span> <span class="hljs-comment">;指定后面的指令是4字节对齐的</span><br> <span class="hljs-meta">END</span><br></code></pre></td></tr></table></figure><ol start="3"><li><h4 id="CODE16、CODE32"><a href="#CODE16、CODE32" class="headerlink" title="CODE16、CODE32"></a>CODE16、CODE32</h4></li></ol><p>语法格式：(<strong>注意：这两条伪指令并不能实现ARM状态的切换。</strong>)</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-symbol">CODE16</span>（或<span class="hljs-meta">CODE32</span>）<br></code></pre></td></tr></table></figure><p>CODE16伪指令通知编译器，其后的指令序列为16位的Thumb指令。</p><p>CODE32伪指令通知编译器，其后的指令序列为32位的ARM指令。</p><p>若在汇编源程序中同时包含ARM指令和Thumb指令时，可用CODE16伪指令通知编译器其后的指令序列为16位的Thumb指令，CODE32伪指令通知编译器其后的指令序列为32位的ARM指令。</p><p>因此，<strong>在使用ARM指令和Thumb</strong>指令混合编程的代码里，可用这两条伪指令进行切换，但注意他们只通知编译器其后指令的类型，并不能对处理器进行状态的切换</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs armasm">使用示例：<br>    <span class="hljs-meta">AREA</span>Init，<span class="hljs-meta">CODE</span>，<span class="hljs-meta">READONLY</span><br>     ……<br>     <span class="hljs-meta">CODE32</span>  ；通知编译器其后的指令为<span class="hljs-number">32</span>位的<span class="hljs-meta">ARM</span>指令<br>     <span class="hljs-keyword">LDR</span><span class="hljs-built_in">R0</span>，＝NEXT＋<span class="hljs-number">1</span>  ；将跳转地址放入寄存器<span class="hljs-built_in">R0</span><br>     <span class="hljs-keyword">BX</span><span class="hljs-built_in">R0</span>；程序跳转到新的位置执行，并将处理器切换到<span class="hljs-meta">Thumb</span>工作状态<br>     ……<br>     <span class="hljs-meta">CODE16</span> ；通知编译器其后的指令为<span class="hljs-number">16</span>位的<span class="hljs-meta">Thumb</span>指令<br><span class="hljs-symbol">NEXT</span><span class="hljs-keyword">LDR</span><span class="hljs-built_in">R3</span>，＝<span class="hljs-number">0x3FF</span><br>     ……<br>     <span class="hljs-meta">END</span>；程序结束<br></code></pre></td></tr></table></figure><ol start="4"><li><h4 id="ENTRY"><a href="#ENTRY" class="headerlink" title="ENTRY"></a>ENTRY</h4></li></ol><p>语法格式：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada"><span class="hljs-keyword">ENTRY</span><br></code></pre></td></tr></table></figure><p>ENTRY伪指令用于指定汇编程序的入口点。在一个完整的汇编程序中至少要有一个ENTRY（也可以有多个，当有多个ENTRY时，程序的真正入口点由链接器指定），但在一个源文件里最多只能有一个ENTRY（可以没有）。</p><p>在只有一个入口时，编译程序会把这个入口的地址定义为系统复位后的程序起始点。</p><p>程序入口应该定义在源文件的第1条有效语句之前。</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs armasm">使用示例：<br>  <span class="hljs-meta">AREA</span> Init，<span class="hljs-meta">CODE</span>，<span class="hljs-meta">READONLY</span><br>  <span class="hljs-meta">ENTRY</span> ；指定应用程序的入口点<br><br> ……<br></code></pre></td></tr></table></figure><ol start="5"><li><h4 id="END"><a href="#END" class="headerlink" title="END"></a>END</h4></li></ol><p>语法格式：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada"><span class="hljs-keyword">END</span><br></code></pre></td></tr></table></figure><p>END伪指令用于通知编译器已经到了源程序的结尾。</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs armasm">使用示例：<br>  <span class="hljs-meta">AREA</span>   Init，<span class="hljs-meta">CODE</span>，<span class="hljs-meta">READONLY</span><br>  ……<br>  <span class="hljs-meta">END</span> ；指定应用程序的结尾<br></code></pre></td></tr></table></figure><ol start="6"><li><h4 id="EQU"><a href="#EQU" class="headerlink" title="EQU"></a>EQU</h4></li></ol><p>语法格式：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs armasm">名称<span class="hljs-meta">EQU</span>表达式&#123;，类型&#125;<br></code></pre></td></tr></table></figure><p>EQU伪指令用于为程序中的常量、标号等定义一个等效的字符名称，类似于C语言中的＃define。</p><p>EQU可用“*”代替。</p><p>名称为EQU伪指令定义的字符名称，当表达式为32位的常量时，可以指定表达式的数据类型，可以有以下三种类型：</p><ul><li>CODE16</li><li>CODE32</li><li>DATA</li></ul><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs armasm">使用示例：<br>Test<span class="hljs-meta">EQU</span><span class="hljs-number">50</span>；定义标号Test的值为<span class="hljs-number">50</span><br><span class="hljs-keyword">Addr</span>*<span class="hljs-number">0x55</span>，<span class="hljs-meta">CODE32</span><br>；定义Addr的值为<span class="hljs-number">0x55</span>，且该处为<span class="hljs-number">32</span>位的<span class="hljs-meta">ARM</span>指令<br></code></pre></td></tr></table></figure><ol start="7"><li><h4 id="EXPORT（或GLOBAL）"><a href="#EXPORT（或GLOBAL）" class="headerlink" title="EXPORT（或GLOBAL）"></a>EXPORT（或GLOBAL）</h4></li></ol><p>语法格式：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">EXPORT</span>标号   &#123;[WEAK]&#125;<br></code></pre></td></tr></table></figure><p>EXPORT伪指令用于在程序中声明一个全局的标号，该标号可在其他的文件中引用。</p><p>EXPORT可用GLOBAL代替。</p><p>标号在程序中区分大小写，[WEAK]选项声明其他的同名标号优先于该标号被引用。</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs armasm">使用示例：<br>    <span class="hljs-meta">AREA</span>Init，<span class="hljs-meta">CODE</span>，<span class="hljs-meta">READONLY</span><br>    <span class="hljs-meta">EXPORT</span>  Stest；声明一个可全局引用的标号Stest<br>    ……<br>    <span class="hljs-meta">END</span><br></code></pre></td></tr></table></figure><h4 id="8-IMPORT"><a href="#8-IMPORT" class="headerlink" title="8.IMPORT"></a>8.IMPORT</h4><p>语法格式：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">IMPORT 标号  &#123;<span class="hljs-selector-attr">[WEAK]</span>&#125;<br></code></pre></td></tr></table></figure><p>IMPORT伪指令用于通知编译器要使用的标号在其他的源文件中定义，但要在当前源文件中引用，而且无论当前源文件是否引用该标号，该标号均会被加入到当前源文件的符号表中。</p><p>标号在程序中区分大小写，[WEAK]选项表示当所有的源文件都没有定义这样一个标号时，编译器也不给出错误信息，在多数情况下将该标号置为0，若该标号为B或BL指令引用，则将B或BL指令置为NOP操作。</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs armasm">使用示例：<br>     <span class="hljs-meta">AREA</span>Init，<span class="hljs-meta">CODE</span>，<span class="hljs-meta">READONLY</span><br>     <span class="hljs-meta">IMPORT</span>  Main；通知编译器当前文件要引用标号<span class="hljs-comment">;Main，但Main在其他源文件中定义</span><br>     ……<br>     <span class="hljs-meta">END</span><br></code></pre></td></tr></table></figure><h4 id="9-EXTERN"><a href="#9-EXTERN" class="headerlink" title="9 EXTERN"></a>9 EXTERN</h4><p>语法格式：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">EXTERN标号&#123;<span class="hljs-selector-attr">[WEAK]</span>&#125;<br></code></pre></td></tr></table></figure><p>EXTERN伪指令用于通知编译器要使用的标号在其他的源文件中定义，但要在当前源文件中引用，如果当前源文件实际并未引用该标号，该标号就不会被加入到当前源文件的符号表中。</p><p>标号在程序中区分大小写，[WEAK]选项表示当所有的源文件都没有定义这样一个标号时，编译器也不给出错误信息，在多数情况下将该标号置为0，若该标号为B或BL指令引用，则将B或BL指令置为NOP操作。</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs armasm">使用示例：<br>    <span class="hljs-meta">AREA</span>Init，<span class="hljs-meta">CODE</span>，<span class="hljs-meta">READONLY</span><br>    <span class="hljs-meta">EXTERN</span>Main；通知编译器当前文件要引用标号Main，但<span class="hljs-comment">;Main在其他源文件中定义</span><br>    ……<br>    <span class="hljs-meta">END</span><br></code></pre></td></tr></table></figure><h4 id="10、-GET（或INCLUDE）"><a href="#10、-GET（或INCLUDE）" class="headerlink" title="10、 GET（或INCLUDE）"></a>10、 GET（或INCLUDE）</h4><p>语法格式：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">GET</span>文件名<br></code></pre></td></tr></table></figure><p>GET伪指令用于将一个源文件包含到当前的源文件中，并将被包含的源文件在当前位置进行汇编处理。</p><p>可以使用INCLUDE代替GET。</p><p>汇编程序中常用的方法是在某源文件中定义一些宏指令，用EQU定义常量的符号名称，用MAP和FIELD定义结构化的数据类型，然后用GET伪指令将这个源文件包含到其他的源文件中。使用方法与C语言中的“include”相似。</p><p>GET伪指令只能用于包含源文件，包含目标文件需要使用INCBIN伪指令</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs armasm">使用示例：<br>  <span class="hljs-meta">AREA</span>Init，<span class="hljs-meta">CODE</span>，<span class="hljs-meta">READONLY</span><br>    <span class="hljs-meta">GET</span><span class="hljs-built_in">a1</span>.s；通知编译器当前源文件包含源文件<span class="hljs-built_in">a1</span>.s<br>    <span class="hljs-meta">GET</span>C：\<span class="hljs-built_in">a2</span>.s ；通知编译器当前源文件包含源文件C：\ <span class="hljs-built_in">a2</span>.s<br>    ……<br>    <span class="hljs-meta">END</span><br></code></pre></td></tr></table></figure><h4 id="11、INCBIN"><a href="#11、INCBIN" class="headerlink" title="11、INCBIN"></a>11、INCBIN</h4><p>语法格式：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">INCBIN</span>文件名<br></code></pre></td></tr></table></figure><p>INCBIN伪指令用于将一个<strong>目标文件或数据文件</strong>包含到当前的源文件中，被包含的文件不作任何变动的存放在当前文件中，编译器从其后开始继续处理。</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs armasm">使用示例：<br>    <span class="hljs-meta">AREA</span>Init，<span class="hljs-meta">CODE</span>，<span class="hljs-meta">READONLY</span><br>    <span class="hljs-meta">INCBIN</span><span class="hljs-built_in">a1</span>.dat；通知编译器当前源文件包含文件；<span class="hljs-built_in">a1</span>.dat<br>    <span class="hljs-meta">INCBIN</span> C：\<span class="hljs-built_in">a2</span>.txt；通知编译器当前源文件包含文件；C:\<span class="hljs-built_in">a2</span>.txt<br>    ……<br>    <span class="hljs-meta">END</span><br></code></pre></td></tr></table></figure><h4 id="12、-RN"><a href="#12、-RN" class="headerlink" title="12、 RN"></a>12、 RN</h4><p>语法格式：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">名称RN表达式<br></code></pre></td></tr></table></figure><p>RN伪指令用于给一个寄存器定义一个别名。采用这种方式可以方便程序员记忆该寄存器的功能。其中，名称为给寄存器定义的别名，表达式为寄存器的编码。</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs armasm">使用示例：<br>    TempRN<span class="hljs-built_in">R0</span>  ；将<span class="hljs-built_in">R0</span>定义一个别名Temp<br></code></pre></td></tr></table></figure><h4 id="13、ROUT"><a href="#13、ROUT" class="headerlink" title="13、ROUT"></a>13、ROUT</h4><p>语法格式：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs armasm">&#123;名称&#125;<span class="hljs-meta">ROUT</span><br></code></pre></td></tr></table></figure><p>ROUT伪指令用于给一个局部变量定义作用范围。</p><p>在程序中未使用该伪指令时，局部变量的作用范围为所在的AREA，而使用ROUT后，局部变量的作为范围为当前ROUT和下一个ROUT之间（指同一个段中）。</p><h3 id="4-1-5几条特殊的伪指令"><a href="#4-1-5几条特殊的伪指令" class="headerlink" title="4.1.5几条特殊的伪指令"></a>4.1.5<strong>几条特殊的伪指令</strong></h3><ul><li>ADR (小范围的地址读取伪指令)</li><li>ADRL(中等范围的地址读取伪指令)</li><li>LDR(大范围的地址读取伪指令)</li><li>NOP(空操作伪指令)</li></ul><h4 id="1、ADR"><a href="#1、ADR" class="headerlink" title="1、ADR"></a>1、ADR</h4><p>语法格式</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-keyword">ADR</span> &#123;cond&#125; 寄存器，表达式<br></code></pre></td></tr></table></figure><p>在汇编编译器处理源程序时，ADR伪指令被编译器替换成一条合适的指令。</p><p>通常编译器用一条ADD指令或SUB指令来实现该ADR伪指令的功能。</p><p>ADR伪指令中的地址是基于PC或寄存器的，所以ADR读取到的地址与位置无关。</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs armasm">使用示例：<br>start <span class="hljs-keyword">MOV</span> <span class="hljs-built_in">r0</span>,<span class="hljs-number">#10</span><br>   <span class="hljs-keyword">ADR</span> <span class="hljs-built_in">r4</span>,start  <span class="hljs-comment">;本指令被替换成一条SUB指令</span><br><span class="hljs-keyword">SUB</span> <span class="hljs-built_in">r4</span>,<span class="hljs-built_in">pc</span>,<span class="hljs-number">#0xc</span><br></code></pre></td></tr></table></figure><p><img src="/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B-%E7%AC%AC4%E7%AB%A0-ARM%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%80-%E4%BC%AA%E6%8C%87%E4%BB%A41/image-20230508222951368.png" srcset="/img/mahmoud-habibi.gif" lazyload alt="ex"></p><h4 id="2、ADRL"><a href="#2、ADRL" class="headerlink" title="2、ADRL"></a>2、ADRL</h4><p>语法格式</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-keyword">ADRL</span> &#123;cond&#125; 寄存器，表达式<br></code></pre></td></tr></table></figure><p>将基于PC或基于寄存器的地址值读取到寄存器中。</p><p>在汇编编译器处理源程序时，ADR伪指令被编译器替换成两条合适的指令。</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs avrasm">使用示例：<br>start <span class="hljs-keyword">MOV</span> <span class="hljs-built_in">r0</span>,<span class="hljs-meta">#10</span><br>   ADRL <span class="hljs-built_in">r4</span>,start +<span class="hljs-number">60000</span> <span class="hljs-comment">;本指令被替换成以下两条指令</span><br>   <br>    *<span class="hljs-keyword">ADD</span> <span class="hljs-built_in">r4</span>,pc,<span class="hljs-meta">#0xe800</span><br>   *<span class="hljs-keyword">ADD</span> <span class="hljs-built_in">r4</span>,<span class="hljs-built_in">r4</span>,<span class="hljs-meta">#0x254</span><br></code></pre></td></tr></table></figure><h4 id="3、LDR"><a href="#3、LDR" class="headerlink" title="3、LDR"></a>3、LDR</h4><blockquote><p><strong>注意：唯一一条ARM指令与伪指令同名的指令。</strong></p></blockquote><p>语法格式</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c">LDR &#123;cond&#125; 寄存器，=[表达式<span class="hljs-string">|标号]</span><br></code></pre></td></tr></table></figure><p>将一个32位的常数或者一个地址值读取到寄存器中。</p><p>当表达式表示的地址值没有超过MOV或MVN指令中地址的取值范围时，用合适的MOV或MVN指令来代替该指令；否则将标签表示的数值放在数据缓冲区中，同时用一条基于PC的LDR指令读取该数值。</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs armasm">使用示例：<br><span class="hljs-keyword">LDR</span> <span class="hljs-built_in">R1</span>,<span class="hljs-number">=0xFF0</span> 汇编后变换成：<span class="hljs-keyword">MOV</span> <span class="hljs-built_in">R1</span>,<span class="hljs-number">0xFF0</span><br><span class="hljs-keyword">LDR</span> <span class="hljs-built_in">R1</span>,<span class="hljs-number">=0xFFFFFF00</span> 汇编后变换成：<br><br><span class="hljs-keyword">LDR</span> <span class="hljs-built_in">R1</span>,[<span class="hljs-built_in">PC</span>,OFFSET_TO LPOOL]<br>……..<br>LPOOL <span class="hljs-meta">DCD</span> <span class="hljs-number">0xFFFFFF00</span><br></code></pre></td></tr></table></figure><h4 id="4、NOP"><a href="#4、NOP" class="headerlink" title="4、NOP"></a>4、NOP</h4><p>语法格式</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-keyword">NOP</span><br></code></pre></td></tr></table></figure><p>NOP伪指令将被替换成ARM中的空操作，如MOV R0,R0</p><p>NOP伪指令不影响CPSR中的条件标志位。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;ARM体系结构与编程&quot;&gt;&lt;a href=&quot;#ARM体系结构与编程&quot; class=&quot;headerlink&quot; title=&quot;ARM体系结构与编程&quot;&gt;&lt;/a&gt;ARM体系结构与编程&lt;/h1&gt;&lt;h2 id=&quot;第4章-ARM程序设计基础&quot;&gt;&lt;a href=&quot;#第4章-ARM程</summary>
      
    
    
    
    <category term="学习资料" scheme="https://www.emokable.top/categories/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/"/>
    
    
    <category term="ARM体系结构与编程" scheme="https://www.emokable.top/tags/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B/"/>
    
    <category term="课件笔记" scheme="https://www.emokable.top/tags/%E8%AF%BE%E4%BB%B6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
</feed>
